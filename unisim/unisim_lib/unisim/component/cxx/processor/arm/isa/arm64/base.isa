/*
 *  Copyright (c) 2007-2017,
 *  Commissariat a l'Energie Atomique (CEA)
 *  All rights reserved.
 *
 *  Redistribution and use in source and binary forms, with or without modification,
 *  are permitted provided that the following conditions are met:
 *
 *   - Redistributions of source code must retain the above copyright notice, this
 *     list of conditions and the following disclaimer.
 *
 *   - Redistributions in binary form must reproduce the above copyright notice,
 *     this list of conditions and the following disclaimer in the documentation
 *     and/or other materials provided with the distribution.
 *
 *   - Neither the name of CEA nor the names of its contributors may be used to
 *     endorse or promote products derived from this software without specific prior
 *     written permission.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 *  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 *  DISCLAIMED.
 *  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
 *  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 *  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 *  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 *  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
 *  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * Authors: Yves Lhuillier (yves.lhuillier@cea.fr)
 */

/*******************************************************************
 * ADC
 *
 * Add with carry: Rd = Rn + Rm + C
 */

op adc_www( 0b00011010000[11] : rm[5] : 0b000000[6] : rn[5] : rd[5] );
adc_www.var format : {char const*} = {"base,1458"};

adc_www.disasm = {
  sink << "adc\t" << DisasmGZWR(rd) << ", " << DisasmGZWR(rn) << ", " << DisasmGZWR(rm);
};

adc_www.execute = {
  typedef typename ARCH::U32 U32;
  
  U32 op1( cpu.GetGSR(rn) ), op2( cpu.GetGZR(rm) ), res = op1 + op2 + U32(cpu.GetCarry());
  cpu.SetGSR(rd, res);
};

op adc_xxx( 0b10011010000[11] : rm[5] : 0b000000[6] : rn[5] : rd[5] );
adc_xxx.var format : {char const*} = {"base,1612"};

adc_xxx.disasm = {
  sink << "adc\t" << DisasmGZXR(rd) << ", " << DisasmGZXR(rn) << ", " << DisasmGZXR(rm);
};

adc_xxx.execute = {
  typedef typename ARCH::U64 U64;
  
  U64 op1( cpu.GetGSR(rn) ), op2( cpu.GetGZR(rm) ), res = op1 + op2 + U64(cpu.GetCarry());
  cpu.SetGSR(rd, res);
};

/*
 * end of ADC
 *******************************************************************/

/*******************************************************************
 * ADCS
 * 
 * Add with carry, setting the condition flags: Rd = Rn + Rm + C
 */

op adcs_www( 0b00111010000[11] : rm[5] : 0b000000[6] : rn[5] : rd[5] );
adcs_www.var format : {char const*} = {"base,1459"};

adcs_www.disasm = {
  sink << "adcs\t" << DisasmGZWR(rd) << ", " << DisasmGZWR(rn) << ", " << DisasmGZWR(rm);
};

adcs_www.execute = {
  typedef typename ARCH::U32 U32;
  typedef typename ARCH::S32 S32;
  typedef typename ARCH::BOOL BOOL;
  
  BOOL carry( cpu.GetCarry() );
  U32 op1( cpu.GetGSR(rn) ), op2( cpu.GetGZR(rm) ), res = op1 + op2 + U32(carry);
  cpu.SetGZR(rd, res);
  
  BOOL n = S32(res) < S32(0), z = res == U32(0);
  if (cpu.Test(carry))
    cpu.SetNZCV( n, z, op1 >= ~op2, n xor (S32(op1) <  S32(~op2)) );
  else
    cpu.SetNZCV( n, z, op1 >  ~op2, n xor (S32(op1) <= S32(~op2)) );
};

op adcs_xxx( 0b10111010000[11] : rm[5] : 0b000000[6] : rn[5] : rd[5] );
adcs_xxx.var format : {char const*} = {"base,1613"};

adcs_xxx.disasm = {
  sink << "adcs\t" << DisasmGZXR(rd) << ", " << DisasmGZXR(rn) << ", " << DisasmGZXR(rm);
};

adcs_xxx.execute = {
  typedef typename ARCH::U64 U64;
  typedef typename ARCH::S64 S64;
  typedef typename ARCH::BOOL BOOL;
  
  BOOL carry( cpu.GetCarry() );
  U64 op1( cpu.GetGSR(rn) ), op2( cpu.GetGZR(rm) ), res = op1 + op2 + U64(carry);
  cpu.SetGZR(rd, res);
  
  BOOL n = S64(res) < S64(0), z = res == U64(0);
  if (cpu.Test(carry))
    cpu.SetNZCV( n, z, op1 >= ~op2, n xor (S64(op1) <  S64(~op2)) );
  else
    cpu.SetNZCV( n, z, op1 >  ~op2, n xor (S64(op1) <= S64(~op2)) );
};

/*
 * end of ADCS
 *******************************************************************/

/*******************************************************************
 * ADD (extended register)
 * 
 * Add (extended register): Rd = Rn + LSL(extend(Rm), amount)
 */

op add_wsxtb( 0b00001011001[11] : rm[5] : 0b100[3] : imm[3] : rn[5] : rd[5] );
add_wsxtb.var reject : {Reject} = {imm >= 5}, format : {char const*} = {"base,375"};

add_wsxtb.disasm = {
  sink << "add\t" << DisasmGSWR(rd) << ", " << DisasmGSWR(rn) << ", " << DisasmGZWR(rm) << ", sxtb" << DisasmINZ(" ", imm);
};

add_wsxtb.execute = {
  typedef typename ARCH::S8 S8;
  typedef typename ARCH::S32 S32;
  typedef typename ARCH::U32 U32;
  
  U32 op1( cpu.GetGSR(rn) ), op2( S32(S8(cpu.GetGZR(rm))) << imm ), res = op1 + op2;
  cpu.SetGSR(rd, res);
};

op add_wsxth( 0b00001011001[11] : rm[5] : 0b101[3] : imm[3] : rn[5] : rd[5] );
add_wsxth.var reject : {Reject} = {imm >= 5}, format : {char const*} = {"base,379"};

add_wsxth.disasm = {
  sink << "add\t" << DisasmGSWR(rd) << ", " << DisasmGSWR(rn) << ", " << DisasmGZWR(rm) << ", sxth" << DisasmINZ(" ", imm);
};

add_wsxth.execute = {
  typedef typename ARCH::S16 S16;
  typedef typename ARCH::S32 S32;
  typedef typename ARCH::U32 U32;
  
  U32 op1( cpu.GetGSR(rn) ), op2( S32(S16(cpu.GetGZR(rm))) << imm ), res = op1 + op2;
  cpu.SetGSR(rd, res);
};

op add_wsxtw( 0b00001011001[11] : rm[5] : 0b110[3] : imm[3] : rn[5] : rd[5] );
add_wsxtw.var reject : {Reject} = {imm >= 5}, format : {char const*} = {"base,383"};

add_wsxtw.disasm = {
  sink << "add\t" << DisasmGSWR(rd) << ", " << DisasmGSWR(rn) << ", " << DisasmGZWR(rm) << ", sxtw" << DisasmINZ(" ", imm);
};

add_wsxtw.execute = {
  typedef typename ARCH::S32 S32;
  typedef typename ARCH::U32 U32;
  
  U32 op1( cpu.GetGSR(rn) ), op2( S32(S32(cpu.GetGZR(rm))) << imm ), res = op1 + op2;
  cpu.SetGSR(rd, res);
};

op add_wsxtx( 0b00001011001[11] : rm[5] : 0b111[3] : imm[3] : rn[5] : rd[5] );
add_wsxtx.var reject : {Reject} = {imm >= 5}, format : {char const*} = {"base,387"};

add_wsxtx.disasm = {
  sink << "add\t" << DisasmGSWR(rd) << ", " << DisasmGSWR(rn) << ", " << DisasmGZWR(rm) << ", sxtx" << DisasmINZ(" ", imm);
};

add_wsxtx.execute = {
  typedef typename ARCH::S64 S64;
  typedef typename ARCH::S32 S32;
  typedef typename ARCH::U32 U32;
  
  U32 op1( cpu.GetGSR(rn) ), op2( S32(S64(cpu.GetGZR(rm))) << imm ), res = op1 + op2;
  cpu.SetGSR(rd, res);
};

op add_wuxtb( 0b00001011001[11] : rm[5] : 0b000[3] : imm[3] : rn[5] : rd[5] );
add_wuxtb.var reject : {Reject} = {imm >= 5}, format : {char const*} = {"base,391"};

add_wuxtb.disasm = {
  sink << "add\t" << DisasmGSWR(rd) << ", " << DisasmGSWR(rn) << ", " << DisasmGZWR(rm) << ", uxtb" << DisasmINZ(" ", imm);
};

add_wuxtb.execute = {
  typedef typename ARCH::U8 U8;
  typedef typename ARCH::U32 U32;
  
  U32 op1( cpu.GetGSR(rn) ), op2( U32(U8(cpu.GetGZR(rm))) << imm ), res = op1 + op2;
  cpu.SetGSR(rd, res);
};

op add_wuxth( 0b00001011001[11] : rm[5] : 0b001[3] : imm[3] : rn[5] : rd[5] );
add_wuxth.var reject : {Reject} = {imm >= 5}, format : {char const*} = {"base,395"};

add_wuxth.disasm = {
  sink << "add\t" << DisasmGSWR(rd) << ", " << DisasmGSWR(rn) << ", " << DisasmGZWR(rm) << ", uxth" << DisasmINZ(" ", imm);
};

add_wuxth.execute = {
  typedef typename ARCH::U16 U16;
  typedef typename ARCH::U32 U32;
  
  U32 op1( cpu.GetGSR(rn) ), op2( U32(U16(cpu.GetGZR(rm))) << imm ), res = op1 + op2;
  cpu.SetGSR(rd, res);
};

op add_wuxtw( 0b00001011001[11] : rm[5] : 0b010[3] : imm[3] : rn[5] : rd[5] );
add_wuxtw.var reject : {Reject} = {imm >= 5}, format : {char const*} = {"base,399"};

add_wuxtw.disasm = {
  sink << "add\t" << DisasmGSWR(rd) << ", " << DisasmGSWR(rn) << ", " << DisasmGZWR(rm) << ", uxtw" << DisasmINZ(" ", imm);
};

add_wuxtw.execute = {
  typedef typename ARCH::U32 U32;
  
  U32 op1( cpu.GetGSR(rn) ), op2( U32(U32(cpu.GetGZR(rm))) << imm ), res = op1 + op2;
  cpu.SetGSR(rd, res);
};

op add_wuxtx( 0b00001011001[11] : rm[5] : 0b011[3] : imm[3] : rn[5] : rd[5] );
add_wuxtx.var reject : {Reject} = {imm >= 5}, format : {char const*} = {"base,403"};

add_wuxtx.disasm = {
  sink << "add\t" << DisasmGSWR(rd) << ", " << DisasmGSWR(rn) << ", " << DisasmGZWR(rm) << ", uxtx" << DisasmINZ(" ", imm);
};

add_wuxtx.execute = {
  typedef typename ARCH::U64 U64;
  typedef typename ARCH::U32 U32;
  
  U32 op1( cpu.GetGSR(rn) ), op2( U32(U64(cpu.GetGZR(rm))) << imm ), res = op1 + op2;
  cpu.SetGSR(rd, res);
};

op add_xsxtb( 0b10001011001[11] : rm[5] : 0b100[3] : imm[3] : rn[5] : rd[5] );
add_xsxtb.var reject : {Reject} = {imm >= 5}, format : {char const*} = {"base,407"};

add_xsxtb.disasm = {
  sink << "add\t" << DisasmGSXR(rd) << ", " << DisasmGSXR(rn) << ", " << DisasmGZWR(rm) << ", sxtb" << DisasmINZ(" ", imm);
};

add_xsxtb.execute = {
  typedef typename ARCH::S8 S8;
  typedef typename ARCH::S64 S64;
  typedef typename ARCH::U64 U64;
  
  U64 op1( cpu.GetGSR(rn) ), op2( S64(S8(cpu.GetGZR(rm))) << imm ), res = op1 + op2;
  cpu.SetGSR(rd, res);
};

op add_xsxth( 0b10001011001[11] : rm[5] : 0b101[3] : imm[3] : rn[5] : rd[5] );
add_xsxth.var reject : {Reject} = {imm >= 5}, format : {char const*} = {"base,411"};

add_xsxth.disasm = {
  sink << "add\t" << DisasmGSXR(rd) << ", " << DisasmGSXR(rn) << ", " << DisasmGZWR(rm) << ", sxth" << DisasmINZ(" ", imm);
};

add_xsxth.execute = {
  typedef typename ARCH::S16 S16;
  typedef typename ARCH::S64 S64;
  typedef typename ARCH::U64 U64;
  
  U64 op1( cpu.GetGSR(rn) ), op2( S64(S16(cpu.GetGZR(rm))) << imm ), res = op1 + op2;
  cpu.SetGSR(rd, res);
};

op add_xsxtw( 0b10001011001[11] : rm[5] : 0b110[3] : imm[3] : rn[5] : rd[5] );
add_xsxtw.var reject : {Reject} = {imm >= 5}, format : {char const*} = {"base,415"};

add_xsxtw.disasm = {
  sink << "add\t" << DisasmGSXR(rd) << ", " << DisasmGSXR(rn) << ", " << DisasmGZWR(rm) << ", sxtw" << DisasmINZ(" ", imm);
};

add_xsxtw.execute = {
  typedef typename ARCH::S32 S32;
  typedef typename ARCH::S64 S64;
  typedef typename ARCH::U64 U64;
  
  U64 op1( cpu.GetGSR(rn) ), op2( S64(S32(cpu.GetGZR(rm))) << imm ), res = op1 + op2;
  cpu.SetGSR(rd, res);
};

op add_xsxtx( 0b10001011001[11] : rm[5] : 0b111[3] : imm[3] : rn[5] : rd[5] );
add_xsxtx.var reject : {Reject} = {imm >= 5}, format : {char const*} = {"base,431"};

add_xsxtx.disasm = {
  sink << "add\t" << DisasmGSXR(rd) << ", " << DisasmGSXR(rn) << ", " << DisasmGZXR(rm) << ", sxtx" << DisasmINZ(" ", imm);
};

add_xsxtx.execute = {
  typedef typename ARCH::S64 S64;
  typedef typename ARCH::U64 U64;
  
  U64 op1( cpu.GetGSR(rn) ), op2( S64(S64(cpu.GetGZR(rm))) << imm ), res = op1 + op2;
  cpu.SetGSR(rd, res);
};

op add_xuxtb( 0b10001011001[11] : rm[5] : 0b000[3] : imm[3] : rn[5] : rd[5] );
add_xuxtb.var reject : {Reject} = {imm >= 5}, format : {char const*} = {"base,419"};

add_xuxtb.disasm = {
  sink << "add\t" << DisasmGSXR(rd) << ", " << DisasmGSXR(rn) << ", " << DisasmGZWR(rm) << ", uxtb" << DisasmINZ(" ", imm);
};

add_xuxtb.execute = {
  typedef typename ARCH::U8 U8;
  typedef typename ARCH::U64 U64;
  
  U64 op1( cpu.GetGSR(rn) ), op2( U64(U8(cpu.GetGZR(rm))) << imm ), res = op1 + op2;
  cpu.SetGSR(rd, res);
};

op add_xuxth( 0b10001011001[11] : rm[5] : 0b001[3] : imm[3] : rn[5] : rd[5] );
add_xuxth.var reject : {Reject} = {imm >= 5}, format : {char const*} = {"base,423"};

add_xuxth.disasm = {
  sink << "add\t" << DisasmGSXR(rd) << ", " << DisasmGSXR(rn) << ", " << DisasmGZWR(rm) << ", uxth" << DisasmINZ(" ", imm);
};

add_xuxth.execute = {
  typedef typename ARCH::U16 U16;
  typedef typename ARCH::U64 U64;
  
  U64 op1( cpu.GetGSR(rn) ), op2( U64(U16(cpu.GetGZR(rm))) << imm ), res = op1 + op2;
  cpu.SetGSR(rd, res);
};

op add_xuxtw( 0b10001011001[11] : rm[5] : 0b010[3] : imm[3] : rn[5] : rd[5] );
add_xuxtw.var reject : {Reject} = {imm >= 5}, format : {char const*} = {"base,427"};

add_xuxtw.disasm = {
  sink << "add\t" << DisasmGSXR(rd) << ", " << DisasmGSXR(rn) << ", " << DisasmGZWR(rm) << ", uxtw" << DisasmINZ(" ", imm);
};

add_xuxtw.execute = {
  typedef typename ARCH::U32 U32;
  typedef typename ARCH::U64 U64;
  
  U64 op1( cpu.GetGSR(rn) ), op2( U64(U32(cpu.GetGZR(rm))) << imm ), res = op1 + op2;
  cpu.SetGSR(rd, res);
};

op add_xuxtx( 0b10001011001[11] : rm[5] : 0b011[3] : imm[3] : rn[5] : rd[5] );
add_xuxtx.var reject : {Reject} = {imm >= 5}, format : {char const*} = {"base,438"};

add_xuxtx.disasm = {
  sink << "add\t" << DisasmGSXR(rd) << ", " << DisasmGSXR(rn) << ", " << DisasmGZXR(rm) << ", uxtx" << DisasmINZ(" ", imm);
};

add_xuxtx.execute = {
  typedef typename ARCH::U64 U64;
  
  U64 op1( cpu.GetGSR(rn) ), op2( U64(U64(cpu.GetGZR(rm))) << imm ), res = op1 + op2;
  cpu.SetGSR(rd, res);
};

/*
 * end of ADD (extended register)
 *******************************************************************/

/*******************************************************************
 * ADD (immediate)
 *
 * Add (immediate): Rd = Rn + shift(imm)
 */

op add_wi( 0b000100010[9] : shl12[1] : imm0[12] : rn[5] : rd[5] );
add_wi.var imm : {uint32_t} = {shl12 ? (imm0 << 12) : imm0}, format : {char const*} = {"base,24"};

add_wi.disasm = {
  sink << "add\t" << DisasmGSWR(rd) << ", " << DisasmGSWR(rn) << ", " << DisasmI(imm,16/*?*/);
};

add_wi.execute = {
  typedef typename ARCH::U32 U32;
  
  U32 op1(cpu.GetGSR(rn)), op2(imm), res = op1 + op2;
  cpu.SetGSR(rd, res);
};

op add_xi( 0b100100010[9] : shl12[1] : imm0[12] : rn[5] : rd[5] );
add_xi.var imm : {uint32_t} = {shl12 ? (imm0 << 12) : imm0}, format : {char const*} = {"base,33"};

add_xi.disasm = {
  sink << "add\t" << DisasmGSXR(rd) << ", " << DisasmGSXR(rn) << ", " << DisasmI(imm,16/*?*/);
};

add_xi.execute = {
  typedef typename ARCH::U64 U64;
  
  U64 op1(cpu.GetGSR(rn)), op2(imm), res = op1 + op2;
  cpu.SetGSR(rd, res);
};

/*
 * end of ADD (immediate)
 *******************************************************************/

/*******************************************************************
 * ADD (shifted register)
 * 
 * Add (shifted register): Rd = Rn + shift(Rm, amount)
 */

op add_wlsl( 0b00001011000[11] : rm[5] : 0b0[1] : imm[5] : rn[5] : rd[5] );
add_wlsl.var format : {char const*} = {"base,182"};

add_wlsl.disasm = {
  sink << "add\t" << DisasmGZWR(rd) << ", " << DisasmGZWR(rn) << ", " << DisasmGZWR(rm) << DisasmINZ(", lsl ",imm);
};

add_wlsl.execute = {
  typedef typename ARCH::U32 U32;
  
  U32 op1( cpu.GetGZR(rn) ), op2( cpu.GetGZR(rm) << imm ), res = op1 + op2;
  cpu.SetGZR(rd, res);
};

op add_wlsr( 0b00001011010[11] : rm[5] : 0b0[1] : imm[5] : rn[5] : rd[5] );
add_wlsr.var format : {char const*} = {"base,194"};

add_wlsr.disasm = {
  sink << "add\t" << DisasmGZWR(rd) << ", " << DisasmGZWR(rn) << ", " << DisasmGZWR(rm) << ", lsr " << DisasmI(imm);
};

add_wlsr.execute = {
  typedef typename ARCH::U32 U32;
  
  U32 op1( cpu.GetGZR(rn) ), op2( cpu.GetGZR(rm) >> imm ), res = op1 + op2;
  cpu.SetGZR(rd, res);
};

op add_wasr( 0b00001011100[11] : rm[5] : 0b0[1] : imm[5] : rn[5] : rd[5] );
add_wasr.var format : {char const*} = {"base,170"};

add_wasr.disasm = {
  sink << "add\t" << DisasmGZWR(rd) << ", " << DisasmGZWR(rn) << ", " << DisasmGZWR(rm) << ", asr " << DisasmI(imm);
};

add_wasr.execute = {
  typedef typename ARCH::U32 U32;
  typedef typename ARCH::S32 S32;
  
  U32 op1( cpu.GetGZR(rn) ), op2( S32(cpu.GetGZR(rm)) >> imm ), res = op1 + op2;
  cpu.SetGZR(rd, res);
};

op add_xlsl( 0b10001011000[11] : rm[5] : imm[6] : rn[5] : rd[5] );
add_xlsl.var format : {char const*} = {"base,122"};

add_xlsl.disasm = {
  sink << "add\t" << DisasmGZXR(rd) << ", " << DisasmGZXR(rn) << ", " << DisasmGZXR(rm) << DisasmINZ(", lsl ",imm);
};

add_xlsl.execute = {
  typedef typename ARCH::U64 U64;
  
  U64 op1( cpu.GetGZR(rn) ), op2( cpu.GetGZR(rm) << imm ), res = op1 + op2;
  cpu.SetGZR(rd, res);
};

op add_xlsr( 0b10001011010[11] : rm[5] : imm[6] : rn[5] : rd[5] );
add_xlsr.var format : {char const*} = {"base,134"};

add_xlsr.disasm = {
  sink << "add\t" << DisasmGZXR(rd) << ", " << DisasmGZXR(rn) << ", " << DisasmGZXR(rm) << ", lsr " << DisasmI(imm);
};

add_xlsr.execute = {
  typedef typename ARCH::U64 U64;
  
  U64 op1( cpu.GetGZR(rn) ), op2( cpu.GetGZR(rm) >> imm ), res = op1 + op2;
  cpu.SetGZR(rd, res);
};

op add_xasr( 0b10001011100[11] : rm[5] : imm[6] : rn[5] : rd[5] );
add_xasr.var format : {char const*} = {"base,110"};

add_xasr.disasm = {
  sink << "add\t" << DisasmGZXR(rd) << ", " << DisasmGZXR(rn) << ", " << DisasmGZXR(rm) << ", asr " << DisasmI(imm);
};

add_xasr.execute = {
  typedef typename ARCH::U64 U64;
  typedef typename ARCH::S64 S64;
  
  U64 op1( cpu.GetGZR(rn) ), op2( S64(cpu.GetGZR(rm)) >> imm ), res = op1 + op2;
  cpu.SetGZR(rd, res);
};

/*
 * end of ADD (shifted register)
 *******************************************************************/

/*******************************************************************
 * ADDS (extended register)
 *
 * Add (extended register), setting the condition flags: Rd = Rn + LSL(extend(Rm), amount)
 */

op adds_wsxtb( 0b00101011001[11] : rm[5] : 0b100[3] : imm[3] : rn[5] : rd[5] );
adds_wsxtb.var reject : {Reject} = {imm >= 5}, format : {char const*} = {"base,376"};

adds_wsxtb.disasm = {
  if (rd == 31)
    sink << "cmn\t" << DisasmGSWR(rn) << ", " << DisasmGZWR(rm) << ", sxtb" << DisasmINZ(" ", imm);
  else
    sink << "adds\t" << DisasmGZWR(rd) << ", " << DisasmGSWR(rn) << ", " << DisasmGZWR(rm) << ", sxtb" << DisasmINZ(" ", imm);
};

adds_wsxtb.execute = {
  typedef typename ARCH::S8 S8;
  typedef typename ARCH::S32 S32;
  typedef typename ARCH::U32 U32;
  
  U32 op1( cpu.GetGSR(rn) ), op2( S32(S8(cpu.GetGZR(rm))) << imm ), res = op1 + op2;
  cpu.SetGZR(rd, res);
  cpu.SetNZCV( S32(res) < S32(0), res == U32(0), op1 > ~op2, (S32(res) < S32(0)) xor (S32(op1) <= S32(~op2)) );
};

op adds_wsxth( 0b00101011001[11] : rm[5] : 0b101[3] : imm[3] : rn[5] : rd[5] );
adds_wsxth.var reject : {Reject} = {imm >= 5}, format : {char const*} = {"base,380"};

adds_wsxth.disasm = {
  if (rd == 31)
    sink << "cmn\t" << DisasmGSWR(rn) << ", " << DisasmGZWR(rm) << ", sxth" << DisasmINZ(" ", imm);
  else
    sink << "adds\t" << DisasmGZWR(rd) << ", " << DisasmGSWR(rn) << ", " << DisasmGZWR(rm) << ", sxth" << DisasmINZ(" ", imm);
};

adds_wsxth.execute = {
  typedef typename ARCH::S16 S16;
  typedef typename ARCH::S32 S32;
  typedef typename ARCH::U32 U32;
  
  U32 op1( cpu.GetGSR(rn) ), op2( S32(S16(cpu.GetGZR(rm))) << imm ), res = op1 + op2;
  cpu.SetGZR(rd, res);
  cpu.SetNZCV( S32(res) < S32(0), res == U32(0), op1 > ~op2, (S32(res) < S32(0)) xor (S32(op1) <= S32(~op2)) );
};

op adds_wsxtw( 0b00101011001[11] : rm[5] : 0b110[3] : imm[3] : rn[5] : rd[5] );
adds_wsxtw.var reject : {Reject} = {imm >= 5}, format : {char const*} = {"base,384"};

adds_wsxtw.disasm = {
  if (rd == 31)
    sink << "cmn\t" << DisasmGSWR(rn) << ", " << DisasmGZWR(rm) << ", sxtw" << DisasmINZ(" ", imm);
  else
    sink << "adds\t" << DisasmGZWR(rd) << ", " << DisasmGSWR(rn) << ", " << DisasmGZWR(rm) << ", sxtw" << DisasmINZ(" ", imm);
};

adds_wsxtw.execute = {
  typedef typename ARCH::S32 S32;
  typedef typename ARCH::U32 U32;
  
  U32 op1( cpu.GetGSR(rn) ), op2( S32(S32(cpu.GetGZR(rm))) << imm ), res = op1 + op2;
  cpu.SetGZR(rd, res);
  cpu.SetNZCV( S32(res) < S32(0), res == U32(0), op1 > ~op2, (S32(res) < S32(0)) xor (S32(op1) <= S32(~op2)) );
};

op adds_wsxtx( 0b00101011001[11] : rm[5] : 0b111[3] : imm[3] : rn[5] : rd[5] );
adds_wsxtx.var reject : {Reject} = {imm >= 5}, format : {char const*} = {"base,388"};

adds_wsxtx.disasm = {
  if (rd == 31)
    sink << "cmn\t" << DisasmGSWR(rn) << ", " << DisasmGZWR(rm) << ", sxtx" << DisasmINZ(" ", imm);
  else
    sink << "adds\t" << DisasmGZWR(rd) << ", " << DisasmGSWR(rn) << ", " << DisasmGZWR(rm) << ", sxtx" << DisasmINZ(" ", imm);
};

adds_wsxtx.execute = {
  typedef typename ARCH::S64 S64;
  typedef typename ARCH::S32 S32;
  typedef typename ARCH::U32 U32;
  
  U32 op1( cpu.GetGSR(rn) ), op2( S32(S64(cpu.GetGZR(rm))) << imm ), res = op1 + op2;
  cpu.SetGZR(rd, res);
  cpu.SetNZCV( S32(res) < S32(0), res == U32(0), op1 > ~op2, (S32(res) < S32(0)) xor (S32(op1) <= S32(~op2)) );
};

op adds_wuxtb( 0b00101011001[11] : rm[5] : 0b000[3] : imm[3] : rn[5] : rd[5] );
adds_wuxtb.var reject : {Reject} = {imm >= 5}, format : {char const*} = {"base,392"};

adds_wuxtb.disasm = {
  if (rd == 31)
    sink << "cmn\t" << DisasmGSWR(rn) << ", " << DisasmGZWR(rm) << ", uxtb" << DisasmINZ(" ", imm);
  else
    sink << "adds\t" << DisasmGZWR(rd) << ", " << DisasmGSWR(rn) << ", " << DisasmGZWR(rm) << ", uxtb" << DisasmINZ(" ", imm);
};

adds_wuxtb.execute = {
  typedef typename ARCH::U8 U8;
  typedef typename ARCH::U32 U32;
  typedef typename ARCH::S32 S32;
  
  U32 op1( cpu.GetGSR(rn) ), op2( U32(U8(cpu.GetGZR(rm))) << imm ), res = op1 + op2;
  cpu.SetGZR(rd, res);
  cpu.SetNZCV( S32(res) < S32(0), res == U32(0), op1 > ~op2, (S32(res) < S32(0)) xor (S32(op1) <= S32(~op2)) );
};

op adds_wuxth( 0b00101011001[11] : rm[5] : 0b001[3] : imm[3] : rn[5] : rd[5] );
adds_wuxth.var reject : {Reject} = {imm >= 5}, format : {char const*} = {"base,396"};

adds_wuxth.disasm = {
  if (rd == 31)
    sink << "cmn\t" << DisasmGSWR(rn) << ", " << DisasmGZWR(rm) << ", uxth" << DisasmINZ(" ", imm);
  else
    sink << "adds\t" << DisasmGZWR(rd) << ", " << DisasmGSWR(rn) << ", " << DisasmGZWR(rm) << ", uxth" << DisasmINZ(" ", imm);
};

adds_wuxth.execute = {
  typedef typename ARCH::U16 U16;
  typedef typename ARCH::U32 U32;
  typedef typename ARCH::S32 S32;
  
  U32 op1( cpu.GetGSR(rn) ), op2( U32(U16(cpu.GetGZR(rm))) << imm ), res = op1 + op2;
  cpu.SetGZR(rd, res);
  cpu.SetNZCV( S32(res) < S32(0), res == U32(0), op1 > ~op2, (S32(res) < S32(0)) xor (S32(op1) <= S32(~op2)) );
};

op adds_wuxtw( 0b00101011001[11] : rm[5] : 0b010[3] : imm[3] : rn[5] : rd[5] );
adds_wuxtw.var reject : {Reject} = {imm >= 5}, format : {char const*} = {"base,400"};

adds_wuxtw.disasm = {
  if (rd == 31)
    sink << "cmn\t" << DisasmGSWR(rn) << ", " << DisasmGZWR(rm) << ", uxtw" << DisasmINZ(" ", imm);
  else
    sink << "adds\t" << DisasmGZWR(rd) << ", " << DisasmGSWR(rn) << ", " << DisasmGZWR(rm) << ", uxtw" << DisasmINZ(" ", imm);
};

adds_wuxtw.execute = {
  typedef typename ARCH::U32 U32;
  typedef typename ARCH::S32 S32;
  
  U32 op1( cpu.GetGSR(rn) ), op2( U32(U32(cpu.GetGZR(rm))) << imm ), res = op1 + op2;
  cpu.SetGZR(rd, res);
  cpu.SetNZCV( S32(res) < S32(0), res == U32(0), op1 > ~op2, (S32(res) < S32(0)) xor (S32(op1) <= S32(~op2)) );
};

op adds_wuxtx( 0b00101011001[11] : rm[5] : 0b011[3] : imm[3] : rn[5] : rd[5] );
adds_wuxtx.var reject : {Reject} = {imm >= 5}, format : {char const*} = {"base,404"};

adds_wuxtx.disasm = {
  if (rd == 31)
    sink << "cmn\t" << DisasmGSWR(rn) << ", " << DisasmGZWR(rm) << ", uxtx" << DisasmINZ(" ", imm);
  else
    sink << "adds\t" << DisasmGZWR(rd) << ", " << DisasmGSWR(rn) << ", " << DisasmGZWR(rm) << ", uxtx" << DisasmINZ(" ", imm);
};

adds_wuxtx.execute = {
  typedef typename ARCH::U64 U64;
  typedef typename ARCH::U32 U32;
  typedef typename ARCH::S32 S32;
  
  U32 op1( cpu.GetGSR(rn) ), op2( U32(U64(cpu.GetGZR(rm))) << imm ), res = op1 + op2;
  cpu.SetGZR(rd, res);
  cpu.SetNZCV( S32(res) < S32(0), res == U32(0), op1 > ~op2, (S32(res) < S32(0)) xor (S32(op1) <= S32(~op2)) );
};

op adds_xsxtb( 0b10101011001[11] : rm[5] : 0b100[3] : imm[3] : rn[5] : rd[5] );
adds_xsxtb.var reject : {Reject} = {imm >= 5}, format : {char const*} = {"base,408"};

adds_xsxtb.disasm = {
  if (rd == 31)
    sink << "cmn\t" << DisasmGSXR(rn) << ", " << DisasmGZWR(rm) << ", sxtb" << DisasmINZ(" ", imm);
  else
    sink << "adds\t" << DisasmGZXR(rd) << ", " << DisasmGSXR(rn) << ", " << DisasmGZWR(rm) << ", sxtb" << DisasmINZ(" ", imm);
};

adds_xsxtb.execute = {
  typedef typename ARCH::S8 S8;
  typedef typename ARCH::S64 S64;
  typedef typename ARCH::U64 U64;
  
  U64 op1( cpu.GetGSR(rn) ), op2( S64(S8(cpu.GetGZR(rm))) << imm ), res = op1 + op2;
  cpu.SetGZR(rd, res);
  cpu.SetNZCV( S64(res) < S64(0), res == U64(0), op1 > ~op2, (S64(res) < S64(0)) xor (S64(op1) <= S64(~op2)) );
};

op adds_xsxth( 0b10101011001[11] : rm[5] : 0b101[3] : imm[3] : rn[5] : rd[5] );
adds_xsxth.var reject : {Reject} = {imm >= 5}, format : {char const*} = {"base,412"};

adds_xsxth.disasm = {
  if (rd == 31)
    sink << "cmn\t" << DisasmGSXR(rn) << ", " << DisasmGZWR(rm) << ", sxth" << DisasmINZ(" ", imm);
  else
    sink << "adds\t" << DisasmGZXR(rd) << ", " << DisasmGSXR(rn) << ", " << DisasmGZWR(rm) << ", sxth" << DisasmINZ(" ", imm);
};

adds_xsxth.execute = {
  typedef typename ARCH::S16 S16;
  typedef typename ARCH::S64 S64;
  typedef typename ARCH::U64 U64;
  
  U64 op1( cpu.GetGSR(rn) ), op2( S64(S16(cpu.GetGZR(rm))) << imm ), res = op1 + op2;
  cpu.SetGZR(rd, res);
  cpu.SetNZCV( S64(res) < S64(0), res == U64(0), op1 > ~op2, (S64(res) < S64(0)) xor (S64(op1) <= S64(~op2)) );
};

op adds_xsxtw( 0b10101011001[11] : rm[5] : 0b110[3] : imm[3] : rn[5] : rd[5] );
adds_xsxtw.var reject : {Reject} = {imm >= 5}, format : {char const*} = {"base,416"};

adds_xsxtw.disasm = {
  if (rd == 31)
    sink << "cmn\t" << DisasmGSXR(rn) << ", " << DisasmGZWR(rm) << ", sxtw" << DisasmINZ(" ", imm);
  else
    sink << "adds\t" << DisasmGZXR(rd) << ", " << DisasmGSXR(rn) << ", " << DisasmGZWR(rm) << ", sxtw" << DisasmINZ(" ", imm);
};

adds_xsxtw.execute = {
  typedef typename ARCH::S32 S32;
  typedef typename ARCH::S64 S64;
  typedef typename ARCH::U64 U64;
  
  U64 op1( cpu.GetGSR(rn) ), op2( S64(S32(cpu.GetGZR(rm))) << imm ), res = op1 + op2;
  cpu.SetGZR(rd, res);
  cpu.SetNZCV( S64(res) < S64(0), res == U64(0), op1 > ~op2, (S64(res) < S64(0)) xor (S64(op1) <= S64(~op2)) );
};

op adds_xsxtx( 0b10101011001[11] : rm[5] : 0b111[3] : imm[3] : rn[5] : rd[5] );
adds_xsxtx.var reject : {Reject} = {imm >= 5}, format : {char const*} = {"base,432"};

adds_xsxtx.disasm = {
  if (rd == 31)
    sink << "cmn\t" << DisasmGSXR(rn) << ", " << DisasmGZXR(rm) << ", sxtx" << DisasmINZ(" ", imm);
  else
    sink << "adds\t" << DisasmGZXR(rd) << ", " << DisasmGSXR(rn) << ", " << DisasmGZXR(rm) << ", sxtx" << DisasmINZ(" ", imm);
};

adds_xsxtx.execute = {
  typedef typename ARCH::S64 S64;
  typedef typename ARCH::U64 U64;
  
  U64 op1( cpu.GetGSR(rn) ), op2( S64(S64(cpu.GetGZR(rm))) << imm ), res = op1 + op2;
  cpu.SetGZR(rd, res);
  cpu.SetNZCV( S64(res) < S64(0), res == U64(0), op1 > ~op2, (S64(res) < S64(0)) xor (S64(op1) <= S64(~op2)) );
};

op adds_xuxtb( 0b10101011001[11] : rm[5] : 0b000[3] : imm[3] : rn[5] : rd[5] );
adds_xuxtb.var reject : {Reject} = {imm >= 5}, format : {char const*} = {"base,420"};

adds_xuxtb.disasm = {
  if (rd == 31)
    sink << "cmn\t" << DisasmGSXR(rn) << ", " << DisasmGZWR(rm) << ", uxtb" << DisasmINZ(" ", imm);
  else
    sink << "adds\t" << DisasmGZXR(rd) << ", " << DisasmGSXR(rn) << ", " << DisasmGZWR(rm) << ", uxtb" << DisasmINZ(" ", imm);
};

adds_xuxtb.execute = {
  typedef typename ARCH::U8 U8;
  typedef typename ARCH::U64 U64;
  typedef typename ARCH::S64 S64;
  
  U64 op1( cpu.GetGSR(rn) ), op2( U64(U8(cpu.GetGZR(rm))) << imm ), res = op1 + op2;
  cpu.SetGZR(rd, res);
  cpu.SetNZCV( S64(res) < S64(0), res == U64(0), op1 > ~op2, (S64(res) < S64(0)) xor (S64(op1) <= S64(~op2)) );
};

op adds_xuxth( 0b10101011001[11] : rm[5] : 0b001[3] : imm[3] : rn[5] : rd[5] );
adds_xuxth.var reject : {Reject} = {imm >= 5}, format : {char const*} = {"base,424"};

adds_xuxth.disasm = {
  if (rd == 31)
    sink << "cmn\t" << DisasmGSXR(rn) << ", " << DisasmGZWR(rm) << ", uxth" << DisasmINZ(" ", imm);
  else
    sink << "adds\t" << DisasmGZXR(rd) << ", " << DisasmGSXR(rn) << ", " << DisasmGZWR(rm) << ", uxth" << DisasmINZ(" ", imm);
};

adds_xuxth.execute = {
  typedef typename ARCH::U16 U16;
  typedef typename ARCH::U64 U64;
  typedef typename ARCH::S64 S64;
  
  U64 op1( cpu.GetGSR(rn) ), op2( U64(U16(cpu.GetGZR(rm))) << imm ), res = op1 + op2;
  cpu.SetGZR(rd, res);
  cpu.SetNZCV( S64(res) < S64(0), res == U64(0), op1 > ~op2, (S64(res) < S64(0)) xor (S64(op1) <= S64(~op2)) );
};

op adds_xuxtw( 0b10101011001[11] : rm[5] : 0b010[3] : imm[3] : rn[5] : rd[5] );
adds_xuxtw.var reject : {Reject} = {imm >= 5}, format : {char const*} = {"base,428"};

adds_xuxtw.disasm = {
  if (rd == 31)
    sink << "cmn\t" << DisasmGSXR(rn) << ", " << DisasmGZWR(rm) << ", uxtw" << DisasmINZ(" ", imm);
  else
    sink << "adds\t" << DisasmGZXR(rd) << ", " << DisasmGSXR(rn) << ", " << DisasmGZWR(rm) << ", uxtw" << DisasmINZ(" ", imm);
};

adds_xuxtw.execute = {
  typedef typename ARCH::U32 U32;
  typedef typename ARCH::U64 U64;
  typedef typename ARCH::S64 S64;
  
  U64 op1( cpu.GetGSR(rn) ), op2( U64(U32(cpu.GetGZR(rm))) << imm ), res = op1 + op2;
  cpu.SetGZR(rd, res);
  cpu.SetNZCV( S64(res) < S64(0), res == U64(0), op1 > ~op2, (S64(res) < S64(0)) xor (S64(op1) <= S64(~op2)) );
};

op adds_xuxtx( 0b10101011001[11] : rm[5] : 0b011[3] : imm[3] : rn[5] : rd[5] );
adds_xuxtx.var reject : {Reject} = {imm >= 5}, format : {char const*} = {"base,436"};

adds_xuxtx.disasm = {
  if (rd == 31)
    sink << "cmn\t" << DisasmGSXR(rn) << ", " << DisasmGZXR(rm) << ", uxtx" << DisasmINZ(" ", imm);
  else
    sink << "adds\t" << DisasmGZXR(rd) << ", " << DisasmGSXR(rn) << ", " << DisasmGZXR(rm) << ", uxtx" << DisasmINZ(" ", imm);
};

adds_xuxtx.execute = {
  typedef typename ARCH::U64 U64;
  typedef typename ARCH::S64 S64;
  
  U64 op1( cpu.GetGSR(rn) ), op2( U64(U64(cpu.GetGZR(rm))) << imm ), res = op1 + op2;
  cpu.SetGZR(rd, res);
  cpu.SetNZCV( S64(res) < S64(0), res == U64(0), op1 > ~op2, (S64(res) < S64(0)) xor (S64(op1) <= S64(~op2)) );
};

/*
 * end of ADDS (extended register)
 *******************************************************************/

/*******************************************************************
 * ADDS (immediate)
 *
 * Add (immediate), setting the condition flags: Rd = Rn + shift(imm)
 */

op adds_wi( 0b001100010[9] : shl12[1] : imm0[12] : rn[5] : rd[5] );
adds_wi.var imm : {uint32_t} = {shl12 ? (imm0 << 12) : imm0}, format : {char const*} = {"base,23"};

adds_wi.disasm = {
  if (rd == 31)
    sink << "cmn\t" << DisasmGSWR(rn) << ", " << DisasmI(imm,16/*?*/);
  else
    sink << "adds\t" << DisasmGZWR(rd) << ", " << DisasmGSWR(rn) << ", " << DisasmI(imm,16/*?*/);
};

adds_wi.execute = {
  typedef typename ARCH::S32 S32;
  typedef typename ARCH::U32 U32;
  
  U32 op1(cpu.GetGSR(rn)), op2(imm), res = op1 + op2;
  cpu.SetGZR(rd, res);
  cpu.SetNZCV( S32(res) < S32(0), res == U32(0), op1 > ~op2, (S32(res) < S32(0)) xor (S32(op1) <= S32(~op2)) );
};

op adds_xi( 0b101100010[9] : shl12[1] : imm0[12] : rn[5] : rd[5] );
adds_xi.var imm : {uint32_t} = {shl12 ? (imm0 << 12) : imm0}, format : {char const*} = {"base,32"};

adds_xi.disasm = {
  if (rd == 31)
    sink << "cmn\t" << DisasmGSXR(rn) << ", " << DisasmI(imm,16/*?*/);
  else
    sink << "adds\t" << DisasmGZXR(rd) << ", " << DisasmGSXR(rn) << ", " << DisasmI(imm,16/*?*/);
};

adds_xi.execute = {
  typedef typename ARCH::S64 S64;
  typedef typename ARCH::U64 U64;
  
  U64 op1(cpu.GetGSR(rn)), op2(imm), res = op1 + op2;
  cpu.SetGZR(rd, res);
  cpu.SetNZCV( S64(res) < S64(0), res == U64(0), op1 > ~op2, (S64(res) < S64(0)) xor (S64(op1) <= S64(~op2)) );
};

/*
 * end of ADDS (immediate)
 *******************************************************************/

/*******************************************************************
 * ADDS (shifted register)
 * 
 * Add (shifted register), setting the condition flags: Rd = Rn + shift(Rm, amount)
 */

op adds_wlsl( 0b00101011000[11] : rm[5] : 0b0[1] : imm[5] : rn[5] : rd[5] );
adds_wlsl.var format : {char const*} = {"base,183"};

adds_wlsl.disasm = {
  if (rd == 31)
    sink << "cmn\t" << DisasmGZWR(rn) << ", " << DisasmGZWR(rm) << DisasmINZ(", lsl ",imm);
  else
    sink << "adds\t" << DisasmGZWR(rd) << ", " << DisasmGZWR(rn) << ", " << DisasmGZWR(rm) << DisasmINZ(", lsl ",imm);
};

adds_wlsl.execute = {
  typedef typename ARCH::U32 U32;
  typedef typename ARCH::S32 S32;
  
  U32 op1( cpu.GetGZR(rn) ), op2( cpu.GetGZR(rm) << imm ), res = op1 + op2;
  cpu.SetGZR(rd, res);
  cpu.SetNZCV( S32(res) < S32(0), res == U32(0), op1 > ~op2, (S32(res) < S32(0)) xor (S32(op1) <= S32(~op2)) );
};

op adds_wlsr( 0b00101011010[11] : rm[5] : 0b0[1] : imm[5] : rn[5] : rd[5] );
adds_wlsr.var format : {char const*} = {"base,204"};

adds_wlsr.disasm = {
  if (rd == 31)
    sink << "cmn\t" << DisasmGZWR(rn) << ", " << DisasmGZWR(rm) << ", lsr " << DisasmI(imm);
  else
    sink << "adds\t" << DisasmGZWR(rd) << ", " << DisasmGZWR(rn) << ", " << DisasmGZWR(rm) << ", lsr " << DisasmI(imm);
};

adds_wlsr.execute = {
  typedef typename ARCH::U32 U32;
  typedef typename ARCH::S32 S32;
  
  U32 op1( cpu.GetGZR(rn) ), op2( cpu.GetGZR(rm) >> imm ), res = op1 + op2;
  cpu.SetGZR(rd, res);
  cpu.SetNZCV( S32(res) < S32(0), res == U32(0), op1 > ~op2, (S32(res) < S32(0)) xor (S32(op1) <= S32(~op2)) );
};

op adds_wasr( 0b00101011100[11] : rm[5] : 0b0[1] : imm[5] : rn[5] : rd[5] );
adds_wasr.var format : {char const*} = {"base,180"};

adds_wasr.disasm = {
  if (rd == 31)
    sink << "cmn\t" << DisasmGZWR(rn) << ", " << DisasmGZWR(rm) << ", asr " << DisasmI(imm);
  else
    sink << "adds\t" << DisasmGZWR(rd) << ", " << DisasmGZWR(rn) << ", " << DisasmGZWR(rm) << ", asr " << DisasmI(imm);
};

adds_wasr.execute = {
  typedef typename ARCH::U32 U32;
  typedef typename ARCH::S32 S32;
  
  U32 op1( cpu.GetGZR(rn) ), op2( S32(cpu.GetGZR(rm)) >> imm ), res = op1 + op2;
  cpu.SetGZR(rd, res);
  cpu.SetNZCV( S32(res) < S32(0), res == U32(0), op1 > ~op2, (S32(res) < S32(0)) xor (S32(op1) <= S32(~op2)) );
};

op adds_xlsl( 0b10101011000[11] : rm[5] : imm[6] : rn[5] : rd[5] );
adds_xlsl.var format : {char const*} = {"base,128"};

adds_xlsl.disasm = {
  if (rd == 31)
    sink << "cmn\t" << DisasmGZXR(rn) << ", " << DisasmGZXR(rm) << DisasmINZ(", lsl ",imm);
  else
    sink << "adds\t" << DisasmGZXR(rd) << ", " << DisasmGZXR(rn) << ", " << DisasmGZXR(rm) << DisasmINZ(", lsl ",imm);
};

adds_xlsl.execute = {
  typedef typename ARCH::U64 U64;
  typedef typename ARCH::S64 S64;
  
  U64 op1( cpu.GetGZR(rn) ), op2( cpu.GetGZR(rm) << imm ), res = op1 + op2;
  cpu.SetGZR(rd, res);
  cpu.SetNZCV( S64(res) < S64(0), res == U64(0), op1 > ~op2, (S64(res) < S64(0)) xor (S64(op1) <= S64(~op2)) );
};

op adds_xlsr( 0b10101011010[11] : rm[5] : imm[6] : rn[5] : rd[5] );
adds_xlsr.var format : {char const*} = {"base,144"};

adds_xlsr.disasm = {
  if (rd == 31)
    sink << "cmn\t" << DisasmGZXR(rn) << ", " << DisasmGZXR(rm) << ", lsr " << DisasmI(imm);
  else
    sink << "adds\t" << DisasmGZXR(rd) << ", " << DisasmGZXR(rn) << ", " << DisasmGZXR(rm) << ", lsr " << DisasmI(imm);
};

adds_xlsr.execute = {
  typedef typename ARCH::U64 U64;
  typedef typename ARCH::S64 S64;
  
  U64 op1( cpu.GetGZR(rn) ), op2( cpu.GetGZR(rm) >> imm ), res = op1 + op2;
  cpu.SetGZR(rd, res);
  cpu.SetNZCV( S64(res) < S64(0), res == U64(0), op1 > ~op2, (S64(res) < S64(0)) xor (S64(op1) <= S64(~op2)) );
};

op adds_xasr( 0b10101011100[11] : rm[5] : imm[6] : rn[5] : rd[5] );
adds_xasr.var format : {char const*} = {"base,120"};

adds_xasr.disasm = {
  if (rd == 31)
    sink << "cmn\t" << DisasmGZXR(rn) << ", " << DisasmGZXR(rm) << ", asr " << DisasmI(imm);
  else
    sink << "adds\t" << DisasmGZXR(rd) << ", " << DisasmGZXR(rn) << ", " << DisasmGZXR(rm) << ", asr " << DisasmI(imm);
};

adds_xasr.execute = {
  typedef typename ARCH::U64 U64;
  typedef typename ARCH::S64 S64;
  
  U64 op1( cpu.GetGZR(rn) ), op2( S64(cpu.GetGZR(rm)) >> imm ), res = op1 + op2;
  cpu.SetGZR(rd, res);
  cpu.SetNZCV( S64(res) < S64(0), res == U64(0), op1 > ~op2, (S64(res) < S64(0)) xor (S64(op1) <= S64(~op2)) );
};

/*
 * end of ADDS (shifted register)
 *******************************************************************/

/*******************************************************************
 * ADR
 *
 * Address of label at a PC-relative offset
 */

op adr( 0b0[1] : imm0[2] : 0b10000[5] : shl<2> sext imm1[19] : rd[5] );
adr.var imm : {int32_t} = {imm1|imm0}, format : {char const*} = {"base,2"};

adr.disasm = {
  sink << "adr\t" << DisasmGZXR(rd) << ", 0x" << std::hex << (this->GetAddr()+imm);
};

adr.execute = {
  typedef typename ARCH::U64 U64;
  
  cpu.SetGZR(rd, cpu.GetPC() + U64(imm));
};

/*
 * end of ADR
 *******************************************************************/

/*******************************************************************
 * ADRP
 *
 * Address of 4KB page at a PC-relative offset
 */

op adrp( 0b1[1] : imm0[2] : 0b10000[5] : shl<2> sext imm1[19] : rd[5] );
adrp.var imm : {int32_t} = {imm1|imm0}, format : {char const*} = {"base,1"};

adrp.disasm = {
  sink << "adrp\t" << DisasmGZXR(rd) << ", 0x" << std::hex << ((this->GetAddr()+(imm<<12))&(-1ll<<12));
};

adrp.execute = {
  typedef typename ARCH::U64 U64;
  
  cpu.SetGZR(rd, (cpu.GetPC() + U64(imm<<12)) & U64(-1ll<<12));
};

/*
 * end of ADRP
 *******************************************************************/

/*******************************************************************
 * AND (immediate)
 *
 * Bitwise AND (immediate): Rd = Rn AND imm
 */

op and_wi( 0b0001001000[10] : immr[6] : imms[6] : rn[5] : rd[5] );
and_wi.var imm : {uint32_t} = {DecodeBitMasks(0,imms,immr).wmask}, format : {char const*} = {"base,71"};

and_wi.disasm = {
  sink << "and\t" << DisasmGSWR(rd) << ", " << DisasmGZWR(rn) << ", " << DisasmI(imm,16);
};

and_wi.execute = {
  typedef typename ARCH::U32 U32;
  
  U32 op1(cpu.GetGZR(rn)), op2(imm), res = op1 & op2;
  cpu.SetGSR(rd, res);
};

op and_xi( 0b100100100[9] : n[1] : immr[6] : imms[6] : rn[5] : rd[5] );
and_xi.var imm : {uint64_t} = {DecodeBitMasks(n,imms,immr).wmask}, format : {char const*} = {"base,26"};

and_xi.disasm = {
  sink << "and\t" << DisasmGSXR(rd) << ", " << DisasmGZXR(rn) << ", " << DisasmI(imm,16);
};

and_xi.execute = {
  typedef typename ARCH::U64 U64;
  
  U64 op1(cpu.GetGZR(rn)), op2(imm), res = op1 & op2;
  cpu.SetGSR(rd, res);
};

/*
 * end of AND (immediate)
 *******************************************************************/

/*******************************************************************
 * AND (shifted register)
 *
 * Bitwise AND (shifted register): Rd = Rn AND shift(Rm, amount)
 */

op and_wlsl( 0b00001010000[11] : rm[5] : 0b0[1] : imm[5] : rn[5] : rd[5] );
and_wlsl.var format : {char const*} = {"base,187"};

and_wlsl.disasm = {
  sink << "and\t" << DisasmGZWR(rd) << ", " << DisasmGZWR(rn) << ", " << DisasmGZWR(rm) << DisasmINZ(", lsl ",imm);
};

and_wlsl.execute = {
  typedef typename ARCH::U32 U32;
  
  U32 op1( cpu.GetGZR(rn) ), op2( cpu.GetGZR(rm) << imm ), res = op1 & op2;
  cpu.SetGZR(rd, res);
};

op and_wlsr( 0b00001010010[11] : rm[5] : 0b0[1] : imm[5] : rn[5] : rd[5] );
and_wlsr.var format : {char const*} = {"base,195"};

and_wlsr.disasm = {
  sink << "and\t" << DisasmGZWR(rd) << ", " << DisasmGZWR(rn) << ", " << DisasmGZWR(rm) << ", lsr " << DisasmI(imm);
};

and_wlsr.execute = {
  typedef typename ARCH::U32 U32;
  
  U32 op1( cpu.GetGZR(rn) ), op2( cpu.GetGZR(rm) >> imm ), res = op1 & op2;
  cpu.SetGZR(rd, res);
};

op and_wasr( 0b00001010100[11] : rm[5] : 0b0[1] : imm[5] : rn[5] : rd[5] );
and_wasr.var format : {char const*} = {"base,171"};

and_wasr.disasm = {
  sink << "and\t" << DisasmGZWR(rd) << ", " << DisasmGZWR(rn) << ", " << DisasmGZWR(rm) << ", asr " << DisasmI(imm);
};

and_wasr.execute = {
  typedef typename ARCH::U32 U32;
  typedef typename ARCH::S32 S32;
  
  U32 op1( cpu.GetGZR(rn) ), op2( S32(cpu.GetGZR(rm)) >> imm ), res = op1 & op2;
  cpu.SetGZR(rd, res);
};

op and_wror( 0b00001010110[11] : rm[5] : 0b0[1] : imm[5] : rn[5] : rd[5] );
and_wror.var format : {char const*} = {"base,206"};

and_wror.disasm = {
  sink << "and\t" << DisasmGZWR(rd) << ", " << DisasmGZWR(rn) << ", " << DisasmGZWR(rm) << ", ror " << DisasmI(imm);
};

and_wror.execute = {
  typedef typename ARCH::U32 U32;
  
  U32 op1( cpu.GetGZR(rn) ), op2( RotateRight(U32(cpu.GetGZR(rm)), imm) ), res = op1 & op2;
  cpu.SetGZR(rd, res);
};

op and_xlsl( 0b10001010000[11] : rm[5] : imm[6] : rn[5] : rd[5] );
and_xlsl.var format : {char const*} = {"base,123"};

and_xlsl.disasm = {
  sink << "and\t" << DisasmGZXR(rd) << ", " << DisasmGZXR(rn) << ", " << DisasmGZXR(rm) << DisasmINZ(", lsl ",imm);
};

and_xlsl.execute = {
  typedef typename ARCH::U64 U64;
  
  U64 op1( cpu.GetGZR(rn) ), op2( cpu.GetGZR(rm) << imm ), res = op1 & op2;
  cpu.SetGZR(rd, res);
};

op and_xlsr( 0b10001010010[11] : rm[5] : imm[6] : rn[5] : rd[5] );
and_xlsr.var format : {char const*} = {"base,135"};

and_xlsr.disasm = {
  sink << "and\t" << DisasmGZXR(rd) << ", " << DisasmGZXR(rn) << ", " << DisasmGZXR(rm) << ", lsr " << DisasmI(imm);
};

and_xlsr.execute = {
  typedef typename ARCH::U64 U64;
  
  U64 op1( cpu.GetGZR(rn) ), op2( cpu.GetGZR(rm) >> imm ), res = op1 & op2;
  cpu.SetGZR(rd, res);
};

op and_xasr( 0b10001010100[11] : rm[5] : imm[6] : rn[5] : rd[5] );
and_xasr.var format : {char const*} = {"base,111"};

and_xasr.disasm = {
  sink << "and\t" << DisasmGZXR(rd) << ", " << DisasmGZXR(rn) << ", " << DisasmGZXR(rm) << ", asr " << DisasmI(imm);
};

and_xasr.execute = {
  typedef typename ARCH::U64 U64;
  typedef typename ARCH::S64 S64;
  
  U64 op1( cpu.GetGZR(rn) ), op2( S64(cpu.GetGZR(rm)) >> imm ), res = op1 & op2;
  cpu.SetGZR(rd, res);
};

op and_xror( 0b10001010110[11] : rm[5] : imm[6] : rn[5] : rd[5] );
and_xror.var format : {char const*} = {"base,146"};

and_xror.disasm = {
  sink << "and\t" << DisasmGZXR(rd) << ", " << DisasmGZXR(rn) << ", " << DisasmGZXR(rm) << ", ror " << DisasmI(imm);
};

and_xror.execute = {
  typedef typename ARCH::U64 U64;
  
  U64 op1( cpu.GetGZR(rn) ), op2( RotateRight(U64(cpu.GetGZR(rm)), imm) ), res = op1 & op2;
  cpu.SetGZR(rd, res);
};

/*
 * end of AND (shifted register)
 *******************************************************************/

/*******************************************************************
 * ANDS (immediate)
 *
 * Bitwise AND (immediate), setting the condition flags: Rd = Rn AND imm
 */

op ands_wi( 0b0111001000[10] : immr[6] : imms[6] : rn[5] : rd[5] );
ands_wi.var imm : {uint32_t} = {DecodeBitMasks(0,imms,immr).wmask}, format : {char const*} = {"base,73"};

ands_wi.disasm = {
  if (rd == 31)
    sink << "tst\t" << DisasmGZWR(rn) << ", " << DisasmI(imm,16);
  else
    sink << "ands\t" << DisasmGZWR(rd) << ", " << DisasmGZWR(rn) << ", " << DisasmI(imm,16);
};

ands_wi.execute = {
  typedef typename ARCH::U32 U32;
  typedef typename ARCH::S32 S32;
  typedef typename ARCH::BOOL BOOL;
  
  U32 op1(cpu.GetGZR(rn)), op2(imm), res = op1 & op2;
  cpu.SetGZR(rd, res);
  cpu.SetNZCV( S32(res) < S32(0), res == U32(0), BOOL(false), BOOL(false) );
};

op ands_xi( 0b111100100[9] : n[1] : immr[6] : imms[6] : rn[5] : rd[5] );
ands_xi.var imm : {uint64_t} = {DecodeBitMasks(n,imms,immr).wmask}, format : {char const*} = {"base,29"};

ands_xi.disasm = {
  if (rd == 31)
    sink << "tst\t" << DisasmGZXR(rn) << ", " << DisasmI(imm,16);
  else
    sink << "ands\t" << DisasmGZXR(rd) << ", " << DisasmGZXR(rn) << ", " << DisasmI(imm,16);
};

ands_xi.execute = {
  typedef typename ARCH::U64 U64;
  typedef typename ARCH::S64 S64;
  typedef typename ARCH::BOOL BOOL;
  
  U64 op1(cpu.GetGZR(rn)), op2(imm), res = op1 & op2;
  cpu.SetGZR(rd, res);
  cpu.SetNZCV( S64(res) < S64(0), res == U64(0), BOOL(false), BOOL(false) );
};

/*
 * end of ANDS (immediate)
 *******************************************************************/

/*******************************************************************
 * ANDS (shifted register)
 *
 * Bitwise AND (shifted register), setting the condition flags: Rd = Rn AND shift(Rm, amount)
 */

op ands_wlsl( 0b01101010000[11] : rm[5] : 0b0[1] : imm[5] : rn[5] : rd[5] );
ands_wlsl.var format : {char const*} = {"base,184"};

ands_wlsl.disasm = {
  if (rd == 31)
    sink << "tst\t" << DisasmGZWR(rn) << ", " << DisasmGZWR(rm) << DisasmINZ(", lsl ",imm);
  else
    sink << "ands\t" << DisasmGZWR(rd) << ", " << DisasmGZWR(rn) << ", " << DisasmGZWR(rm) << DisasmINZ(", lsl ",imm);
};

ands_wlsl.execute = {
  typedef typename ARCH::U32 U32;
  typedef typename ARCH::S32 S32;
  typedef typename ARCH::BOOL BOOL;
  
  U32 op1( cpu.GetGZR(rn) ), op2( cpu.GetGZR(rm) << imm ), res = op1 & op2;
  cpu.SetGZR(rd, res);
  cpu.SetNZCV( S32(res) < S32(0), res == U32(0), BOOL(false), BOOL(false) );
};

op ands_wlsr( 0b01101010010[11] : rm[5] : 0b0[1] : imm[5] : rn[5] : rd[5] );
ands_wlsr.var format : {char const*} = {"base,205"};

ands_wlsr.disasm = {
  if (rd == 31)
    sink << "tst\t" << DisasmGZWR(rn) << ", " << DisasmGZWR(rm) << ", lsr " << DisasmI(imm);
  else
    sink << "ands\t" << DisasmGZWR(rd) << ", " << DisasmGZWR(rn) << ", " << DisasmGZWR(rm) << ", lsr " << DisasmI(imm);
};

ands_wlsr.execute = {
  typedef typename ARCH::U32 U32;
  typedef typename ARCH::S32 S32;
  typedef typename ARCH::BOOL BOOL;
  
  U32 op1( cpu.GetGZR(rn) ), op2( cpu.GetGZR(rm) >> imm ), res = op1 & op2;
  cpu.SetGZR(rd, res);
  cpu.SetNZCV( S32(res) < S32(0), res == U32(0), BOOL(false), BOOL(false) );
};

op ands_wasr( 0b01101010100[11] : rm[5] : 0b0[1] : imm[5] : rn[5] : rd[5] );
ands_wasr.var format : {char const*} = {"base,181"};

ands_wasr.disasm = {
  if (rd == 31)
    sink << "tst\t" << DisasmGZWR(rn) << ", " << DisasmGZWR(rm) << ", asr " << DisasmI(imm);
  else
    sink << "ands\t" << DisasmGZWR(rd) << ", " << DisasmGZWR(rn) << ", " << DisasmGZWR(rm) << ", asr " << DisasmI(imm);
};

ands_wasr.execute = {
  typedef typename ARCH::U32 U32;
  typedef typename ARCH::S32 S32;
  typedef typename ARCH::BOOL BOOL;
  
  U32 op1( cpu.GetGZR(rn) ), op2( S32(cpu.GetGZR(rm)) >> imm ), res = op1 & op2;
  cpu.SetGZR(rd, res);
  cpu.SetNZCV( S32(res) < S32(0), res == U32(0), BOOL(false), BOOL(false) );
};

op ands_wror( 0b01101010110[11] : rm[5] : 0b0[1] : imm[5] : rn[5] : rd[5] );
ands_wror.var format : {char const*} = {"base,213"};

ands_wror.disasm = {
  if (rd == 31)
    sink << "tst\t" << DisasmGZWR(rn) << ", " << DisasmGZWR(rm) << ", ror " << DisasmI(imm);
  else
    sink << "ands\t" << DisasmGZWR(rd) << ", " << DisasmGZWR(rn) << ", " << DisasmGZWR(rm) << ", ror " << DisasmI(imm);
};

ands_wror.execute = {
  typedef typename ARCH::U32 U32;
  typedef typename ARCH::S32 S32;
  typedef typename ARCH::BOOL BOOL;
  
  U32 op1( cpu.GetGZR(rn) ), op2( RotateRight(U32(cpu.GetGZR(rm)), imm) ), res = op1 & op2;
  cpu.SetGZR(rd, res);
  cpu.SetNZCV( S32(res) < S32(0), res == U32(0), BOOL(false), BOOL(false) );
};

op ands_xlsl( 0b11101010000[11] : rm[5] : imm[6] : rn[5] : rd[5] );
ands_xlsl.var format : {char const*} = {"base,130"};

ands_xlsl.disasm = {
  if (rd == 31)
    sink << "tst\t" << DisasmGZXR(rn) << ", " << DisasmGZXR(rm) << DisasmINZ(", lsl ",imm);
  else
    sink << "ands\t" << DisasmGZXR(rd) << ", " << DisasmGZXR(rn) << ", " << DisasmGZXR(rm) << DisasmINZ(", lsl ",imm);
};

ands_xlsl.execute = {
  typedef typename ARCH::U64 U64;
  typedef typename ARCH::S64 S64;
  typedef typename ARCH::BOOL BOOL;
  
  U64 op1( cpu.GetGZR(rn) ), op2( cpu.GetGZR(rm) << imm ), res = op1 & op2;
  cpu.SetGZR(rd, res);
  cpu.SetNZCV( S64(res) < S64(0), res == U64(0), BOOL(false), BOOL(false) );
};

op ands_xlsr( 0b11101010010[11] : rm[5] : imm[6] : rn[5] : rd[5] );
ands_xlsr.var format : {char const*} = {"base,145"};

ands_xlsr.disasm = {
  if (rd == 31)
    sink << "tst\t" << DisasmGZXR(rn) << ", " << DisasmGZXR(rm) << ", lsr " << DisasmI(imm);
  else
    sink << "ands\t" << DisasmGZXR(rd) << ", " << DisasmGZXR(rn) << ", " << DisasmGZXR(rm) << ", lsr " << DisasmI(imm);
};

ands_xlsr.execute = {
  typedef typename ARCH::U64 U64;
  typedef typename ARCH::S64 S64;
  typedef typename ARCH::BOOL BOOL;
  
  U64 op1( cpu.GetGZR(rn) ), op2( cpu.GetGZR(rm) >> imm ), res = op1 & op2;
  cpu.SetGZR(rd, res);
  cpu.SetNZCV( S64(res) < S64(0), res == U64(0), BOOL(false), BOOL(false) );
};

op ands_xasr( 0b11101010100[11] : rm[5] : imm[6] : rn[5] : rd[5] );
ands_xasr.var format : {char const*} = {"base,121"};

ands_xasr.disasm = {
  if (rd == 31)
    sink << "tst\t" << DisasmGZXR(rn) << ", " << DisasmGZXR(rm) << ", asr " << DisasmI(imm);
  else
    sink << "ands\t" << DisasmGZXR(rd) << ", " << DisasmGZXR(rn) << ", " << DisasmGZXR(rm) << ", asr " << DisasmI(imm);
};

ands_xasr.execute = {
  typedef typename ARCH::U64 U64;
  typedef typename ARCH::S64 S64;
  typedef typename ARCH::BOOL BOOL;
  
  U64 op1( cpu.GetGZR(rn) ), op2( S64(cpu.GetGZR(rm)) >> imm ), res = op1 & op2;
  cpu.SetGZR(rd, res);
  cpu.SetNZCV( S64(res) < S64(0), res == U64(0), BOOL(false), BOOL(false) );
};

op ands_xror( 0b11101010110[11] : rm[5] : imm[6] : rn[5] : rd[5] );
ands_xror.var format : {char const*} = {"base,153"};

ands_xror.disasm = {
  if (rd == 31)
    sink << "tst\t" << DisasmGZXR(rn) << ", " << DisasmGZXR(rm) << ", ror " << DisasmI(imm);
  else
    sink << "ands\t" << DisasmGZXR(rd) << ", " << DisasmGZXR(rn) << ", " << DisasmGZXR(rm) << ", ror " << DisasmI(imm);
};

ands_xror.execute = {
  typedef typename ARCH::U64 U64;
  typedef typename ARCH::S64 S64;
  typedef typename ARCH::BOOL BOOL;
  
  U64 op1( cpu.GetGZR(rn) ), op2( RotateRight(U64(cpu.GetGZR(rm)), imm) ), res = op1 & op2;
  cpu.SetGZR(rd, res);
  cpu.SetNZCV( S64(res) < S64(0), res == U64(0), BOOL(false), BOOL(false) );
};

/*
 * end of ANDS (shifted register)
 *******************************************************************/

/*******************************************************************
 * ASR (register)
 *
 * Arithmetic shift right (register): Rd = ASR(Rn, Rm)
 */

op asr_www( 0b00011010110[11] : rm[5] : 0b001010[6] : rn[5] : rd[5] );
asr_www.var format : {char const*} = {"base,1460"};

asr_www.disasm = {
  sink << "asr\t" << DisasmGZWR(rd) << ", " << DisasmGZWR(rn) << ", " << DisasmGZWR(rm);
};

asr_www.execute = {
  typedef typename ARCH::U32 U32;
  typedef typename ARCH::S32 S32;
  
  U32 op1( cpu.GetGZR(rn) ), op2( cpu.GetGZR(rm) ), res( S32(op1) >> (op2 & U32(0b11111)) );
  cpu.SetGZR(rd, res);
};

op asr_xxx( 0b10011010110[11] : rm[5] : 0b001010[6] : rn[5] : rd[5] );
asr_xxx.var format : {char const*} = {"base,1614"};

asr_xxx.disasm = {
  sink << "asr\t" << DisasmGZXR(rd) << ", " << DisasmGZXR(rn) << ", " << DisasmGZXR(rm);
};

asr_xxx.execute = {
  typedef typename ARCH::U64 U64;
  typedef typename ARCH::S64 S64;
  
  U64 op1( cpu.GetGZR(rn) ), op2( cpu.GetGZR(rm) ), res( S64(op1) >> (op2 & U64(0b111111)) );
  cpu.SetGZR(rd, res);
};

/*
 * end of ASR (register)
 *******************************************************************/

/*******************************************************************
 * B
 *
 * Branch unconditionally to a label at a PC-relative offset, with a
 * hint that this is not a subroutine call or return
 */

op b( 0b000101[6] : shl<2> sext imm[26] );
b.var format : {char const*} = {"base,3"};

b.disasm = {
  sink << "b\t0x" << std::hex << (this->GetAddr()+imm);
};

b.execute = {
  typedef typename ARCH::U64 U64;
  typedef typename ARCH::S64 S64;
  
  cpu.BranchTo( cpu.GetPC() + U64(S64(imm)), ARCH::B_JMP );
};

/*
 * end of B
 *******************************************************************/

/*******************************************************************
 * B.cond
 *
 * Branch conditionally to a label at a PC-relative offset, with a hint that this is not a subroutine call or return
 */

op b_cond( 0b01010100[8] : shl<2> sext imm[19] : 0b0[1] : cond[4] );
b_cond.var format : {char const*} = {"base,20"};

b_cond.disasm = {
  sink << "b." << DisasmCond(cond) << "\t0x" << std::hex << (this->GetAddr()+imm);
};

b_cond.execute = {
  typedef typename ARCH::U64 U64;
  typedef typename ARCH::S64 S64;
  
  if (CheckCondition(cpu, cond))
    cpu.BranchTo( cpu.GetPC() + U64(S64(imm)), ARCH::B_JMP );
};

/*
 * end of B.cond
 *******************************************************************/

/*******************************************************************
 * BFM
 *
 * Bitfield move, leaving other bits unchanged
 */

op bfm_w( 0b00110011000[11] : immr[5] : 0b0[1] : imms[5] : rn[5] : rd[5] );
bfm_w.var format : {char const*} = {"base,162"};

bfm_w.disasm = {
  if (imms < immr)
    sink << "bfi\t" << DisasmGZWR(rd) << ", " << DisasmGZWR(rn) << ", " << DisasmI(-immr&31) << ", " << DisasmI(imms+1);
  else
    sink << "bfxil\t" << DisasmGZWR(rd) << ", " << DisasmGZWR(rn) << ", " << DisasmI(immr) << ", " << DisasmI(imms+1-immr);
};

bfm_w.execute = {
  typedef typename ARCH::U32 U32;
  unsigned l = (imms ^ 31), r = (l + immr) & 31;
  uint32_t mask = (uint32_t(int32_t(-1)) << l) >> r;
  
  U32 src( cpu.GetGZR(rn) ), bf( (src << l) >> r ), dst( cpu.GetGZR(rd) ), res( (dst & U32(~mask)) | bf );
  cpu.SetGZR(rd, res);
};

op bfm_x( 0b1011001101[10] : immr[6] : imms[6] : rn[5] : rd[5] );
bfm_x.var format : {char const*} = {"base,90"};

bfm_x.disasm = {
  if (imms < immr)
    sink << "bfi\t" << DisasmGZXR(rd) << ", " << DisasmGZXR(rn) << ", " << DisasmI(-immr&63) << ", " << DisasmI(imms+1);
  else
    sink << "bfxil\t" << DisasmGZXR(rd) << ", " << DisasmGZXR(rn) << ", " << DisasmI(immr) << ", " << DisasmI(imms+1-immr);
};

bfm_x.execute = {
  typedef typename ARCH::U64 U64;
  unsigned l = (imms ^ 63), r = (l + immr) & 63;
  uint64_t mask = (uint64_t(int64_t(-1)) << l) >> r;
  
  U64 src( cpu.GetGZR(rn) ), bf( (src << l) >> r ), res( (cpu.GetGZR(rd) & U64(~mask)) | bf );
  cpu.SetGZR(rd, res);
};

/*
 * end of BFM
 *******************************************************************/

/*******************************************************************
 * BIC (shifted register)
 *
 * Bitwise bit clear (shifted register): Rd = Rn AND NOT shift(Rm, amount)
 */

op bic_wlsl( 0b00001010001[11] : rm[5] : 0b0[1] : imm[5] : rn[5] : rd[5] );
bic_wlsl.var format : {char const*} = {"base,188"};

bic_wlsl.disasm = {
  sink << "bic\t" << DisasmGZWR(rd) << ", " << DisasmGZWR(rn) << ", " << DisasmGZWR(rm) << DisasmINZ(", lsl ",imm);
};

bic_wlsl.execute = {
  typedef typename ARCH::U32 U32;
  
  U32 op1( cpu.GetGZR(rn) ), op2( cpu.GetGZR(rm) << imm ), res = op1 & ~op2;
  cpu.SetGZR(rd, res);
};

op bic_wlsr( 0b00001010011[11] : rm[5] : 0b0[1] : imm[5] : rn[5] : rd[5] );
bic_wlsr.var format : {char const*} = {"base,196"};

bic_wlsr.disasm = {
  sink << "bic\t" << DisasmGZWR(rd) << ", " << DisasmGZWR(rn) << ", " << DisasmGZWR(rm) << ", lsr " << DisasmI(imm);
};

bic_wlsr.execute = {
  typedef typename ARCH::U32 U32;
  
  U32 op1( cpu.GetGZR(rn) ), op2( cpu.GetGZR(rm) >> imm ), res = op1 & ~op2;
  cpu.SetGZR(rd, res);
};

op bic_wasr( 0b00001010101[11] : rm[5] : 0b0[1] : imm[5] : rn[5] : rd[5] );
bic_wasr.var format : {char const*} = {"base,172"};

bic_wasr.disasm = {
  sink << "bic\t" << DisasmGZWR(rd) << ", " << DisasmGZWR(rn) << ", " << DisasmGZWR(rm) << ", asr " << DisasmI(imm);
};

bic_wasr.execute = {
  typedef typename ARCH::U32 U32;
  typedef typename ARCH::S32 S32;
  
  U32 op1( cpu.GetGZR(rn) ), op2( S32(cpu.GetGZR(rm)) >> imm ), res = op1 & ~op2;
  cpu.SetGZR(rd, res);
};

op bic_wror( 0b00001010111[11] : rm[5] : 0b0[1] : imm[5] : rn[5] : rd[5] );
bic_wror.var format : {char const*} = {"base,207"};

bic_wror.disasm = {
  sink << "bic\t" << DisasmGZWR(rd) << ", " << DisasmGZWR(rn) << ", " << DisasmGZWR(rm) << ", ror " << DisasmI(imm);
};

bic_wror.execute = {
  typedef typename ARCH::U32 U32;
  
  U32 op1( cpu.GetGZR(rn) ), op2( RotateRight(U32(cpu.GetGZR(rm)), imm) ), res = op1 & ~op2;
  cpu.SetGZR(rd, res);
};

op bic_xlsl( 0b10001010001[11] : rm[5] : imm[6] : rn[5] : rd[5] );
bic_xlsl.var format : {char const*} = {"base,124"};

bic_xlsl.disasm = {
  sink << "bic\t" << DisasmGZXR(rd) << ", " << DisasmGZXR(rn) << ", " << DisasmGZXR(rm) << DisasmINZ(", lsl ",imm);
};

bic_xlsl.execute = {
  typedef typename ARCH::U64 U64;
  
  U64 op1( cpu.GetGZR(rn) ), op2( cpu.GetGZR(rm) << imm ), res = op1 & ~op2;
  cpu.SetGZR(rd, res);
};

op bic_xlsr( 0b10001010011[11] : rm[5] : imm[6] : rn[5] : rd[5] );
bic_xlsr.var format : {char const*} = {"base,136"};

bic_xlsr.disasm = {
  sink << "bic\t" << DisasmGZXR(rd) << ", " << DisasmGZXR(rn) << ", " << DisasmGZXR(rm) << ", lsr " << DisasmI(imm);
};

bic_xlsr.execute = {
  typedef typename ARCH::U64 U64;
  
  U64 op1( cpu.GetGZR(rn) ), op2( cpu.GetGZR(rm) >> imm ), res = op1 & ~op2;
  cpu.SetGZR(rd, res);
};

op bic_xasr( 0b10001010101[11] : rm[5] : imm[6] : rn[5] : rd[5] );
bic_xasr.var format : {char const*} = {"base,112"};

bic_xasr.disasm = {
  sink << "bic\t" << DisasmGZXR(rd) << ", " << DisasmGZXR(rn) << ", " << DisasmGZXR(rm) << ", asr " << DisasmI(imm);
};

bic_xasr.execute = {
  typedef typename ARCH::U64 U64;
  typedef typename ARCH::S64 S64;
  
  U64 op1( cpu.GetGZR(rn) ), op2( S64(cpu.GetGZR(rm)) >> imm ), res = op1 & ~op2;
  cpu.SetGZR(rd, res);
};

op bic_xror( 0b10001010111[11] : rm[5] : imm[6] : rn[5] : rd[5] );
bic_xror.var format : {char const*} = {"base,147"};

bic_xror.disasm = {
  sink << "bic\t" << DisasmGZXR(rd) << ", " << DisasmGZXR(rn) << ", " << DisasmGZXR(rm) << ", ror " << DisasmI(imm);
};

bic_xror.execute = {
  typedef typename ARCH::U64 U64;
  
  U64 op1( cpu.GetGZR(rn) ), op2( RotateRight(U64(cpu.GetGZR(rm)), imm) ), res = op1 & ~op2;
  cpu.SetGZR(rd, res);
};

/*
 * end of BIC (shifted register)
 *******************************************************************/

/*******************************************************************
 * BICS (shifted register)
 *
 * Bitwise bit clear (shifted register), setting the condition flags: Rd = Rn AND NOT shift(Rm, amount)
 */

op bics_wlsl( 0b01101010001[11] : rm[5] : 0b0[1] : imm[5] : rn[5] : rd[5] );
bics_wlsl.var format : {char const*} = {"base,189"};

bics_wlsl.disasm = {
  sink << "bics\t" << DisasmGZWR(rd) << ", " << DisasmGZWR(rn) << ", " << DisasmGZWR(rm) << DisasmINZ(", lsl ",imm);
};

bics_wlsl.execute = {
  typedef typename ARCH::U32 U32;
  typedef typename ARCH::S32 S32;
  typedef typename ARCH::BOOL BOOL;
  
  U32 op1( cpu.GetGZR(rn) ), op2( cpu.GetGZR(rm) << imm ), res = op1 & ~op2;
  cpu.SetGZR(rd, res);
  cpu.SetNZCV( S32(res) < S32(0), res == U32(0), BOOL(false), BOOL(false) );
};

op bics_wlsr( 0b01101010011[11] : rm[5] : 0b0[1] : imm[5] : rn[5] : rd[5] );
bics_wlsr.var format : {char const*} = {"base,197"};

bics_wlsr.disasm = {
  sink << "bics\t" << DisasmGZWR(rd) << ", " << DisasmGZWR(rn) << ", " << DisasmGZWR(rm) << ", lsr " << DisasmI(imm);
};

bics_wlsr.execute = {
  typedef typename ARCH::U32 U32;
  typedef typename ARCH::S32 S32;
  typedef typename ARCH::BOOL BOOL;
  
  U32 op1( cpu.GetGZR(rn) ), op2( cpu.GetGZR(rm) >> imm ), res = op1 & ~op2;
  cpu.SetGZR(rd, res);
  cpu.SetNZCV( S32(res) < S32(0), res == U32(0), BOOL(false), BOOL(false) );
};

op bics_wasr( 0b01101010101[11] : rm[5] : 0b0[1] : imm[5] : rn[5] : rd[5] );
bics_wasr.var format : {char const*} = {"base,173"};

bics_wasr.disasm = {
  sink << "bics\t" << DisasmGZWR(rd) << ", " << DisasmGZWR(rn) << ", " << DisasmGZWR(rm) << ", asr " << DisasmI(imm);
};

bics_wasr.execute = {
  typedef typename ARCH::U32 U32;
  typedef typename ARCH::S32 S32;
  typedef typename ARCH::BOOL BOOL;
  
  U32 op1( cpu.GetGZR(rn) ), op2( S32(cpu.GetGZR(rm)) >> imm ), res = op1 & ~op2;
  cpu.SetGZR(rd, res);
  cpu.SetNZCV( S32(res) < S32(0), res == U32(0), BOOL(false), BOOL(false) );
};

op bics_wror( 0b01101010111[11] : rm[5] : 0b0[1] : imm[5] : rn[5] : rd[5] );
bics_wror.var format : {char const*} = {"base,208"};

bics_wror.disasm = {
  sink << "bics\t" << DisasmGZWR(rd) << ", " << DisasmGZWR(rn) << ", " << DisasmGZWR(rm) << ", ror " << DisasmI(imm);
};

bics_wror.execute = {
  typedef typename ARCH::U32 U32;
  typedef typename ARCH::S32 S32;
  typedef typename ARCH::BOOL BOOL;
  
  U32 op1( cpu.GetGZR(rn) ), op2( RotateRight(U32(cpu.GetGZR(rm)), imm) ), res = op1 & ~op2;
  cpu.SetGZR(rd, res);
  cpu.SetNZCV( S32(res) < S32(0), res == U32(0), BOOL(false), BOOL(false) );
};

op bics_xlsl( 0b11101010001[11] : rm[5] : imm[6] : rn[5] : rd[5] );
bics_xlsl.var format : {char const*} = {"base,125"};

bics_xlsl.disasm = {
  sink << "bics\t" << DisasmGZXR(rd) << ", " << DisasmGZXR(rn) << ", " << DisasmGZXR(rm) << DisasmINZ(", lsl ",imm);
};

bics_xlsl.execute = {
  typedef typename ARCH::U64 U64;
  typedef typename ARCH::S64 S64;
  typedef typename ARCH::BOOL BOOL;
  
  U64 op1( cpu.GetGZR(rn) ), op2( cpu.GetGZR(rm) << imm ), res = op1 & ~op2;
  cpu.SetGZR(rd, res);
  cpu.SetNZCV( S64(res) < S64(0), res == U64(0), BOOL(false), BOOL(false) );
};

op bics_xlsr( 0b11101010011[11] : rm[5] : imm[6] : rn[5] : rd[5] );
bics_xlsr.var format : {char const*} = {"base,137"};

bics_xlsr.disasm = {
  sink << "bics\t" << DisasmGZXR(rd) << ", " << DisasmGZXR(rn) << ", " << DisasmGZXR(rm) << ", lsr " << DisasmI(imm);
};

bics_xlsr.execute = {
  typedef typename ARCH::U64 U64;
  typedef typename ARCH::S64 S64;
  typedef typename ARCH::BOOL BOOL;
  
  U64 op1( cpu.GetGZR(rn) ), op2( cpu.GetGZR(rm) >> imm ), res = op1 & ~op2;
  cpu.SetGZR(rd, res);
  cpu.SetNZCV( S64(res) < S64(0), res == U64(0), BOOL(false), BOOL(false) );
};

op bics_xasr( 0b11101010101[11] : rm[5] : imm[6] : rn[5] : rd[5] );
bics_xasr.var format : {char const*} = {"base,113"};

bics_xasr.disasm = {
  sink << "bics\t" << DisasmGZXR(rd) << ", " << DisasmGZXR(rn) << ", " << DisasmGZXR(rm) << ", asr " << DisasmI(imm);
};

bics_xasr.execute = {
  typedef typename ARCH::U64 U64;
  typedef typename ARCH::S64 S64;
  typedef typename ARCH::BOOL BOOL;
  
  U64 op1( cpu.GetGZR(rn) ), op2( S64(cpu.GetGZR(rm)) >> imm ), res = op1 & ~op2;
  cpu.SetGZR(rd, res);
  cpu.SetNZCV( S64(res) < S64(0), res == U64(0), BOOL(false), BOOL(false) );
};

op bics_xror( 0b11101010111[11] : rm[5] : imm[6] : rn[5] : rd[5] );
bics_xror.var format : {char const*} = {"base,148"};

bics_xror.disasm = {
  sink << "bics\t" << DisasmGZXR(rd) << ", " << DisasmGZXR(rn) << ", " << DisasmGZXR(rm) << ", ror " << DisasmI(imm);
};

bics_xror.execute = {
  typedef typename ARCH::U64 U64;
  typedef typename ARCH::S64 S64;
  typedef typename ARCH::BOOL BOOL;
  
  U64 op1( cpu.GetGZR(rn) ), op2( RotateRight(U64(cpu.GetGZR(rm)), imm) ), res = op1 & ~op2;
  cpu.SetGZR(rd, res);
  cpu.SetNZCV( S64(res) < S64(0), res == U64(0), BOOL(false), BOOL(false) );
};

/*
 * end of BICS (shifted register)
 *******************************************************************/

/*******************************************************************
 * BL
 *
 * Branch with link, calls a subroutine at a PC-relative offset, setting register X30 to PC + 4
 */

op bl( 0b100101[6] : shl<2> sext imm[26] );
bl.var format : {char const*} = {"base,4"};

bl.disasm = {
  sink << "bl\t0x" << std::hex << (this->GetAddr()+int64_t(imm));
};

bl.execute = {
  typedef typename ARCH::U64 U64;
  typedef typename ARCH::S64 S64;
  
  U64 target_addr( cpu.GetPC() + U64(S64(imm)) );
  U64 return_addr( cpu.GetNPC() );
  cpu.SetGZR(30, return_addr);
  cpu.BranchTo( target_addr, ARCH::B_CALL );
};

/*
 * end of BL
 *******************************************************************/

/*******************************************************************
 * BLR
 *
 * Branch with link to register, calls a subroutine at an address in a register, setting register X30 to PC + 4
 */

op blr( 0b1101011000111111000000[22] : rn[5] : 0b00000[5] );
blr.var format : {char const*} = {"base,2886"};

blr.disasm = {
  sink << "blr\t" << DisasmGZXR(rn);
};

blr.execute = {
  typedef typename ARCH::U64 U64;
  
  U64 target_addr( cpu.GetGZR(rn) );
  U64 return_addr( cpu.GetNPC() );
  cpu.SetGZR(30, return_addr);
  cpu.BranchTo( target_addr, ARCH::B_CALL );
};

/*
 * end of BLR
 *******************************************************************/

/*******************************************************************
 * BR
 *
 * Branch to register, branches unconditionally to an address in a register, with a hint that this is not a subroutine return
 */

op br( 0b1101011000011111000000[22] : rn[5] : 0b00000[5] );
br.var format : {char const*} = {"base,2887"};

br.disasm = {
  sink << "br\t" << DisasmGZXR(rn);
};

br.execute = {
  typedef typename ARCH::U64 U64;
  
  U64 target_addr( cpu.GetGZR(rn) );
  cpu.BranchTo( target_addr, ARCH::B_JMP );
};

/*
 * end of BR
 *******************************************************************/

op brk( 0b11010100001[11] : imm[16] : 0b00000[5] );
brk.var format : {char const*} = {"base,573"};

brk.disasm = {
  sink << "brk\t" << DisasmI(imm,16);
};

/*******************************************************************
 * CBNZ
 *
 * Compare and branch if nonzero to a label at a PC-relative offset,
 * without affecting the condition flags, and with a hint that this is
 * not a subroutine call or return
 */

op cbnz_wlit( 0b00110101[8] : shl<2> sext imm[19] : rt[5] );
cbnz_wlit.var format : {char const*} = {"base,12"};

cbnz_wlit.disasm = {
  sink << "cbnz\t" << DisasmGZWR(rt) << ", 0x" << std::hex << (this->GetAddr()+imm);
};

cbnz_wlit.execute = {
  typedef typename ARCH::U32 U32;
  typedef typename ARCH::U64 U64;
  typedef typename ARCH::S64 S64;
  
  U32 op1( cpu.GetGZR(rt) );
  
  if (cpu.Test( op1 != U32(0) ))
    cpu.BranchTo( cpu.GetPC() + U64(S64(imm)), ARCH::B_JMP );
};

op cbnz_xlit( 0b10110101[8] : shl<2> sext imm[19] : rt[5] );
cbnz_xlit.var format : {char const*} = {"base,15"};

cbnz_xlit.disasm = {
  sink << "cbnz\t" << DisasmGZXR(rt) << ", 0x" << std::hex << (this->GetAddr()+imm);
};

cbnz_xlit.execute = {
  typedef typename ARCH::U64 U64;
  typedef typename ARCH::S64 S64;
  
  U64 op1( cpu.GetGZR(rt) );
  
  if (cpu.Test( op1 != U64(0) ))
    cpu.BranchTo( cpu.GetPC() + U64(S64(imm)), ARCH::B_JMP );
};

/*
 * end of CBNZ
 *******************************************************************/

/*******************************************************************
 * CBZ
 *
 * Compare and branch if zero to a label at a PC-relative offset,
 * without affecting the condition flags, and with a hint that this is
 * not a subroutine call or return
 */

op cbz_wlit( 0b00110100[8] : shl<2> sext imm[19] : rt[5] );
cbz_wlit.var format : {char const*} = {"base,13"};

cbz_wlit.disasm = {
  sink << "cbz\t" << DisasmGZWR(rt) << ", 0x" << std::hex << (this->GetAddr()+imm);
};

cbz_wlit.execute = {
  typedef typename ARCH::U32 U32;
  typedef typename ARCH::U64 U64;
  typedef typename ARCH::S64 S64;
  
  U32 op1( cpu.GetGZR(rt) );
  
  if (cpu.Test( op1 == U32(0) ))
    cpu.BranchTo( cpu.GetPC() + U64(S64(imm)), ARCH::B_JMP );
};

op cbz_xlit( 0b10110100[8] : shl<2> sext imm[19] : rt[5] );
cbz_xlit.var format : {char const*} = {"base,16"};

cbz_xlit.disasm = {
  sink << "cbz\t" << DisasmGZXR(rt) << ", 0x" << std::hex << (this->GetAddr()+imm);
};

cbz_xlit.execute = {
  typedef typename ARCH::U64 U64;
  typedef typename ARCH::S64 S64;
  
  U64 op1( cpu.GetGZR(rt) );
  
  if (cpu.Test( op1 == U64(0) ))
    cpu.BranchTo( cpu.GetPC() + U64(S64(imm)), ARCH::B_JMP );
};

/*
 * end of CBZ
 *******************************************************************/

/*******************************************************************
 * CCMN (immediate)
 *
 * Conditional compare negative (immediate), setting condition flags
 * to result of comparison or an immediate value:
 *
 * flags = if cond then compare(Rn, #-imm) else #nzcv
 */

op ccmn_wi( 0b00111010010[11] : imm[5] : cond[4] : 0b10[2] : rn[5] : 0b0[1] : n[1] : z[1] : c[1] : v[1] );
ccmn_wi.var format : {char const*} = {"base,366"};

ccmn_wi.disasm = {
  sink << "ccmn\t" << DisasmGZWR(rn) << ", " << DisasmI(imm,16) << ", " << DisasmI((n<<3)|(z<<2)|(c<<1)|(v<<0),16) << ", " << DisasmCond(cond);
};

ccmn_wi.execute = {
  typedef typename ARCH::S32 S32;
  typedef typename ARCH::U32 U32;
  typedef typename ARCH::BOOL BOOL;
  
  if (CheckCondition(cpu, cond))
    {
      U32 op1( cpu.GetGZR(rn) ), op2( imm ), res = op1 + op2;
      cpu.SetNZCV( S32(res) < S32(0), res == U32(0), op1 > ~op2, (S32(res) < S32(0)) xor (S32(op1) <= S32(~op2)) );
    }
  else
    cpu.SetNZCV( BOOL(n==1), BOOL(z==1), BOOL(c==1), BOOL(v==1) );
};

op ccmn_xi( 0b10111010010[11] : imm[5] : cond[4] : 0b10[2] : rn[5] : 0b0[1] : n[1] : z[1] : c[1] : v[1] );
ccmn_xi.var format : {char const*} = {"base,370"};

ccmn_xi.disasm = {
  sink << "ccmn\t" << DisasmGZXR(rn) << ", " << DisasmI(imm,16) << ", " << DisasmI((n<<3)|(z<<2)|(c<<1)|(v<<0),16) << ", " << DisasmCond(cond);
};

ccmn_xi.execute = {
  typedef typename ARCH::S64 S64;
  typedef typename ARCH::U64 U64;
  typedef typename ARCH::BOOL BOOL;
  
  if (CheckCondition(cpu, cond))
    {
      U64 op1( cpu.GetGZR(rn) ), op2( imm ), res = op1 + op2;
      cpu.SetNZCV( S64(res) < S64(0), res == U64(0), op1 > ~op2, (S64(res) < S64(0)) xor (S64(op1) <= S64(~op2)) );
    }
  else
    cpu.SetNZCV( BOOL(n==1), BOOL(z==1), BOOL(c==1), BOOL(v==1) );
};

/*
 * end of CCMN (immediate)
 *******************************************************************/

/*******************************************************************
 * CCMN (register)
 *
 * Conditional compare negative (register), setting condition flags to
 * result of comparison or an immediate value:
 *
 * flags = if cond then compare(Rn, -Rm) else #nzcv
 */

op ccmn_w( 0b00111010010[11] : rm[5] : cond[4] : 0b00[2] : rn[5] : 0b0[1] : n[1] : z[1] : c[1] : v[1] );
ccmn_w.var format : {char const*} = {"base,368"};

ccmn_w.disasm = {
  sink << "ccmn\t" << DisasmGZWR(rn) << ", " << DisasmGZWR(rm) << ", " << DisasmI((n<<3)|(z<<2)|(c<<1)|(v<<0),16) << ", " << DisasmCond(cond);
};

ccmn_w.execute = {
  typedef typename ARCH::S32 S32;
  typedef typename ARCH::U32 U32;
  typedef typename ARCH::BOOL BOOL;
  
  if (CheckCondition(cpu, cond))
    {
      U32 op1( cpu.GetGZR(rn) ), op2( cpu.GetGZR(rm) ), res = op1 + op2;
      cpu.SetNZCV( S32(res) < S32(0), res == U32(0), op1 > ~op2, (S32(res) < S32(0)) xor (S32(op1) <= S32(~op2)) );
    }
  else
    cpu.SetNZCV( BOOL(n==1), BOOL(z==1), BOOL(c==1), BOOL(v==1) );
};

op ccmn_x( 0b10111010010[11] : rm[5] : cond[4] : 0b00[2] : rn[5] : 0b0[1] : n[1] : z[1] : c[1] : v[1] );
ccmn_x.var format : {char const*} = {"base,372"};

ccmn_x.disasm = {
  sink << "ccmn\t" << DisasmGZXR(rn) << ", " << DisasmGZXR(rm) << ", " << DisasmI((n<<3)|(z<<2)|(c<<1)|(v<<0),16) << ", " << DisasmCond(cond);
};

ccmn_x.execute = {
  typedef typename ARCH::S64 S64;
  typedef typename ARCH::U64 U64;
  typedef typename ARCH::BOOL BOOL;
  
  if (CheckCondition(cpu, cond))
    {
      U64 op1( cpu.GetGZR(rn) ), op2( cpu.GetGZR(rm) ), res = op1 + op2;
      cpu.SetNZCV( S64(res) < S64(0), res == U64(0), op1 > ~op2, (S64(res) < S64(0)) xor (S64(op1) <= S64(~op2)) );
    }
  else
    cpu.SetNZCV( BOOL(n==1), BOOL(z==1), BOOL(c==1), BOOL(v==1) );
};

/*
 * end of CCMN (register)
 *******************************************************************/

/*******************************************************************
 * CCMP (immediate)
 *
 * Conditional compare (immediate), setting condition flags to result
 * of comparison or an immediate value:
 *
 * flags = if cond then compare(Rn, #imm) else #nzcv
 */

op ccmp_wi( 0b01111010010[11] : imm[5] : cond[4] : 0b10[2] : rn[5] : 0b0[1] : n[1] : z[1] : c[1] : v[1] );
ccmp_wi.var format : {char const*} = {"base,367"};

ccmp_wi.disasm = {
  sink << "ccmp\t" << DisasmGZWR(rn) << ", " << DisasmI(imm,16) << ", " << DisasmI((n<<3)|(z<<2)|(c<<1)|(v<<0),16) << ", " << DisasmCond(cond);
};

ccmp_wi.execute = {
  typedef typename ARCH::U32 U32;
  typedef typename ARCH::S32 S32;
  typedef typename ARCH::BOOL BOOL;
  
  if (CheckCondition(cpu, cond))
    {
      U32 op1( cpu.GetGZR(rn) ), op2( imm ), res = op1 - op2;
      cpu.SetNZCV( S32(res) < S32(0), op1 == op2, op1 >= op2, (S32(res) < S32(0)) xor (S32(op1) < S32(op2)) );
    }
  else
    cpu.SetNZCV( BOOL(n==1), BOOL(z==1), BOOL(c==1), BOOL(v==1) );
};

op ccmp_xi( 0b11111010010[11] : imm[5] : cond[4] : 0b10[2] : rn[5] : 0b0[1] : n[1] : z[1] : c[1] : v[1] );
ccmp_xi.var format : {char const*} = {"base,371"};

ccmp_xi.disasm = {
  sink << "ccmp\t" << DisasmGZXR(rn) << ", " << DisasmI(imm,16) << ", " << DisasmI((n<<3)|(z<<2)|(c<<1)|(v<<0),16) << ", " << DisasmCond(cond);
};

ccmp_xi.execute = {
  typedef typename ARCH::U64 U64;
  typedef typename ARCH::S64 S64;
  typedef typename ARCH::BOOL BOOL;
  
  if (CheckCondition(cpu, cond))
    {
      U64 op1( cpu.GetGZR(rn) ), op2( imm ), res = op1 - op2;
      cpu.SetNZCV( S64(res) < S64(0), op1 == op2, op1 >= op2, (S64(res) < S64(0)) xor (S64(op1) < S64(op2)) );
    }
  else
    cpu.SetNZCV( BOOL(n==1), BOOL(z==1), BOOL(c==1), BOOL(v==1) );
};

/*
 * end of CCMP (immediate)
 *******************************************************************/

/*******************************************************************
 * CCMP (register)
 *
 * Conditional compare (register), setting condition flags to result
 * of comparison or an immediate value:
 *
 * flags = if cond then compare(Rn, Rm) else #nzcv
 */

op ccmp_w( 0b01111010010[11] : rm[5] : cond[4] : 0b00[2] : rn[5] : 0b0[1] : n[1] : z[1] : c[1] : v[1] );
ccmp_w.var format : {char const*} = {"base,369"};

ccmp_w.disasm = {
  sink << "ccmp\t" << DisasmGZWR(rn) << ", " << DisasmGZWR(rm) << ", " << DisasmI((n<<3)|(z<<2)|(c<<1)|(v<<0),16) << ", " << DisasmCond(cond);
};

ccmp_w.execute = {
  typedef typename ARCH::U32 U32;
  typedef typename ARCH::S32 S32;
  typedef typename ARCH::BOOL BOOL;
  
  if (CheckCondition(cpu, cond))
    {
      U32 op1( cpu.GetGZR(rn) ), op2( cpu.GetGZR(rm) ), res = op1 - op2;
      cpu.SetNZCV( S32(res) < S32(0), op1 == op2, op1 >= op2, (S32(res) < S32(0)) xor (S32(op1) < S32(op2)) );
    }
  else
    cpu.SetNZCV( BOOL(n==1), BOOL(z==1), BOOL(c==1), BOOL(v==1) );
};

op ccmp_x( 0b11111010010[11] : rm[5] : cond[4] : 0b00[2] : rn[5] : 0b0[1] : n[1] : z[1] : c[1] : v[1] );
ccmp_x.var format : {char const*} = {"base,373"};

ccmp_x.disasm = {
  sink << "ccmp\t" << DisasmGZXR(rn) << ", " << DisasmGZXR(rm) << ", " << DisasmI((n<<3)|(z<<2)|(c<<1)|(v<<0),16) << ", " << DisasmCond(cond);
};

ccmp_x.execute = {
  typedef typename ARCH::U64 U64;
  typedef typename ARCH::S64 S64;
  typedef typename ARCH::BOOL BOOL;
  
  if (CheckCondition(cpu, cond))
    {
      U64 op1( cpu.GetGZR(rn) ), op2( cpu.GetGZR(rm) ), res = op1 - op2;
      cpu.SetNZCV( S64(res) < S64(0), op1 == op2, op1 >= op2, (S64(res) < S64(0)) xor (S64(op1) < S64(op2)) );
    }
  else
    cpu.SetNZCV( BOOL(n==1), BOOL(z==1), BOOL(c==1), BOOL(v==1) );
};

/*
 * end of CCMN (register)
 *******************************************************************/

/*******************************************************************
 * CLREX
 *
 * Clear exclusive monitor
 */

op clrex( 0b11010101000000110011[20] : imm[4] : 0b01011111[8] );
clrex.var format : {char const*} = {"base,2942"};

clrex.disasm = {
  sink << "clrex\t" << DisasmI(imm,16);
};

clrex.execute = {
  cpu.ClearExclusiveLocal();
};

/*
 * end of CLREX
 *******************************************************************/

/*******************************************************************
 * CLS
 *
 * Count leading sign bits: Rd = CLS(Rn)
 */

op cls_w( 0b0101101011000000000101[22] : rn[5] : rd[5] );
cls_w.var format : {char const*} = {"base,2615"};

cls_w.disasm = {
  sink << "cls\t" << DisasmGZWR(rd) << ", " << DisasmGZWR(rn);
};

cls_w.execute = {
  typedef typename ARCH::U32 U32;
  typedef typename ARCH::S32 S32;
  
  U32 val( cpu.GetGZR(rn) );
  val = val ^ U32(S32(val) >> 1);
  
  if (cpu.Test( val == U32(0) ))
    val = U32(31);
  else
    val = U32(30) - BitScanReverse( val );
  
  cpu.SetGZR(rd, val);
};

op cls_x( 0b1101101011000000000101[22] : rn[5] : rd[5] );
cls_x.var format : {char const*} = {"base,2655"};

cls_x.disasm = {
  sink << "cls\t" << DisasmGZXR(rd) << ", " << DisasmGZXR(rn);
};

cls_x.execute = {
  typedef typename ARCH::S64 S64;
  typedef typename ARCH::U64 U64;
  
  U64 val( cpu.GetGZR(rn) );
  val = val ^ U64(S64(val) >> 1);
  
  if (cpu.Test( val == U64(0) ))
    val = U64(63);
  else
    val = U64(62) - BitScanReverse( val );
  
  cpu.SetGZR(rd, val);
};

/*
 * end of CLS
 *******************************************************************/

/*******************************************************************
 * CLZ
 *
 * Count leading zero bits: Rd = CLZ(Rn)
 */

op clz_w( 0b0101101011000000000100[22] : rn[5] : rd[5] );
clz_w.var format : {char const*} = {"base,2616"};

clz_w.disasm = {
  sink << "clz\t" << DisasmGZWR(rd) << ", " << DisasmGZWR(rn);
};

clz_w.execute = {
  typedef typename ARCH::U32 U32;
  
  U32 val( cpu.GetGZR(rn) );
  if (cpu.Test( val == U32(0) ))
    val = U32(32);
  else
    val = U32(31) - BitScanReverse( val );
  
  cpu.SetGZR(rd, val);
};

op clz_x( 0b1101101011000000000100[22] : rn[5] : rd[5] );
clz_x.var format : {char const*} = {"base,2654"};

clz_x.disasm = {
  sink << "clz\t" << DisasmGZXR(rd) << ", " << DisasmGZXR(rn);
};

clz_x.execute = {
  typedef typename ARCH::U64 U64;
  
  U64 val( cpu.GetGZR(rn) );
  if (cpu.Test( val == U64(0) ))
    val = U64(64);
  else
    val = U64(63) - BitScanReverse( val );
  
  cpu.SetGZR(rd, val);
};

/*
 * end of CLZ
 *******************************************************************/

/*******************************************************************
 * CSEL
 *
 * Conditional select, returning the first or second input: Rd = if cond then Rn else Rm
 */

op csel_w( 0b00011010100[11] : rm[5] : cond[4] : 0b00[2] : rn[5] : rd[5] );
csel_w.var format : {char const*} = {"base,291"};

csel_w.disasm = {
  sink << "csel\t" << DisasmGZWR(rd) << ", " << DisasmGZWR(rn) << ", " << DisasmGZWR(rm) << ", " << DisasmCond(cond);
};

csel_w.execute = {
  typedef typename ARCH::U32 U32;
  
  U32 res;
  if (CheckCondition(cpu, cond))
    res = U32(cpu.GetGZR(rn));
  else
    res = U32(cpu.GetGZR(rm));
  cpu.SetGZR(rd, res);
};

op csel_x( 0b10011010100[11] : rm[5] : cond[4] : 0b00[2] : rn[5] : rd[5] );
csel_x.var format : {char const*} = {"base,327"};

csel_x.disasm = {
  sink << "csel\t" << DisasmGZXR(rd) << ", " << DisasmGZXR(rn) << ", " << DisasmGZXR(rm) << ", " << DisasmCond(cond);
};

csel_x.execute = {
  typedef typename ARCH::U64 U64;
  
  U64 res;
  if (CheckCondition(cpu, cond))
    res = cpu.GetGZR(rn);
  else
    res = cpu.GetGZR(rm);
  cpu.SetGZR(rd, res);
};

/*
 * end of CSEL
 *******************************************************************/

/*******************************************************************
 * CSINC
 *
 * Conditional select increment, returning the first input or
 * incremented second input: Rd = if cond then Rn else (Rm + 1)
 */

op csinc_w( 0b00011010100[11] : rm[5] : cond[4] : 0b01[2] : rn[5] : rd[5] );
csinc_w.var format : {char const*} = {"base,292"};

csinc_w.disasm = {
  if ((rn == rm) and (cond < 0b1110))
    if (rn != 31)
      sink << "cinc\t" << DisasmGZWR(rd) << ", " << DisasmGZWR(rn) << ", " << DisasmCond(cond^1);
    else
      sink << "cset\t" << DisasmGZWR(rd) << ", " << DisasmCond(cond^1);
  else
    sink << "csinc\t" << DisasmGZWR(rd) << ", " << DisasmGZWR(rn) << ", " << DisasmGZWR(rm) << ", " << DisasmCond(cond);
};

csinc_w.execute = {
  typedef typename ARCH::U32 U32;
  
  U32 res;
  if (CheckCondition(cpu, cond))
    res = U32(cpu.GetGZR(rn));
  else
    res = U32(cpu.GetGZR(rm)) + U32(1);
  cpu.SetGZR(rd, res);
};

op csinc_x( 0b10011010100[11] : rm[5] : cond[4] : 0b01[2] : rn[5] : rd[5] );
csinc_x.var format : {char const*} = {"base,328"};

csinc_x.disasm = {
  if ((rn == rm) and (cond < 0b1110))
    if (rn != 31)
      sink << "cinc\t" << DisasmGZXR(rd) << ", " << DisasmGZXR(rn) << ", " << DisasmCond(cond^1);
    else
      sink << "cset\t" << DisasmGZXR(rd) << ", " << DisasmCond(cond^1);
  else
    sink << "csinc\t" << DisasmGZXR(rd) << ", " << DisasmGZXR(rn) << ", " << DisasmGZXR(rm) << ", " << DisasmCond(cond);
};

csinc_x.execute = {
  typedef typename ARCH::U64 U64;
  
  U64 res;
  if (CheckCondition(cpu, cond))
    res = cpu.GetGZR(rn);
  else
    res = cpu.GetGZR(rm) + U64(1);
  cpu.SetGZR(rd, res);
};

/*
 * end of CSINC
 *******************************************************************/

/*******************************************************************
 * CSINV
 *
 * Conditional select inversion, returning the first input or inverted
 * second input: Rd = if cond then Rn else NOT (Rm)
 */

op csinv_w( 0b01011010100[11] : rm[5] : cond[4] : 0b00[2] : rn[5] : rd[5] );
csinv_w.var format : {char const*} = {"base,293"};

csinv_w.disasm = {
  if ((rn == rm) and (cond < 0b1110))
    if (rn != 31)
      sink << "cinv\t" << DisasmGZWR(rd) << ", " << DisasmGZWR(rn) << ", " << DisasmCond(cond^1);
    else
      sink << "csetm\t" << DisasmGZWR(rd) << ", " << DisasmCond(cond^1);
  else
    sink << "csinv\t" << DisasmGZWR(rd) << ", " << DisasmGZWR(rn) << ", " << DisasmGZWR(rm) << ", " << DisasmCond(cond);
};

csinv_w.execute = {
  typedef typename ARCH::U32 U32;
  
  U32 res;
  if (CheckCondition(cpu, cond))
    res = U32(cpu.GetGZR(rn));
  else
    res = ~U32(cpu.GetGZR(rm));
  cpu.SetGZR(rd, res);
};

op csinv_x( 0b11011010100[11] : rm[5] : cond[4] : 0b00[2] : rn[5] : rd[5] );
csinv_x.var format : {char const*} = {"base,329"};

csinv_x.disasm = {
  if ((rn == rm) and (cond < 0b1110))
    if (rn != 31)
      sink << "cinv\t" << DisasmGZXR(rd) << ", " << DisasmGZXR(rn) << ", " << DisasmCond(cond^1);
    else
      sink << "csetm\t" << DisasmGZXR(rd) << ", " << DisasmCond(cond^1);
  else
    sink << "csinv\t" << DisasmGZXR(rd) << ", " << DisasmGZXR(rn) << ", " << DisasmGZXR(rm) << ", " << DisasmCond(cond);
};

csinv_x.execute = {
  typedef typename ARCH::U64 U64;
  
  U64 res;
  if (CheckCondition(cpu, cond))
    res = cpu.GetGZR(rn);
  else
    res = ~(cpu.GetGZR(rm));
  cpu.SetGZR(rd, res);
};

/*
 * end of CSINV
 *******************************************************************/

/*******************************************************************
 * CSNEG
 *
 * Conditional select negation, returning the first input or negated
 * second input: Rd = if cond then Rn else -Rm
 */

op csneg_w( 0b01011010100[11] : rm[5] : cond[4] : 0b01[2] : rn[5] : rd[5] );
csneg_w.var format : {char const*} = {"base,294"};

csneg_w.disasm = {
  if ((rn == rm) and (cond < 0b1110))
    sink << "cneg\t" << DisasmGZWR(rd) << ", " << DisasmGZWR(rn) << ", " << DisasmCond(cond^1);
  else
    sink << "csneg\t" << DisasmGZWR(rd) << ", " << DisasmGZWR(rn) << ", " << DisasmGZWR(rm) << ", " << DisasmCond(cond);
};

csneg_w.execute = {
  typedef typename ARCH::U32 U32;
  
  U32 res;
  if (CheckCondition(cpu, cond))
    res = U32(cpu.GetGZR(rn));
  else
    res = -U32(cpu.GetGZR(rm));
  cpu.SetGZR(rd, res);
};

op csneg_x( 0b11011010100[11] : rm[5] : cond[4] : 0b01[2] : rn[5] : rd[5] );
csneg_x.var format : {char const*} = {"base,330"};

csneg_x.disasm = {
  if ((rn == rm) and (cond < 0b1110))
    sink << "cneg\t" << DisasmGZXR(rd) << ", " << DisasmGZXR(rn) << ", " << DisasmCond(cond^1);
  else
    sink << "csneg\t" << DisasmGZXR(rd) << ", " << DisasmGZXR(rn) << ", " << DisasmGZXR(rm) << ", " << DisasmCond(cond);
};

csneg_x.execute = {
  typedef typename ARCH::U64 U64;
  
  U64 res;
  if (CheckCondition(cpu, cond))
    res = cpu.GetGZR(rn);
  else
    res = -(cpu.GetGZR(rm));
  cpu.SetGZR(rd, res);
};

/*
 * end of CSNEG
 *******************************************************************/

/*******************************************************************
 * DCPS1
 *
 * Debug switch to exception level 1
 */

op dcps1( 0b11010100101[11] : imm[16] : 0b00001[5] );
dcps1.var format : {char const*} = {"base,578"};

dcps1.disasm = {
  sink << "dcps1\t" << DisasmI(imm,16);
};

/*
 * end of DCPS1
 *******************************************************************/

/*******************************************************************
 * DCPS2
 *
 * Debug switch to exception level 2
 */

op dcps2( 0b11010100101[11] : imm[16] : 0b00010[5] );
dcps2.var format : {char const*} = {"base,579"};

dcps2.disasm = {
  sink << "dcps2\t" << DisasmI(imm,16);
};

/*
 * end of DCPS2
 *******************************************************************/

/*******************************************************************
 * DCPS3
 *
 * Debug switch to exception level 
 */

op dcps3( 0b11010100101[11] : imm[16] : 0b00011[5] );
dcps3.var format : {char const*} = {"base,580"};

dcps3.disasm = {
  sink << "dcps3\t" << DisasmI(imm,16);
};

/*
 * end of DCPS3
 *******************************************************************/

/*******************************************************************
 * DMB
 *
 * Data memory barrier
 */

op dmb( 0b11010101000000110011[20] : imm[4] : 0b10111111[8] );
dmb.var format : {char const*} = {"base,2943"};

dmb.disasm = {
  sink << "dmb\t" << DisasmBarrierOption(imm);
};

dmb.execute = {
};

/*
 * end of DMB
 *******************************************************************/

/*******************************************************************
 * DRPS
 *
 * Debug restore processor state
 */

op drps( 0b11010110101111110000001111100000[32] );
drps.var format : {char const*} = {"base,2946"};

drps.disasm = {
  sink << "drps";
};

/*
 * end of DRPS
 *******************************************************************/

/*******************************************************************
 * DSB
 *
 * Data synchronization barrier
 */

op dsb( 0b11010101000000110011[20] : imm[4] : 0b10011111[8] );
dsb.var format : {char const*} = {"base,2944"};

dsb.disasm = {
  sink << "dsb\t" << DisasmBarrierOption(imm);
};

/*
 * end of DSB
 *******************************************************************/

/*******************************************************************
 * EON (shifted register)
 *
 * Bitwise exclusive OR NOT (shifted register): Rd = Rn EOR NOT shift(Rm, amount)
 */

op eon_wlsl( 0b01001010001[11] : rm[5] : 0b0[1] : imm[5] : rn[5] : rd[5] );
eon_wlsl.var format : {char const*} = {"base,190"};

eon_wlsl.disasm = {
  sink << "eon\t" << DisasmGZWR(rd) << ", " << DisasmGZWR(rn) << ", " << DisasmGZWR(rm) << DisasmINZ(", lsl ",imm);
};

eon_wlsl.execute = {
  typedef typename ARCH::U32 U32;
  
  U32 op1( cpu.GetGZR(rn) ), op2( cpu.GetGZR(rm) << imm ), res = op1 ^ ~op2;
  cpu.SetGZR(rd, res);
};

op eon_wlsr( 0b01001010011[11] : rm[5] : 0b0[1] : imm[5] : rn[5] : rd[5] );
eon_wlsr.var format : {char const*} = {"base,198"};

eon_wlsr.disasm = {
  sink << "eon\t" << DisasmGZWR(rd) << ", " << DisasmGZWR(rn) << ", " << DisasmGZWR(rm) << ", lsr " << DisasmI(imm);
};

eon_wlsr.execute = {
  typedef typename ARCH::U32 U32;
  
  U32 op1( cpu.GetGZR(rn) ), op2( cpu.GetGZR(rm) >> imm ), res = op1 ^ ~op2;
  cpu.SetGZR(rd, res);
};

op eon_wasr( 0b01001010101[11] : rm[5] : 0b0[1] : imm[5] : rn[5] : rd[5] );
eon_wasr.var format : {char const*} = {"base,174"};

eon_wasr.disasm = {
  sink << "eon\t" << DisasmGZWR(rd) << ", " << DisasmGZWR(rn) << ", " << DisasmGZWR(rm) << ", asr " << DisasmI(imm);
};

eon_wasr.execute = {
  typedef typename ARCH::U32 U32;
  typedef typename ARCH::S32 S32;
  
  U32 op1( cpu.GetGZR(rn) ), op2( S32(cpu.GetGZR(rm)) >> imm ), res = op1 ^ ~op2;
  cpu.SetGZR(rd, res);
};

op eon_wror( 0b01001010111[11] : rm[5] : 0b0[1] : imm[5] : rn[5] : rd[5] );
eon_wror.var format : {char const*} = {"base,209"};

eon_wror.disasm = {
  sink << "eon\t" << DisasmGZWR(rd) << ", " << DisasmGZWR(rn) << ", " << DisasmGZWR(rm) << ", ror " << DisasmI(imm);
};

eon_wror.execute = {
  typedef typename ARCH::U32 U32;
  
  U32 op1( cpu.GetGZR(rn) ), op2( RotateRight(U32(cpu.GetGZR(rm)), imm) ), res = op1 ^ ~op2;
  cpu.SetGZR(rd, res);
};

op eon_xlsl( 0b11001010001[11] : rm[5] : imm[6] : rn[5] : rd[5] );
eon_xlsl.var format : {char const*} = {"base,126"};

eon_xlsl.disasm = {
  sink << "eon\t" << DisasmGZXR(rd) << ", " << DisasmGZXR(rn) << ", " << DisasmGZXR(rm) << DisasmINZ(", lsl ",imm);
};

eon_xlsl.execute = {
  typedef typename ARCH::U64 U64;
  
  U64 op1( cpu.GetGZR(rn) ), op2( cpu.GetGZR(rm) << imm ), res = op1 ^ ~op2;
  cpu.SetGZR(rd, res);
};

op eon_xlsr( 0b11001010011[11] : rm[5] : imm[6] : rn[5] : rd[5] );
eon_xlsr.var format : {char const*} = {"base,138"};

eon_xlsr.disasm = {
  sink << "eon\t" << DisasmGZXR(rd) << ", " << DisasmGZXR(rn) << ", " << DisasmGZXR(rm) << ", lsr " << DisasmI(imm);
};

eon_xlsr.execute = {
  typedef typename ARCH::U64 U64;
  
  U64 op1( cpu.GetGZR(rn) ), op2( cpu.GetGZR(rm) >> imm ), res = op1 ^ ~op2;
  cpu.SetGZR(rd, res);
};

op eon_xasr( 0b11001010101[11] : rm[5] : imm[6] : rn[5] : rd[5] );
eon_xasr.var format : {char const*} = {"base,114"};

eon_xasr.disasm = {
  sink << "eon\t" << DisasmGZXR(rd) << ", " << DisasmGZXR(rn) << ", " << DisasmGZXR(rm) << ", asr " << DisasmI(imm);
};

eon_xasr.execute = {
  typedef typename ARCH::U64 U64;
  typedef typename ARCH::S64 S64;
  
  U64 op1( cpu.GetGZR(rn) ), op2( S64(cpu.GetGZR(rm)) >> imm ), res = op1 ^ ~op2;
  cpu.SetGZR(rd, res);
};

op eon_xror( 0b11001010111[11] : rm[5] : imm[6] : rn[5] : rd[5] );
eon_xror.var format : {char const*} = {"base,149"};

eon_xror.disasm = {
  sink << "eon\t" << DisasmGZXR(rd) << ", " << DisasmGZXR(rn) << ", " << DisasmGZXR(rm) << ", ror " << DisasmI(imm);
};

eon_xror.execute = {
  typedef typename ARCH::U64 U64;
  
  U64 op1( cpu.GetGZR(rn) ), op2( RotateRight(U64(cpu.GetGZR(rm)), imm) ), res = op1 ^ ~op2;
  cpu.SetGZR(rd, res);
};

/*
 * end of EON (shifted register)
 *******************************************************************/

/*******************************************************************
 * EOR (immediate)
 *
 * Bitwise exclusive OR (immediate): Rd = Rn EOR imm
 */

op eor_wi( 0b0101001000[10] : immr[6] : imms[6] : rn[5] : rd[5] );
eor_wi.var imm : {uint32_t} = {DecodeBitMasks(0,imms,immr).wmask}, format : {char const*} = {"base,72"};

eor_wi.disasm = {
  sink << "eor\t" << DisasmGSWR(rd) << ", " << DisasmGZWR(rn) << ", " << DisasmI(imm,16);
};

eor_wi.execute = {
  typedef typename ARCH::U32 U32;
  
  U32 op1(cpu.GetGZR(rn)), op2(imm), res = op1 ^ op2;
  cpu.SetGSR(rd, res);
};

op eor_xi( 0b110100100[9] : n[1] : immr[6] : imms[6] : rn[5] : rd[5] );
eor_xi.var imm : {uint64_t} = {DecodeBitMasks(n,imms,immr).wmask}, format : {char const*} = {"base,27"};

eor_xi.disasm = {
  sink << "eor\t" << DisasmGSXR(rd) << ", " << DisasmGZXR(rn) << ", " << DisasmI(imm,16);
};

eor_xi.execute = {
  typedef typename ARCH::U64 U64;
  
  U64 op1(cpu.GetGZR(rn)), op2(imm), res = op1 ^ op2;
  cpu.SetGSR(rd, res);
};

/*
 * end of EOR (immediate)
 *******************************************************************/

/*******************************************************************
 * EOR (shifted register)
 *
 * Bitwise exclusive OR (shifted register): Rd = Rn EOR shift(Rm, amount)
 */

op eor_wlsl( 0b01001010000[11] : rm[5] : 0b0[1] : imm[5] : rn[5] : rd[5] );
eor_wlsl.var format : {char const*} = {"base,191"};

eor_wlsl.disasm = {
  sink << "eor\t" << DisasmGZWR(rd) << ", " << DisasmGZWR(rn) << ", " << DisasmGZWR(rm) << DisasmINZ(", lsl ",imm);
};

eor_wlsl.execute = {
  typedef typename ARCH::U32 U32;
  
  U32 op1( cpu.GetGZR(rn) ), op2( cpu.GetGZR(rm) << imm ), res = op1 ^ op2;
  cpu.SetGZR(rd, res);
};

op eor_wlsr( 0b01001010010[11] : rm[5] : 0b0[1] : imm[5] : rn[5] : rd[5] );
eor_wlsr.var format : {char const*} = {"base,199"};

eor_wlsr.disasm = {
  sink << "eor\t" << DisasmGZWR(rd) << ", " << DisasmGZWR(rn) << ", " << DisasmGZWR(rm) << ", lsr " << DisasmI(imm);
};

eor_wlsr.execute = {
  typedef typename ARCH::U32 U32;
  
  U32 op1( cpu.GetGZR(rn) ), op2( cpu.GetGZR(rm) >> imm ), res = op1 ^ op2;
  cpu.SetGZR(rd, res);
};

op eor_wasr( 0b01001010100[11] : rm[5] : 0b0[1] : imm[5] : rn[5] : rd[5] );
eor_wasr.var format : {char const*} = {"base,175"};

eor_wasr.disasm = {
  sink << "eor\t" << DisasmGZWR(rd) << ", " << DisasmGZWR(rn) << ", " << DisasmGZWR(rm) << ", asr " << DisasmI(imm);
};

eor_wasr.execute = {
  typedef typename ARCH::U32 U32;
  typedef typename ARCH::S32 S32;
  
  U32 op1( cpu.GetGZR(rn) ), op2( S32(cpu.GetGZR(rm)) >> imm ), res = op1 ^ op2;
  cpu.SetGZR(rd, res);
};

op eor_wror( 0b01001010110[11] : rm[5] : 0b0[1] : imm[5] : rn[5] : rd[5] );
eor_wror.var format : {char const*} = {"base,210"};

eor_wror.disasm = {
  sink << "eor\t" << DisasmGZWR(rd) << ", " << DisasmGZWR(rn) << ", " << DisasmGZWR(rm) << ", ror " << DisasmI(imm);
};

eor_wror.execute = {
  typedef typename ARCH::U32 U32;
  
  U32 op1( cpu.GetGZR(rn) ), op2( RotateRight(U32(cpu.GetGZR(rm)), imm) ), res = op1 ^ op2;
  cpu.SetGZR(rd, res);
};

op eor_xlsl( 0b11001010000[11] : rm[5] : imm[6] : rn[5] : rd[5] );
eor_xlsl.var format : {char const*} = {"base,127"};

eor_xlsl.disasm = {
  sink << "eor\t" << DisasmGZXR(rd) << ", " << DisasmGZXR(rn) << ", " << DisasmGZXR(rm) << DisasmINZ(", lsl ",imm);
};

eor_xlsl.execute = {
  typedef typename ARCH::U64 U64;
  
  U64 op1( cpu.GetGZR(rn) ), op2( cpu.GetGZR(rm) << imm ), res = op1 ^ op2;
  cpu.SetGZR(rd, res);
};

op eor_xlsr( 0b11001010010[11] : rm[5] : imm[6] : rn[5] : rd[5] );
eor_xlsr.var format : {char const*} = {"base,139"};

eor_xlsr.disasm = {
  sink << "eor\t" << DisasmGZXR(rd) << ", " << DisasmGZXR(rn) << ", " << DisasmGZXR(rm) << ", lsr " << DisasmI(imm);
};

eor_xlsr.execute = {
  typedef typename ARCH::U64 U64;
  
  U64 op1( cpu.GetGZR(rn) ), op2( cpu.GetGZR(rm) >> imm ), res = op1 ^ op2;
  cpu.SetGZR(rd, res);
};

op eor_xasr( 0b11001010100[11] : rm[5] : imm[6] : rn[5] : rd[5] );
eor_xasr.var format : {char const*} = {"base,115"};

eor_xasr.disasm = {
  sink << "eor\t" << DisasmGZXR(rd) << ", " << DisasmGZXR(rn) << ", " << DisasmGZXR(rm) << ", asr " << DisasmI(imm);
};

eor_xasr.execute = {
  typedef typename ARCH::U64 U64;
  typedef typename ARCH::S64 S64;
  
  U64 op1( cpu.GetGZR(rn) ), op2( S64(cpu.GetGZR(rm)) >> imm ), res = op1 ^ op2;
  cpu.SetGZR(rd, res);
};

op eor_xror( 0b11001010110[11] : rm[5] : imm[6] : rn[5] : rd[5] );
eor_xror.var format : {char const*} = {"base,150"};

eor_xror.disasm = {
  sink << "eor\t" << DisasmGZXR(rd) << ", " << DisasmGZXR(rn) << ", " << DisasmGZXR(rm) << ", ror " << DisasmI(imm);
};

eor_xror.execute = {
  typedef typename ARCH::U64 U64;
  
  U64 op1( cpu.GetGZR(rn) ), op2( RotateRight(U64(cpu.GetGZR(rm)), imm) ), res = op1 ^ op2;
  cpu.SetGZR(rd, res);
};

/*
 * end of EOR (shifted register)
 *******************************************************************/

/*******************************************************************
 * ERET
 *
 * Exception return using current ELR and SPSR
 */

op eret( 0b11010110100111110000001111100000[32] );
eret.var format : {char const*} = {"base,2947"};

eret.disasm = {
  sink << "eret";
};

/*
 * end of ERET
 *******************************************************************/

/*******************************************************************
 * EXTR
 *
 * Extract register from pair of registers
 */

op extr_w( 0b00010011100[11] : rm[5] : 0b0[1] : imms[5] : rn[5] : rd[5] );
extr_w.var format : {char const*} = {"base,165"};

extr_w.disasm = {
  if (rn == rm)
    sink << "ror\t" << DisasmGZWR(rd) << ", " << DisasmGZWR(rn) << ", " << DisasmI(imms);
  else
    sink << "extr\t" << DisasmGZWR(rd) << ", " << DisasmGZWR(rn) << ", " << DisasmGZWR(rm) << ", " << DisasmI(imms);
};

extr_w.execute = {
  typedef typename ARCH::U32 U32;
  
  U32 op1( cpu.GetGZR(rn) ), op2( cpu.GetGZR(rm) ), res( ((op1 << 1) << (imms ^ 31)) | (op2 >> imms) );
  cpu.SetGZR(rd, res);
};

op extr_x( 0b10010011110[11] : rm[5] : imms[6] : rn[5] : rd[5] );
extr_x.var format : {char const*} = {"base,109"};

extr_x.disasm = {
  if (rn == rm)
    sink << "ror\t" << DisasmGZXR(rd) << ", " << DisasmGZXR(rn) << ", " << DisasmI(imms);
  else
    sink << "extr\t" << DisasmGZXR(rd) << ", " << DisasmGZXR(rn) << ", " << DisasmGZXR(rm) << ", " << DisasmI(imms);
};

extr_x.execute = {
  typedef typename ARCH::U64 U64;
  
  U64 op1( cpu.GetGZR(rn) ), op2( cpu.GetGZR(rm) ), res( ((op1 << 1) << (imms ^ 63)) | (op2 >> imms) );
  cpu.SetGZR(rd, res);
};

/*
 * end of EXTR
 *******************************************************************/

/*******************************************************************
 * HINT
 *
 * Hint instruction
 */

op hint( 0b11010101000000110010[20] : imm[7] : 0b11111[5] );
hint.var format : {char const*} = {"base,2885"};

hint.disasm = {
  sink << "hint\t" << DisasmI(imm,16);
};

/*
 * end of HINT
 *******************************************************************/

/*******************************************************************
 * HLT
 *
 * Halting debug-mode breakpoint
 */

op hlt( 0b11010100010[11] : imm[16] : 0b00000[5] );
hlt.var format : {char const*} = {"base,574"};

hlt.disasm = {
  sink << "hlt\t" << DisasmI(imm,16);
};

/*
 * end of HLT
 *******************************************************************/

/*******************************************************************
 * HVC
 *
 * Generate exception targeting exception level 2
 */

op hvc( 0b11010100000[11] : imm[16] : 0b00010[5] );
hvc.var format : {char const*} = {"base,575"};

hvc.disasm = {
  sink << "hvc\t" << DisasmI(imm,16);
};

/*
 * end of HVC
 *******************************************************************/

/*******************************************************************
 * ISB
 *
 * Instruction synchronization barrier
 */

op isb( 0b11010101000000110011[20] : imm[4] : 0b11011111[8] );
isb.var format : {char const*} = {"base,2945"};

isb.disasm = {
  sink << "isb\t" << DisasmI(imm,16);
};

/*
 * end of ISB
 *******************************************************************/

/*******************************************************************
 * LDAR
 *
 * Load-acquire register
 */

op ldar_w( 0b1000100011011111111111[22] : rn[5] : rt[5] );
ldar_w.var format : {char const*} = {"base,2622"};

ldar_w.disasm = {
  sink << "ldar\t" << DisasmGZWR(rt) << ", [" << DisasmGSXR(rn) << "]";
};

ldar_w.execute = {
  typedef typename ARCH::U32 U32;
  typedef typename ARCH::U64 U64;
  
  U64 addr( cpu.GetGSR(rn) );
  U32 data( cpu.MemRead32(addr) );
  cpu.SetGZR(rt, data);
};


op ldar_x( 0b1100100011011111111111[22] : rn[5] : rt[5] );
ldar_x.var format : {char const*} = {"base,2656"};

ldar_x.disasm = {
  sink << "ldar\t" << DisasmGZXR(rt) << ", [" << DisasmGSXR(rn) << "]";
};

ldar_x.execute = {
  typedef typename ARCH::U64 U64;
  
  U64 addr( cpu.GetGSR(rn) );
  U64 data( cpu.MemRead64(addr) );
  cpu.SetGZR(rt, data);
};

/*
 * end of LDAR
 *******************************************************************/

/*******************************************************************
 * LDARB
 *
 * Load-acquire register byte
 */

op ldarb_w( 0b0000100011011111111111[22] : rn[5] : rt[5] );
ldarb_w.var format : {char const*} = {"base,2623"};

ldarb_w.disasm = {
  sink << "ldarb\t" << DisasmGZWR(rt) << ", [" << DisasmGSXR(rn) << "]";
};

ldarb_w.execute = {
  typedef typename ARCH::U8 U8;
  typedef typename ARCH::U64 U64;
  
  U64 addr( cpu.GetGSR(rn) );
  U8 data( cpu.MemRead8(addr) );
  cpu.SetGZR(rt, data);
};
/*
 * end of LDARB
 *******************************************************************/

/*******************************************************************
 * LDARH
 *
 * Load-acquire register halfword
 */

op ldarh_w( 0b0100100011011111111111[22] : rn[5] : rt[5] );
ldarh_w.var format : {char const*} = {"base,2624"};

ldarh_w.disasm = {
  sink << "ldarh\t" << DisasmGZWR(rt) << ", [" << DisasmGSXR(rn) << "]";
};

ldarh_w.execute = {
  typedef typename ARCH::U16 U16;
  typedef typename ARCH::U64 U64;
  
  U64 addr( cpu.GetGSR(rn) );
  U16 data( cpu.MemRead16(addr) );
  cpu.SetGZR(rt, data);
};

/*
 * end of LDARH
 *******************************************************************/

/*******************************************************************
 * LDAXP
 *
 * Load-acquire exclusive pair of registers
 */

op ldaxp_w( 0b10001000011[11] : rs[5] : 0b1[1] : rt2[5] : rn[5] : rt[5] );
ldaxp_w.var format : {char const*} = {"base,220"};

ldaxp_w.disasm = {
  sink << "ldaxp\t" << DisasmGZWR(rt) << ", " << DisasmGZWR(rt2) << ", [" << DisasmGSXR(rn) << "]";
};

ldaxp_w.execute = {
  typedef typename ARCH::U32 U32;
  typedef typename ARCH::U64 U64;
  
  U64 addr( cpu.GetGSR(rn) );
  cpu.SetExclusiveMonitors( addr, 8 );
  U32 data0( cpu.MemRead32( addr + U64(0) ) ),
      data1( cpu.MemRead32( addr + U64(4) ) );
  cpu.SetGZR(rt,  data0);
  cpu.SetGZR(rt2, data1);
};

op ldaxp_x( 0b11001000011[11] : rs[5] : 0b1[1] : rt2[5] : rn[5] : rt[5] );
ldaxp_x.var format : {char const*} = {"base,243"};

ldaxp_x.disasm = {
  sink << "ldaxp\t" << DisasmGZXR(rt) << ", " << DisasmGZXR(rt2) << ", [" << DisasmGSXR(rn) << "]";
};

ldaxp_x.execute = {
  typedef typename ARCH::U64 U64;
  
  U64 addr( cpu.GetGSR(rn) );
  cpu.SetExclusiveMonitors( addr, 16 );
  U64 data0( cpu.MemRead64( addr + U64(0) ) ),
      data1( cpu.MemRead64( addr + U64(8) ) );
  cpu.SetGZR(rt,  data0);
  cpu.SetGZR(rt2, data1);
};

/*
 * end of LDAXP
 *******************************************************************/

/*******************************************************************
 * LDAXR
 *
 * Load-acquire exclusive register
 */

op ldaxr_w( 0b10001000010[11] : rs[5] : 0b1[1] : rt2[5] : rn[5] : rt[5] );
ldaxr_w.var format : {char const*} = {"base,226"};

ldaxr_w.disasm = {
  sink << "ldaxr\t" << DisasmGZWR(rt) << ", [" << DisasmGSXR(rn) << "]";
};

ldaxr_w.execute = {
  typedef typename ARCH::U64 U64;

  U64 addr = cpu.GetGSR(rn);
  cpu.SetExclusiveMonitors( addr, 4 );
  cpu.SetGZR(rt, cpu.MemRead32( addr ));
};

op ldaxr_x( 0b11001000010[11] : rs[5] : 0b1[1] : rt2[5] : rn[5] : rt[5] );
ldaxr_x.var format : {char const*} = {"base,245"};

ldaxr_x.disasm = {
  sink << "ldaxr\t" << DisasmGZXR(rt) << ", [" << DisasmGSXR(rn) << "]";
};

ldaxr_x.execute = {
  typedef typename ARCH::U64 U64;

  U64 addr = cpu.GetGSR(rn);
  cpu.SetExclusiveMonitors( addr, 8 );
  cpu.SetGZR(rt, cpu.MemRead64( addr ));
};

/*
 * end of LDAXR
 *******************************************************************/

/*******************************************************************
 * LDAXRB
 *
 * Load-acquire exclusive register byte
 */

op ldaxrb_w( 0b00001000010[11] : rs[5] : 0b1[1] : rt2[5] : rn[5] : rt[5] );
ldaxrb_w.var format : {char const*} = {"base,227"};

ldaxrb_w.disasm = {
  sink << "ldaxrb\t" << DisasmGZWR(rt) << ", [" << DisasmGSXR(rn) << "]";
};

ldaxrb_w.execute = {
  typedef typename ARCH::U64 U64;

  U64 addr = cpu.GetGSR(rn);
  cpu.SetExclusiveMonitors( addr, 1 );
  cpu.SetGZR(rt, U64(cpu.MemRead8( addr )));
};

/*
 * end of LDAXRB
 *******************************************************************/

/*******************************************************************
 * LDAXRH
 *
 * Load-acquire exclusive register halfword
 */

op ldaxrh_w( 0b01001000010[11] : rs[5] : 0b1[1] : rt2[5] : rn[5] : rt[5] );
ldaxrh_w.var format : {char const*} = {"base,228"};

ldaxrh_w.disasm = {
  sink << "ldaxrh\t" << DisasmGZWR(rt) << ", [" << DisasmGSXR(rn) << "]";
};

ldaxrh_w.execute = {
  typedef typename ARCH::U64 U64;

  U64 addr = cpu.GetGSR(rn);
  cpu.SetExclusiveMonitors( addr, 2 );
  cpu.SetGZR(rt, U64(cpu.MemRead16( addr )));
};

/*
 * end of LDAXRH
 *******************************************************************/

/*******************************************************************
 * LDNP
 *
 * Load pair of registers, with non-temporal hint
 */

op ldnp_wo( 0b0010100001[10] : shl<2> sext imm[7] : rt2[5] : rn[5] : rt[5] );
ldnp_wo.var format : {char const*} = {"base,74"};

ldnp_wo.disasm = {
  sink << "ldnp\t" << DisasmGZWR(rt) << ", " << DisasmGZWR(rt2) << ", [" << DisasmGSXR(rn) << "," << DisasmI(imm) << "]";
};

ldnp_wo.execute = {
  typedef typename ARCH::U32 U32;
  typedef typename ARCH::U64 U64;
  typedef typename ARCH::S64 S64;
  
  U64 addr( cpu.GetGSR(rn) + U64(S64(imm)) );
  U32 data0( cpu.MemRead32( addr + U64(0) ) ),
      data1( cpu.MemRead32( addr + U64(4) ) );
  cpu.SetGZR(rt,  data0);
  cpu.SetGZR(rt2, data1);
};

op ldnp_xo( 0b1010100001[10] : shl<3> sext imm[7] : rt2[5] : rn[5] : rt[5] );
ldnp_xo.var format : {char const*} = {"base,93"};

ldnp_xo.disasm = {
  sink << "ldnp\t" << DisasmGZXR(rt) << ", " << DisasmGZXR(rt2) << ", [" << DisasmGSXR(rn) << "," << DisasmI(imm) << "]";
};

ldnp_xo.execute = {
  typedef typename ARCH::U64 U64;
  typedef typename ARCH::S64 S64;
  
  U64 addr( cpu.GetGSR(rn) + U64(S64(imm)) );
  U64 data0( cpu.MemRead64( addr + U64(0) ) ),
      data1( cpu.MemRead64( addr + U64(8) ) );
  cpu.SetGZR(rt,  data0);
  cpu.SetGZR(rt2, data1);
};

/*
 * end of LDNP
 *******************************************************************/

/*******************************************************************
 * LDP
 *
 * Load pair of registers
 */

op ldp_wpo( 0b0010100011[10] : shl<2> sext imm[7] : rt2[5] : rn[5] : rt[5] );
ldp_wpo.var format : {char const*} = {"base,80"};

ldp_wpo.disasm = {
  sink << "ldp\t" << DisasmGZWR(rt) << ", " << DisasmGZWR(rt2) << ", [" << DisasmGSXR(rn) << "]," << DisasmI(imm);
};

ldp_wpo.execute = {
  typedef typename ARCH::U32 U32;
  typedef typename ARCH::U64 U64;
  typedef typename ARCH::S64 S64;
  
  U64 addr( cpu.GetGSR(rn) );
  U32 data0( cpu.MemRead32( addr + U64(0) ) ),
      data1( cpu.MemRead32( addr + U64(4) ) );
  cpu.SetGZR(rt,  data0);
  cpu.SetGZR(rt2, data1);
  cpu.SetGSR(rn, addr + U64(S64(imm)) );
};

op ldp_xpo( 0b1010100011[10] : shl<3> sext imm[7] : rt2[5] : rn[5] : rt[5] );
ldp_xpo.var format : {char const*} = {"base,101"};

ldp_xpo.disasm = {
  sink << "ldp\t" << DisasmGZXR(rt) << ", " << DisasmGZXR(rt2) << ", [" << DisasmGSXR(rn) << "]," << DisasmI(imm);
};

ldp_xpo.execute = {
  typedef typename ARCH::U64 U64;
  typedef typename ARCH::S64 S64;
  
  U64 addr( cpu.GetGSR(rn) );
  U64 data0( cpu.MemRead64( addr + U64(0) ) ),
      data1( cpu.MemRead64( addr + U64(8) ) );
  cpu.SetGZR(rt,  data0);
  cpu.SetGZR(rt2, data1);
  cpu.SetGSR(rn, addr + U64(S64(imm)) );
};

op ldp_wop( 0b0010100111[10] : shl<2> sext imm[7] : rt2[5] : rn[5] : rt[5] );
ldp_wop.var format : {char const*} = {"base,78"};

ldp_wop.disasm = {
  sink << "ldp\t" << DisasmGZWR(rt) << ", " << DisasmGZWR(rt2) << ", [" << DisasmGSXR(rn) << "," << DisasmI(imm) << "]!";
};

ldp_wop.execute = {
  typedef typename ARCH::U32 U32;
  typedef typename ARCH::U64 U64;
  typedef typename ARCH::S64 S64;
  
  U64 addr( cpu.GetGSR(rn) + U64(S64(imm)) );
  U32 data0( cpu.MemRead32( addr + U64(0) ) ),
      data1( cpu.MemRead32( addr + U64(4) ) );
  cpu.SetGZR(rt,  data0);
  cpu.SetGZR(rt2, data1);
  cpu.SetGSR(rn, addr);
};

op ldp_xop( 0b1010100111[10] : shl<3> sext imm[7] : rt2[5] : rn[5] : rt[5] );
ldp_xop.var format : {char const*} = {"base,98"};

ldp_xop.disasm = {
  sink << "ldp\t" << DisasmGZXR(rt) << ", " << DisasmGZXR(rt2) << ", [" << DisasmGSXR(rn) << "," << DisasmI(imm) << "]!";
};

ldp_xop.execute = {
  typedef typename ARCH::U64 U64;
  typedef typename ARCH::S64 S64;
  
  U64 addr( cpu.GetGSR(rn) + U64(S64(imm)) );
  U64 data0( cpu.MemRead64( addr + U64(0) ) ),
      data1( cpu.MemRead64( addr + U64(8) ) );
  cpu.SetGZR(rt,  data0);
  cpu.SetGZR(rt2, data1);
  cpu.SetGSR(rn, addr);
};

op ldp_wo( 0b0010100101[10] : shl<2> sext imm[7] : rt2[5] : rn[5] : rt[5] );
ldp_wo.var format : {char const*} = {"base,75"};

ldp_wo.disasm = {
  sink << "ldp\t" << DisasmGZWR(rt) << ", " << DisasmGZWR(rt2) << ", [" << DisasmGSXR(rn) << "," << DisasmI(imm) << "]";
};

ldp_wo.execute = {
  typedef typename ARCH::U32 U32;
  typedef typename ARCH::U64 U64;
  typedef typename ARCH::S64 S64;
  
  U64 addr( cpu.GetGSR(rn) + U64(S64(imm)) );
  U32 data0( cpu.MemRead32( addr + U64(0) ) ),
      data1( cpu.MemRead32( addr + U64(4) ) );
  cpu.SetGZR(rt,  data0);
  cpu.SetGZR(rt2, data1);
};

op ldp_xo( 0b1010100101[10] : shl<3> sext imm[7] : rt2[5] : rn[5] : rt[5] );
ldp_xo.var format : {char const*} = {"base,94"};

ldp_xo.disasm = {
  sink << "ldp\t" << DisasmGZXR(rt) << ", " << DisasmGZXR(rt2) << ", [" << DisasmGSXR(rn) << "," << DisasmI(imm) << "]";
};

ldp_xo.execute = {
  typedef typename ARCH::U64 U64;
  typedef typename ARCH::S64 S64;
  
  U64 addr( cpu.GetGSR(rn) + U64(S64(imm)) );
  U64 data0( cpu.MemRead64( addr + U64(0) ) ),
      data1( cpu.MemRead64( addr + U64(8) ) );
  cpu.SetGZR(rt,  data0);
  cpu.SetGZR(rt2, data1);
};

/*
 * end of LDP
 *******************************************************************/

/*******************************************************************
 * LDPSW
 *
 * Load pair of registers signed word
 */

op ldpsw_xpo( 0b0110100011[10] : shl<2> sext imm[7] : rt2[5] : rn[5] : rt[5] );
ldpsw_xpo.var format : {char const*} = {"base,102"};

ldpsw_xpo.disasm = {
  sink << "ldpsw\t" << DisasmGZXR(rt) << ", " << DisasmGZXR(rt2) << ", [" << DisasmGSXR(rn) << "]," << DisasmI(imm);
};

ldpsw_xpo.execute = {
  typedef typename ARCH::S32 S32;
  typedef typename ARCH::U64 U64;
  typedef typename ARCH::S64 S64;
  
  U64 addr( cpu.GetGSR(rn) );
  S32 data0( cpu.MemRead32( addr + U64(0) ) ),
      data1( cpu.MemRead32( addr + U64(4) ) );
  cpu.SetGZR(rt,  U64(S64(data0)));
  cpu.SetGZR(rt2, U64(S64(data1)));
  cpu.SetGSR(rn, addr + U64(S64(imm)) );
};

op ldpsw_xop( 0b0110100111[10] : shl<2> sext imm[7] : rt2[5] : rn[5] : rt[5] );
ldpsw_xop.var format : {char const*} = {"base,99"};

ldpsw_xop.disasm = {
  sink << "ldpsw\t" << DisasmGZXR(rt) << ", " << DisasmGZXR(rt2) << ", [" << DisasmGSXR(rn) << "," << DisasmI(imm) << "]!";
};

ldpsw_xop.execute = {
  typedef typename ARCH::S32 S32;
  typedef typename ARCH::U64 U64;
  typedef typename ARCH::S64 S64;
  
  U64 addr( cpu.GetGSR(rn) + U64(S64(imm)) );
  S32 data0( cpu.MemRead32( addr + U64(0) ) ),
      data1( cpu.MemRead32( addr + U64(4) ) );
  cpu.SetGZR(rt,  U64(S64(data0)));
  cpu.SetGZR(rt2, U64(S64(data1)));
  cpu.SetGSR(rn, addr);
};

op ldpsw_xo( 0b0110100101[10] : shl<2> sext imm[7] : rt2[5] : rn[5] : rt[5] );
ldpsw_xo.var format : {char const*} = {"base,95"};

ldpsw_xo.disasm = {
  sink << "ldpsw\t" << DisasmGZXR(rt) << ", " << DisasmGZXR(rt2) << ", [" << DisasmGSXR(rn) << "," << DisasmI(imm) << "]";
};

ldpsw_xo.execute = {
  typedef typename ARCH::S32 S32;
  typedef typename ARCH::U64 U64;
  typedef typename ARCH::S64 S64;
  
  U64 addr( cpu.GetGSR(rn) + U64(S64(imm)) );
  S32 data0( cpu.MemRead32( addr + U64(0) ) ),
      data1( cpu.MemRead32( addr + U64(4) ) );
  cpu.SetGZR(rt,  U64(S64(data0)));
  cpu.SetGZR(rt2, U64(S64(data1)));
};

/*
 * end of LDPSW
 *******************************************************************/

/*******************************************************************
 * LDR (immediate)
 *
 * Load register (immediate offset)
 */

op ldr_wsopost( 0b10111000010[11] : sext imm[9] : 0b01[2] : rn[5] : rt[5] );
ldr_wsopost.var format : {char const*} = {"base,319"};

ldr_wsopost.disasm = {
  sink << "ldr\t" << DisasmGZWR(rt) << ", [" << DisasmGSXR(rn) << "]," << DisasmI(imm);
};

ldr_wsopost.execute = {
  typedef typename ARCH::U32 U32;
  typedef typename ARCH::U64 U64;
  typedef typename ARCH::S64 S64;
  
  U64 addr( cpu.GetGSR(rn) );
  U32 data( cpu.MemRead32(addr) );
  cpu.SetGZR(rt, data);
  cpu.SetGSR(rn, addr + U64(S64(imm)) );
};

op ldr_xsopost( 0b11111000010[11] : sext imm[9] : 0b01[2] : rn[5] : rt[5] );
ldr_xsopost.var format : {char const*} = {"base,346"};

ldr_xsopost.disasm = {
  sink << "ldr\t" << DisasmGZXR(rt) << ", [" << DisasmGSXR(rn) << "]," << DisasmI(imm);
};

ldr_xsopost.execute = {
  typedef typename ARCH::U64 U64;
  typedef typename ARCH::S64 S64;
  
  U64 addr( cpu.GetGSR(rn) );
  U64 data( cpu.MemRead64(addr) );
  cpu.SetGZR(rt, data);
  cpu.SetGSR(rn, addr + U64(S64(imm)) );
};

op ldr_wsopre( 0b10111000010[11] : sext imm[9] : 0b11[2] : rn[5] : rt[5] );
ldr_wsopre.var format : {char const*} = {"base,311"};

ldr_wsopre.disasm = {
  sink << "ldr\t" << DisasmGZWR(rt) << ", [" << DisasmGSXR(rn) << "," << DisasmI(imm) << "]!";
};

ldr_wsopre.execute = {
  typedef typename ARCH::U32 U32;
  typedef typename ARCH::U64 U64;
  typedef typename ARCH::S64 S64;
  
  U64 addr( cpu.GetGSR(rn) + U64(S64(imm)) );
  U32 data( cpu.MemRead32(addr) );
  cpu.SetGZR(rt, data);
  cpu.SetGSR(rn, addr);
};

op ldr_xsopre( 0b11111000010[11] : sext imm[9] : 0b11[2] : rn[5] : rt[5] );
ldr_xsopre.var format : {char const*} = {"base,341"};

ldr_xsopre.disasm = {
  sink << "ldr\t" << DisasmGZXR(rt) << ", [" << DisasmGSXR(rn) << "," << DisasmI(imm) << "]!";
};

ldr_xsopre.execute = {
  typedef typename ARCH::U64 U64;
  typedef typename ARCH::S64 S64;
  
  U64 addr( cpu.GetGSR(rn) + U64(S64(imm)) );
  U64 data( cpu.MemRead64(addr) );
  cpu.SetGZR(rt, data);
  cpu.SetGSR(rn, addr);
};

op ldr_wuo( 0b1011100101[10] : shl<2> imm[12] : rn[5] : rt[5] );
ldr_wuo.var format : {char const*} = {"base,82"};

ldr_wuo.disasm = {
  sink << "ldr\t" << DisasmGZWR(rt) << ", [" << DisasmGSXR(rn) << "," << DisasmI(imm) << "]";
};

ldr_wuo.execute = {
  typedef typename ARCH::U32 U32;
  typedef typename ARCH::U64 U64;
  
  U64 addr( cpu.GetGSR(rn) + U64(imm) );
  U32 data( cpu.MemRead32(addr) );
  cpu.SetGZR(rt, data);
};

op ldr_xuo( 0b1111100101[10] : shl<3> imm[12] : rn[5] : rt[5] );
ldr_xuo.var format : {char const*} = {"base,104"};

ldr_xuo.disasm = {
  sink << "ldr\t" << DisasmGZXR(rt) << ", [" << DisasmGSXR(rn) << "," << DisasmI(imm) << "]";
};

ldr_xuo.execute = {
  typedef typename ARCH::U64 U64;
  
  U64 addr( cpu.GetGSR(rn) + U64(imm) );
  U64 data( cpu.MemRead64(addr) );
  cpu.SetGZR(rt, data);
};

/*
 * end of LDR (immediate)
 *******************************************************************/

/*******************************************************************
 * LDR (literal)
 *
 * Load register (PC-relative literal)
 */

op ldr_wlit( 0b00011000[8] : shl<2> sext imm[19] : rt[5] );
ldr_wlit.var format : {char const*} = {"base,14"};

ldr_wlit.disasm = {
  sink << "ldr\t" << DisasmGZWR(rt) << ", 0x" << std::hex << (this->GetAddr()+imm);
};

ldr_wlit.execute = {
  typedef typename ARCH::U32 U32;
  typedef typename ARCH::U64 U64;
  typedef typename ARCH::S64 S64;
  
  U64 addr( cpu.GetPC() + U64(S64(imm)) );
  U32 data( cpu.MemRead32(addr) );
  cpu.SetGZR(rt, data);
};

op ldr_xlit( 0b01011000[8] : shl<2> sext imm[19] : rt[5] );
ldr_xlit.var format : {char const*} = {"base,17"};

ldr_xlit.disasm = {
  sink << "ldr\t" << DisasmGZXR(rt) << ", 0x" << std::hex << (this->GetAddr()+imm);
};

ldr_xlit.execute = {
  typedef typename ARCH::U64 U64;
  typedef typename ARCH::S64 S64;
  
  U64 addr( cpu.GetPC() + U64(S64(imm)) );
  U64 data( cpu.MemRead64(addr) );
  cpu.SetGZR(rt, data);
};

/*
 * end of LDR (literal)
 *******************************************************************/

/*******************************************************************
 * LDR (register)
 *
 * Load register (register offset)
 */

op ldr_wxwu( 0b10111000011[11] : rm[5] : 0b010[3] : s[1] : 0b10[2] : rn[5] : rt[5] );
ldr_wxwu.var shift : {uint8_t} = {s*2}, format : {char const*} = {"base,623"};

ldr_wxwu.disasm = {
  sink << "ldr\t" << DisasmGZWR(rt) << ", [" << DisasmGSXR(rn) << "," << DisasmGZWR(rm) << ",uxtw" << DisasmINZ(" ", shift) << "]";
};

ldr_wxwu.execute = {
  typedef typename ARCH::U32 U32;
  typedef typename ARCH::U64 U64;

  U64 offset( U64(U32(cpu.GetGZR(rm))) << shift ), addr( cpu.GetGSR(rn) + offset );
  U32 data( cpu.MemRead32(addr) );
  cpu.SetGZR(rt, data);
};

op ldr_wxxu( 0b10111000011[11] : rm[5] : 0b011[3] : s[1] : 0b10[2] : rn[5] : rt[5] );
ldr_wxxu.var format : {char const*} = {"base,1596"}, shift : {uint8_t} = {s*2};

ldr_wxxu.disasm = {
  sink << "ldr\t" << DisasmGZWR(rt) << ", [" << DisasmGSXR(rn) << "," << DisasmGZXR(rm) << DisasmINZ(",lsl ",shift) << "]";
};

ldr_wxxu.execute = {
  typedef typename ARCH::U32 U32;
  typedef typename ARCH::U64 U64;

  U64 offset( U64(U64(cpu.GetGZR(rm))) << shift ), addr( cpu.GetGSR(rn) + offset );
  U32 data( cpu.MemRead32(addr) );
  cpu.SetGZR(rt, data);
};

op ldr_wxws( 0b10111000011[11] : rm[5] : 0b110[3] : s[1] : 0b10[2] : rn[5] : rt[5] );
ldr_wxws.var shift : {uint8_t} = {s*2}, format : {char const*} = {"base,615"};

ldr_wxws.disasm = {
  sink << "ldr\t" << DisasmGZWR(rt) << ", [" << DisasmGSXR(rn) << "," << DisasmGZWR(rm) << ",sxtw" << DisasmINZ(" ", shift) << "]";
};

ldr_wxws.execute = {
  typedef typename ARCH::S32 S32;
  typedef typename ARCH::S64 S64;
  typedef typename ARCH::U32 U32;
  typedef typename ARCH::U64 U64;

  U64 offset( S64(S32(cpu.GetGZR(rm))) << shift ), addr( cpu.GetGSR(rn) + offset );
  U32 data( cpu.MemRead32(addr) );
  cpu.SetGZR(rt, data);
};

op ldr_wxxs( 0b10111000011[11] : rm[5] : 0b111[3] : s[1] : 0b10[2] : rn[5] : rt[5] );
ldr_wxxs.var shift : {uint8_t} = {s*2}, format : {char const*} = {"base,631"};

ldr_wxxs.disasm = {
  sink << "ldr\t" << DisasmGZWR(rt) << ", [" << DisasmGSXR(rn) << "," << DisasmGZXR(rm) << ",sxtx" << DisasmINZ(" ", shift) << "]";
};

ldr_wxxs.execute = {
  typedef typename ARCH::S64 S64;
  typedef typename ARCH::U32 U32;
  typedef typename ARCH::U64 U64;

  U64 offset( S64(S64(cpu.GetGZR(rm))) << shift ), addr( cpu.GetGSR(rn) + offset );
  U32 data( cpu.MemRead32(addr) );
  cpu.SetGZR(rt, data);
};

op ldr_xxwu( 0b11111000011[11] : rm[5] : 0b010[3] : s[1] : 0b10[2] : rn[5] : rt[5] );
ldr_xxwu.var shift : {uint8_t} = {s*3}, format : {char const*} = {"base,644"};

ldr_xxwu.disasm = {
  sink << "ldr\t" << DisasmGZXR(rt) << ", [" << DisasmGSXR(rn) << "," << DisasmGZWR(rm) << ",uxtw" << DisasmINZ(" ", shift) << "]";
};

ldr_xxwu.execute = {
  typedef typename ARCH::U32 U32;
  typedef typename ARCH::U64 U64;

  U64 offset( U64(U32(cpu.GetGZR(rm))) << shift ), addr( cpu.GetGSR(rn) + offset );
  U64 data( cpu.MemRead64(addr) );
  cpu.SetGZR(rt, data);
};

op ldr_xxxu( 0b11111000011[11] : rm[5] : 0b011[3] : s[1] : 0b10[2] : rn[5] : rt[5] );
ldr_xxxu.var format : {char const*} = {"base,1661"}, shift : {uint8_t} = {s*3};

ldr_xxxu.disasm = {
  sink << "ldr\t" << DisasmGZXR(rt) << ", [" << DisasmGSXR(rn) << "," << DisasmGZXR(rm) << DisasmINZ(",lsl ",shift) << "]";
};

ldr_xxxu.execute = {
  typedef typename ARCH::U64 U64;

  U64 offset( U64(U64(cpu.GetGZR(rm))) << shift ), addr( cpu.GetGSR(rn) + offset );
  U64 data( cpu.MemRead64(addr) );
  cpu.SetGZR(rt, data);
};

op ldr_xxws( 0b11111000011[11] : rm[5] : 0b110[3] : s[1] : 0b10[2] : rn[5] : rt[5] );
ldr_xxws.var shift : {uint8_t} = {s*3}, format : {char const*} = {"base,639"};

ldr_xxws.disasm = {
  sink << "ldr\t" << DisasmGZXR(rt) << ", [" << DisasmGSXR(rn) << "," << DisasmGZWR(rm) << ",sxtw" << DisasmINZ(" ", shift) << "]";
};

ldr_xxws.execute = {
  typedef typename ARCH::S32 S32;
  typedef typename ARCH::S64 S64;
  typedef typename ARCH::U64 U64;

  U64 offset( S64(S32(cpu.GetGZR(rm))) << shift ), addr( cpu.GetGSR(rn) + offset );
  U64 data( cpu.MemRead64(addr) );
  cpu.SetGZR(rt, data);
};

op ldr_xxxs( 0b11111000011[11] : rm[5] : 0b111[3] : s[1] : 0b10[2] : rn[5] : rt[5] );
ldr_xxxs.var shift : {uint8_t} = {s*3}, format : {char const*} = {"base,649"};

ldr_xxxs.disasm = {
  sink << "ldr\t" << DisasmGZXR(rt) << ", [" << DisasmGSXR(rn) << "," << DisasmGZXR(rm) << ",sxtx" << DisasmINZ(" ", shift) << "]";
};

ldr_xxxs.execute = {
  typedef typename ARCH::S64 S64;
  typedef typename ARCH::U64 U64;

  U64 offset( S64(S64(cpu.GetGZR(rm))) << shift ), addr( cpu.GetGSR(rn) + offset );
  U64 data( cpu.MemRead64(addr) );
  cpu.SetGZR(rt, data);
};

/*
 * end of LDR (register)
 *******************************************************************/

/*******************************************************************
 * LDRB (immediate)
 *
 * Load register byte (immediate offset)
 */

op ldrb_wsopost( 0b00111000010[11] : sext imm[9] : 0b01[2] : rn[5] : rt[5] );
ldrb_wsopost.var format : {char const*} = {"base,320"};

ldrb_wsopost.disasm = {
  sink << "ldrb\t" << DisasmGZWR(rt) << ", [" << DisasmGSXR(rn) << "]," << DisasmI(imm);
};

ldrb_wsopost.execute = {
  typedef typename ARCH::U8 U8;
  typedef typename ARCH::U64 U64;
  typedef typename ARCH::S64 S64;
  
  U64 addr( cpu.GetGSR(rn) );
  U8 data( cpu.MemRead8(addr) );
  cpu.SetGZR(rt, data);
  cpu.SetGSR(rn, addr + U64(S64(imm)) );
};

op ldrb_wsopre( 0b00111000010[11] : sext imm[9] : 0b11[2] : rn[5] : rt[5] );
ldrb_wsopre.var format : {char const*} = {"base,312"};

ldrb_wsopre.disasm = {
  sink << "ldrb\t" << DisasmGZWR(rt) << ", [" << DisasmGSXR(rn) << "," << DisasmI(imm) << "]!";
};

ldrb_wsopre.execute = {
  typedef typename ARCH::U8 U8;
  typedef typename ARCH::U64 U64;
  typedef typename ARCH::S64 S64;
  
  U64 addr( cpu.GetGSR(rn) + U64(S64(imm)) );
  U8 data( cpu.MemRead8(addr) );
  cpu.SetGZR(rt, data);
  cpu.SetGSR(rn, addr);
};

op ldrb_wuo( 0b0011100101[10] : imm[12] : rn[5] : rt[5] );
ldrb_wuo.var format : {char const*} = {"base,83"};

ldrb_wuo.disasm = {
  sink << "ldrb\t" << DisasmGZWR(rt) << ", [" << DisasmGSXR(rn) << "," << DisasmI(imm) << "]";
};

ldrb_wuo.execute = {
  typedef typename ARCH::U8 U8;
  typedef typename ARCH::U64 U64;
  
  U64 addr( cpu.GetGSR(rn) + U64(imm) );
  U8 data( cpu.MemRead8(addr) );
  cpu.SetGZR(rt, data);
};

/*
 * end of LDRB (immediate)
 *******************************************************************/

/*******************************************************************
 * LDRB (register)
 *
 * Load register byte (register offset)
 */

op ldrb_wxwu( 0b00111000011[11] : rm[5] : 0b010[3] : s[1] : 0b10[2] : rn[5] : rt[5] );
ldrb_wxwu.var shift : {uint8_t} = {s*0}, format : {char const*} = {"base,624"};

ldrb_wxwu.disasm = {
  sink << "ldrb\t" << DisasmGZWR(rt) << ", [" << DisasmGSXR(rn) << "," << DisasmGZWR(rm) << ",uxtw" << DisasmINZ(" ", shift) << "]";
};

ldrb_wxwu.execute = {
  typedef typename ARCH::U32 U32;
  typedef typename ARCH::U64 U64;

  U64 offset( U64(U32(cpu.GetGZR(rm))) << shift ), addr( cpu.GetGSR(rn) + offset );
  U32 data( cpu.MemRead8(addr) );
  cpu.SetGZR(rt, data);
};

op ldrb_wxxu( 0b00111000011[11] : rm[5] : 0b011[3] : s[1] : 0b10[2] : rn[5] : rt[5] );
ldrb_wxxu.var format : {char const*} = {"base,1597"}, shift : {uint8_t} = {s*0};

ldrb_wxxu.disasm = {
  sink << "ldrb\t" << DisasmGZWR(rt) << ", [" << DisasmGSXR(rn) << "," << DisasmGZXR(rm) << DisasmINZ(",lsl ",shift) << "]";
};

ldrb_wxxu.execute = {
  typedef typename ARCH::U32 U32;
  typedef typename ARCH::U64 U64;

  U64 offset( U64(U64(cpu.GetGZR(rm))) << shift ), addr( cpu.GetGSR(rn) + offset );
  U32 data( cpu.MemRead8(addr) );
  cpu.SetGZR(rt, data);
};

op ldrb_wxws( 0b00111000011[11] : rm[5] : 0b110[3] : s[1] : 0b10[2] : rn[5] : rt[5] );
ldrb_wxws.var shift : {uint8_t} = {s*0}, format : {char const*} = {"base,616"};

ldrb_wxws.disasm = {
  sink << "ldrb\t" << DisasmGZWR(rt) << ", [" << DisasmGSXR(rn) << "," << DisasmGZWR(rm) << ",sxtw" << DisasmINZ(" ", shift) << "]";
};

ldrb_wxws.execute = {
  typedef typename ARCH::S32 S32;
  typedef typename ARCH::S64 S64;
  typedef typename ARCH::U32 U32;
  typedef typename ARCH::U64 U64;

  U64 offset( S64(S32(cpu.GetGZR(rm))) << shift ), addr( cpu.GetGSR(rn) + offset );
  U32 data( cpu.MemRead8(addr) );
  cpu.SetGZR(rt, data);
};

op ldrb_wxxs( 0b00111000011[11] : rm[5] : 0b111[3] : s[1] : 0b10[2] : rn[5] : rt[5] );
ldrb_wxxs.var shift : {uint8_t} = {s*0}, format : {char const*} = {"base,632"};

ldrb_wxxs.disasm = {
  sink << "ldrb\t" << DisasmGZWR(rt) << ", [" << DisasmGSXR(rn) << "," << DisasmGZXR(rm) << ",sxtx" << DisasmINZ(" ", shift) << "]";
};

ldrb_wxxs.execute = {
  typedef typename ARCH::S64 S64;
  typedef typename ARCH::U32 U32;
  typedef typename ARCH::U64 U64;

  U64 offset( S64(S64(cpu.GetGZR(rm))) << shift ), addr( cpu.GetGSR(rn) + offset );
  U32 data( cpu.MemRead8(addr) );
  cpu.SetGZR(rt, data);
};

/*
 * end of LDRB (register)
 *******************************************************************/

/*******************************************************************
 * LDRH (immediate)
 *
 * Load register halfword (immediate offset)
 */

op ldrh_wsopost( 0b01111000010[11] : sext imm[9] : 0b01[2] : rn[5] : rt[5] );
ldrh_wsopost.var format : {char const*} = {"base,321"};

ldrh_wsopost.disasm = {
  sink << "ldrh\t" << DisasmGZWR(rt) << ", [" << DisasmGSXR(rn) << "]," << DisasmI(imm);
};

ldrh_wsopost.execute = {
  typedef typename ARCH::U16 U16;
  typedef typename ARCH::U64 U64;
  typedef typename ARCH::S64 S64;
  
  U64 addr( cpu.GetGSR(rn) );
  U16 data( cpu.MemRead16(addr) );
  cpu.SetGZR(rt, data);
  cpu.SetGSR(rn, addr + U64(S64(imm)) );
};

op ldrh_wsopre( 0b01111000010[11] : sext imm[9] : 0b11[2] : rn[5] : rt[5] );
ldrh_wsopre.var format : {char const*} = {"base,313"};

ldrh_wsopre.disasm = {
  sink << "ldrh\t" << DisasmGZWR(rt) << ", [" << DisasmGSXR(rn) << "," << DisasmI(imm) << "]!";
};

ldrh_wsopre.execute = {
  typedef typename ARCH::U16 U16;
  typedef typename ARCH::U64 U64;
  typedef typename ARCH::S64 S64;
  
  U64 addr( cpu.GetGSR(rn) + U64(S64(imm)) );
  U16 data( cpu.MemRead16(addr) );
  cpu.SetGZR(rt, data);
  cpu.SetGSR(rn, addr);
};

op ldrh_wuo( 0b0111100101[10] : shl<1> imm[12] : rn[5] : rt[5] );
ldrh_wuo.var format : {char const*} = {"base,84"};

ldrh_wuo.disasm = {
  sink << "ldrh\t" << DisasmGZWR(rt) << ", [" << DisasmGSXR(rn) << "," << DisasmI(imm) << "]";
};

ldrh_wuo.execute = {
  typedef typename ARCH::U16 U16;
  typedef typename ARCH::U64 U64;
  
  U64 addr( cpu.GetGSR(rn) + U64(imm) );
  U16 data( cpu.MemRead16(addr) );
  cpu.SetGZR(rt, data);
};

/*
 * end of LDRH (immediate)
 *******************************************************************/

/*******************************************************************
 * LDRH (register)
 *
 * Load register halfword (register offset)
 */

op ldrh_wxwu( 0b01111000011[11] : rm[5] : 0b010[3] : s[1] : 0b10[2] : rn[5] : rt[5] );
ldrh_wxwu.var shift : {uint8_t} = {s*1}, format : {char const*} = {"base,625"};

ldrh_wxwu.disasm = {
  sink << "ldrh\t" << DisasmGZWR(rt) << ", [" << DisasmGSXR(rn) << "," << DisasmGZWR(rm) << ",uxtw" << DisasmINZ(" ", shift) << "]";
};

ldrh_wxwu.execute = {
  typedef typename ARCH::U32 U32;
  typedef typename ARCH::U64 U64;

  U64 offset( U64(U32(cpu.GetGZR(rm))) << shift ), addr( cpu.GetGSR(rn) + offset );
  U32 data( cpu.MemRead16(addr) );
  cpu.SetGZR(rt, data);
};

op ldrh_wxxu( 0b01111000011[11] : rm[5] : 0b011[3] : s[1] : 0b10[2] : rn[5] : rt[5] );
ldrh_wxxu.var format : {char const*} = {"base,1598"}, shift : {uint8_t} = {s*1};

ldrh_wxxu.disasm = {
  sink << "ldrh\t" << DisasmGZWR(rt) << ", [" << DisasmGSXR(rn) << "," << DisasmGZXR(rm) << DisasmINZ(",lsl ",shift) << "]";
};

ldrh_wxxu.execute = {
  typedef typename ARCH::U32 U32;
  typedef typename ARCH::U64 U64;

  U64 offset( U64(U64(cpu.GetGZR(rm))) << shift ), addr( cpu.GetGSR(rn) + offset );
  U32 data( cpu.MemRead16(addr) );
  cpu.SetGZR(rt, data);
};

op ldrh_wxws( 0b01111000011[11] : rm[5] : 0b110[3] : s[1] : 0b10[2] : rn[5] : rt[5] );
ldrh_wxws.var shift : {uint8_t} = {s*1}, format : {char const*} = {"base,617"};

ldrh_wxws.disasm = {
  sink << "ldrh\t" << DisasmGZWR(rt) << ", [" << DisasmGSXR(rn) << "," << DisasmGZWR(rm) << ",sxtw" << DisasmINZ(" ", shift) << "]";
};

ldrh_wxws.execute = {
  typedef typename ARCH::S32 S32;
  typedef typename ARCH::S64 S64;
  typedef typename ARCH::U32 U32;
  typedef typename ARCH::U64 U64;

  U64 offset( S64(S32(cpu.GetGZR(rm))) << shift ), addr( cpu.GetGSR(rn) + offset );
  U32 data( cpu.MemRead16(addr) );
  cpu.SetGZR(rt, data);
};

op ldrh_wxxs( 0b01111000011[11] : rm[5] : 0b111[3] : s[1] : 0b10[2] : rn[5] : rt[5] );
ldrh_wxxs.var shift : {uint8_t} = {s*1}, format : {char const*} = {"base,633"};

ldrh_wxxs.disasm = {
  sink << "ldrh\t" << DisasmGZWR(rt) << ", [" << DisasmGSXR(rn) << "," << DisasmGZXR(rm) << ",sxtx" << DisasmINZ(" ", shift) << "]";
};

ldrh_wxxs.execute = {
  typedef typename ARCH::S64 S64;
  typedef typename ARCH::U32 U32;
  typedef typename ARCH::U64 U64;

  U64 offset( S64(S64(cpu.GetGZR(rm))) << shift ), addr( cpu.GetGSR(rn) + offset );
  U32 data( cpu.MemRead16(addr) );
  cpu.SetGZR(rt, data);
};

/*
 * end of LDRH (register)
 *******************************************************************/

/*******************************************************************
 * LDRSB (immediate)
 *
 * Load register signed byte (immediate offset)
 */

op ldrsb_wsopost( 0b00111000110[11] : sext imm[9] : 0b01[2] : rn[5] : rt[5] );
ldrsb_wsopost.var format : {char const*} = {"base,322"};

ldrsb_wsopost.disasm = {
  sink << "ldrsb\t" << DisasmGZWR(rt) << ", [" << DisasmGSXR(rn) << "]," << DisasmI(imm);
};

ldrsb_wsopost.execute = {
  typedef typename ARCH::S8  S8;
  typedef typename ARCH::S32 S32;
  typedef typename ARCH::U32 U32;
  typedef typename ARCH::U64 U64;
  typedef typename ARCH::S64 S64;
  
  U64 addr( cpu.GetGSR(rn) );
  S8 data( cpu.MemRead8(addr) );
  cpu.SetGZR(rt, U32(S32(data)));
  cpu.SetGSR(rn, addr + U64(S64(imm)) );
};

op ldrsb_xsopost( 0b00111000100[11] : sext imm[9] : 0b01[2] : rn[5] : rt[5] );
ldrsb_xsopost.var format : {char const*} = {"base,347"};

ldrsb_xsopost.disasm = {
  sink << "ldrsb\t" << DisasmGZXR(rt) << ", [" << DisasmGSXR(rn) << "]," << DisasmI(imm);
};

ldrsb_xsopost.execute = {
  typedef typename ARCH::S8  S8;
  typedef typename ARCH::S64 S64;
  typedef typename ARCH::U64 U64;
  
  U64 addr( cpu.GetGSR(rn) );
  S8 data( cpu.MemRead8(addr) );
  cpu.SetGZR(rt, U64(S64(data)));
  cpu.SetGSR(rn, addr + U64(S64(imm)) );
};

op ldrsb_wsopre( 0b00111000110[11] : sext imm[9] : 0b11[2] : rn[5] : rt[5] );
ldrsb_wsopre.var format : {char const*} = {"base,314"};

ldrsb_wsopre.disasm = {
  sink << "ldrsb\t" << DisasmGZWR(rt) << ", [" << DisasmGSXR(rn) << "," << DisasmI(imm) << "]!";
};

ldrsb_wsopre.execute = {
  typedef typename ARCH::S8  S8;
  typedef typename ARCH::S32 S32;
  typedef typename ARCH::U32 U32;
  typedef typename ARCH::U64 U64;
  typedef typename ARCH::S64 S64;
  
  U64 addr( cpu.GetGSR(rn) + U64(S64(imm)) );
  S8 data( cpu.MemRead8(addr) );
  cpu.SetGZR(rt, U32(S32(data)));
  cpu.SetGSR(rn, addr);
};

op ldrsb_xsopre( 0b00111000100[11] : sext imm[9] : 0b11[2] : rn[5] : rt[5] );
ldrsb_xsopre.var format : {char const*} = {"base,342"};

ldrsb_xsopre.disasm = {
  sink << "ldrsb\t" << DisasmGZXR(rt) << ", [" << DisasmGSXR(rn) << "," << DisasmI(imm) << "]!";
};

ldrsb_xsopre.execute = {
  typedef typename ARCH::S8  S8;
  typedef typename ARCH::S64 S64;
  typedef typename ARCH::U64 U64;
  
  U64 addr( cpu.GetGSR(rn) + U64(S64(imm)) );
  S8 data( cpu.MemRead8(addr) );
  cpu.SetGZR(rt, U64(S64(data)));
  cpu.SetGSR(rn, addr);
};

op ldrsb_wuo( 0b0011100111[10] : imm[12] : rn[5] : rt[5] );
ldrsb_wuo.var format : {char const*} = {"base,85"};

ldrsb_wuo.disasm = {
  sink << "ldrsb\t" << DisasmGZWR(rt) << ", [" << DisasmGSXR(rn) << "," << DisasmI(imm) << "]";
};

ldrsb_wuo.execute = {
  typedef typename ARCH::S8  S8;
  typedef typename ARCH::S32 S32;
  typedef typename ARCH::U32 U32;
  typedef typename ARCH::U64 U64;
  
  U64 addr( cpu.GetGSR(rn) + U64(imm) );
  S8 data( cpu.MemRead8(addr) );
  cpu.SetGZR(rt, U32(S32(data)));
};

op ldrsb_xuo( 0b0011100110[10] : imm[12] : rn[5] : rt[5] );
ldrsb_xuo.var format : {char const*} = {"base,105"};

ldrsb_xuo.disasm = {
  sink << "ldrsb\t" << DisasmGZXR(rt) << ", [" << DisasmGSXR(rn) << "," << DisasmI(imm) << "]";
};

ldrsb_xuo.execute = {
  typedef typename ARCH::S8  S8;
  typedef typename ARCH::S64 S64;
  typedef typename ARCH::U64 U64;
  
  U64 addr( cpu.GetGSR(rn) + U64(imm) );
  S8 data( cpu.MemRead8(addr) );
  cpu.SetGZR(rt, U64(S64(data)));
};

/*
 * end of LDRSB (immediate)
 *******************************************************************/

/*******************************************************************
 * LDRSB (register)
 *
 * Load register signed byte (register offset)
 */

op ldrsb_wxwu( 0b00111000111[11] : rm[5] : 0b010[3] : s[1] : 0b10[2] : rn[5] : rt[5] );
ldrsb_wxwu.var shift : {uint8_t} = {s*0}, format : {char const*} = {"base,626"};

ldrsb_wxwu.disasm = {
  sink << "ldrsb\t" << DisasmGZWR(rt) << ", [" << DisasmGSXR(rn) << "," << DisasmGZWR(rm) << ",uxtw" << DisasmINZ(" ", shift) << "]";
};

ldrsb_wxwu.execute = {
  typedef typename ARCH::S32 S32;
  typedef typename ARCH::S8 S8;
  typedef typename ARCH::U32 U32;
  typedef typename ARCH::U64 U64;

  U64 offset( U64(U32(cpu.GetGZR(rm))) << shift ), addr( cpu.GetGSR(rn) + offset );
  U32 data( S32(S8(cpu.MemRead8(addr))) );
  cpu.SetGZR(rt, data);
};

op ldrsb_wxxu( 0b00111000111[11] : rm[5] : 0b011[3] : s[1] : 0b10[2] : rn[5] : rt[5] );
ldrsb_wxxu.var format : {char const*} = {"base,1599"}, shift : {uint8_t} = {s*0};

ldrsb_wxxu.disasm = {
  sink << "ldrsb\t" << DisasmGZWR(rt) << ", [" << DisasmGSXR(rn) << "," << DisasmGZXR(rm) << DisasmINZ(",lsl ",shift) << "]";
};

ldrsb_wxxu.execute = {
  typedef typename ARCH::S32 S32;
  typedef typename ARCH::S8 S8;
  typedef typename ARCH::U32 U32;
  typedef typename ARCH::U64 U64;

  U64 offset( U64(U64(cpu.GetGZR(rm))) << shift ), addr( cpu.GetGSR(rn) + offset );
  U32 data( S32(S8(cpu.MemRead8(addr))) );
  cpu.SetGZR(rt, data);
};

op ldrsb_wxws( 0b00111000111[11] : rm[5] : 0b110[3] : s[1] : 0b10[2] : rn[5] : rt[5] );
ldrsb_wxws.var shift : {uint8_t} = {s*0}, format : {char const*} = {"base,618"};

ldrsb_wxws.disasm = {
  sink << "ldrsb\t" << DisasmGZWR(rt) << ", [" << DisasmGSXR(rn) << "," << DisasmGZWR(rm) << ",sxtw" << DisasmINZ(" ", shift) << "]";
};

ldrsb_wxws.execute = {
  typedef typename ARCH::S32 S32;
  typedef typename ARCH::S64 S64;
  typedef typename ARCH::S8 S8;
  typedef typename ARCH::U32 U32;
  typedef typename ARCH::U64 U64;

  U64 offset( S64(S32(cpu.GetGZR(rm))) << shift ), addr( cpu.GetGSR(rn) + offset );
  U32 data( S32(S8(cpu.MemRead8(addr))) );
  cpu.SetGZR(rt, data);
};

op ldrsb_wxxs( 0b00111000111[11] : rm[5] : 0b111[3] : s[1] : 0b10[2] : rn[5] : rt[5] );
ldrsb_wxxs.var shift : {uint8_t} = {s*0}, format : {char const*} = {"base,634"};

ldrsb_wxxs.disasm = {
  sink << "ldrsb\t" << DisasmGZWR(rt) << ", [" << DisasmGSXR(rn) << "," << DisasmGZXR(rm) << ",sxtx" << DisasmINZ(" ", shift) << "]";
};

ldrsb_wxxs.execute = {
  typedef typename ARCH::S32 S32;
  typedef typename ARCH::S64 S64;
  typedef typename ARCH::S8 S8;
  typedef typename ARCH::U32 U32;
  typedef typename ARCH::U64 U64;

  U64 offset( S64(S64(cpu.GetGZR(rm))) << shift ), addr( cpu.GetGSR(rn) + offset );
  U32 data( S32(S8(cpu.MemRead8(addr))) );
  cpu.SetGZR(rt, data);
};

op ldrsb_xxwu( 0b00111000101[11] : rm[5] : 0b010[3] : s[1] : 0b10[2] : rn[5] : rt[5] );
ldrsb_xxwu.var shift : {uint8_t} = {s*0}, format : {char const*} = {"base,645"};

ldrsb_xxwu.disasm = {
  sink << "ldrsb\t" << DisasmGZXR(rt) << ", [" << DisasmGSXR(rn) << "," << DisasmGZWR(rm) << ",uxtw" << DisasmINZ(" ", shift) << "]";
};

ldrsb_xxwu.execute = {
  typedef typename ARCH::S64 S64;
  typedef typename ARCH::S8 S8;
  typedef typename ARCH::U32 U32;
  typedef typename ARCH::U64 U64;

  U64 offset( U64(U32(cpu.GetGZR(rm))) << shift ), addr( cpu.GetGSR(rn) + offset );
  U64 data( S64(S8(cpu.MemRead8(addr))) );
  cpu.SetGZR(rt, data);
};

op ldrsb_xxxu( 0b00111000101[11] : rm[5] : 0b011[3] : s[1] : 0b10[2] : rn[5] : rt[5] );
ldrsb_xxxu.var format : {char const*} = {"base,1662"}, shift : {uint8_t} = {s*0};

ldrsb_xxxu.disasm = {
  sink << "ldrsb\t" << DisasmGZXR(rt) << ", [" << DisasmGSXR(rn) << "," << DisasmGZXR(rm) << DisasmINZ(",lsl ",shift) << "]";
};

ldrsb_xxxu.execute = {
  typedef typename ARCH::S64 S64;
  typedef typename ARCH::S8 S8;
  typedef typename ARCH::U64 U64;

  U64 offset( U64(U64(cpu.GetGZR(rm))) << shift ), addr( cpu.GetGSR(rn) + offset );
  U64 data( S64(S8(cpu.MemRead8(addr))) );
  cpu.SetGZR(rt, data);
};

op ldrsb_xxws( 0b00111000101[11] : rm[5] : 0b110[3] : s[1] : 0b10[2] : rn[5] : rt[5] );
ldrsb_xxws.var shift : {uint8_t} = {s*0}, format : {char const*} = {"base,640"};

ldrsb_xxws.disasm = {
  sink << "ldrsb\t" << DisasmGZXR(rt) << ", [" << DisasmGSXR(rn) << "," << DisasmGZWR(rm) << ",sxtw" << DisasmINZ(" ", shift) << "]";
};

ldrsb_xxws.execute = {
  typedef typename ARCH::S32 S32;
  typedef typename ARCH::S64 S64;
  typedef typename ARCH::S8 S8;
  typedef typename ARCH::U64 U64;

  U64 offset( S64(S32(cpu.GetGZR(rm))) << shift ), addr( cpu.GetGSR(rn) + offset );
  U64 data( S64(S8(cpu.MemRead8(addr))) );
  cpu.SetGZR(rt, data);
};

op ldrsb_xxxs( 0b00111000101[11] : rm[5] : 0b111[3] : s[1] : 0b10[2] : rn[5] : rt[5] );
ldrsb_xxxs.var shift : {uint8_t} = {s*0}, format : {char const*} = {"base,650"};

ldrsb_xxxs.disasm = {
  sink << "ldrsb\t" << DisasmGZXR(rt) << ", [" << DisasmGSXR(rn) << "," << DisasmGZXR(rm) << ",sxtx" << DisasmINZ(" ", shift) << "]";
};

ldrsb_xxxs.execute = {
  typedef typename ARCH::S64 S64;
  typedef typename ARCH::S8 S8;
  typedef typename ARCH::U64 U64;

  U64 offset( S64(S64(cpu.GetGZR(rm))) << shift ), addr( cpu.GetGSR(rn) + offset );
  U64 data( S64(S8(cpu.MemRead8(addr))) );
  cpu.SetGZR(rt, data);
};

/*
 * end of LDRSB (register)
 *******************************************************************/

/*******************************************************************
 * LDRSH (immediate)
 *
 * Load register signed halfword (immediate offset)
 */

op ldrsh_wsopost( 0b01111000110[11] : sext imm[9] : 0b01[2] : rn[5] : rt[5] );
ldrsh_wsopost.var format : {char const*} = {"base,323"};

ldrsh_wsopost.disasm = {
  sink << "ldrsh\t" << DisasmGZWR(rt) << ", [" << DisasmGSXR(rn) << "]," << DisasmI(imm);
};

ldrsh_wsopost.execute = {
  typedef typename ARCH::S16 S16;
  typedef typename ARCH::S32 S32;
  typedef typename ARCH::U32 U32;
  typedef typename ARCH::U64 U64;
  typedef typename ARCH::S64 S64;
  
  U64 addr( cpu.GetGSR(rn) );
  S16 data( cpu.MemRead16(addr) );
  cpu.SetGZR(rt, U32(S32(data)));
  cpu.SetGSR(rn, addr + U64(S64(imm)) );
};

op ldrsh_xsopost( 0b01111000100[11] : sext imm[9] : 0b01[2] : rn[5] : rt[5] );
ldrsh_xsopost.var format : {char const*} = {"base,348"};

ldrsh_xsopost.disasm = {
  sink << "ldrsh\t" << DisasmGZXR(rt) << ", [" << DisasmGSXR(rn) << "]," << DisasmI(imm);
};

ldrsh_xsopost.execute = {
  typedef typename ARCH::S16 S16;
  typedef typename ARCH::S64 S64;
  typedef typename ARCH::U64 U64;
  
  U64 addr( cpu.GetGSR(rn) );
  S16 data( cpu.MemRead16(addr) );
  cpu.SetGZR(rt, U64(S64(data)));
  cpu.SetGSR(rn, addr + U64(S64(imm)) );
};

op ldrsh_wsopre( 0b01111000110[11] : sext imm[9] : 0b11[2] : rn[5] : rt[5] );
ldrsh_wsopre.var format : {char const*} = {"base,315"};

ldrsh_wsopre.disasm = {
  sink << "ldrsh\t" << DisasmGZWR(rt) << ", [" << DisasmGSXR(rn) << "," << DisasmI(imm) << "]!";
};

ldrsh_wsopre.execute = {
  typedef typename ARCH::S16 S16;
  typedef typename ARCH::S32 S32;
  typedef typename ARCH::U32 U32;
  typedef typename ARCH::U64 U64;
  typedef typename ARCH::S64 S64;
  
  U64 addr( cpu.GetGSR(rn) + U64(S64(imm)) );
  S16 data( cpu.MemRead16(addr) );
  cpu.SetGZR(rt, U32(S32(data)));
  cpu.SetGSR(rn, addr);
};

op ldrsh_xsopre( 0b01111000100[11] : sext imm[9] : 0b11[2] : rn[5] : rt[5] );
ldrsh_xsopre.var format : {char const*} = {"base,343"};

ldrsh_xsopre.disasm = {
  sink << "ldrsh\t" << DisasmGZXR(rt) << ", [" << DisasmGSXR(rn) << "," << DisasmI(imm) << "]!";
};

ldrsh_xsopre.execute = {
  typedef typename ARCH::S16 S16;
  typedef typename ARCH::S64 S64;
  typedef typename ARCH::U64 U64;
  
  U64 addr( cpu.GetGSR(rn) + U64(S64(imm)) );
  S16 data( cpu.MemRead16(addr) );
  cpu.SetGZR(rt, U64(S64(data)));
  cpu.SetGSR(rn, addr);
};

op ldrsh_wuo( 0b0111100111[10] : shl<1> imm[12] : rn[5] : rt[5] );
ldrsh_wuo.var format : {char const*} = {"base,86"};

ldrsh_wuo.disasm = {
  sink << "ldrsh\t" << DisasmGZWR(rt) << ", [" << DisasmGSXR(rn) << "," << DisasmI(imm) << "]";
};

ldrsh_wuo.execute = {
  typedef typename ARCH::S16 S16;
  typedef typename ARCH::S32 S32;
  typedef typename ARCH::U32 U32;
  typedef typename ARCH::U64 U64;
  
  U64 addr( cpu.GetGSR(rn) + U64(imm) );
  S16 data( cpu.MemRead16(addr) );
  cpu.SetGZR(rt, U32(S32(data)));
};

op ldrsh_xuo( 0b0111100110[10] : shl<1> imm[12] : rn[5] : rt[5] );
ldrsh_xuo.var format : {char const*} = {"base,106"};

ldrsh_xuo.disasm = {
  sink << "ldrsh\t" << DisasmGZXR(rt) << ", [" << DisasmGSXR(rn) << "," << DisasmI(imm) << "]";
};

ldrsh_xuo.execute = {
  typedef typename ARCH::S16 S16;
  typedef typename ARCH::S64 S64;
  typedef typename ARCH::U64 U64;
  
  U64 addr( cpu.GetGSR(rn) + U64(imm) );
  S16 data( cpu.MemRead16(addr) );
  cpu.SetGZR(rt, U64(S64(data)));
};

/*
 * end of LDRSH (immediate)
 *******************************************************************/

/*******************************************************************
 * LDRSH (register)
 *
 * Load register signed halfword (register offset)
 */

op ldrsh_wxwu( 0b01111000111[11] : rm[5] : 0b010[3] : s[1] : 0b10[2] : rn[5] : rt[5] );
ldrsh_wxwu.var shift : {uint8_t} = {s*1}, format : {char const*} = {"base,627"};

ldrsh_wxwu.disasm = {
  sink << "ldrsh\t" << DisasmGZWR(rt) << ", [" << DisasmGSXR(rn) << "," << DisasmGZWR(rm) << ",uxtw" << DisasmINZ(" ", shift) << "]";
};

ldrsh_wxwu.execute = {
  typedef typename ARCH::S16 S16;
  typedef typename ARCH::S32 S32;
  typedef typename ARCH::U32 U32;
  typedef typename ARCH::U64 U64;

  U64 offset( U64(U32(cpu.GetGZR(rm))) << shift ), addr( cpu.GetGSR(rn) + offset );
  U32 data( S32(S16(cpu.MemRead16(addr))) );
  cpu.SetGZR(rt, data);
};

op ldrsh_wxxu( 0b01111000111[11] : rm[5] : 0b011[3] : s[1] : 0b10[2] : rn[5] : rt[5] );
ldrsh_wxxu.var format : {char const*} = {"base,1600"}, shift : {uint8_t} = {s*1};

ldrsh_wxxu.disasm = {
  sink << "ldrsh\t" << DisasmGZWR(rt) << ", [" << DisasmGSXR(rn) << "," << DisasmGZXR(rm) << DisasmINZ(",lsl ",shift) << "]";
};

ldrsh_wxxu.execute = {
  typedef typename ARCH::S16 S16;
  typedef typename ARCH::S32 S32;
  typedef typename ARCH::U32 U32;
  typedef typename ARCH::U64 U64;

  U64 offset( U64(U64(cpu.GetGZR(rm))) << shift ), addr( cpu.GetGSR(rn) + offset );
  U32 data( S32(S16(cpu.MemRead16(addr))) );
  cpu.SetGZR(rt, data);
};

op ldrsh_wxws( 0b01111000111[11] : rm[5] : 0b110[3] : s[1] : 0b10[2] : rn[5] : rt[5] );
ldrsh_wxws.var shift : {uint8_t} = {s*1}, format : {char const*} = {"base,619"};

ldrsh_wxws.disasm = {
  sink << "ldrsh\t" << DisasmGZWR(rt) << ", [" << DisasmGSXR(rn) << "," << DisasmGZWR(rm) << ",sxtw" << DisasmINZ(" ", shift) << "]";
};

ldrsh_wxws.execute = {
  typedef typename ARCH::S16 S16;
  typedef typename ARCH::S32 S32;
  typedef typename ARCH::S64 S64;
  typedef typename ARCH::U32 U32;
  typedef typename ARCH::U64 U64;

  U64 offset( S64(S32(cpu.GetGZR(rm))) << shift ), addr( cpu.GetGSR(rn) + offset );
  U32 data( S32(S16(cpu.MemRead16(addr))) );
  cpu.SetGZR(rt, data);
};

op ldrsh_wxxs( 0b01111000111[11] : rm[5] : 0b111[3] : s[1] : 0b10[2] : rn[5] : rt[5] );
ldrsh_wxxs.var shift : {uint8_t} = {s*1}, format : {char const*} = {"base,635"};

ldrsh_wxxs.disasm = {
  sink << "ldrsh\t" << DisasmGZWR(rt) << ", [" << DisasmGSXR(rn) << "," << DisasmGZXR(rm) << ",sxtx" << DisasmINZ(" ", shift) << "]";
};

ldrsh_wxxs.execute = {
  typedef typename ARCH::S16 S16;
  typedef typename ARCH::S32 S32;
  typedef typename ARCH::S64 S64;
  typedef typename ARCH::U32 U32;
  typedef typename ARCH::U64 U64;

  U64 offset( S64(S64(cpu.GetGZR(rm))) << shift ), addr( cpu.GetGSR(rn) + offset );
  U32 data( S32(S16(cpu.MemRead16(addr))) );
  cpu.SetGZR(rt, data);
};

op ldrsh_xxwu( 0b01111000101[11] : rm[5] : 0b010[3] : s[1] : 0b10[2] : rn[5] : rt[5] );
ldrsh_xxwu.var shift : {uint8_t} = {s*1}, format : {char const*} = {"base,646"};

ldrsh_xxwu.disasm = {
  sink << "ldrsh\t" << DisasmGZXR(rt) << ", [" << DisasmGSXR(rn) << "," << DisasmGZWR(rm) << ",uxtw" << DisasmINZ(" ", shift) << "]";
};

ldrsh_xxwu.execute = {
  typedef typename ARCH::S16 S16;
  typedef typename ARCH::S64 S64;
  typedef typename ARCH::U32 U32;
  typedef typename ARCH::U64 U64;

  U64 offset( U64(U32(cpu.GetGZR(rm))) << shift ), addr( cpu.GetGSR(rn) + offset );
  U64 data( S64(S16(cpu.MemRead16(addr))) );
  cpu.SetGZR(rt, data);
};

op ldrsh_xxxu( 0b01111000101[11] : rm[5] : 0b011[3] : s[1] : 0b10[2] : rn[5] : rt[5] );
ldrsh_xxxu.var format : {char const*} = {"base,1663"}, shift : {uint8_t} = {s*1};

ldrsh_xxxu.disasm = {
  sink << "ldrsh\t" << DisasmGZXR(rt) << ", [" << DisasmGSXR(rn) << "," << DisasmGZXR(rm) << DisasmINZ(",lsl ",shift) << "]";
};

ldrsh_xxxu.execute = {
  typedef typename ARCH::S16 S16;
  typedef typename ARCH::S64 S64;
  typedef typename ARCH::U64 U64;

  U64 offset( U64(U64(cpu.GetGZR(rm))) << shift ), addr( cpu.GetGSR(rn) + offset );
  U64 data( S64(S16(cpu.MemRead16(addr))) );
  cpu.SetGZR(rt, data);
};

op ldrsh_xxws( 0b01111000101[11] : rm[5] : 0b110[3] : s[1] : 0b10[2] : rn[5] : rt[5] );
ldrsh_xxws.var shift : {uint8_t} = {s*1}, format : {char const*} = {"base,641"};

ldrsh_xxws.disasm = {
  sink << "ldrsh\t" << DisasmGZXR(rt) << ", [" << DisasmGSXR(rn) << "," << DisasmGZWR(rm) << ",sxtw" << DisasmINZ(" ", shift) << "]";
};

ldrsh_xxws.execute = {
  typedef typename ARCH::S16 S16;
  typedef typename ARCH::S32 S32;
  typedef typename ARCH::S64 S64;
  typedef typename ARCH::U64 U64;

  U64 offset( S64(S32(cpu.GetGZR(rm))) << shift ), addr( cpu.GetGSR(rn) + offset );
  U64 data( S64(S16(cpu.MemRead16(addr))) );
  cpu.SetGZR(rt, data);
};

op ldrsh_xxxs( 0b01111000101[11] : rm[5] : 0b111[3] : s[1] : 0b10[2] : rn[5] : rt[5] );
ldrsh_xxxs.var shift : {uint8_t} = {s*1}, format : {char const*} = {"base,651"};

ldrsh_xxxs.disasm = {
  sink << "ldrsh\t" << DisasmGZXR(rt) << ", [" << DisasmGSXR(rn) << "," << DisasmGZXR(rm) << ",sxtx" << DisasmINZ(" ", shift) << "]";
};

ldrsh_xxxs.execute = {
  typedef typename ARCH::S16 S16;
  typedef typename ARCH::S64 S64;
  typedef typename ARCH::U64 U64;

  U64 offset( S64(S64(cpu.GetGZR(rm))) << shift ), addr( cpu.GetGSR(rn) + offset );
  U64 data( S64(S16(cpu.MemRead16(addr))) );
  cpu.SetGZR(rt, data);
};

/*
 * end of LDRSH (register)
 *******************************************************************/

/*******************************************************************
 * LDRSW (literal)
 *
 * Load register signed word (PC-relative literal)
 */

op ldrsw_xlit( 0b10011000[8] : shl<2> sext imm[19] : rt[5] );
ldrsw_xlit.var format : {char const*} = {"base,18"};

ldrsw_xlit.disasm = {
  sink << "ldrsw\t" << DisasmGZXR(rt) << ", 0x" << std::hex << (this->GetAddr()+imm);
};

ldrsw_xlit.execute = {
  typedef typename ARCH::U64 U64;
  typedef typename ARCH::S32 S32;
  typedef typename ARCH::S64 S64;
  
  U64 addr( cpu.GetPC() + U64(S64(imm)) );
  U64 data( S64(S32( cpu.MemRead32(addr))) );
  cpu.SetGZR(rt, data);
};

/*
 * end of LDRSW (literal)
 *******************************************************************/

/*******************************************************************
 * LDRSW (immediate)
 *
 * Load register signed halfword (immediate offset)
 */

op ldrsw_xsopost( 0b10111000100[11] : sext imm[9] : 0b01[2] : rn[5] : rt[5] );
ldrsw_xsopost.var format : {char const*} = {"base,349"};

ldrsw_xsopost.disasm = {
  sink << "ldrsw\t" << DisasmGZXR(rt) << ", [" << DisasmGSXR(rn) << "]," << DisasmI(imm);
};

ldrsw_xsopost.execute = {
  typedef typename ARCH::S32  S32;
  typedef typename ARCH::S64 S64;
  typedef typename ARCH::U64 U64;
  
  U64 addr( cpu.GetGSR(rn) );
  S32 data( cpu.MemRead32(addr) );
  cpu.SetGZR(rt, U64(S64(data)));
  cpu.SetGSR(rn, addr + U64(S64(imm)) );
};

op ldrsw_xsopre( 0b10111000100[11] : sext imm[9] : 0b11[2] : rn[5] : rt[5] );
ldrsw_xsopre.var format : {char const*} = {"base,344"};

ldrsw_xsopre.disasm = {
  sink << "ldrsw\t" << DisasmGZXR(rt) << ", [" << DisasmGSXR(rn) << "," << DisasmI(imm) << "]!";
};

ldrsw_xsopre.execute = {
  typedef typename ARCH::S32  S32;
  typedef typename ARCH::S64 S64;
  typedef typename ARCH::U64 U64;
  
  U64 addr( cpu.GetGSR(rn) + U64(S64(imm)) );
  S32 data( cpu.MemRead32(addr) );
  cpu.SetGZR(rt, U64(S64(data)));
  cpu.SetGSR(rn, addr);
};

op ldrsw_xuo( 0b1011100110[10] : shl<2> imm[12] : rn[5] : rt[5] );
ldrsw_xuo.var format : {char const*} = {"base,107"};

ldrsw_xuo.disasm = {
  sink << "ldrsw\t" << DisasmGZXR(rt) << ", [" << DisasmGSXR(rn) << "," << DisasmI(imm) << "]";
};

ldrsw_xuo.execute = {
  typedef typename ARCH::S32  S32;
  typedef typename ARCH::S64 S64;
  typedef typename ARCH::U64 U64;
  
  U64 addr( cpu.GetGSR(rn) + U64(imm) );
  S32 data( cpu.MemRead32(addr) );
  cpu.SetGZR(rt, U64(S64(data)));
};

/*
 * end of LDRSW (immediate)
 *******************************************************************/

/*******************************************************************
 * LDRSW (register)
 *
 * Load register signed word (register offset)
 */

op ldrsw_xxwu( 0b10111000101[11] : rm[5] : 0b010[3] : s[1] : 0b10[2] : rn[5] : rt[5] );
ldrsw_xxwu.var shift : {uint8_t} = {s*2}, format : {char const*} = {"base,647"};

ldrsw_xxwu.disasm = {
  sink << "ldrsw\t" << DisasmGZXR(rt) << ", [" << DisasmGSXR(rn) << "," << DisasmGZWR(rm) << ",uxtw" << DisasmINZ(" ", shift) << "]";
};

ldrsw_xxwu.execute = {
  typedef typename ARCH::S32 S32;
  typedef typename ARCH::S64 S64;
  typedef typename ARCH::U32 U32;
  typedef typename ARCH::U64 U64;

  U64 offset( U64(U32(cpu.GetGZR(rm))) << shift ), addr( cpu.GetGSR(rn) + offset );
  U64 data( S64(S32(cpu.MemRead32(addr))) );
  cpu.SetGZR(rt, data);
};

op ldrsw_xxxu( 0b10111000101[11] : rm[5] : 0b011[3] : s[1] : 0b10[2] : rn[5] : rt[5] );
ldrsw_xxxu.var format : {char const*} = {"base,1664"}, shift : {uint8_t} = {s*2};

ldrsw_xxxu.disasm = {
  sink << "ldrsw\t" << DisasmGZXR(rt) << ", [" << DisasmGSXR(rn) << "," << DisasmGZXR(rm) << DisasmINZ(",lsl ",shift) << "]";
};

ldrsw_xxxu.execute = {
  typedef typename ARCH::S32 S32;
  typedef typename ARCH::S64 S64;
  typedef typename ARCH::U64 U64;

  U64 offset( U64(U64(cpu.GetGZR(rm))) << shift ), addr( cpu.GetGSR(rn) + offset );
  U64 data( S64(S32(cpu.MemRead32(addr))) );
  cpu.SetGZR(rt, data);
};

op ldrsw_xxws( 0b10111000101[11] : rm[5] : 0b110[3] : s[1] : 0b10[2] : rn[5] : rt[5] );
ldrsw_xxws.var shift : {uint8_t} = {s*2}, format : {char const*} = {"base,642"};

ldrsw_xxws.disasm = {
  sink << "ldrsw\t" << DisasmGZXR(rt) << ", [" << DisasmGSXR(rn) << "," << DisasmGZWR(rm) << ",sxtw" << DisasmINZ(" ", shift) << "]";
};

ldrsw_xxws.execute = {
  typedef typename ARCH::S32 S32;
  typedef typename ARCH::S64 S64;
  typedef typename ARCH::U64 U64;

  U64 offset( S64(S32(cpu.GetGZR(rm))) << shift ), addr( cpu.GetGSR(rn) + offset );
  U64 data( S64(S32(cpu.MemRead32(addr))) );
  cpu.SetGZR(rt, data);
};

op ldrsw_xxxs( 0b10111000101[11] : rm[5] : 0b111[3] : s[1] : 0b10[2] : rn[5] : rt[5] );
ldrsw_xxxs.var shift : {uint8_t} = {s*2}, format : {char const*} = {"base,652"};

ldrsw_xxxs.disasm = {
  sink << "ldrsw\t" << DisasmGZXR(rt) << ", [" << DisasmGSXR(rn) << "," << DisasmGZXR(rm) << ",sxtx" << DisasmINZ(" ", shift) << "]";
};

ldrsw_xxxs.execute = {
  typedef typename ARCH::S32 S32;
  typedef typename ARCH::S64 S64;
  typedef typename ARCH::U64 U64;

  U64 offset( S64(S64(cpu.GetGZR(rm))) << shift ), addr( cpu.GetGSR(rn) + offset );
  U64 data( S64(S32(cpu.MemRead32(addr))) );
  cpu.SetGZR(rt, data);
};

/*
 * end of LDRSW (register)
 *******************************************************************/

op ldtr_wbo( 0b10111000010[11] : sext imm[9] : 0b10[2] : rn[5] : rt[5] );
ldtr_wbo.var format : {char const*} = {"base,297"};

ldtr_wbo.disasm = {
  sink << "ldtr\t" << DisasmGZWR(rt) << ", [" << DisasmGSXR(rn) << "," << DisasmI(imm) << "]";
};

op ldtr_xbo( 0b11111000010[11] : sext imm[9] : 0b10[2] : rn[5] : rt[5] );
ldtr_xbo.var format : {char const*} = {"base,334"};

ldtr_xbo.disasm = {
  sink << "ldtr\t" << DisasmGZXR(rt) << ", [" << DisasmGSXR(rn) << "," << DisasmI(imm) << "]";
};

op ldtrb_wbo( 0b00111000010[11] : sext imm[9] : 0b10[2] : rn[5] : rt[5] );
ldtrb_wbo.var format : {char const*} = {"base,298"};

ldtrb_wbo.disasm = {
  sink << "ldtrb\t" << DisasmGZWR(rt) << ", [" << DisasmGSXR(rn) << "," << DisasmI(imm) << "]";
};

op ldtrh_wbo( 0b01111000010[11] : sext imm[9] : 0b10[2] : rn[5] : rt[5] );
ldtrh_wbo.var format : {char const*} = {"base,299"};

ldtrh_wbo.disasm = {
  sink << "ldtrh\t" << DisasmGZWR(rt) << ", [" << DisasmGSXR(rn) << "," << DisasmI(imm) << "]";
};

op ldtrsb_wbo( 0b00111000110[11] : sext imm[9] : 0b10[2] : rn[5] : rt[5] );
ldtrsb_wbo.var format : {char const*} = {"base,300"};

ldtrsb_wbo.disasm = {
  sink << "ldtrsb\t" << DisasmGZWR(rt) << ", [" << DisasmGSXR(rn) << "," << DisasmI(imm) << "]";
};

op ldtrsb_xbo( 0b00111000100[11] : sext imm[9] : 0b10[2] : rn[5] : rt[5] );
ldtrsb_xbo.var format : {char const*} = {"base,335"};

ldtrsb_xbo.disasm = {
  sink << "ldtrsb\t" << DisasmGZXR(rt) << ", [" << DisasmGSXR(rn) << "," << DisasmI(imm) << "]";
};

op ldtrsh_wbo( 0b01111000110[11] : sext imm[9] : 0b10[2] : rn[5] : rt[5] );
ldtrsh_wbo.var format : {char const*} = {"base,301"};

ldtrsh_wbo.disasm = {
  sink << "ldtrsh\t" << DisasmGZWR(rt) << ", [" << DisasmGSXR(rn) << "," << DisasmI(imm) << "]";
};

op ldtrsh_xbo( 0b01111000100[11] : sext imm[9] : 0b10[2] : rn[5] : rt[5] );
ldtrsh_xbo.var format : {char const*} = {"base,336"};

ldtrsh_xbo.disasm = {
  sink << "ldtrsh\t" << DisasmGZXR(rt) << ", [" << DisasmGSXR(rn) << "," << DisasmI(imm) << "]";
};

op ldtrsw_xbo( 0b10111000100[11] : sext imm[9] : 0b10[2] : rn[5] : rt[5] );
ldtrsw_xbo.var format : {char const*} = {"base,337"};

ldtrsw_xbo.disasm = {
  sink << "ldtrsw\t" << DisasmGZXR(rt) << ", [" << DisasmGSXR(rn) << "," << DisasmI(imm) << "]";
};

/*******************************************************************
 * LDUR
 *
 * Load register (unscaled offset)
 */

op ldur_wbo( 0b10111000010[11] : sext imm[9] : 0b00[2] : rn[5] : rt[5] );
ldur_wbo.var format : {char const*} = {"base,295"};

ldur_wbo.disasm = {
  sink << "ldr\t" << DisasmGZWR(rt) << ", [" << DisasmGSXR(rn) << "," << DisasmI(imm) << "]";
};

ldur_wbo.execute = {
  typedef typename ARCH::U32 U32;
  typedef typename ARCH::U64 U64;
  typedef typename ARCH::S64 S64;
  
  U64 addr( cpu.GetGSR(rn) + U64(S64(imm)) );
  U32 data( cpu.MemRead32(addr) );
  cpu.SetGZR(rt, data);
};

op ldur_xbo( 0b11111000010[11] : sext imm[9] : 0b00[2] : rn[5] : rt[5] );
ldur_xbo.var format : {char const*} = {"base,332"};

ldur_xbo.disasm = {
  sink << "ldr\t" << DisasmGZXR(rt) << ", [" << DisasmGSXR(rn) << "," << DisasmI(imm) << "]";
};

ldur_xbo.execute = {
  typedef typename ARCH::U64 U64;
  typedef typename ARCH::S64 S64;
  
  U64 addr( cpu.GetGSR(rn) + U64(S64(imm)) );
  U64 data( cpu.MemRead64(addr) );
  cpu.SetGZR(rt, data);
};

/*
 * end of LDUR
 *******************************************************************/

/*******************************************************************
 * LDURB
 *
 * Load register byte (unscaled offset)
 */

op ldurb_wbo( 0b00111000010[11] : sext imm[9] : 0b00[2] : rn[5] : rt[5] );
ldurb_wbo.var format : {char const*} = {"base,305"};

ldurb_wbo.disasm = {
  sink << "ldrb\t" << DisasmGZWR(rt) << ", [" << DisasmGSXR(rn) << "," << DisasmI(imm) << "]";
};

ldurb_wbo.execute = {
  typedef typename ARCH::U8 U8;
  typedef typename ARCH::U64 U64;
  typedef typename ARCH::S64 S64;
  
  U64 addr( cpu.GetGSR(rn) + U64(S64(imm)) );
  U8 data( cpu.MemRead8(addr) );
  cpu.SetGZR(rt, data);
};

/*
 * end of LDURB
 *******************************************************************/

/*******************************************************************
 * LDURH
 *
 * Load register halfword (unscaled offset)
 */

op ldurh_wbo( 0b01111000010[11] : sext imm[9] : 0b00[2] : rn[5] : rt[5] );
ldurh_wbo.var format : {char const*} = {"base,308"};

ldurh_wbo.disasm = {
  sink << "ldrh\t" << DisasmGZWR(rt) << ", [" << DisasmGSXR(rn) << "," << DisasmI(imm) << "]";
};

ldurh_wbo.execute = {
  typedef typename ARCH::U16 U16;
  typedef typename ARCH::U64 U64;
  typedef typename ARCH::S64 S64;
  
  U64 addr( cpu.GetGSR(rn) + U64(S64(imm)) );
  U16 data( cpu.MemRead16(addr) );
  cpu.SetGZR(rt, data);
};

/*
 * end of LDURH
 *******************************************************************/

/*******************************************************************
 * LDURSB
 *
 * Load register signed byte (unscaled offset)
 */

op ldursb_wbo( 0b00111000110[11] : sext imm[9] : 0b00[2] : rn[5] : rt[5] );
ldursb_wbo.var format : {char const*} = {"base,306"};

ldursb_wbo.disasm = {
  sink << "ldrsb\t" << DisasmGZWR(rt) << ", [" << DisasmGSXR(rn) << "," << DisasmI(imm) << "]";
};

ldursb_wbo.execute = {
  typedef typename ARCH::S8  S8;
  typedef typename ARCH::S32 S32;
  typedef typename ARCH::U32 U32;
  typedef typename ARCH::U64 U64;
  typedef typename ARCH::S64 S64;
  
  U64 addr( cpu.GetGSR(rn) + U64(S64(imm)) );
  S8 data( cpu.MemRead8(addr) );
  cpu.SetGZR(rt, U32(S32(data)));
};

op ldursb_xbo( 0b00111000100[11] : sext imm[9] : 0b00[2] : rn[5] : rt[5] );
ldursb_xbo.var format : {char const*} = {"base,339"};

ldursb_xbo.disasm = {
  sink << "ldrsb\t" << DisasmGZXR(rt) << ", [" << DisasmGSXR(rn) << "," << DisasmI(imm) << "]";
};

ldursb_xbo.execute = {
  typedef typename ARCH::S8  S8;
  typedef typename ARCH::S64 S64;
  typedef typename ARCH::U64 U64;
  
  U64 addr( cpu.GetGSR(rn) + U64(S64(imm)) );
  S8 data( cpu.MemRead8(addr) );
  cpu.SetGZR(rt, U64(S64(data)));
};

/*
 * end of LDURSB
 *******************************************************************/

/*******************************************************************
 * LDURSH
 *
 * Load register signed halfword (unscaled offset)
 */

op ldursh_wbo( 0b01111000110[11] : sext imm[9] : 0b00[2] : rn[5] : rt[5] );
ldursh_wbo.var format : {char const*} = {"base,309"};

ldursh_wbo.disasm = {
  sink << "ldrsh\t" << DisasmGZWR(rt) << ", [" << DisasmGSXR(rn) << "," << DisasmI(imm) << "]";
};

ldursh_wbo.execute = {
  typedef typename ARCH::S16 S16;
  typedef typename ARCH::S32 S32;
  typedef typename ARCH::U32 U32;
  typedef typename ARCH::U64 U64;
  typedef typename ARCH::S64 S64;
  
  U64 addr( cpu.GetGSR(rn) + U64(S64(imm)) );
  S16 data( cpu.MemRead16(addr) );
  cpu.SetGZR(rt, U32(S32(data)));
};

op ldursh_xbo( 0b01111000100[11] : sext imm[9] : 0b00[2] : rn[5] : rt[5] );
ldursh_xbo.var format : {char const*} = {"base,340"};

ldursh_xbo.disasm = {
  sink << "ldrsh\t" << DisasmGZXR(rt) << ", [" << DisasmGSXR(rn) << "," << DisasmI(imm) << "]";
};

ldursh_xbo.execute = {
  typedef typename ARCH::S16 S16;
  typedef typename ARCH::S64 S64;
  typedef typename ARCH::U64 U64;
  
  U64 addr( cpu.GetGSR(rn) + U64(S64(imm)) );
  S16 data( cpu.MemRead16(addr) );
  cpu.SetGZR(rt, U64(S64(data)));
};

/*
 * end of LDURSH
 *******************************************************************/

/*******************************************************************
 * LDURSW
 * Load register signed word (unscaled offset)
 */

op ldursw_xbo( 0b10111000100[11] : sext imm[9] : 0b00[2] : rn[5] : rt[5] );
ldursw_xbo.var format : {char const*} = {"base,331"};

ldursw_xbo.disasm = {
  sink << "ldrsw\t" << DisasmGZXR(rt) << ", [" << DisasmGSXR(rn) << "," << DisasmI(imm) << "]";
};

ldursw_xbo.execute = {
  typedef typename ARCH::S32  S32;
  typedef typename ARCH::S64 S64;
  typedef typename ARCH::U64 U64;
  
  U64 addr( cpu.GetGSR(rn) + U64(S64(imm)) );
  S32 data( cpu.MemRead32(addr) );
  cpu.SetGZR(rt, U64(S64(data)));
};

/*
 * end of LDURSW
 *******************************************************************/

/*******************************************************************
 * LDXP
 *
 * Load exclusive pair of registers
 */

op ldxp_w( 0b10001000011[11] : rs[5] : 0b0[1] : rt2[5] : rn[5] : rt[5] );
ldxp_w.var format : {char const*} = {"base,221"};

ldxp_w.disasm = {
  sink << "ldxp\t" << DisasmGZWR(rt) << ", " << DisasmGZWR(rt2) << ", [" << DisasmGSXR(rn) << "]";
};

ldxp_w.execute = {
  typedef typename ARCH::U32 U32;
  typedef typename ARCH::U64 U64;
  
  U64 addr( cpu.GetGSR(rn) );
  cpu.SetExclusiveMonitors( addr, 8 );
  U32 data0( cpu.MemRead32( addr + U64(0) ) ),
      data1( cpu.MemRead32( addr + U64(4) ) );
  cpu.SetGZR(rt,  data0);
  cpu.SetGZR(rt2, data1);
};

op ldxp_x( 0b11001000011[11] : rs[5] : 0b0[1] : rt2[5] : rn[5] : rt[5] );
ldxp_x.var format : {char const*} = {"base,244"};

ldxp_x.disasm = {
  sink << "ldxp\t" << DisasmGZXR(rt) << ", " << DisasmGZXR(rt2) << ", [" << DisasmGSXR(rn) << "]";
};

ldxp_x.execute = {
  typedef typename ARCH::U64 U64;
  
  U64 addr( cpu.GetGSR(rn) );
  cpu.SetExclusiveMonitors( addr, 16 );
  U64 data0( cpu.MemRead64( addr + U64(0) ) ),
      data1( cpu.MemRead64( addr + U64(8) ) );
  cpu.SetGZR(rt,  data0);
  cpu.SetGZR(rt2, data1);
};

/*
 * end of LDXP
 *******************************************************************/

/*******************************************************************
 * LDXR
 *
 * Load exclusive register
 */

op ldxr_w( 0b10001000010[11] : rs[5] : 0b0[1] : rt2[5] : rn[5] : rt[5] );
ldxr_w.var format : {char const*} = {"base,229"};

ldxr_w.disasm = {
  sink << "ldxr\t" << DisasmGZWR(rt) << ", [" << DisasmGSXR(rn) << "]";
};

ldxr_w.execute = {
  typedef typename ARCH::U64 U64;

  U64 addr = cpu.GetGSR(rn);
  cpu.SetExclusiveMonitors( addr, 4 );
  cpu.SetGZR(rt, cpu.MemRead32( addr ));
};

op ldxr_x( 0b11001000010[11] : rs[5] : 0b0[1] : rt2[5] : rn[5] : rt[5] );
ldxr_x.var format : {char const*} = {"base,246"};

ldxr_x.disasm = {
  sink << "ldxr\t" << DisasmGZXR(rt) << ", [" << DisasmGSXR(rn) << "]";
};

ldxr_x.execute = {
  typedef typename ARCH::U64 U64;

  U64 addr = cpu.GetGSR(rn);
  cpu.SetExclusiveMonitors( addr, 8 );
  cpu.SetGZR(rt, cpu.MemRead64( addr ));
};

/*
 * end of LDXR
 *******************************************************************/

/*******************************************************************
 * LDXRB
 * Load exclusive register byte
 */

op ldxrb_w( 0b00001000010[11] : rs[5] : 0b0[1] : rt2[5] : rn[5] : rt[5] );
ldxrb_w.var format : {char const*} = {"base,230"};

ldxrb_w.disasm = {
  sink << "ldxrb\t" << DisasmGZWR(rt) << ", [" << DisasmGSXR(rn) << "]";
};

ldxrb_w.execute = {
  typedef typename ARCH::U64 U64;

  U64 addr = cpu.GetGSR(rn);
  cpu.SetExclusiveMonitors( addr, 1 );
  cpu.SetGZR(rt, U64(cpu.MemRead8( addr )));
};

/*
 * end of LDXRB
 *******************************************************************/

/*******************************************************************
 * LDXRH
 *
 * Load exclusive register halfword
 */

op ldxrh_w( 0b01001000010[11] : rs[5] : 0b0[1] : rt2[5] : rn[5] : rt[5] );
ldxrh_w.var format : {char const*} = {"base,231"};

ldxrh_w.disasm = {
  sink << "ldxrh\t" << DisasmGZWR(rt) << ", [" << DisasmGSXR(rn) << "]";
};

ldxrh_w.execute = {
  typedef typename ARCH::U64 U64;

  U64 addr = cpu.GetGSR(rn);
  cpu.SetExclusiveMonitors( addr, 2 );
  cpu.SetGZR(rt, U64(cpu.MemRead16( addr )));
};

/*
 * end of LDXRH
 *******************************************************************/

/*******************************************************************
 * LSL (register)
 *
 * Logical shift left (register): Rd = LSL(Rn, Rm)
 */

op lsl_www( 0b00011010110[11] : rm[5] : 0b001000[6] : rn[5] : rd[5] );
lsl_www.var format : {char const*} = {"base,1467"};

lsl_www.disasm = {
  sink << "lsl\t" << DisasmGZWR(rd) << ", " << DisasmGZWR(rn) << ", " << DisasmGZWR(rm);
};

lsl_www.execute = {
  typedef typename ARCH::U32 U32;
  
  U32 op1( cpu.GetGZR(rn) ), op2( cpu.GetGZR(rm) ), res( op1 << (op2 & U32(0b11111)) );
  cpu.SetGZR(rd, res);
};

op lsl_xxx( 0b10011010110[11] : rm[5] : 0b001000[6] : rn[5] : rd[5] );
lsl_xxx.var format : {char const*} = {"base,1615"};

lsl_xxx.disasm = {
  sink << "lsl\t" << DisasmGZXR(rd) << ", " << DisasmGZXR(rn) << ", " << DisasmGZXR(rm);
};

lsl_xxx.execute = {
  typedef typename ARCH::U64 U64;
  
  U64 op1( cpu.GetGZR(rn) ), op2( cpu.GetGZR(rm) ), res( op1 << (op2 & U64(0b111111)) );
  cpu.SetGZR(rd, res);
};

/*
 * end of LSL (register)
 *******************************************************************/

/*******************************************************************
 * LSR (register)
 *
 * Logical shift right (register) : Rd = LSR(Rn, Rm)
 */

op lsr_www( 0b00011010110[11] : rm[5] : 0b001001[6] : rn[5] : rd[5] );
lsr_www.var format : {char const*} = {"base,1468"};

lsr_www.disasm = {
  sink << "lsr\t" << DisasmGZWR(rd) << ", " << DisasmGZWR(rn) << ", " << DisasmGZWR(rm);
};

lsr_www.execute = {
  typedef typename ARCH::U32 U32;
  
  U32 op1( cpu.GetGZR(rn) ), op2( cpu.GetGZR(rm) ), res( op1 >> (op2 & U32(0b11111)) );
  cpu.SetGZR(rd, res);
};

op lsr_xxx( 0b10011010110[11] : rm[5] : 0b001001[6] : rn[5] : rd[5] );
lsr_xxx.var format : {char const*} = {"base,1616"};

lsr_xxx.disasm = {
  sink << "lsr\t" << DisasmGZXR(rd) << ", " << DisasmGZXR(rn) << ", " << DisasmGZXR(rm);
};

lsr_xxx.execute = {
  typedef typename ARCH::U64 U64;
  
  U64 op1( cpu.GetGZR(rn) ), op2( cpu.GetGZR(rm) ), res( op1 >> (op2 & U64(0b111111)) );
  cpu.SetGZR(rd, res);
};

/*
 * end of LSR (register)
 *******************************************************************/

/*******************************************************************
 * MADD
 *
 * Multiply-add: Rd = Ra + Rn * Rm
 */

op madd_w( 0b00011011000[11] : rm[5] : 0b0[1] : ra[5] : rn[5] : rd[5] );
madd_w.var format : {char const*} = {"base,166"};

madd_w.disasm = {
  if (ra == 31)
    sink << "mul\t" << DisasmGZWR(rd) << ", " << DisasmGZWR(rn) << ", " << DisasmGZWR(rm);
  else
    sink << "madd\t" << DisasmGZWR(rd) << ", " << DisasmGZWR(rn) << ", " << DisasmGZWR(rm) << ", " << DisasmGZWR(ra);
};

madd_w.execute = {
  typedef typename ARCH::U32 U32;
  
  U32 op1( cpu.GetGZR(rn) ), op2( cpu.GetGZR(rm) ), acc( cpu.GetGZR(ra) ), res( acc + op1*op2 );
  cpu.SetGZR(rd, res);
};

op madd_x( 0b10011011000[11] : rm[5] : 0b0[1] : ra[5] : rn[5] : rd[5] );
madd_x.var format : {char const*} = {"base,241"};

madd_x.disasm = {
  if (ra == 31)
    sink << "mul\t" << DisasmGZXR(rd) << ", " << DisasmGZXR(rn) << ", " << DisasmGZXR(rm);
  else
    sink << "madd\t" << DisasmGZXR(rd) << ", " << DisasmGZXR(rn) << ", " << DisasmGZXR(rm) << ", " << DisasmGZXR(ra);
};

madd_x.execute = {
  typedef typename ARCH::U64 U64;
  
  U64 op1( cpu.GetGZR(rn) ), op2( cpu.GetGZR(rm) ), res( cpu.GetGZR(ra) + op1*op2 );
  cpu.SetGZR(rd, res);
};

/*
 * end of MADD
 *******************************************************************/

/*******************************************************************
 * MOV (immediate)
 * MOVZ|MOVN compound
 *
 * Move immediate to register: Rd = imm
 */

op mov_wi( 0b0[1] : sext n[1] : 0b01001010[8] : shl<4> shift[1] : imm0[16] : rd[5] );
mov_wi.var imm : {uint32_t} = {(uint32_t(imm0) << shift)^~int32_t(n)}, format : {char const*} = {"base,19"};

mov_wi.disasm = {
  sink << "mov\t" << DisasmGZWR(rd) << ", " << DisasmI(imm,16);
};

mov_wi.execute = {
  cpu.SetGZR(rd, typename ARCH::U64(imm));
};

op mov_xi( 0b1[1] : sext n[1] : 0b0100101[7] : shl<4> shift[2] : imm0[16] : rd[5] );
mov_xi.var imm : {uint64_t} = {(uint64_t(imm0) << shift)^~int64_t(n)}, format : {char const*} = {"base,7"};

mov_xi.disasm = {
  sink << "mov\t" << DisasmGZXR(rd) << ", " << DisasmI(imm,16);
};

mov_xi.execute = {
  cpu.SetGZR(rd, typename ARCH::U64(imm));
};

/*
 * end of MOV (immediate)
 *******************************************************************/

/*******************************************************************
 * MOVK
 *
 * Move 16-bit immediate into register, keeping other bits unchanged: Rd<shift+15:shift> = imm16
 */

op movk_w( 0b0111001010[10] : shl<4> shift[1] : imm[16] : rd[5] );
movk_w.var format : {char const*} = {"base,69"};

movk_w.disasm = {
  sink << "movk\t" << DisasmGZWR(rd) << ", " << DisasmI(imm,16) << DisasmINZ(", lsl ",shift);
};

movk_w.execute = {
  typedef typename ARCH::U32 U32;
  
  U32 src( cpu.GetGZR(rd) ), mask( ~(uint32_t(0xffff) << shift) ), res( (src & mask) | (U32(imm) << shift) );
  cpu.SetGZR(rd, res);
};

op movk_x( 0b111100101[9] : shl<4> shift[2] : imm[16] : rd[5] );
movk_x.var format : {char const*} = {"base,25"};

movk_x.disasm = {
  sink << "movk\t" << DisasmGZXR(rd) << ", " << DisasmI(imm,16) << DisasmINZ(", lsl ",shift);
};

movk_x.execute = {
  typedef typename ARCH::U64 U64;
  
  U64 src( cpu.GetGZR(rd) ), mask( ~(uint64_t(0xffff) << shift) ), res( (src & mask) | (U64(imm) << shift) );
  cpu.SetGZR(rd, res);
};

/*
 * end of MOVK
 *******************************************************************/

/*******************************************************************
 * MRS
 *
 * Move from system register
 */

op mrs_reg( 0b110101010011[12] : o0[1] : op1[3] : crn[4] : crm[4] : op2[3] : rt[5] );
mrs_reg.var format : {char const*} = {"base,249"};

mrs_reg.disasm = {
  sink << "mrs\t" << DisasmGZXR(rt) << ", ";
  cpu.NameSystemRegister( 2+o0, op1, crn, crm, op2, sink );
  sink << "\t; ";
  cpu.DescribeSystemRegister( 2+o0, op1, crn, crm, op2, sink );
};

mrs_reg.execute = {
  cpu.CheckSystemAccess(op1);
  typename ARCH::U64 src( cpu.ReadSystemRegister( 2+o0, op1, crn, crm, op2 ) );
  cpu.SetGZR(rt, src);
};

/*
 * end of MRS
 *******************************************************************/

/*******************************************************************
 * MSR (immediate)
 *
 * Move immediate to processor state field
 */

op msr_imm( 0b1101010100000[13] : op1[3] : 0b0100[4] : imm[4] : op2[3] : rt[5] );
msr_imm.var format : {char const*} = {"base,1794"};

msr_imm.disasm = {
  sink << "msr\t<pstatefield>" << DisasmI(imm);
};

/*
 * end of MSR (immediate)
 *******************************************************************/

/*******************************************************************
 * MSR (register)
 *
 * Move to system register
 */

op msr_reg( 0b110101010001[12] : o0[1] : op1[3] : crn[4] : crm[4] : op2[3] : rt[5] );
msr_reg.var format : {char const*} = {"base,248"};

msr_reg.disasm = {
  sink << "msr\t";
  cpu.NameSystemRegister( 2+o0, op1, crn, crm, op2, sink );
  sink << ", " << DisasmGZXR(rt) << "\t; ";
  cpu.DescribeSystemRegister( 2+o0, op1, crn, crm, op2, sink );
};

msr_reg.execute = {
  cpu.CheckSystemAccess(op1);
  typename ARCH::U64 src( cpu.GetGZR(rt) );
  cpu.WriteSystemRegister( 2+o0, op1, crn, crm, op2, src );
};

/*
 * end of MSR (register)
 *******************************************************************/

/*******************************************************************
 * MSUB
 *
 * Multiply-subtract: Rd = Ra - Rn * Rm
 */

op msub_w( 0b00011011000[11] : rm[5] : 0b1[1] : ra[5] : rn[5] : rd[5] );
msub_w.var format : {char const*} = {"base,167"};

msub_w.disasm = {
  if (ra == 31)
    sink << "mneg\t" << DisasmGZWR(rd) << ", " << DisasmGZWR(rn) << ", " << DisasmGZWR(rm);
  else
    sink << "msub\t" << DisasmGZWR(rd) << ", " << DisasmGZWR(rn) << ", " << DisasmGZWR(rm) << ", " << DisasmGZWR(ra);
};

msub_w.execute = {
  typedef typename ARCH::U32 U32;
  
  U32 op1( cpu.GetGZR(rn) ), op2( cpu.GetGZR(rm) ), acc( cpu.GetGZR(ra) ), res( acc - op1*op2 );
  cpu.SetGZR(rd, res);
};

op msub_x( 0b10011011000[11] : rm[5] : 0b1[1] : ra[5] : rn[5] : rd[5] );
msub_x.var format : {char const*} = {"base,242"};

msub_x.disasm = {
  if (ra == 31)
    sink << "mneg\t" << DisasmGZXR(rd) << ", " << DisasmGZXR(rn) << ", " << DisasmGZXR(rm);
  else
    sink << "msub\t" << DisasmGZXR(rd) << ", " << DisasmGZXR(rn) << ", " << DisasmGZXR(rm) << ", " << DisasmGZXR(ra);
};

msub_x.execute = {
  typedef typename ARCH::U64 U64;
  
  U64 op1( cpu.GetGZR(rn) ), op2( cpu.GetGZR(rm) ), res( cpu.GetGZR(ra) - op1*op2 );
  cpu.SetGZR(rd, res);
};

/*
 * end of MSUB
 *******************************************************************/

/*******************************************************************
 * NOP
 *
 * No operation
 */

op nop( 0b11010101000000110010000000011111[32] );
nop.var format : {char const*} = {"base,2948"};

nop.disasm = {
  sink << "nop";
};

/*
 * end of NOP
 *******************************************************************/

/*******************************************************************
 * ORN (shifted register)
 *
 * Bitwise inclusive OR NOT (shifted register): Rd = Rn OR NOT shift(Rm, amount)
 */

op orn_wlsl( 0b00101010001[11] : rm[5] : 0b0[1] : imm[5] : rn[5] : rd[5] );
orn_wlsl.var format : {char const*} = {"base,185"};

orn_wlsl.disasm = {
  if (rn == 31)
    sink << "mvn\t" << DisasmGZWR(rd) << ", " << DisasmGZWR(rm) << DisasmINZ(", lsl ",imm);
  else
    sink << "orn\t" << DisasmGZWR(rd) << ", " << DisasmGZWR(rn) << ", " << DisasmGZWR(rm) << DisasmINZ(", lsl ",imm);
};

orn_wlsl.execute = {
  typedef typename ARCH::U32 U32;
  
  U32 op1( cpu.GetGZR(rn) ), op2( cpu.GetGZR(rm) << imm ), res = op1 | ~op2;
  cpu.SetGZR(rd, res);
};

op orn_wlsr( 0b00101010011[11] : rm[5] : 0b0[1] : imm[5] : rn[5] : rd[5] );
orn_wlsr.var format : {char const*} = {"base,200"};

orn_wlsr.disasm = {
  if (rn == 31)
    sink << "mvn\t" << DisasmGZWR(rd) << ", " << DisasmGZWR(rm) << ", lsr " << DisasmI(imm);
  else
    sink << "orn\t" << DisasmGZWR(rd) << ", " << DisasmGZWR(rn) << ", " << DisasmGZWR(rm) << ", lsr " << DisasmI(imm);
};

orn_wlsr.execute = {
  typedef typename ARCH::U32 U32;
  
  U32 op1( cpu.GetGZR(rn) ), op2( cpu.GetGZR(rm) >> imm ), res = op1 | ~op2;
  cpu.SetGZR(rd, res);
};

op orn_wasr( 0b00101010101[11] : rm[5] : 0b0[1] : imm[5] : rn[5] : rd[5] );
orn_wasr.var format : {char const*} = {"base,176"};

orn_wasr.disasm = {
  if (rn == 31)
    sink << "mvn\t" << DisasmGZWR(rd) << ", " << DisasmGZWR(rm) << ", asr " << DisasmI(imm);
  else
    sink << "orn\t" << DisasmGZWR(rd) << ", " << DisasmGZWR(rn) << ", " << DisasmGZWR(rm) << ", asr " << DisasmI(imm);
};

orn_wasr.execute = {
  typedef typename ARCH::U32 U32;
  typedef typename ARCH::S32 S32;
  
  U32 op1( cpu.GetGZR(rn) ), op2( S32(cpu.GetGZR(rm)) >> imm ), res = op1 | ~op2;
  cpu.SetGZR(rd, res);
};

op orn_wror( 0b00101010111[11] : rm[5] : 0b0[1] : imm[5] : rn[5] : rd[5] );
orn_wror.var format : {char const*} = {"base,211"};

orn_wror.disasm = {
  if (rn == 31)
    sink << "mvn\t" << DisasmGZWR(rd) << ", " << DisasmGZWR(rm) << ", ror " << DisasmI(imm);
  else
    sink << "orn\t" << DisasmGZWR(rd) << ", " << DisasmGZWR(rn) << ", " << DisasmGZWR(rm) << ", ror " << DisasmI(imm);
};

orn_wror.execute = {
  typedef typename ARCH::U32 U32;
  
  U32 op1( cpu.GetGZR(rn) ), op2( RotateRight(U32(cpu.GetGZR(rm)), imm) ), res = op1 | ~op2;
  cpu.SetGZR(rd, res);
};

op orn_xlsl( 0b10101010001[11] : rm[5] : imm[6] : rn[5] : rd[5] );
orn_xlsl.var format : {char const*} = {"base,131"};

orn_xlsl.disasm = {
  if (rn == 31)
    sink << "mvn\t" << DisasmGZXR(rd) << ", " << DisasmGZXR(rm) << DisasmINZ(", lsl ",imm);
  else
    sink << "orn\t" << DisasmGZXR(rd) << ", " << DisasmGZXR(rn) << ", " << DisasmGZXR(rm) << DisasmINZ(", lsl ",imm);
};

orn_xlsl.execute = {
  typedef typename ARCH::U64 U64;
  
  U64 op1( cpu.GetGZR(rn) ), op2( cpu.GetGZR(rm) << imm ), res = op1 | ~op2;
  cpu.SetGZR(rd, res);
};

op orn_xlsr( 0b10101010011[11] : rm[5] : imm[6] : rn[5] : rd[5] );
orn_xlsr.var format : {char const*} = {"base,140"};

orn_xlsr.disasm = {
  if (rn == 31)
    sink << "mvn\t" << DisasmGZXR(rd) << ", " << DisasmGZXR(rm) << ", lsr " << DisasmI(imm);
  else
    sink << "orn\t" << DisasmGZXR(rd) << ", " << DisasmGZXR(rn) << ", " << DisasmGZXR(rm) << ", lsr " << DisasmI(imm);
};

orn_xlsr.execute = {
  typedef typename ARCH::U64 U64;
  
  U64 op1( cpu.GetGZR(rn) ), op2( cpu.GetGZR(rm) >> imm ), res = op1 | ~op2;
  cpu.SetGZR(rd, res);
};

op orn_xasr( 0b10101010101[11] : rm[5] : imm[6] : rn[5] : rd[5] );
orn_xasr.var format : {char const*} = {"base,116"};

orn_xasr.disasm = {
  if (rn == 31)
    sink << "mvn\t" << DisasmGZXR(rd) << ", " << DisasmGZXR(rm) << ", asr " << DisasmI(imm);
  else
    sink << "orn\t" << DisasmGZXR(rd) << ", " << DisasmGZXR(rn) << ", " << DisasmGZXR(rm) << ", asr " << DisasmI(imm);
};

orn_xasr.execute = {
  typedef typename ARCH::U64 U64;
  typedef typename ARCH::S64 S64;
  
  U64 op1( cpu.GetGZR(rn) ), op2( S64(cpu.GetGZR(rm)) >> imm ), res = op1 | ~op2;
  cpu.SetGZR(rd, res);
};

op orn_xror( 0b10101010111[11] : rm[5] : imm[6] : rn[5] : rd[5] );
orn_xror.var format : {char const*} = {"base,151"};

orn_xror.disasm = {
  if (rn == 31)
    sink << "mvn\t" << DisasmGZXR(rd) << ", " << DisasmGZXR(rm) << ", ror " << DisasmI(imm);
  else
    sink << "orn\t" << DisasmGZXR(rd) << ", " << DisasmGZXR(rn) << ", " << DisasmGZXR(rm) << ", ror " << DisasmI(imm);
};

orn_xror.execute = {
  typedef typename ARCH::U64 U64;
  
  U64 op1( cpu.GetGZR(rn) ), op2( RotateRight(U64(cpu.GetGZR(rm)), imm) ), res = op1 | ~op2;
  cpu.SetGZR(rd, res);
};

/*
 * end of ORN (shifted register)
 *******************************************************************/

/*******************************************************************
 * ORR (immediate)
 *
 * Bitwise inclusive OR (immediate): Rd = Rn OR imm
 */

op orr_wi( 0b0011001000[10] : immr[6] : imms[6] : rn[5] : rd[5] );
orr_wi.var imm : {uint32_t} = {DecodeBitMasks(0,imms,immr).wmask}, format : {char const*} = {"base,70"};

orr_wi.disasm = {
  if (rn == 31)
    sink << "mov\t" << DisasmGSWR(rd) << ", " << DisasmI(imm,16);
  else
    sink << "orr\t" << DisasmGSWR(rd) << ", " << DisasmGZWR(rn) << ", " << DisasmI(imm,16);
};

orr_wi.execute = {
  typedef typename ARCH::U32 U32;
  
  U32 op1(cpu.GetGZR(rn)), op2(imm), res = op1 | op2;
  cpu.SetGSR(rd, res);
};

op orr_xi( 0b101100100[9] : n[1] : immr[6] : imms[6] : rn[5] : rd[5] );
orr_xi.var imm : {uint64_t} = {DecodeBitMasks(n,imms,immr).wmask}, format : {char const*} = {"base,28"};

orr_xi.disasm = {
  if (rn == 31)
    sink << "mov\t" << DisasmGSXR(rd) << ", " << DisasmI(imm,16);
  else
    sink << "orr\t" << DisasmGSXR(rd) << ", " << DisasmGZXR(rn) << ", " << DisasmI(imm,16);
};

orr_xi.execute = {
  typedef typename ARCH::U64 U64;
  
  U64 op1(cpu.GetGZR(rn)), op2(imm), res = op1 | op2;
  cpu.SetGSR(rd, res);
};

/*
 * end of ORR (immediate)
 *******************************************************************/

/*******************************************************************
 * ORR (shifted register)
 *
 * Bitwise inclusive OR (shifted register): Rd = Rn OR shift(Rm, amount)
 */

op orr_wlsl( 0b00101010000[11] : rm[5] : 0b0[1] : imm[5] : rn[5] : rd[5] );
orr_wlsl.var format : {char const*} = {"base,193"};

orr_wlsl.disasm = {
  if (rn == 31)
    sink << "mov\t" << DisasmGZWR(rd) << ", " << DisasmGZWR(rm) << DisasmINZ(", lsl ",imm);
  else
    sink << "orr\t" << DisasmGZWR(rd) << ", " << DisasmGZWR(rn) << ", " << DisasmGZWR(rm) << DisasmINZ(", lsl ",imm);
};

orr_wlsl.execute = {
  typedef typename ARCH::U32 U32;
  
  U32 op1( cpu.GetGZR(rn) ), op2( cpu.GetGZR(rm) << imm ), res = op1 | op2;
  cpu.SetGZR(rd, res);
};

op orr_xlsl( 0b10101010000[11] : rm[5] : imm[6] : rn[5] : rd[5] );
orr_xlsl.var format : {char const*} = {"base,132"};

orr_xlsl.disasm = {
  if (rn == 31)
    sink << "mov\t" << DisasmGZXR(rd) << ", " << DisasmGZXR(rm) << DisasmINZ(", lsl ",imm);
  else
    sink << "orr\t" << DisasmGZXR(rd) << ", " << DisasmGZXR(rn) << ", " << DisasmGZXR(rm) << DisasmINZ(", lsl ",imm);
};

orr_xlsl.execute = {
  typedef typename ARCH::U64 U64;
  
  U64 op1( cpu.GetGZR(rn) ), op2( cpu.GetGZR(rm) << imm ), res = op1 | op2;
  cpu.SetGZR(rd, res);
};

op orr_wlsr( 0b00101010010[11] : rm[5] : 0b0[1] : imm[5] : rn[5] : rd[5] );
orr_wlsr.var format : {char const*} = {"base,203"};

orr_wlsr.disasm = {
  if (rn == 31)
    sink << "mov\t" << DisasmGZWR(rd) << ", " << DisasmGZWR(rm) << ", lsr " << DisasmI(imm);
  else
    sink << "orr\t" << DisasmGZWR(rd) << ", " << DisasmGZWR(rn) << ", " << DisasmGZWR(rm) << ", lsr " << DisasmI(imm);
};

orr_wlsr.execute = {
  typedef typename ARCH::U32 U32;
  
  U32 op1( cpu.GetGZR(rn) ), op2( cpu.GetGZR(rm) >> imm ), res = op1 | op2;
  cpu.SetGZR(rd, res);
};

op orr_xlsr( 0b10101010010[11] : rm[5] : imm[6] : rn[5] : rd[5] );
orr_xlsr.var format : {char const*} = {"base,143"};

orr_xlsr.disasm = {
  if (rn == 31)
    sink << "mov\t" << DisasmGZXR(rd) << ", " << DisasmGZXR(rm) << ", lsr " << DisasmI(imm);
  else
    sink << "orr\t" << DisasmGZXR(rd) << ", " << DisasmGZXR(rn) << ", " << DisasmGZXR(rm) << ", lsr " << DisasmI(imm);
};

orr_xlsr.execute = {
  typedef typename ARCH::U64 U64;
  
  U64 op1( cpu.GetGZR(rn) ), op2( cpu.GetGZR(rm) >> imm ), res = op1 | op2;
  cpu.SetGZR(rd, res);
};

op orr_wasr( 0b00101010100[11] : rm[5] : 0b0[1] : imm[5] : rn[5] : rd[5] );
orr_wasr.var format : {char const*} = {"base,179"};

orr_wasr.disasm = {
  if (rn == 31)
    sink << "mov\t" << DisasmGZWR(rd) << ", " << DisasmGZWR(rm) << ", asr " << DisasmI(imm);
  else
    sink << "orr\t" << DisasmGZWR(rd) << ", " << DisasmGZWR(rn) << ", " << DisasmGZWR(rm) << ", asr " << DisasmI(imm);
};

orr_wasr.execute = {
  typedef typename ARCH::U32 U32;
  typedef typename ARCH::S32 S32;
  
  U32 op1( cpu.GetGZR(rn) ), op2( S32(cpu.GetGZR(rm)) >> imm ), res = op1 | op2;
  cpu.SetGZR(rd, res);
};

op orr_xasr( 0b10101010100[11] : rm[5] : imm[6] : rn[5] : rd[5] );
orr_xasr.var format : {char const*} = {"base,119"};

orr_xasr.disasm = {
  if (rn == 31)
    sink << "mov\t" << DisasmGZXR(rd) << ", " << DisasmGZXR(rm) << ", asr " << DisasmI(imm);
  else
    sink << "orr\t" << DisasmGZXR(rd) << ", " << DisasmGZXR(rn) << ", " << DisasmGZXR(rm) << ", asr " << DisasmI(imm);
};

orr_xasr.execute = {
  typedef typename ARCH::U64 U64;
  typedef typename ARCH::S64 S64;
  
  U64 op1( cpu.GetGZR(rn) ), op2( S64(cpu.GetGZR(rm)) >> imm ), res = op1 | op2;
  cpu.SetGZR(rd, res);
};

op orr_wror( 0b00101010110[11] : rm[5] : 0b0[1] : imm[5] : rn[5] : rd[5] );
orr_wror.var format : {char const*} = {"base,212"};

orr_wror.disasm = {
  if (rn == 31)
    sink << "mov\t" << DisasmGZWR(rd) << ", " << DisasmGZWR(rm) << ", ror " << DisasmI(imm);
  else
    sink << "orr\t" << DisasmGZWR(rd) << ", " << DisasmGZWR(rn) << ", " << DisasmGZWR(rm) << ", ror " << DisasmI(imm);
};

orr_wror.execute = {
  typedef typename ARCH::U32 U32;
  
  U32 op1( cpu.GetGZR(rn) ), op2( RotateRight(U32(cpu.GetGZR(rm)), imm) ), res = op1 | op2;
  cpu.SetGZR(rd, res);
};

op orr_xror( 0b10101010110[11] : rm[5] : imm[6] : rn[5] : rd[5] );
orr_xror.var format : {char const*} = {"base,152"};

orr_xror.disasm = {
  if (rn == 31)
    sink << "mov\t" << DisasmGZXR(rd) << ", " << DisasmGZXR(rm) << ", ror " << DisasmI(imm);
  else
    sink << "orr\t" << DisasmGZXR(rd) << ", " << DisasmGZXR(rn) << ", " << DisasmGZXR(rm) << ", ror " << DisasmI(imm);
};

orr_xror.execute = {
  typedef typename ARCH::U64 U64;
  
  U64 op1( cpu.GetGZR(rn) ), op2( RotateRight(U64(cpu.GetGZR(rm)), imm) ), res = op1 | op2;
  cpu.SetGZR(rd, res);
};

/*
 * end of ORR (shifted register)
 *******************************************************************/

op prfm_lit( 0b11011000[8] : shl<2> sext imm[19] : rt[5] );
prfm_lit.var format : {char const*} = {"base,8"};

prfm_lit.disasm = {
  sink << "prfm\t" << DisasmI(rt,16) << ", 0x" << std::hex << (this->GetAddr()+imm);
};

op prfm_xi( 0b1111100110[10] : shl<3> imm[12] : rn[5] : rt[5] );
prfm_xi.var format : {char const*} = {"base,34"};

prfm_xi.disasm = {
  sink << "prfm\t" << DisasmI(rt,16) << ", [" << DisasmGSXR(rn) << "," << DisasmI(imm) << "]";
};

op prfm_xws( 0b11111000101[11] : rm[5] : 0b110[3] : s[1] : 0b10[2] : rn[5] : rt[5] );
prfm_xws.var shift : {uint8_t} = {s*3}, format : {char const*} = {"base,581"};

prfm_xws.disasm = {
  sink << "prfm\t" << DisasmI(rt,16) << ", [" << DisasmGSXR(rn) << "," << DisasmGZWR(rm) << ",sxtw" << DisasmINZ(" ", shift) << "]";
};

op prfm_xwu( 0b11111000101[11] : rm[5] : 0b010[3] : s[1] : 0b10[2] : rn[5] : rt[5] );
prfm_xwu.var shift : {uint8_t} = {s*3}, format : {char const*} = {"base,582"};

prfm_xwu.disasm = {
  sink << "prfm\t" << DisasmI(rt,16) << ", [" << DisasmGSXR(rn) << "," << DisasmGZWR(rm) << ",uxtw" << DisasmINZ(" ", shift) << "]";
};

op prfm_xxl( 0b11111000101[11] : rm[5] : 0b011[3] : s[1] : 0b10[2] : rn[5] : rt[5] );
prfm_xxl.var shift : {uint8_t} = {s*3}, format : {char const*} = {"base,583"};

prfm_xxl.disasm = {
  sink << "prfm\t" << DisasmI(rt,16) << ", [" << DisasmGSXR(rn) << "," << DisasmGZXR(rm) << DisasmINZ(",lsl ",shift) << "]";
};

op prfm_xxs( 0b11111000101[11] : rm[5] : 0b111[3] : s[1] : 0b10[2] : rn[5] : rt[5] );
prfm_xxs.var shift : {uint8_t} = {s*3}, format : {char const*} = {"base,584"};

prfm_xxs.disasm = {
  sink << "prfm\t" << DisasmI(rt,16) << ", [" << DisasmGSXR(rn) << "," << DisasmGZXR(rm) << ",sxtx" << DisasmINZ(" ", shift) << "]";
};

op prfum( 0b11111000100[11] : sext imm[9] : 0b00[2] : rn[5] : rt[5] );
prfum.var format : {char const*} = {"base,258"};

prfum.disasm = {
  sink << "prfum\t" << DisasmI(rt,16) << ", [" << DisasmGSXR(rn) << "," << DisasmI(imm) << "]";
};

/*******************************************************************
 * RBIT
 *
 * Reverse bit order
 */

op rbit_w( 0b0101101011000000000000[22] : rn[5] : rd[5] );
rbit_w.var format : {char const*} = {"base,2617"};

rbit_w.disasm = {
  sink << "rbit\t" << DisasmGZWR(rd) << ", " << DisasmGZWR(rn);
};

rbit_w.execute = {
  typedef typename ARCH::U32 U32;
  
  U32 res( cpu.GetGZR(rn) );
  uint32_t const masks[] = {0x55555555, 0x33333333, 0x0f0f0f0f, 0x00ff00ff, 0x0000ffff};
  
  for (unsigned i = 0; i < 5; ++i) {
    unsigned shift = (1<<i);
    U32 mask = U32(masks[i]);
    res = ((res >> shift) & mask) | ((res & mask) << shift);
  }
    
  cpu.SetGZR(rd, res);
};

op rbit_x( 0b1101101011000000000000[22] : rn[5] : rd[5] );
rbit_x.var format : {char const*} = {"base,2617"};

rbit_x.disasm = {
  sink << "rbit\t" << DisasmGZXR(rd) << ", " << DisasmGZXR(rn);
};

rbit_x.execute = {
  typedef typename ARCH::U64 U64;
  
  U64 res( cpu.GetGZR(rn) );
  uint64_t const masks[] = {0x5555555555555555ull, 0x3333333333333333ull, 0x0f0f0f0f0f0f0f0full, 0x00ff00ff00ff00ffull, 0x0000ffff0000ffffull, 0x00000000ffffffffull};
  
  for (unsigned i = 0; i < 5; ++i) {
    unsigned shift = (1<<i);
    U64 mask = U64(masks[i]);
    res = ((res >> shift) & mask) | ((res & mask) << shift);
  }
    
  cpu.SetGZR(rd, res);
};

/*
 * end of RBIT
 *******************************************************************/

/*******************************************************************
 * RET
 *
 * Return from subroutine, branches unconditionally to an address in a
 * register, with a hint that this is a subroutine return
 */

op ret( 0b1101011001011111000000[22] : rn[5] : 0b00000[5] );
ret.var format : {char const*} = {"base,2888"};

ret.disasm = {
  if (rn == 30)
    sink << "ret";
  else
    sink << "ret\t" << DisasmGZXR(rn);
};

ret.execute = {
  cpu.BranchTo( cpu.GetGZR(rn), ARCH::B_RET );
};

/*
 * end of RET
 *******************************************************************/

/*******************************************************************
 * REV
 *
 * Reverse bytes
 */

op rev_w( 0b0101101011000000000010[22] : rn[5] : rd[5] );
rev_w.var format : {char const*} = {"base,2618"};

rev_w.disasm = {
  sink << "rev\t" << DisasmGZWR(rd) << ", " << DisasmGZWR(rn);
};

rev_w.execute = {
  typedef typename ARCH::U32 U32;
  
  U32 const msk( 0xff );
  U32 src( cpu.GetGZR(rn) ), res( ((src << 24) & (msk << 24)) | ((src << 8) & (msk << 16)) | ((src >> 8) & (msk << 8)) | ((src >> 24) & (msk << 0)) );
  cpu.SetGZR(rd, res);
};

op rev_x( 0b1101101011000000000011[22] : rn[5] : rd[5] );
rev_x.var format : {char const*} = {"base,2653"};

rev_x.disasm = {
  sink << "rev\t" << DisasmGZXR(rd) << ", " << DisasmGZXR(rn);
};

rev_x.execute = {
  typedef typename ARCH::U64 U64;
  
  U64 const msk( 0xff );
  U64 src( cpu.GetGZR(rn) ), res( ((src << 56) & (msk << 56)) | ((src << 40) & (msk << 48)) | ((src << 24) & (msk << 40)) | ((src << 8) & (msk << 32)) | ((src >> 8) & (msk << 24)) | ((src >> 24) & (msk << 16)) | ((src >> 40) & (msk << 8)) | ((src >> 56) & (msk << 0)) );
  cpu.SetGZR(rd, res);
};

/*
 * end of REV
 *******************************************************************/

/*******************************************************************
 * REV16
 *
 * Reverse bytes in 16-bit halfwords
 */

op rev16_w( 0b0101101011000000000001[22] : rn[5] : rd[5] );
rev16_w.var format : {char const*} = {"base,2619"};

rev16_w.disasm = {
  sink << "rev16\t" << DisasmGZWR(rd) << ", " << DisasmGZWR(rn);
};

rev16_w.execute = {
  typedef typename ARCH::U32 U32;
  
  U32 res( cpu.GetGZR(rn) );
  uint32_t const masks[] = {0x00ff00ff};
  
  for (unsigned i = 0; i < 1; ++i) {
    unsigned shift = (8<<i);
    U32 mask = U32(masks[i]);
    res = ((res >> shift) & mask) | ((res & mask) << shift);
  }
    
  cpu.SetGZR(rd, res);
};

op rev16_x( 0b1101101011000000000001[22] : rn[5] : rd[5] );
rev16_x.var format : {char const*} = {"base,2651"};

rev16_x.disasm = {
  sink << "rev16\t" << DisasmGZXR(rd) << ", " << DisasmGZXR(rn);
};

rev16_x.execute = {
  typedef typename ARCH::U64 U64;
  
  U64 res( cpu.GetGZR(rn) );
  uint64_t const masks[] = {0x00ff00ff00ff00ffull};
  
  for (unsigned i = 0; i < 1; ++i) {
    unsigned shift = (8<<i);
    U64 mask = U64(masks[i]);
    res = ((res >> shift) & mask) | ((res & mask) << shift);
  }
    
  cpu.SetGZR(rd, res);
};

/*
 * end of REV16
 *******************************************************************/

/*******************************************************************
 * REV32
 *
 * Reverse bytes in 32-bit words
 */

op rev32_x( 0b1101101011000000000010[22] : rn[5] : rd[5] );
rev32_x.var format : {char const*} = {"base,2652"};

rev32_x.disasm = {
  sink << "rev32\t" << DisasmGZXR(rd) << ", " << DisasmGZXR(rn);
};

rev32_x.execute = {
  typedef typename ARCH::U64 U64;
  
  U64 res( cpu.GetGZR(rn) );
  uint64_t const masks[] = {0x00ff00ff00ff00ffull, 0x0000ffff0000ffffull};
  
  for (unsigned i = 0; i < 2; ++i) {
    unsigned shift = (8<<i);
    U64 mask = U64(masks[i]);
    res = ((res >> shift) & mask) | ((res & mask) << shift);
  }
    
  cpu.SetGZR(rd, res);
};

/*
 * end of REV32
 *******************************************************************/

/*******************************************************************
 * ROR (register)
 *
 * Rotate right (register): Rd = ROR(Rn, Rm)
 */

op ror_www( 0b00011010110[11] : rm[5] : 0b001011[6] : rn[5] : rd[5] );
ror_www.var format : {char const*} = {"base,1469"};

ror_www.disasm = {
  sink << "ror\t" << DisasmGZWR(rd) << ", " << DisasmGZWR(rn) << ", " << DisasmGZWR(rm);
};

ror_www.execute = {
  typedef typename ARCH::U32 U32;
  
  U32 op1( cpu.GetGZR(rn) ), op2( cpu.GetGZR(rm) ), res( RotateRight(op1, op2 & U32(0b11111)) );
  cpu.SetGZR(rd, res);
};

op ror_xxx( 0b10011010110[11] : rm[5] : 0b001011[6] : rn[5] : rd[5] );
ror_xxx.var format : {char const*} = {"base,1617"};

ror_xxx.disasm = {
  sink << "ror\t" << DisasmGZXR(rd) << ", " << DisasmGZXR(rn) << ", " << DisasmGZXR(rm);
};

ror_xxx.execute = {
  typedef typename ARCH::U64 U64;
  
  U64 op1( cpu.GetGZR(rn) ), op2( cpu.GetGZR(rm) ), res( RotateRight(op1, op2 & U64(0b111111)) );
  cpu.SetGZR(rd, res);
};

/*
 * end of ROR (register)
 *******************************************************************/

/*******************************************************************
 * SBC
 *
 * Subtract with carry: Rd = Rn - Rm - 1 + C
 */

op sbc_www( 0b01011010000[11] : rm[5] : 0b000000[6] : rn[5] : rd[5] );
sbc_www.var format : {char const*} = {"base,1472"};

sbc_www.disasm = {
  if (rn == 31)
    sink << "ngc\t" << DisasmGZWR(rd) << ", " << DisasmGZWR(rm);
  else
    sink << "sbc\t" << DisasmGZWR(rd) << ", " << DisasmGZWR(rn) << ", " << DisasmGZWR(rm);
};

sbc_www.execute = {
  typedef typename ARCH::U32 U32;
  
  U32 op1( cpu.GetGSR(rn) ), op2( cpu.GetGZR(rm) ), res = op1 - op2 - U32(not cpu.GetCarry());
  cpu.SetGSR(rd, res);
};

op sbc_xxx( 0b11011010000[11] : rm[5] : 0b000000[6] : rn[5] : rd[5] );
sbc_xxx.var format : {char const*} = {"base,1620"};

sbc_xxx.disasm = {
  if (rn == 31)
    sink << "ngc\t" << DisasmGZXR(rd) << ", " << DisasmGZXR(rm);
  else
    sink << "sbc\t" << DisasmGZXR(rd) << ", " << DisasmGZXR(rn) << ", " << DisasmGZXR(rm);
};

sbc_xxx.execute = {
  typedef typename ARCH::U64 U64;
  
  U64 op1( cpu.GetGSR(rn) ), op2( cpu.GetGZR(rm) ), res = op1 - op2 - U64(not cpu.GetCarry());
  cpu.SetGSR(rd, res);
};

/*
 * end of SBC
 *******************************************************************/

/*******************************************************************
 * SBCS
 *
 * Subtract with carry, setting the condition flags: Rd = Rn - Rm - 1 + C
 */

op sbcs_www( 0b01111010000[11] : rm[5] : 0b000000[6] : rn[5] : rd[5] );
sbcs_www.var format : {char const*} = {"base,1473"};

sbcs_www.disasm = {
  if (rn == 31)
    sink << "ngcs\t" << DisasmGZWR(rd) << ", " << DisasmGZWR(rm);
  else
    sink << "sbcs\t" << DisasmGZWR(rd) << ", " << DisasmGZWR(rn) << ", " << DisasmGZWR(rm);
};

sbcs_www.execute = {
  typedef typename ARCH::U32 U32;
  typedef typename ARCH::S32 S32;
  typedef typename ARCH::BOOL BOOL;
  
  BOOL borrow( not cpu.GetCarry() );
  U32 op1( cpu.GetGSR(rn) ), op2( cpu.GetGZR(rm) ), res = op1 - op2 - U32(borrow);
  cpu.SetGSR(rd, res);
  
  BOOL n = S32(res) < S32(0), z = op1 == op2;
  if (cpu.Test(borrow))
    cpu.SetNZCV( n, z, op1 >  op2, n xor (S32(op1) <= S32(op2)) );
  else
    cpu.SetNZCV( n, z, op1 >= op2, n xor (S32(op1) <  S32(op2)) );
};

op sbcs_xxx( 0b11111010000[11] : rm[5] : 0b000000[6] : rn[5] : rd[5] );
sbcs_xxx.var format : {char const*} = {"base,1619"};

sbcs_xxx.disasm = {
  if (rn == 31)
    sink << "ngcs\t" << DisasmGZXR(rd) << ", " << DisasmGZXR(rm);
  else
    sink << "sbcs\t" << DisasmGZXR(rd) << ", " << DisasmGZXR(rn) << ", " << DisasmGZXR(rm);
};

sbcs_xxx.execute = {
  typedef typename ARCH::U64 U64;
  typedef typename ARCH::S64 S64;
  typedef typename ARCH::BOOL BOOL;
  
  BOOL borrow( not cpu.GetCarry() );
  U64 op1( cpu.GetGSR(rn) ), op2( cpu.GetGZR(rm) ), res = op1 - op2 - U64(borrow);
  cpu.SetGSR(rd, res);
  
  BOOL n = S64(res) < S64(0), z = op1 == op2;
  if (cpu.Test(borrow))
    cpu.SetNZCV( n, z, op1 >  op2, n xor (S64(op1) <= S64(op2)) );
  else
    cpu.SetNZCV( n, z, op1 >= op2, n xor (S64(op1) <  S64(op2)) );
};

/*
 * end of SBCS
 *******************************************************************/

/*******************************************************************
 * SBFM
 *
 * Signed bitfield move, with sign replication to left and zeros to right.
 */

op sbfm_w( 0b00010011000[11] : immr[5] : 0b0[1] : imms[5] : rn[5] : rd[5] );
sbfm_w.var format : {char const*} = {"base,163"};

sbfm_w.disasm = {
  if (imms == 0b11111)
    sink << "asr\t" << DisasmGZWR(rd) << ", " << DisasmGZWR(rn) << ", " << DisasmI(immr);
  else if (imms < immr)
    sink << "sbfiz\t" << DisasmGZWR(rd) << ", " << DisasmGZWR(rn) << ", " << DisasmI(-immr&31) << ", " << DisasmI(imms+1);
  else if ((immr == 0) and (imms == 0b00111))
    sink << "sxtb\t" << DisasmGZWR(rd) << ", " << DisasmGZWR(rn);
  else if ((immr == 0) and (imms == 0b01111))
    sink << "sxth\t" << DisasmGZWR(rd) << ", " << DisasmGZWR(rn);
  else
    sink << "sbfx\t" << DisasmGZWR(rd) << ", " << DisasmGZWR(rn) << ", " << DisasmI(immr) << ", " << DisasmI(imms+1-immr);
};

sbfm_w.execute = {
  typedef typename ARCH::U32 U32;
  typedef typename ARCH::S32 S32;
  unsigned l = (imms ^ 31), r = (l + immr) & 31;
  
  U32 src( cpu.GetGZR(rn) ), res( S32(src << l) >> r );
  cpu.SetGZR(rd, res);
};


op sbfm_x( 0b1001001101[10] : immr[6] : imms[6] : rn[5] : rd[5] );
sbfm_x.var format : {char const*} = {"base,91"};

sbfm_x.disasm = {
  if (imms == 0b111111)
    sink << "asr\t" << DisasmGZXR(rd) << ", " << DisasmGZXR(rn) << ", " << DisasmI(immr);
  else if (imms < immr)
    sink << "sbfiz\t" << DisasmGZXR(rd) << ", " << DisasmGZXR(rn) << ", " << DisasmI(-immr&63) << ", " << DisasmI(imms+1);
  else if ((immr == 0) and (imms == 0b000111))
    sink << "sxtb\t" << DisasmGZXR(rd) << ", " << DisasmGZXR(rn);
  else if ((immr == 0) and (imms == 0b001111))
    sink << "sxth\t" << DisasmGZXR(rd) << ", " << DisasmGZXR(rn);
  else if ((immr == 0) and (imms == 0b011111))
    sink << "sxtw\t" << DisasmGZXR(rd) << ", " << DisasmGZXR(rn);
  else
    sink << "sbfx\t" << DisasmGZXR(rd) << ", " << DisasmGZXR(rn) << ", " << DisasmI(immr) << ", " << DisasmI(imms+1-immr);
};

sbfm_x.execute = {
  typedef typename ARCH::U64 U64;
  typedef typename ARCH::S64 S64;
  unsigned l = (imms ^ 63), r = (l + immr) & 63;
  
  U64 src( cpu.GetGZR(rn) ), res( S64(src << l) >> r );
  cpu.SetGZR(rd, res);
};

/*
 * end of SBFM
 *******************************************************************/

/*******************************************************************
 * SDIV
 *
 * Signed divide: Rd = Rn / Rm
 */

op sdiv_www( 0b00011010110[11] : rm[5] : 0b000011[6] : rn[5] : rd[5] );
sdiv_www.var format : {char const*} = {"base,1470"};

sdiv_www.disasm = {
  sink << "sdiv\t" << DisasmGZWR(rd) << ", " << DisasmGZWR(rn) << ", " << DisasmGZWR(rm);
};

sdiv_www.execute = {
  typedef typename ARCH::S32 S32;
  typedef typename ARCH::U32 U32;
  
  S32 const zero(0);
  S32 op1( cpu.GetGZR(rn) ), op2( cpu.GetGZR(rm) ), res = cpu.Test(op2 == zero) ? zero : (op1 / op2);
  cpu.SetGZR(rd, U32(res));
};

op sdiv_xxx( 0b10011010110[11] : rm[5] : 0b000011[6] : rn[5] : rd[5] );
sdiv_xxx.var format : {char const*} = {"base,1470"};

sdiv_xxx.disasm = {
  sink << "sdiv\t" << DisasmGZXR(rd) << ", " << DisasmGZXR(rn) << ", " << DisasmGZXR(rm);
};

sdiv_xxx.execute = {
  typedef typename ARCH::S64 S64;
  typedef typename ARCH::U64 U64;
  
  S64 const zero(0);
  S64 op1( cpu.GetGZR(rn) ), op2( cpu.GetGZR(rm) ), res = cpu.Test(op2 == zero) ? zero : (op1 / op2);
  cpu.SetGZR(rd, U64(res));
};

/*
 * end of SDIV
 *******************************************************************/

op sev( 0b11010101000000110010000010011111[32] );
sev.var format : {char const*} = {"base,2949"};

sev.disasm = {
  sink << "sev";
};

op sevl( 0b11010101000000110010000010111111[32] );
sevl.var format : {char const*} = {"base,2950"};

sevl.disasm = {
  sink << "sevl";
};

op smaddl_xw( 0b10011011001[11] : rm[5] : 0b0[1] : ra[5] : rn[5] : rd[5] );
smaddl_xw.var format : {char const*} = {"base,235"};

smaddl_xw.disasm = {
  if (ra == 31)
    sink << "smull\t" << DisasmGZXR(rd) << ", " << DisasmGZWR(rn) << ", " << DisasmGZWR(rm);
  else
    sink << "smaddl\t" << DisasmGZXR(rd) << ", " << DisasmGZWR(rn) << ", " << DisasmGZWR(rm) << ", " << DisasmGZXR(ra);
};

op smc( 0b11010100000[11] : imm[16] : 0b00011[5] );
smc.var format : {char const*} = {"base,576"};

smc.disasm = {
  sink << "smc\t" << DisasmI(imm,16);
};

op smsubl_xw( 0b10011011001[11] : rm[5] : 0b1[1] : ra[5] : rn[5] : rd[5] );
smsubl_xw.var format : {char const*} = {"base,236"};

smsubl_xw.disasm = {
  if (ra == 31)
    sink << "smnegl\t" << DisasmGZXR(rd) << ", " << DisasmGZWR(rn) << ", " << DisasmGZWR(rm);
  else
    sink << "smsubl\t" << DisasmGZXR(rd) << ", " << DisasmGZWR(rn) << ", " << DisasmGZWR(rm) << ", " << DisasmGZXR(ra);
};

op smulh( 0b10011011010[11] : rm[5] : 0b0[1] : ra[5] : rn[5] : rd[5] );
smulh.var format : {char const*} = {"base,239"};

smulh.disasm = {
  sink << "smulh\t" << DisasmGZXR(rd) << ", " << DisasmGZXR(rn) << ", " << DisasmGZXR(rm);
};

/*******************************************************************
 * STLR
 *
 * Store-release register
 */

op stlr_w( 0b10001000100[11] : rs[5] : 0b1[1] : rt2[5] : rn[5] : rt[5] );
stlr_w.var format : {char const*} = {"base,232"};

stlr_w.disasm = {
  sink << "stlr\t" << DisasmGZWR(rt) << ", [" << DisasmGSXR(rn) << "]";
};

stlr_w.execute = {
  typedef typename ARCH::U32 U32;
  typedef typename ARCH::U64 U64;
  
  U64 addr( cpu.GetGSR(rn) );
  U32 data( cpu.GetGZR(rt) );
  cpu.MemWrite32(addr, data);
};

op stlr_x( 0b11001000100[11] : rs[5] : 0b1[1] : rt2[5] : rn[5] : rt[5] );
stlr_x.var format : {char const*} = {"base,247"};

stlr_x.disasm = {
  sink << "stlr\t" << DisasmGZXR(rt) << ", [" << DisasmGSXR(rn) << "]";
};

stlr_x.execute = {
  typedef typename ARCH::U64 U64;
  
  U64 addr( cpu.GetGSR(rn) );
  U64 data( cpu.GetGZR(rt) );
  cpu.MemWrite64(addr, data);
};

/*
 * end of STLR
 *******************************************************************/

/*******************************************************************
 * STLRB
 *
 * Store-release register byte
 */

op stlrb_w( 0b00001000100[11] : rs[5] : 0b1[1] : rt2[5] : rn[5] : rt[5] );
stlrb_w.var format : {char const*} = {"base,233"};

stlrb_w.disasm = {
  sink << "stlrb\t" << DisasmGZWR(rt) << ", [" << DisasmGSXR(rn) << "]";
};

stlrb_w.execute = {
  typedef typename ARCH::U8 U8;
  typedef typename ARCH::U64 U64;
  
  U64 addr( cpu.GetGSR(rn) );
  U8 data( cpu.GetGZR(rt) );
  cpu.MemWrite8(addr, data);
};

/*
 * end of STLRB
 *******************************************************************/

/*******************************************************************
 * STLRH
 *
 * Store-release register halfword
 */

op stlrh_w( 0b01001000100[11] : rs[5] : 0b1[1] : rt2[5] : rn[5] : rt[5] );
stlrh_w.var format : {char const*} = {"base,234"};

stlrh_w.disasm = {
  sink << "stlrh\t" << DisasmGZWR(rt) << ", [" << DisasmGSXR(rn) << "]";
};

stlrh_w.execute = {
  typedef typename ARCH::U16 U16;
  typedef typename ARCH::U64 U64;
  
  U64 addr( cpu.GetGSR(rn) );
  U16 data( cpu.GetGZR(rt) );
  cpu.MemWrite16(addr, data);
};

/*
 * end of STLRH
 *******************************************************************/

/*******************************************************************
 * STLXP
 *
 * Store-release exclusive pair of registers, returning status
 */

op stlxp_w( 0b10001000001[11] : rs[5] : 0b1[1] : rt2[5] : rn[5] : rt[5] );
stlxp_w.var format : {char const*} = {"base,168"};

stlxp_w.disasm = {
  sink << "stlxp\t" << DisasmGZWR(rs) << ", " << DisasmGZWR(rt) << ", " << DisasmGZWR(rt2) << ", [" << DisasmGSXR(rn) << "]";
};

stlxp_w.execute = {
  typedef typename ARCH::U32 U32;
  typedef typename ARCH::U64 U64;
  
  U64 addr( cpu.GetGSR(rn) );
  U32 data0( cpu.GetGZR(rt) ), data1( cpu.GetGZR(rt2) );
  if (cpu.ExclusiveMonitorsPass(addr, 8)) {
    cpu.MemWrite32( addr + U64(0), data0 );
    cpu.MemWrite32( addr + U64(4), data1 );
    cpu.SetGZR(rs, U64(0));
  } else {
    cpu.SetGZR(rs, U64(1));
  }
};

op stlxp_x( 0b11001000001[11] : rs[5] : 0b1[1] : rt2[5] : rn[5] : rt[5] );
stlxp_x.var format : {char const*} = {"base,222"};

stlxp_x.disasm = {
  sink << "stlxp\t" << DisasmGZWR(rs) << ", " << DisasmGZXR(rt) << ", " << DisasmGZXR(rt2) << ", [" << DisasmGSXR(rn) << "]";
};

stlxp_x.execute = {
  typedef typename ARCH::U64 U64;
  
  U64 addr( cpu.GetGSR(rn) );
  U64 data0( cpu.GetGZR(rt) ), data1( cpu.GetGZR(rt2) );
  if (cpu.ExclusiveMonitorsPass(addr, 16)) {
    cpu.MemWrite64( addr + U64(0), data0 );
    cpu.MemWrite64( addr + U64(8), data1 );
    cpu.SetGZR(rs, U64(0));
  } else {
    cpu.SetGZR(rs, U64(1));
  }
};

/*
 * end of STLXP
 *******************************************************************/

/*******************************************************************
 * STLXR
 *
 * Store-release exclusive register, returning status
 */

op stlxr_w( 0b10001000000[11] : rs[5] : 0b1[1] : rt2[5] : rn[5] : rt[5] );
stlxr_w.var format : {char const*} = {"base,214"};

stlxr_w.disasm = {
  sink << "stlxr\t" << DisasmGZWR(rs) << ", " << DisasmGZWR(rt) << ", [" << DisasmGSXR(rn) << "]";
};

stlxr_w.execute = {
  typedef typename ARCH::U32 U32;
  typedef typename ARCH::U64 U64;
  
  U64 addr = cpu.GetGSR(rn);
  if (cpu.ExclusiveMonitorsPass(addr, 4)) {
    cpu.MemWrite32( addr, U32(cpu.GetGZR(rt)) );
    cpu.SetGZR(rs, U64(0));
  } else {
    cpu.SetGZR(rs, U64(1));
  }
};

op stlxr_x( 0b11001000000[11] : rs[5] : 0b1[1] : rt2[5] : rn[5] : rt[5] );
stlxr_x.var format : {char const*} = {"base,224"};

stlxr_x.disasm = {
  sink << "stlxr\t" << DisasmGZWR(rs) << ", " << DisasmGZXR(rt) << ", [" << DisasmGSXR(rn) << "]";
};

stlxr_x.execute = {
  typedef typename ARCH::U64 U64;
  
  U64 addr = cpu.GetGSR(rn);
  if (cpu.ExclusiveMonitorsPass(addr, 8)) {
    cpu.MemWrite64( addr, cpu.GetGZR(rt) );
    cpu.SetGZR(rs, U64(0));
  } else {
    cpu.SetGZR(rs, U64(1));
  }
};

/*
 * end of STLXR
 *******************************************************************/

/*******************************************************************
 * STLXRB
 *
 * Store-release exclusive register byte, returning status
 */

op stlxrb_w( 0b00001000000[11] : rs[5] : 0b1[1] : rt2[5] : rn[5] : rt[5] );
stlxrb_w.var format : {char const*} = {"base,215"};

stlxrb_w.disasm = {
  sink << "stlxrb\t" << DisasmGZWR(rs) << ", " << DisasmGZWR(rt) << ", [" << DisasmGSXR(rn) << "]";
};

stlxrb_w.execute = {
  typedef typename ARCH::U8  U8;
  typedef typename ARCH::U64 U64;
  
  U64 addr = cpu.GetGSR(rn);
  if (cpu.ExclusiveMonitorsPass(addr, 1)) {
    cpu.MemWrite8( addr, U8(cpu.GetGZR(rt)) );
    cpu.SetGZR(rs, U64(0));
  } else {
    cpu.SetGZR(rs, U64(1));
  }
};

/*
 * end of STLXRB
 *******************************************************************/

/*******************************************************************
 * STLXRH
 *
 * Store-release exclusive register halfword, returning status
 */

op stlxrh_w( 0b01001000000[11] : rs[5] : 0b1[1] : rt2[5] : rn[5] : rt[5] );
stlxrh_w.var format : {char const*} = {"base,216"};

stlxrh_w.disasm = {
  sink << "stlxrh\t" << DisasmGZWR(rs) << ", " << DisasmGZWR(rt) << ", [" << DisasmGSXR(rn) << "]";
};

stlxrh_w.execute = {
  typedef typename ARCH::U16 U16;
  typedef typename ARCH::U64 U64;
  
  U64 addr = cpu.GetGSR(rn);
  if (cpu.ExclusiveMonitorsPass(addr, 2)) {
    cpu.MemWrite16( addr, U16(cpu.GetGZR(rt)) );
    cpu.SetGZR(rs, U64(0));
  } else {
    cpu.SetGZR(rs, U64(1));
  }
};

/*
 * end of STLXRH
 *******************************************************************/

/*******************************************************************
 * STNP
 *
 * Store pair of registers, with non-temporal hint
 */

op stnp_w( 0b0010100000[10] : shl<2> sext imm[7] : rt2[5] : rn[5] : rt[5] );
stnp_w.var format : {char const*} = {"base,76"};

stnp_w.disasm = {
  sink << "stnp\t" << DisasmGZWR(rt) << ", " << DisasmGZWR(rt2) << ", [" << DisasmGSXR(rn) << "," << DisasmI(imm) << "]";
};

stnp_w.execute = {
  typedef typename ARCH::U32 U32;
  typedef typename ARCH::U64 U64;
  
  U64 addr( cpu.GetGSR(rn) );
  U32 data0( cpu.GetGZR(rt) ), data1( cpu.GetGZR(rt2) );
  cpu.MemWrite32( addr + U64(0), data0 );
  cpu.MemWrite32( addr + U64(4), data1 );
};

op stnp_x( 0b1010100000[10] : shl<3> sext imm[7] : rt2[5] : rn[5] : rt[5] );
stnp_x.var format : {char const*} = {"base,96"};

stnp_x.disasm = {
  sink << "stnp\t" << DisasmGZXR(rt) << ", " << DisasmGZXR(rt2) << ", [" << DisasmGSXR(rn) << "," << DisasmI(imm) << "]";
};

stnp_x.execute = {
  typedef typename ARCH::U64 U64;
  
  U64 addr( cpu.GetGSR(rn) );
  U64 data0( cpu.GetGZR(rt) ), data1( cpu.GetGZR(rt2) );
  cpu.MemWrite64( addr + U64(0), data0 );
  cpu.MemWrite64( addr + U64(8), data1 );
};

/*
 * end of STNP
 *******************************************************************/

/*******************************************************************
 * STP
 * 
 * Store pair of registers
 */

op stp_wpo( 0b0010100010[10] : shl<2> sext imm[7] : rt2[5] : rn[5] : rt[5] );
stp_wpo.var format : {char const*} = {"base,81"};

stp_wpo.disasm = {
  sink << "stp\t" << DisasmGZWR(rt) << ", " << DisasmGZWR(rt2) << ", [" << DisasmGSXR(rn) << "]," << DisasmI(imm);
};

stp_wpo.execute = {
  typedef typename ARCH::U32 U32;
  typedef typename ARCH::U64 U64;
  typedef typename ARCH::S64 S64;
  
  U64 addr( cpu.GetGSR(rn) );
  U32 data0( cpu.GetGZR(rt) ), data1( cpu.GetGZR(rt2) );
  cpu.MemWrite32( addr + U64(0), data0 );
  cpu.MemWrite32( addr + U64(4), data1 );
  cpu.SetGSR(rn, addr + U64(S64(imm)));
};

op stp_xpo( 0b1010100010[10] : shl<3> sext imm[7] : rt2[5] : rn[5] : rt[5] );
stp_xpo.var format : {char const*} = {"base,103"};

stp_xpo.disasm = {
  sink << "stp\t" << DisasmGZXR(rt) << ", " << DisasmGZXR(rt2) << ", [" << DisasmGSXR(rn) << "]," << DisasmI(imm);
};

stp_xpo.execute = {
  typedef typename ARCH::U64 U64;
  typedef typename ARCH::S64 S64;
  
  U64 addr( cpu.GetGSR(rn) );
  U64 data0( cpu.GetGZR(rt) ), data1( cpu.GetGZR(rt2) );
  cpu.MemWrite64( addr + U64(0), data0 );
  cpu.MemWrite64( addr + U64(8), data1 );
  cpu.SetGSR(rn, addr + U64(S64(imm)));
};

op stp_wop( 0b0010100110[10] : shl<2> sext imm[7] : rt2[5] : rn[5] : rt[5] );
stp_wop.var format : {char const*} = {"base,79"};

stp_wop.disasm = {
  sink << "stp\t" << DisasmGZWR(rt) << ", " << DisasmGZWR(rt2) << ", [" << DisasmGSXR(rn) << "," << DisasmI(imm) << "]!";
};

stp_wop.execute = {
  typedef typename ARCH::U32 U32;
  typedef typename ARCH::U64 U64;
  typedef typename ARCH::S64 S64;
  
  U64 addr( cpu.GetGSR(rn) + U64(S64(imm)) );
  U32 data0( cpu.GetGZR(rt) ), data1( cpu.GetGZR(rt2) );
  cpu.MemWrite32( addr + U64(0), data0 );
  cpu.MemWrite32( addr + U64(4), data1 );
  cpu.SetGSR(rn, addr);
};

op stp_xop( 0b1010100110[10] : shl<3> sext imm[7] : rt2[5] : rn[5] : rt[5] );
stp_xop.var format : {char const*} = {"base,100"};

stp_xop.disasm = {
  sink << "stp\t" << DisasmGZXR(rt) << ", " << DisasmGZXR(rt2) << ", [" << DisasmGSXR(rn) << "," << DisasmI(imm) << "]!";
};

stp_xop.execute = {
  typedef typename ARCH::U64 U64;
  typedef typename ARCH::S64 S64;
  
  U64 addr( cpu.GetGSR(rn) + U64(S64(imm)) );
  U64 data0( cpu.GetGZR(rt) ), data1( cpu.GetGZR(rt2) );
  cpu.MemWrite64( addr + U64(0), data0 );
  cpu.MemWrite64( addr + U64(8), data1 );
  cpu.SetGSR(rn, addr);
};

op stp_wo( 0b0010100100[10] : shl<2> sext imm[7] : rt2[5] : rn[5] : rt[5] );
stp_wo.var format : {char const*} = {"base,77"};

stp_wo.disasm = {
  sink << "stp\t" << DisasmGZWR(rt) << ", " << DisasmGZWR(rt2) << ", [" << DisasmGSXR(rn) << "," << DisasmI(imm) << "]";
};

stp_wo.execute = {
  typedef typename ARCH::U32 U32;
  typedef typename ARCH::U64 U64;
  typedef typename ARCH::S64 S64;
  
  U64 addr( cpu.GetGSR(rn) + U64(S64(imm)) );
  U32 data0( cpu.GetGZR(rt) ), data1( cpu.GetGZR(rt2) );
  cpu.MemWrite32( addr + U64(0), data0 );
  cpu.MemWrite32( addr + U64(4), data1 );
};

op stp_xo( 0b1010100100[10] : shl<3> sext imm[7] : rt2[5] : rn[5] : rt[5] );
stp_xo.var format : {char const*} = {"base,97"};

stp_xo.disasm = {
  sink << "stp\t" << DisasmGZXR(rt) << ", " << DisasmGZXR(rt2) << ", [" << DisasmGSXR(rn) << "," << DisasmI(imm) << "]";
};

stp_xo.execute = {
  typedef typename ARCH::U64 U64;
  typedef typename ARCH::S64 S64;
  
  U64 addr( cpu.GetGSR(rn) + U64(S64(imm)) );
  U64 data0( cpu.GetGZR(rt) ), data1( cpu.GetGZR(rt2) );
  cpu.MemWrite64( addr + U64(0), data0 );
  cpu.MemWrite64( addr + U64(8), data1 );
};

/*
 * end of STP
 *******************************************************************/

/*******************************************************************
 * STR (immediate)
 *
 * Store register (immediate offset)
 */

op str_wsopost( 0b10111000000[11] : sext imm[9] : 0b01[2] : rn[5] : rt[5] );
str_wsopost.var format : {char const*} = {"base,324"};

str_wsopost.disasm = {
  sink << "str\t" << DisasmGZWR(rt) << ", [" << DisasmGSXR(rn) << "]," << DisasmI(imm);
};

str_wsopost.execute = {
  typedef typename ARCH::U32 U32;
  typedef typename ARCH::U64 U64;
  typedef typename ARCH::S64 S64;
  
  U64 addr( cpu.GetGSR(rn) );
  U32 data( cpu.GetGZR(rt) );
  cpu.MemWrite32(addr, data);
  cpu.SetGSR(rn, addr + U64(S64(imm)) );
};

op str_xsopost( 0b11111000000[11] : sext imm[9] : 0b01[2] : rn[5] : rt[5] );
str_xsopost.var format : {char const*} = {"base,350"};

str_xsopost.disasm = {
  sink << "str\t" << DisasmGZXR(rt) << ", [" << DisasmGSXR(rn) << "]," << DisasmI(imm);
};

str_xsopost.execute = {
  typedef typename ARCH::U64 U64;
  typedef typename ARCH::S64 S64;
  
  U64 addr( cpu.GetGSR(rn) );
  U64 data( cpu.GetGZR(rt) );
  cpu.MemWrite64(addr, data);
  cpu.SetGSR(rn, addr + U64(S64(imm)) );
};

op str_wsopre( 0b10111000000[11] : sext imm[9] : 0b11[2] : rn[5] : rt[5] );
str_wsopre.var format : {char const*} = {"base,316"};

str_wsopre.disasm = {
  sink << "str\t" << DisasmGZWR(rt) << ", [" << DisasmGSXR(rn) << "," << DisasmI(imm) << "]!";
};

str_wsopre.execute = {
  typedef typename ARCH::U32 U32;
  typedef typename ARCH::U64 U64;
  typedef typename ARCH::S64 S64;
  
  U64 addr( cpu.GetGSR(rn) + U64(S64(imm)) );
  U32 data( cpu.GetGZR(rt) );
  cpu.MemWrite32(addr, data);
  cpu.SetGSR(rn, addr);
};

op str_xsopre( 0b11111000000[11] : sext imm[9] : 0b11[2] : rn[5] : rt[5] );
str_xsopre.var format : {char const*} = {"base,345"};

str_xsopre.disasm = {
  sink << "str\t" << DisasmGZXR(rt) << ", [" << DisasmGSXR(rn) << "," << DisasmI(imm) << "]!";
};

str_xsopre.execute = {
  typedef typename ARCH::U64 U64;
  typedef typename ARCH::S64 S64;
  
  U64 addr( cpu.GetGSR(rn) + U64(S64(imm)) );
  U64 data( cpu.GetGZR(rt) );
  cpu.MemWrite64(addr, data);
  cpu.SetGSR(rn, addr);
};

op str_wuo( 0b1011100100[10] : shl<2> imm[12] : rn[5] : rt[5] );
str_wuo.var format : {char const*} = {"base,87"};

str_wuo.disasm = {
  sink << "str\t" << DisasmGZWR(rt) << ", [" << DisasmGSXR(rn) << "," << DisasmI(imm) << "]";
};

str_wuo.execute = {
  typedef typename ARCH::U32 U32;
  typedef typename ARCH::U64 U64;
  
  U64 addr( cpu.GetGSR(rn) + U64(imm) );
  U32 data( cpu.GetGZR(rt) );
  cpu.MemWrite32(addr, data);
};

op str_xuo( 0b1111100100[10] : shl<3> imm[12] : rn[5] : rt[5] );
str_xuo.var format : {char const*} = {"base,108"};

str_xuo.disasm = {
  sink << "str\t" << DisasmGZXR(rt) << ", [" << DisasmGSXR(rn) << "," << DisasmI(imm) << "]";
};

str_xuo.execute = {
  typedef typename ARCH::U64 U64;
  
  U64 addr( cpu.GetGSR(rn) + U64(imm) );
  U64 data( cpu.GetGZR(rt) );
  cpu.MemWrite64(addr, data);
};

/*
 * end of STR (immediate)
 *******************************************************************/

/*******************************************************************
 * STR (register)
 *
 * Store register (register offset)
 */

op str_wxwu( 0b10111000001[11] : rm[5] : 0b010[3] : s[1] : 0b10[2] : rn[5] : rt[5] );
str_wxwu.var shift : {uint8_t} = {s*2}, format : {char const*} = {"base,628"};

str_wxwu.disasm = {
  sink << "str\t" << DisasmGZWR(rt) << ", [" << DisasmGSXR(rn) << "," << DisasmGZWR(rm) << ",uxtw" << DisasmINZ(" ", shift) << "]";
};

str_wxwu.execute = {
  typedef typename ARCH::U32 U32;
  typedef typename ARCH::U64 U64;

  U64 offset( U64(U32(cpu.GetGZR(rm))) << shift ), addr( cpu.GetGSR(rn) + offset );
  U32 data( cpu.GetGZR(rt) );
  cpu.MemWrite32(addr, data);
};

op str_wxxu( 0b10111000001[11] : rm[5] : 0b011[3] : s[1] : 0b10[2] : rn[5] : rt[5] );
str_wxxu.var format : {char const*} = {"base,1601"}, shift : {uint8_t} = {s*2};

str_wxxu.disasm = {
  sink << "str\t" << DisasmGZWR(rt) << ", [" << DisasmGSXR(rn) << "," << DisasmGZXR(rm) << DisasmINZ(",lsl ",shift) << "]";
};

str_wxxu.execute = {
  typedef typename ARCH::U32 U32;
  typedef typename ARCH::U64 U64;

  U64 offset( U64(U64(cpu.GetGZR(rm))) << shift ), addr( cpu.GetGSR(rn) + offset );
  U32 data( cpu.GetGZR(rt) );
  cpu.MemWrite32(addr, data);
};

op str_wxws( 0b10111000001[11] : rm[5] : 0b110[3] : s[1] : 0b10[2] : rn[5] : rt[5] );
str_wxws.var shift : {uint8_t} = {s*2}, format : {char const*} = {"base,620"};

str_wxws.disasm = {
  sink << "str\t" << DisasmGZWR(rt) << ", [" << DisasmGSXR(rn) << "," << DisasmGZWR(rm) << ",sxtw" << DisasmINZ(" ", shift) << "]";
};

str_wxws.execute = {
  typedef typename ARCH::S32 S32;
  typedef typename ARCH::S64 S64;
  typedef typename ARCH::U32 U32;
  typedef typename ARCH::U64 U64;

  U64 offset( S64(S32(cpu.GetGZR(rm))) << shift ), addr( cpu.GetGSR(rn) + offset );
  U32 data( cpu.GetGZR(rt) );
  cpu.MemWrite32(addr, data);
};

op str_wxxs( 0b10111000001[11] : rm[5] : 0b111[3] : s[1] : 0b10[2] : rn[5] : rt[5] );
str_wxxs.var shift : {uint8_t} = {s*2}, format : {char const*} = {"base,636"};

str_wxxs.disasm = {
  sink << "str\t" << DisasmGZWR(rt) << ", [" << DisasmGSXR(rn) << "," << DisasmGZXR(rm) << ",sxtx" << DisasmINZ(" ", shift) << "]";
};

str_wxxs.execute = {
  typedef typename ARCH::S64 S64;
  typedef typename ARCH::U32 U32;
  typedef typename ARCH::U64 U64;

  U64 offset( S64(S64(cpu.GetGZR(rm))) << shift ), addr( cpu.GetGSR(rn) + offset );
  U32 data( cpu.GetGZR(rt) );
  cpu.MemWrite32(addr, data);
};

op str_xxwu( 0b11111000001[11] : rm[5] : 0b010[3] : s[1] : 0b10[2] : rn[5] : rt[5] );
str_xxwu.var shift : {uint8_t} = {s*3}, format : {char const*} = {"base,648"};

str_xxwu.disasm = {
  sink << "str\t" << DisasmGZXR(rt) << ", [" << DisasmGSXR(rn) << "," << DisasmGZWR(rm) << ",uxtw" << DisasmINZ(" ", shift) << "]";
};

str_xxwu.execute = {
  typedef typename ARCH::U32 U32;
  typedef typename ARCH::U64 U64;

  U64 offset( U64(U32(cpu.GetGZR(rm))) << shift ), addr( cpu.GetGSR(rn) + offset );
  U64 data( cpu.GetGZR(rt) );
  cpu.MemWrite64(addr, data);
};

op str_xxxu( 0b11111000001[11] : rm[5] : 0b011[3] : s[1] : 0b10[2] : rn[5] : rt[5] );
str_xxxu.var format : {char const*} = {"base,1665"}, shift : {uint8_t} = {s*3};

str_xxxu.disasm = {
  sink << "str\t" << DisasmGZXR(rt) << ", [" << DisasmGSXR(rn) << "," << DisasmGZXR(rm) << DisasmINZ(",lsl ",shift) << "]";
};

str_xxxu.execute = {
  typedef typename ARCH::U64 U64;

  U64 offset( U64(U64(cpu.GetGZR(rm))) << shift ), addr( cpu.GetGSR(rn) + offset );
  U64 data( cpu.GetGZR(rt) );
  cpu.MemWrite64(addr, data);
};

op str_xxws( 0b11111000001[11] : rm[5] : 0b110[3] : s[1] : 0b10[2] : rn[5] : rt[5] );
str_xxws.var shift : {uint8_t} = {s*3}, format : {char const*} = {"base,643"};

str_xxws.disasm = {
  sink << "str\t" << DisasmGZXR(rt) << ", [" << DisasmGSXR(rn) << "," << DisasmGZWR(rm) << ",sxtw" << DisasmINZ(" ", shift) << "]";
};

str_xxws.execute = {
  typedef typename ARCH::S32 S32;
  typedef typename ARCH::S64 S64;
  typedef typename ARCH::U64 U64;

  U64 offset( S64(S32(cpu.GetGZR(rm))) << shift ), addr( cpu.GetGSR(rn) + offset );
  U64 data( cpu.GetGZR(rt) );
  cpu.MemWrite64(addr, data);
};

op str_xxxs( 0b11111000001[11] : rm[5] : 0b111[3] : s[1] : 0b10[2] : rn[5] : rt[5] );
str_xxxs.var shift : {uint8_t} = {s*3}, format : {char const*} = {"base,653"};

str_xxxs.disasm = {
  sink << "str\t" << DisasmGZXR(rt) << ", [" << DisasmGSXR(rn) << "," << DisasmGZXR(rm) << ",sxtx" << DisasmINZ(" ", shift) << "]";
};

str_xxxs.execute = {
  typedef typename ARCH::S64 S64;
  typedef typename ARCH::U64 U64;

  U64 offset( S64(S64(cpu.GetGZR(rm))) << shift ), addr( cpu.GetGSR(rn) + offset );
  U64 data( cpu.GetGZR(rt) );
  cpu.MemWrite64(addr, data);
};

/*
 * end of STR (register)
 *******************************************************************/

/*******************************************************************
 * STRB (immediate)
 *
 * Store register byte (immediate offset)
 */

op strb_wsopost( 0b00111000000[11] : sext imm[9] : 0b01[2] : rn[5] : rt[5] );
strb_wsopost.var format : {char const*} = {"base,325"};

strb_wsopost.disasm = {
  sink << "strb\t" << DisasmGZWR(rt) << ", [" << DisasmGSXR(rn) << "]," << DisasmI(imm);
};

strb_wsopost.execute = {
  typedef typename ARCH::U8 U8;
  typedef typename ARCH::U64 U64;
  typedef typename ARCH::S64 S64;
  
  U64 addr( cpu.GetGSR(rn) );
  U8 data( cpu.GetGZR(rt) );
  cpu.MemWrite8(addr, data);
  cpu.SetGSR(rn, addr + U64(S64(imm)) );
};

op strb_wsopre( 0b00111000000[11] : sext imm[9] : 0b11[2] : rn[5] : rt[5] );
strb_wsopre.var format : {char const*} = {"base,317"};

strb_wsopre.disasm = {
  sink << "strb\t" << DisasmGZWR(rt) << ", [" << DisasmGSXR(rn) << "," << DisasmI(imm) << "]!";
};

strb_wsopre.execute = {
  typedef typename ARCH::U8 U8;
  typedef typename ARCH::U64 U64;
  typedef typename ARCH::S64 S64;
  
  U64 addr( cpu.GetGSR(rn) + U64(S64(imm)) );
  U8 data( cpu.GetGZR(rt) );
  cpu.MemWrite8(addr, data);
  cpu.SetGSR(rn, addr);
};

op strb_wuo( 0b0011100100[10] : imm[12] : rn[5] : rt[5] );
strb_wuo.var format : {char const*} = {"base,88"};

strb_wuo.disasm = {
  sink << "strb\t" << DisasmGZWR(rt) << ", [" << DisasmGSXR(rn) << "," << DisasmI(imm) << "]";
};

strb_wuo.execute = {
  typedef typename ARCH::U8 U8;
  typedef typename ARCH::U64 U64;
  
  U64 addr( cpu.GetGSR(rn) + U64(imm) );
  U8 data( cpu.GetGZR(rt) );
  cpu.MemWrite8(addr, data);
};

/*
 * end of STRB (immediate)
 *******************************************************************/

/*******************************************************************
 * STRB (register)
 *
 * Store register byte (register offset)
 */

op strb_wxwu( 0b00111000001[11] : rm[5] : 0b010[3] : s[1] : 0b10[2] : rn[5] : rt[5] );
strb_wxwu.var shift : {uint8_t} = {s*0}, format : {char const*} = {"base,629"};

strb_wxwu.disasm = {
  sink << "strb\t" << DisasmGZWR(rt) << ", [" << DisasmGSXR(rn) << "," << DisasmGZWR(rm) << ",uxtw" << DisasmINZ(" ", shift) << "]";
};

strb_wxwu.execute = {
  typedef typename ARCH::U32 U32;
  typedef typename ARCH::U64 U64;
  typedef typename ARCH::U8 U8;

  U64 offset( U64(U32(cpu.GetGZR(rm))) << shift ), addr( cpu.GetGSR(rn) + offset );
  U8 data( cpu.GetGZR(rt) );
  cpu.MemWrite8(addr, data);
};

op strb_wxxu( 0b00111000001[11] : rm[5] : 0b011[3] : s[1] : 0b10[2] : rn[5] : rt[5] );
strb_wxxu.var format : {char const*} = {"base,1602"}, shift : {uint8_t} = {s*0};

strb_wxxu.disasm = {
  sink << "strb\t" << DisasmGZWR(rt) << ", [" << DisasmGSXR(rn) << "," << DisasmGZXR(rm) << DisasmINZ(",lsl ",shift) << "]";
};

strb_wxxu.execute = {
  typedef typename ARCH::U64 U64;
  typedef typename ARCH::U8 U8;

  U64 offset( U64(U64(cpu.GetGZR(rm))) << shift ), addr( cpu.GetGSR(rn) + offset );
  U8 data( cpu.GetGZR(rt) );
  cpu.MemWrite8(addr, data);
};

op strb_wxws( 0b00111000001[11] : rm[5] : 0b110[3] : s[1] : 0b10[2] : rn[5] : rt[5] );
strb_wxws.var shift : {uint8_t} = {s*0}, format : {char const*} = {"base,621"};

strb_wxws.disasm = {
  sink << "strb\t" << DisasmGZWR(rt) << ", [" << DisasmGSXR(rn) << "," << DisasmGZWR(rm) << ",sxtw" << DisasmINZ(" ", shift) << "]";
};

strb_wxws.execute = {
  typedef typename ARCH::S32 S32;
  typedef typename ARCH::S64 S64;
  typedef typename ARCH::U64 U64;
  typedef typename ARCH::U8 U8;

  U64 offset( S64(S32(cpu.GetGZR(rm))) << shift ), addr( cpu.GetGSR(rn) + offset );
  U8 data( cpu.GetGZR(rt) );
  cpu.MemWrite8(addr, data);
};

op strb_wxxs( 0b00111000001[11] : rm[5] : 0b111[3] : s[1] : 0b10[2] : rn[5] : rt[5] );
strb_wxxs.var shift : {uint8_t} = {s*0}, format : {char const*} = {"base,637"};

strb_wxxs.disasm = {
  sink << "strb\t" << DisasmGZWR(rt) << ", [" << DisasmGSXR(rn) << "," << DisasmGZXR(rm) << ",sxtx" << DisasmINZ(" ", shift) << "]";
};

strb_wxxs.execute = {
  typedef typename ARCH::S64 S64;
  typedef typename ARCH::U64 U64;
  typedef typename ARCH::U8 U8;

  U64 offset( S64(S64(cpu.GetGZR(rm))) << shift ), addr( cpu.GetGSR(rn) + offset );
  U8 data( cpu.GetGZR(rt) );
  cpu.MemWrite8(addr, data);
};

/*
 * end of STRB (register)
 *******************************************************************/

/*******************************************************************
 * STRH (immediate)
 *
 * Store register halfword (immediate offset)
 */

op strh_wsopost( 0b01111000000[11] : sext imm[9] : 0b01[2] : rn[5] : rt[5] );
strh_wsopost.var format : {char const*} = {"base,326"};

strh_wsopost.disasm = {
  sink << "strh\t" << DisasmGZWR(rt) << ", [" << DisasmGSXR(rn) << "]," << DisasmI(imm);
};

strh_wsopost.execute = {
  typedef typename ARCH::U16 U16;
  typedef typename ARCH::U64 U64;
  typedef typename ARCH::S64 S64;
  
  U64 addr( cpu.GetGSR(rn) );
  U16 data( cpu.GetGZR(rt) );
  cpu.MemWrite16(addr, data);
  cpu.SetGSR(rn, addr + U64(S64(imm)) );
};

op strh_wsopre( 0b01111000000[11] : sext imm[9] : 0b11[2] : rn[5] : rt[5] );
strh_wsopre.var format : {char const*} = {"base,318"};

strh_wsopre.disasm = {
  sink << "strh\t" << DisasmGZWR(rt) << ", [" << DisasmGSXR(rn) << "," << DisasmI(imm) << "]!";
};

strh_wsopre.execute = {
  typedef typename ARCH::U16 U16;
  typedef typename ARCH::U64 U64;
  typedef typename ARCH::S64 S64;
  
  U64 addr( cpu.GetGSR(rn) + U64(S64(imm)) );
  U16 data( cpu.GetGZR(rt) );
  cpu.MemWrite16(addr, data);
  cpu.SetGSR(rn, addr);
};

op strh_wuo( 0b0111100100[10] : shl<1> imm[12] : rn[5] : rt[5] );
strh_wuo.var format : {char const*} = {"base,89"};

strh_wuo.disasm = {
  sink << "strh\t" << DisasmGZWR(rt) << ", [" << DisasmGSXR(rn) << "," << DisasmI(imm) << "]";
};

strh_wuo.execute = {
  typedef typename ARCH::U16 U16;
  typedef typename ARCH::U64 U64;
  
  U64 addr( cpu.GetGSR(rn) + U64(imm) );
  U16 data( cpu.GetGZR(rt) );
  cpu.MemWrite16(addr, data);
};

/*
 * end of STRH (immediate)
 *******************************************************************/

/*******************************************************************
 * STRH (register)
 *
 * Store register halfword (register offset)
 */

op strh_wxwu( 0b01111000001[11] : rm[5] : 0b010[3] : s[1] : 0b10[2] : rn[5] : rt[5] );
strh_wxwu.var shift : {uint8_t} = {s*1}, format : {char const*} = {"base,630"};

strh_wxwu.disasm = {
  sink << "strh\t" << DisasmGZWR(rt) << ", [" << DisasmGSXR(rn) << "," << DisasmGZWR(rm) << ",uxtw" << DisasmINZ(" ", shift) << "]";
};

strh_wxwu.execute = {
  typedef typename ARCH::U16 U16;
  typedef typename ARCH::U32 U32;
  typedef typename ARCH::U64 U64;

  U64 offset( U64(U32(cpu.GetGZR(rm))) << shift ), addr( cpu.GetGSR(rn) + offset );
  U16 data( cpu.GetGZR(rt) );
  cpu.MemWrite16(addr, data);
};

op strh_wxxu( 0b01111000001[11] : rm[5] : 0b011[3] : s[1] : 0b10[2] : rn[5] : rt[5] );
strh_wxxu.var format : {char const*} = {"base,1603"}, shift : {uint8_t} = {s*1};

strh_wxxu.disasm = {
  sink << "strh\t" << DisasmGZWR(rt) << ", [" << DisasmGSXR(rn) << "," << DisasmGZXR(rm) << DisasmINZ(",lsl ",shift) << "]";
};

strh_wxxu.execute = {
  typedef typename ARCH::U16 U16;
  typedef typename ARCH::U64 U64;

  U64 offset( U64(U64(cpu.GetGZR(rm))) << shift ), addr( cpu.GetGSR(rn) + offset );
  U16 data( cpu.GetGZR(rt) );
  cpu.MemWrite16(addr, data);
};

op strh_wxws( 0b01111000001[11] : rm[5] : 0b110[3] : s[1] : 0b10[2] : rn[5] : rt[5] );
strh_wxws.var shift : {uint8_t} = {s*1}, format : {char const*} = {"base,622"};

strh_wxws.disasm = {
  sink << "strh\t" << DisasmGZWR(rt) << ", [" << DisasmGSXR(rn) << "," << DisasmGZWR(rm) << ",sxtw" << DisasmINZ(" ", shift) << "]";
};

strh_wxws.execute = {
  typedef typename ARCH::S32 S32;
  typedef typename ARCH::S64 S64;
  typedef typename ARCH::U16 U16;
  typedef typename ARCH::U64 U64;

  U64 offset( S64(S32(cpu.GetGZR(rm))) << shift ), addr( cpu.GetGSR(rn) + offset );
  U16 data( cpu.GetGZR(rt) );
  cpu.MemWrite16(addr, data);
};

op strh_wxxs( 0b01111000001[11] : rm[5] : 0b111[3] : s[1] : 0b10[2] : rn[5] : rt[5] );
strh_wxxs.var shift : {uint8_t} = {s*1}, format : {char const*} = {"base,638"};

strh_wxxs.disasm = {
  sink << "strh\t" << DisasmGZWR(rt) << ", [" << DisasmGSXR(rn) << "," << DisasmGZXR(rm) << ",sxtx" << DisasmINZ(" ", shift) << "]";
};

strh_wxxs.execute = {
  typedef typename ARCH::S64 S64;
  typedef typename ARCH::U16 U16;
  typedef typename ARCH::U64 U64;

  U64 offset( S64(S64(cpu.GetGZR(rm))) << shift ), addr( cpu.GetGSR(rn) + offset );
  U16 data( cpu.GetGZR(rt) );
  cpu.MemWrite16(addr, data);
};

/*
 * end of STRH (register)
 *******************************************************************/

op sttr_wbo( 0b10111000000[11] : sext imm[9] : 0b10[2] : rn[5] : rt[5] );
sttr_wbo.var format : {char const*} = {"base,302"};

sttr_wbo.disasm = {
  sink << "sttr\t" << DisasmGZWR(rt) << ", [" << DisasmGSXR(rn) << "," << DisasmI(imm) << "]";
};

op sttr_xbo( 0b11111000000[11] : sext imm[9] : 0b10[2] : rn[5] : rt[5] );
sttr_xbo.var format : {char const*} = {"base,338"};

sttr_xbo.disasm = {
  sink << "sttr\t" << DisasmGZXR(rt) << ", [" << DisasmGSXR(rn) << "," << DisasmI(imm) << "]";
};

op sttrb_wbo( 0b00111000000[11] : sext imm[9] : 0b10[2] : rn[5] : rt[5] );
sttrb_wbo.var format : {char const*} = {"base,303"};

sttrb_wbo.disasm = {
  sink << "sttrb\t" << DisasmGZWR(rt) << ", [" << DisasmGSXR(rn) << "," << DisasmI(imm) << "]";
};

op sttrh_wbo( 0b01111000000[11] : sext imm[9] : 0b10[2] : rn[5] : rt[5] );
sttrh_wbo.var format : {char const*} = {"base,304"};

sttrh_wbo.disasm = {
  sink << "sttrh\t" << DisasmGZWR(rt) << ", [" << DisasmGSXR(rn) << "," << DisasmI(imm) << "]";
};

/*******************************************************************
 * STUR
 *
 * Store register (unscaled offset)
 */

op stur_wbo( 0b10111000000[11] : sext imm[9] : 0b00[2] : rn[5] : rt[5] );
stur_wbo.var format : {char const*} = {"base,296"};

stur_wbo.disasm = {
  sink << "str\t" << DisasmGZWR(rt) << ", [" << DisasmGSXR(rn) << "," << DisasmI(imm) << "]";
};

stur_wbo.execute = {
  typedef typename ARCH::U32 U32;
  typedef typename ARCH::U64 U64;
  typedef typename ARCH::S64 S64;
  
  U64 addr( cpu.GetGSR(rn) + U64(S64(imm)) );
  U32 data( cpu.GetGZR(rt) );
  cpu.MemWrite32(addr, data);
};

op stur_xbo( 0b11111000000[11] : sext imm[9] : 0b00[2] : rn[5] : rt[5] );
stur_xbo.var format : {char const*} = {"base,333"};

stur_xbo.disasm = {
  sink << "str\t" << DisasmGZXR(rt) << ", [" << DisasmGSXR(rn) << "," << DisasmI(imm) << "]";
};

stur_xbo.execute = {
  typedef typename ARCH::U64 U64;
  typedef typename ARCH::S64 S64;
  
  U64 addr( cpu.GetGSR(rn) + U64(S64(imm)) );
  U64 data( cpu.GetGZR(rt) );
  cpu.MemWrite64(addr, data);
};

/*
 * end of STUR
 *******************************************************************/

/*******************************************************************
 * STURB
 *
 * Store register byte (unscaled offset)
 */

op sturb_wbo( 0b00111000000[11] : sext imm[9] : 0b00[2] : rn[5] : rt[5] );
sturb_wbo.var format : {char const*} = {"base,307"};

sturb_wbo.disasm = {
  sink << "strb\t" << DisasmGZWR(rt) << ", [" << DisasmGSXR(rn) << "," << DisasmI(imm) << "]";
};

sturb_wbo.execute = {
  typedef typename ARCH::U8 U8;
  typedef typename ARCH::U64 U64;
  typedef typename ARCH::S64 S64;
  
  U64 addr( cpu.GetGSR(rn) + U64(S64(imm)) );
  U8 data( cpu.GetGZR(rt) );
  cpu.MemWrite8(addr, data);
};

/*
 * end of STURB
 *******************************************************************/

/*******************************************************************
 * STURH
 *
 * Store register halfword (unscaled offset)
 */

op sturh_wbo( 0b01111000000[11] : sext imm[9] : 0b00[2] : rn[5] : rt[5] );
sturh_wbo.var format : {char const*} = {"base,310"};

sturh_wbo.disasm = {
  sink << "strh\t" << DisasmGZWR(rt) << ", [" << DisasmGSXR(rn) << "," << DisasmI(imm) << "]";
};

sturh_wbo.execute = {
  typedef typename ARCH::U16 U16;
  typedef typename ARCH::U64 U64;
  typedef typename ARCH::S64 S64;
  
  U64 addr( cpu.GetGSR(rn) + U64(S64(imm)) );
  U16 data( cpu.GetGZR(rt) );
  cpu.MemWrite16(addr, data);
};

/*
 * end of STURB
 *******************************************************************/

/*******************************************************************
 * STXP
 *
 * Store exclusive pair of registers, returning status
 */

op stxp_w( 0b10001000001[11] : rs[5] : 0b0[1] : rt2[5] : rn[5] : rt[5] );
stxp_w.var format : {char const*} = {"base,169"};

stxp_w.disasm = {
  sink << "stxp\t" << DisasmGZWR(rs) << ", " << DisasmGZWR(rt) << ", " << DisasmGZWR(rt2) << ", [" << DisasmGSXR(rn) << "]";
};

stxp_w.execute = {
  typedef typename ARCH::U32 U32;
  typedef typename ARCH::U64 U64;
  
  U64 addr( cpu.GetGSR(rn) );
  U32 data0( cpu.GetGZR(rt) ), data1( cpu.GetGZR(rt2) );
  if (cpu.ExclusiveMonitorsPass(addr, 8)) {
    cpu.MemWrite32( addr + U64(0), data0 );
    cpu.MemWrite32( addr + U64(4), data1 );
    cpu.SetGZR(rs, U64(0));
  } else {
    cpu.SetGZR(rs, U64(1));
  }
};

op stxp_x( 0b11001000001[11] : rs[5] : 0b0[1] : rt2[5] : rn[5] : rt[5] );
stxp_x.var format : {char const*} = {"base,223"};

stxp_x.disasm = {
  sink << "stxp\t" << DisasmGZWR(rs) << ", " << DisasmGZXR(rt) << ", " << DisasmGZXR(rt2) << ", [" << DisasmGSXR(rn) << "]";
};

stxp_x.execute = {
  typedef typename ARCH::U64 U64;
  
  U64 addr( cpu.GetGSR(rn) );
  U64 data0( cpu.GetGZR(rt) ), data1( cpu.GetGZR(rt2) );
  if (cpu.ExclusiveMonitorsPass(addr, 16)) {
    cpu.MemWrite64( addr + U64(0), data0 );
    cpu.MemWrite64( addr + U64(8), data1 );
    cpu.SetGZR(rs, U64(0));
  } else {
    cpu.SetGZR(rs, U64(1));
  }
};

/*
 * end of STXP
 *******************************************************************/

/*******************************************************************
 * STXR
 *
 * Store exclusive register, returning status
 */

op stxr_w( 0b10001000000[11] : rs[5] : 0b0[1] : rt2[5] : rn[5] : rt[5] );
stxr_w.var format : {char const*} = {"base,217"};

stxr_w.disasm = {
  sink << "stxr\t" << DisasmGZWR(rs) << ", " << DisasmGZWR(rt) << ", [" << DisasmGSXR(rn) << "]";
};

stxr_w.execute = {
  typedef typename ARCH::U32 U32;
  typedef typename ARCH::U64 U64;
  
  U64 addr = cpu.GetGSR(rn);
  if (cpu.ExclusiveMonitorsPass(addr, 4)) {
    cpu.MemWrite32( addr, U32(cpu.GetGZR(rt)) );
    cpu.SetGZR(rs, U64(0));
  } else {
    cpu.SetGZR(rs, U64(1));
  }
};

op stxr_x( 0b11001000000[11] : rs[5] : 0b0[1] : rt2[5] : rn[5] : rt[5] );
stxr_x.var format : {char const*} = {"base,225"};

stxr_x.disasm = {
  sink << "stxr\t" << DisasmGZWR(rs) << ", " << DisasmGZXR(rt) << ", [" << DisasmGSXR(rn) << "]";
};

stxr_x.execute = {
  typedef typename ARCH::U64 U64;
  
  U64 addr = cpu.GetGSR(rn);
  if (cpu.ExclusiveMonitorsPass(addr, 8)) {
    cpu.MemWrite64( addr, cpu.GetGZR(rt) );
    cpu.SetGZR(rs, U64(0));
  } else {
    cpu.SetGZR(rs, U64(1));
  }
};

/*
 * end of STXR
 *******************************************************************/

/*******************************************************************
 * STXRB
 *
 * Store exclusive register byte, returning status
 */

op stxrb_w( 0b00001000000[11] : rs[5] : 0b0[1] : rt2[5] : rn[5] : rt[5] );
stxrb_w.var format : {char const*} = {"base,218"};

stxrb_w.disasm = {
  sink << "stxrb\t" << DisasmGZWR(rs) << ", " << DisasmGZWR(rt) << ", [" << DisasmGSXR(rn) << "]";
};

stxrb_w.execute = {
  typedef typename ARCH::U8  U8;
  typedef typename ARCH::U64 U64;
  
  U64 addr = cpu.GetGSR(rn);
  if (cpu.ExclusiveMonitorsPass(addr, 1)) {
    cpu.MemWrite8( addr, U8(cpu.GetGZR(rt)) );
    cpu.SetGZR(rs, U64(0));
  } else {
    cpu.SetGZR(rs, U64(1));
  }
};

/*
 * end of STXRB
 *******************************************************************/

/*******************************************************************
 * STXRH
 *
 * Store exclusive register halfword, returning status
 */

op stxrh_w( 0b01001000000[11] : rs[5] : 0b0[1] : rt2[5] : rn[5] : rt[5] );
stxrh_w.var format : {char const*} = {"base,219"};

stxrh_w.disasm = {
  sink << "stxrh\t" << DisasmGZWR(rs) << ", " << DisasmGZWR(rt) << ", [" << DisasmGSXR(rn) << "]";
};

stxrh_w.execute = {
  typedef typename ARCH::U16 U16;
  typedef typename ARCH::U64 U64;
  
  U64 addr = cpu.GetGSR(rn);
  if (cpu.ExclusiveMonitorsPass(addr, 2)) {
    cpu.MemWrite16( addr, U16(cpu.GetGZR(rt)) );
    cpu.SetGZR(rs, U64(0));
  } else {
    cpu.SetGZR(rs, U64(1));
  }
};

/*
 * end of STXRH
 *******************************************************************/

/*******************************************************************
 * SUB (extended register)
 * Subtract (extended register): Rd = Rn - LSL(extend(Rm), amount)
 */

op sub_wsxtb( 0b01001011001[11] : rm[5] : 0b100[3] : imm[3] : rn[5] : rd[5] );
sub_wsxtb.var reject : {Reject} = {imm >= 5}, format : {char const*} = {"base,377"};

sub_wsxtb.disasm = {
  sink << "sub\t" << DisasmGSWR(rd) << ", " << DisasmGSWR(rn) << ", " << DisasmGZWR(rm) << ", sxtb" << DisasmINZ(" ", imm);
};

sub_wsxtb.execute = {
  typedef typename ARCH::S8 S8;
  typedef typename ARCH::S32 S32;
  typedef typename ARCH::U32 U32;
  
  U32 op1( cpu.GetGSR(rn) ), op2( S32(S8(cpu.GetGZR(rm))) << imm ), res = op1 - op2;
  cpu.SetGSR(rd, res);
};

op sub_wsxth( 0b01001011001[11] : rm[5] : 0b101[3] : imm[3] : rn[5] : rd[5] );
sub_wsxth.var reject : {Reject} = {imm >= 5}, format : {char const*} = {"base,381"};

sub_wsxth.disasm = {
  sink << "sub\t" << DisasmGSWR(rd) << ", " << DisasmGSWR(rn) << ", " << DisasmGZWR(rm) << ", sxth" << DisasmINZ(" ", imm);
};

sub_wsxth.execute = {
  typedef typename ARCH::S16 S16;
  typedef typename ARCH::S32 S32;
  typedef typename ARCH::U32 U32;
  
  U32 op1( cpu.GetGSR(rn) ), op2( S32(S16(cpu.GetGZR(rm))) << imm ), res = op1 - op2;
  cpu.SetGSR(rd, res);
};

op sub_wsxtw( 0b01001011001[11] : rm[5] : 0b110[3] : imm[3] : rn[5] : rd[5] );
sub_wsxtw.var reject : {Reject} = {imm >= 5}, format : {char const*} = {"base,385"};

sub_wsxtw.disasm = {
  sink << "sub\t" << DisasmGSWR(rd) << ", " << DisasmGSWR(rn) << ", " << DisasmGZWR(rm) << ", sxtw" << DisasmINZ(" ", imm);
};

sub_wsxtw.execute = {
  typedef typename ARCH::S32 S32;
  typedef typename ARCH::U32 U32;
  
  U32 op1( cpu.GetGSR(rn) ), op2( S32(S32(cpu.GetGZR(rm))) << imm ), res = op1 - op2;
  cpu.SetGSR(rd, res);
};

op sub_wsxtx( 0b01001011001[11] : rm[5] : 0b111[3] : imm[3] : rn[5] : rd[5] );
sub_wsxtx.var reject : {Reject} = {imm >= 5}, format : {char const*} = {"base,389"};

sub_wsxtx.disasm = {
  sink << "sub\t" << DisasmGSWR(rd) << ", " << DisasmGSWR(rn) << ", " << DisasmGZWR(rm) << ", sxtx" << DisasmINZ(" ", imm);
};

sub_wsxtx.execute = {
  typedef typename ARCH::S64 S64;
  typedef typename ARCH::S32 S32;
  typedef typename ARCH::U32 U32;
  
  U32 op1( cpu.GetGSR(rn) ), op2( S32(S64(cpu.GetGZR(rm))) << imm ), res = op1 - op2;
  cpu.SetGSR(rd, res);
};

op sub_wuxtb( 0b01001011001[11] : rm[5] : 0b000[3] : imm[3] : rn[5] : rd[5] );
sub_wuxtb.var reject : {Reject} = {imm >= 5}, format : {char const*} = {"base,393"};

sub_wuxtb.disasm = {
  sink << "sub\t" << DisasmGSWR(rd) << ", " << DisasmGSWR(rn) << ", " << DisasmGZWR(rm) << ", uxtb" << DisasmINZ(" ", imm);
};

sub_wuxtb.execute = {
  typedef typename ARCH::U8 U8;
  typedef typename ARCH::U32 U32;
  
  U32 op1( cpu.GetGSR(rn) ), op2( U32(U8(cpu.GetGZR(rm))) << imm ), res = op1 - op2;
  cpu.SetGSR(rd, res);
};

op sub_wuxth( 0b01001011001[11] : rm[5] : 0b001[3] : imm[3] : rn[5] : rd[5] );
sub_wuxth.var reject : {Reject} = {imm >= 5}, format : {char const*} = {"base,397"};

sub_wuxth.disasm = {
  sink << "sub\t" << DisasmGSWR(rd) << ", " << DisasmGSWR(rn) << ", " << DisasmGZWR(rm) << ", uxth" << DisasmINZ(" ", imm);
};

sub_wuxth.execute = {
  typedef typename ARCH::U16 U16;
  typedef typename ARCH::U32 U32;
  
  U32 op1( cpu.GetGSR(rn) ), op2( U32(U16(cpu.GetGZR(rm))) << imm ), res = op1 - op2;
  cpu.SetGSR(rd, res);
};

op sub_wuxtw( 0b01001011001[11] : rm[5] : 0b010[3] : imm[3] : rn[5] : rd[5] );
sub_wuxtw.var reject : {Reject} = {imm >= 5}, format : {char const*} = {"base,402"};

sub_wuxtw.disasm = {
  sink << "sub\t" << DisasmGSWR(rd) << ", " << DisasmGSWR(rn) << ", " << DisasmGZWR(rm) << ", uxtw" << DisasmINZ(" ", imm);
};

sub_wuxtw.execute = {
  typedef typename ARCH::U32 U32;
  
  U32 op1( cpu.GetGSR(rn) ), op2( U32(U32(cpu.GetGZR(rm))) << imm ), res = op1 - op2;
  cpu.SetGSR(rd, res);
};

op sub_wuxtx( 0b01001011001[11] : rm[5] : 0b011[3] : imm[3] : rn[5] : rd[5] );
sub_wuxtx.var reject : {Reject} = {imm >= 5}, format : {char const*} = {"base,405"};

sub_wuxtx.disasm = {
  sink << "sub\t" << DisasmGSWR(rd) << ", " << DisasmGSWR(rn) << ", " << DisasmGZWR(rm) << ", uxtx" << DisasmINZ(" ", imm);
};

sub_wuxtx.execute = {
  typedef typename ARCH::U64 U64;
  typedef typename ARCH::U32 U32;
  
  U32 op1( cpu.GetGSR(rn) ), op2( U32(U64(cpu.GetGZR(rm))) << imm ), res = op1 - op2;
  cpu.SetGSR(rd, res);
};

op sub_xsxtb( 0b11001011001[11] : rm[5] : 0b100[3] : imm[3] : rn[5] : rd[5] );
sub_xsxtb.var reject : {Reject} = {imm >= 5}, format : {char const*} = {"base,409"};

sub_xsxtb.disasm = {
  sink << "sub\t" << DisasmGSXR(rd) << ", " << DisasmGSXR(rn) << ", " << DisasmGZWR(rm) << ", sxtb" << DisasmINZ(" ", imm);
};

sub_xsxtb.execute = {
  typedef typename ARCH::S8 S8;
  typedef typename ARCH::S64 S64;
  typedef typename ARCH::U64 U64;
  
  U64 op1( cpu.GetGSR(rn) ), op2( S64(S8(cpu.GetGZR(rm))) << imm ), res = op1 - op2;
  cpu.SetGSR(rd, res);
};

op sub_xsxth( 0b11001011001[11] : rm[5] : 0b101[3] : imm[3] : rn[5] : rd[5] );
sub_xsxth.var reject : {Reject} = {imm >= 5}, format : {char const*} = {"base,413"};

sub_xsxth.disasm = {
  sink << "sub\t" << DisasmGSXR(rd) << ", " << DisasmGSXR(rn) << ", " << DisasmGZWR(rm) << ", sxth" << DisasmINZ(" ", imm);
};

sub_xsxth.execute = {
  typedef typename ARCH::S16 S16;
  typedef typename ARCH::S64 S64;
  typedef typename ARCH::U64 U64;
  
  U64 op1( cpu.GetGSR(rn) ), op2( S64(S16(cpu.GetGZR(rm))) << imm ), res = op1 - op2;
  cpu.SetGSR(rd, res);
};

op sub_xsxtw( 0b11001011001[11] : rm[5] : 0b110[3] : imm[3] : rn[5] : rd[5] );
sub_xsxtw.var reject : {Reject} = {imm >= 5}, format : {char const*} = {"base,417"};

sub_xsxtw.disasm = {
  sink << "sub\t" << DisasmGSXR(rd) << ", " << DisasmGSXR(rn) << ", " << DisasmGZWR(rm) << ", sxtw" << DisasmINZ(" ", imm);
};

sub_xsxtw.execute = {
  typedef typename ARCH::S32 S32;
  typedef typename ARCH::S64 S64;
  typedef typename ARCH::U64 U64;
  
  U64 op1( cpu.GetGSR(rn) ), op2( S64(S32(cpu.GetGZR(rm))) << imm ), res = op1 - op2;
  cpu.SetGSR(rd, res);
};

op sub_xsxtx( 0b11001011001[11] : rm[5] : 0b111[3] : imm[3] : rn[5] : rd[5] );
sub_xsxtx.var reject : {Reject} = {imm >= 5}, format : {char const*} = {"base,433"};

sub_xsxtx.disasm = {
  sink << "sub\t" << DisasmGSXR(rd) << ", " << DisasmGSXR(rn) << ", " << DisasmGZXR(rm) << ", sxtx" << DisasmINZ(" ", imm);
};

sub_xsxtx.execute = {
  typedef typename ARCH::S64 S64;
  typedef typename ARCH::U64 U64;
  
  U64 op1( cpu.GetGSR(rn) ), op2( S64(S64(cpu.GetGZR(rm))) << imm ), res = op1 - op2;
  cpu.SetGSR(rd, res);
};

op sub_xuxtb( 0b11001011001[11] : rm[5] : 0b000[3] : imm[3] : rn[5] : rd[5] );
sub_xuxtb.var reject : {Reject} = {imm >= 5}, format : {char const*} = {"base,421"};

sub_xuxtb.disasm = {
  sink << "sub\t" << DisasmGSXR(rd) << ", " << DisasmGSXR(rn) << ", " << DisasmGZWR(rm) << ", uxtb" << DisasmINZ(" ", imm);
};

sub_xuxtb.execute = {
  typedef typename ARCH::U8 U8;
  typedef typename ARCH::U64 U64;
  
  U64 op1( cpu.GetGSR(rn) ), op2( U64(U8(cpu.GetGZR(rm))) << imm ), res = op1 - op2;
  cpu.SetGSR(rd, res);
};

op sub_xuxth( 0b11001011001[11] : rm[5] : 0b001[3] : imm[3] : rn[5] : rd[5] );
sub_xuxth.var reject : {Reject} = {imm >= 5}, format : {char const*} = {"base,425"};

sub_xuxth.disasm = {
  sink << "sub\t" << DisasmGSXR(rd) << ", " << DisasmGSXR(rn) << ", " << DisasmGZWR(rm) << ", uxth" << DisasmINZ(" ", imm);
};

sub_xuxth.execute = {
  typedef typename ARCH::U16 U16;
  typedef typename ARCH::U64 U64;
  
  U64 op1( cpu.GetGSR(rn) ), op2( U64(U16(cpu.GetGZR(rm))) << imm ), res = op1 - op2;
  cpu.SetGSR(rd, res);
};

op sub_xuxtw( 0b11001011001[11] : rm[5] : 0b010[3] : imm[3] : rn[5] : rd[5] );
sub_xuxtw.var reject : {Reject} = {imm >= 5}, format : {char const*} = {"base,429"};

sub_xuxtw.disasm = {
  sink << "sub\t" << DisasmGSXR(rd) << ", " << DisasmGSXR(rn) << ", " << DisasmGZWR(rm) << ", uxtw" << DisasmINZ(" ", imm);
};

sub_xuxtw.execute = {
  typedef typename ARCH::U32 U32;
  typedef typename ARCH::U64 U64;
  
  U64 op1( cpu.GetGSR(rn) ), op2( U64(U32(cpu.GetGZR(rm))) << imm ), res = op1 - op2;
  cpu.SetGSR(rd, res);
};

op sub_xuxtx( 0b11001011001[11] : rm[5] : 0b011[3] : imm[3] : rn[5] : rd[5] );
sub_xuxtx.var reject : {Reject} = {imm >= 5}, format : {char const*} = {"base,435"};

sub_xuxtx.disasm = {
  sink << "sub\t" << DisasmGSXR(rd) << ", " << DisasmGSXR(rn) << ", " << DisasmGZXR(rm) << ", uxtx" << DisasmINZ(" ", imm);
};

sub_xuxtx.execute = {
  typedef typename ARCH::U64 U64;
  
  U64 op1( cpu.GetGSR(rn) ), op2( U64(U64(cpu.GetGZR(rm))) << imm ), res = op1 - op2;
  cpu.SetGSR(rd, res);
};

/*
 * end of SUB (extended register)
 *******************************************************************/

/*******************************************************************
 * SUB (immediate)
 *
 * Sub (immediate): Rd = Rn - shift(imm)
 */

op sub_wi( 0b010100010[9] : shl12[1] : imm0[12] : rn[5] : rd[5] );
sub_wi.var imm : {uint32_t} = {shl12 ? (imm0 << 12) : imm0}, format : {char const*} = {"base,21"};

sub_wi.disasm = {
  sink << "sub\t" << DisasmGSWR(rd) << ", " << DisasmGSWR(rn) << ", " << DisasmI(imm,16/*?*/);
};

sub_wi.execute = {
  typedef typename ARCH::U32 U32;
  
  U32 op1(cpu.GetGSR(rn)), op2(imm), res = op1 - op2;
  cpu.SetGSR(rd, res);
};

op sub_xi( 0b110100010[9] : shl12[1] : imm0[12] : rn[5] : rd[5] );
sub_xi.var imm : {uint32_t} = {shl12 ? (imm0 << 12) : imm0}, format : {char const*} = {"base,30"};

sub_xi.disasm = {
  sink << "sub\t" << DisasmGSXR(rd) << ", " << DisasmGSXR(rn) << ", " << DisasmI(imm,16/*?*/);
};

sub_xi.execute = {
  typedef typename ARCH::U64 U64;
  
  U64 op1(cpu.GetGSR(rn)), op2(imm), res = op1 - op2;
  cpu.SetGSR(rd, res);
};

/*
 * end of SUB (immediate)
 *******************************************************************/

/*******************************************************************
 * SUB (shifted register)
 * 
 * Subtract (shifted register): Rd = Rn - shift(Rm, amount)
 */

op sub_wlsl( 0b01001011000[11] : rm[5] : 0b0[1] : imm[5] : rn[5] : rd[5] );
sub_wlsl.var format : {char const*} = {"base,186"};

sub_wlsl.disasm = {
  if (rn == 31)
    sink << "neg\t" << DisasmGZWR(rd) << ", " << DisasmGZWR(rm) << DisasmINZ(", lsl ",imm);
  else
    sink << "sub\t" << DisasmGZWR(rd) << ", " << DisasmGZWR(rn) << ", " << DisasmGZWR(rm) << DisasmINZ(", lsl ",imm);
};

sub_wlsl.execute = {
  typedef typename ARCH::U32 U32;
  
  U32 op1( cpu.GetGZR(rn) ), op2( cpu.GetGZR(rm) << imm ), res = op1 - op2;
  cpu.SetGZR(rd, res);
};

op sub_wlsr( 0b01001011010[11] : rm[5] : 0b0[1] : imm[5] : rn[5] : rd[5] );
sub_wlsr.var format : {char const*} = {"base,201"};

sub_wlsr.disasm = {
  if (rn == 31)
    sink << "neg\t" << DisasmGZWR(rd) << ", " << DisasmGZWR(rm) << ", lsr " << DisasmI(imm);
  else
    sink << "sub\t" << DisasmGZWR(rd) << ", " << DisasmGZWR(rn) << ", " << DisasmGZWR(rm) << ", lsr " << DisasmI(imm);
};

sub_wlsr.execute = {
  typedef typename ARCH::U32 U32;
  
  U32 op1( cpu.GetGZR(rn) ), op2( cpu.GetGZR(rm) >> imm ), res = op1 - op2;
  cpu.SetGZR(rd, res);
};

op sub_wasr( 0b01001011100[11] : rm[5] : 0b0[1] : imm[5] : rn[5] : rd[5] );
sub_wasr.var format : {char const*} = {"base,177"};

sub_wasr.disasm = {
  if (rn == 31)
    sink << "neg\t" << DisasmGZWR(rd) << ", " << DisasmGZWR(rm) << ", asr " << DisasmI(imm);
  else
    sink << "sub\t" << DisasmGZWR(rd) << ", " << DisasmGZWR(rn) << ", " << DisasmGZWR(rm) << ", asr " << DisasmI(imm);
};

sub_wasr.execute = {
  typedef typename ARCH::U32 U32;
  typedef typename ARCH::S32 S32;
  
  U32 op1( cpu.GetGZR(rn) ), op2( S32(cpu.GetGZR(rm)) >> imm ), res = op1 - op2;
  cpu.SetGZR(rd, res);
};

op sub_xlsl( 0b11001011000[11] : rm[5] : imm[6] : rn[5] : rd[5] );
sub_xlsl.var format : {char const*} = {"base,129"};

sub_xlsl.disasm = {
  if (rn == 31)
    sink << "neg\t" << DisasmGZXR(rd) << ", " << DisasmGZXR(rm) << DisasmINZ(", lsl ",imm);
  else
    sink << "sub\t" << DisasmGZXR(rd) << ", " << DisasmGZXR(rn) << ", " << DisasmGZXR(rm) << DisasmINZ(", lsl ",imm);
};

sub_xlsl.execute = {
  typedef typename ARCH::U64 U64;
  
  U64 op1( cpu.GetGZR(rn) ), op2( cpu.GetGZR(rm) << imm ), res = op1 - op2;
  cpu.SetGZR(rd, res);
};

op sub_xlsr( 0b11001011010[11] : rm[5] : imm[6] : rn[5] : rd[5] );
sub_xlsr.var format : {char const*} = {"base,141"};

sub_xlsr.disasm = {
  if (rn == 31)
    sink << "neg\t" << DisasmGZXR(rd) << ", " << DisasmGZXR(rm) << ", lsr " << DisasmI(imm);
  else
    sink << "sub\t" << DisasmGZXR(rd) << ", " << DisasmGZXR(rn) << ", " << DisasmGZXR(rm) << ", lsr " << DisasmI(imm);
};

sub_xlsr.execute = {
  typedef typename ARCH::U64 U64;
  
  U64 op1( cpu.GetGZR(rn) ), op2( cpu.GetGZR(rm) >> imm ), res = op1 - op2;
  cpu.SetGZR(rd, res);
};

op sub_xasr( 0b11001011100[11] : rm[5] : imm[6] : rn[5] : rd[5] );
sub_xasr.var format : {char const*} = {"base,117"};

sub_xasr.disasm = {
  if (rn == 31)
    sink << "neg\t" << DisasmGZXR(rd) << ", " << DisasmGZXR(rm) << ", asr " << DisasmI(imm);
  else
    sink << "sub\t" << DisasmGZXR(rd) << ", " << DisasmGZXR(rn) << ", " << DisasmGZXR(rm) << ", asr " << DisasmI(imm);
};

sub_xasr.execute = {
  typedef typename ARCH::U64 U64;
  typedef typename ARCH::S64 S64;
  
  U64 op1( cpu.GetGZR(rn) ), op2( S64(cpu.GetGZR(rm)) >> imm ), res = op1 - op2;
  cpu.SetGZR(rd, res);
};

/*
 * end of SUB (shifted register)
 *******************************************************************/

/*******************************************************************
 * SUBS (extended register)
 * 
 * Subtract (extended register), setting the condition flags: Rd = Rn - LSL(extend(Rm), amount)
 */

op subs_wuxtb( 0b01101011001[11] : rm[5] : 0b000[3] : imm[3] : rn[5] : rd[5] );
subs_wuxtb.var reject : {Reject} = {imm >= 5}, format : {char const*} = {"base,394"};

subs_wuxtb.disasm = {
  if (rd == 31)
    sink << "cmp\t" << DisasmGSWR(rn) << ", " << DisasmGZWR(rm) << ", uxtb" << DisasmINZ(" ", imm);
  else
    sink << "subs\t" << DisasmGZWR(rd) << ", " << DisasmGSWR(rn) << ", " << DisasmGZWR(rm) << ", uxtb" << DisasmINZ(" ", imm);
};

subs_wuxtb.execute = {
  typedef typename ARCH::U8 U8;
  typedef typename ARCH::U32 U32;
  typedef typename ARCH::S32 S32;
  
  U32 op1( cpu.GetGSR(rn) ), op2( U32(U8(cpu.GetGZR(rm))) << imm ), res = op1 - op2;
  cpu.SetGZR(rd, res);
  cpu.SetNZCV( S32(res) < S32(0), op1 == op2, op1 >= op2, (S32(res) < S32(0)) xor (S32(op1) < S32(op2)) );
};

op subs_wuxth( 0b01101011001[11] : rm[5] : 0b001[3] : imm[3] : rn[5] : rd[5] );
subs_wuxth.var reject : {Reject} = {imm >= 5}, format : {char const*} = {"base,398"};

subs_wuxth.disasm = {
  if (rd == 31)
    sink << "cmp\t" << DisasmGSWR(rn) << ", " << DisasmGZWR(rm) << ", uxth" << DisasmINZ(" ", imm);
  else
    sink << "subs\t" << DisasmGZWR(rd) << ", " << DisasmGSWR(rn) << ", " << DisasmGZWR(rm) << ", uxth" << DisasmINZ(" ", imm);
};

subs_wuxth.execute = {
  typedef typename ARCH::U16 U16;
  typedef typename ARCH::U32 U32;
  typedef typename ARCH::S32 S32;
  
  U32 op1( cpu.GetGSR(rn) ), op2( U32(U16(cpu.GetGZR(rm))) << imm ), res = op1 - op2;
  cpu.SetGZR(rd, res);
  cpu.SetNZCV( S32(res) < S32(0), op1 == op2, op1 >= op2, (S32(res) < S32(0)) xor (S32(op1) < S32(op2)) );
};

op subs_wuxtw( 0b01101011001[11] : rm[5] : 0b010[3] : imm[3] : rn[5] : rd[5] );
subs_wuxtw.var reject : {Reject} = {imm >= 5}, format : {char const*} = {"base,401"};

subs_wuxtw.disasm = {
  if (rd == 31)
    sink << "cmp\t" << DisasmGSWR(rn) << ", " << DisasmGZWR(rm) << ", uxtw" << DisasmINZ(" ", imm);
  else
    sink << "subs\t" << DisasmGZWR(rd) << ", " << DisasmGSWR(rn) << ", " << DisasmGZWR(rm) << ", uxtw" << DisasmINZ(" ", imm);
};

subs_wuxtw.execute = {
  typedef typename ARCH::U32 U32;
  typedef typename ARCH::S32 S32;
  
  U32 op1( cpu.GetGSR(rn) ), op2( U32(U32(cpu.GetGZR(rm))) << imm ), res = op1 - op2;
  cpu.SetGZR(rd, res);
  cpu.SetNZCV( S32(res) < S32(0), op1 == op2, op1 >= op2, (S32(res) < S32(0)) xor (S32(op1) < S32(op2)) );
};

op subs_wuxtx( 0b01101011001[11] : rm[5] : 0b011[3] : imm[3] : rn[5] : rd[5] );
subs_wuxtx.var reject : {Reject} = {imm >= 5}, format : {char const*} = {"base,406"};

subs_wuxtx.disasm = {
  if (rd == 31)
    sink << "cmp\t" << DisasmGSWR(rn) << ", " << DisasmGZWR(rm) << ", uxtx" << DisasmINZ(" ", imm);
  else
    sink << "subs\t" << DisasmGZWR(rd) << ", " << DisasmGSWR(rn) << ", " << DisasmGZWR(rm) << ", uxtx" << DisasmINZ(" ", imm);
};

subs_wuxtx.execute = {
  typedef typename ARCH::U64 U64;
  typedef typename ARCH::U32 U32;
  typedef typename ARCH::S32 S32;
  
  U32 op1( cpu.GetGSR(rn) ), op2( U32(U64(cpu.GetGZR(rm))) << imm ), res = op1 - op2;
  cpu.SetGZR(rd, res);
  cpu.SetNZCV( S32(res) < S32(0), op1 == op2, op1 >= op2, (S32(res) < S32(0)) xor (S32(op1) < S32(op2)) );
};

op subs_wsxtb( 0b01101011001[11] : rm[5] : 0b100[3] : imm[3] : rn[5] : rd[5] );
subs_wsxtb.var reject : {Reject} = {imm >= 5}, format : {char const*} = {"base,378"};

subs_wsxtb.disasm = {
  if (rd == 31)
    sink << "cmp\t" << DisasmGSWR(rn) << ", " << DisasmGZWR(rm) << ", sxtb" << DisasmINZ(" ", imm);
  else
    sink << "subs\t" << DisasmGZWR(rd) << ", " << DisasmGSWR(rn) << ", " << DisasmGZWR(rm) << ", sxtb" << DisasmINZ(" ", imm);
};

subs_wsxtb.execute = {
  typedef typename ARCH::S8 S8;
  typedef typename ARCH::S32 S32;
  typedef typename ARCH::U32 U32;
  
  U32 op1( cpu.GetGSR(rn) ), op2( S32(S8(cpu.GetGZR(rm))) << imm ), res = op1 - op2;
  cpu.SetGZR(rd, res);
  cpu.SetNZCV( S32(res) < S32(0), op1 == op2, op1 >= op2, (S32(res) < S32(0)) xor (S32(op1) < S32(op2)) );
};

op subs_wsxth( 0b01101011001[11] : rm[5] : 0b101[3] : imm[3] : rn[5] : rd[5] );
subs_wsxth.var reject : {Reject} = {imm >= 5}, format : {char const*} = {"base,382"};

subs_wsxth.disasm = {
  if (rd == 31)
    sink << "cmp\t" << DisasmGSWR(rn) << ", " << DisasmGZWR(rm) << ", sxth" << DisasmINZ(" ", imm);
  else
    sink << "subs\t" << DisasmGZWR(rd) << ", " << DisasmGSWR(rn) << ", " << DisasmGZWR(rm) << ", sxth" << DisasmINZ(" ", imm);
};

subs_wsxth.execute = {
  typedef typename ARCH::S16 S16;
  typedef typename ARCH::S32 S32;
  typedef typename ARCH::U32 U32;
  
  U32 op1( cpu.GetGSR(rn) ), op2( S32(S16(cpu.GetGZR(rm))) << imm ), res = op1 - op2;
  cpu.SetGZR(rd, res);
  cpu.SetNZCV( S32(res) < S32(0), op1 == op2, op1 >= op2, (S32(res) < S32(0)) xor (S32(op1) < S32(op2)) );
};

op subs_wsxtw( 0b01101011001[11] : rm[5] : 0b110[3] : imm[3] : rn[5] : rd[5] );
subs_wsxtw.var reject : {Reject} = {imm >= 5}, format : {char const*} = {"base,386"};

subs_wsxtw.disasm = {
  if (rd == 31)
    sink << "cmp\t" << DisasmGSWR(rn) << ", " << DisasmGZWR(rm) << ", sxtw" << DisasmINZ(" ", imm);
  else
    sink << "subs\t" << DisasmGZWR(rd) << ", " << DisasmGSWR(rn) << ", " << DisasmGZWR(rm) << ", sxtw" << DisasmINZ(" ", imm);
};

subs_wsxtw.execute = {
  typedef typename ARCH::S32 S32;
  typedef typename ARCH::U32 U32;
  
  U32 op1( cpu.GetGSR(rn) ), op2( S32(S32(cpu.GetGZR(rm))) << imm ), res = op1 - op2;
  cpu.SetGZR(rd, res);
  cpu.SetNZCV( S32(res) < S32(0), op1 == op2, op1 >= op2, (S32(res) < S32(0)) xor (S32(op1) < S32(op2)) );
};

op subs_wsxtx( 0b01101011001[11] : rm[5] : 0b111[3] : imm[3] : rn[5] : rd[5] );
subs_wsxtx.var reject : {Reject} = {imm >= 5}, format : {char const*} = {"base,390"};

subs_wsxtx.disasm = {
  if (rd == 31)
    sink << "cmp\t" << DisasmGSWR(rn) << ", " << DisasmGZWR(rm) << ", sxtx" << DisasmINZ(" ", imm);
  else
    sink << "subs\t" << DisasmGZWR(rd) << ", " << DisasmGSWR(rn) << ", " << DisasmGZWR(rm) << ", sxtx" << DisasmINZ(" ", imm);
};

subs_wsxtx.execute = {
  typedef typename ARCH::S64 S64;
  typedef typename ARCH::S32 S32;
  typedef typename ARCH::U32 U32;
  
  U32 op1( cpu.GetGSR(rn) ), op2( S32(S64(cpu.GetGZR(rm))) << imm ), res = op1 - op2;
  cpu.SetGZR(rd, res);
  cpu.SetNZCV( S32(res) < S32(0), op1 == op2, op1 >= op2, (S32(res) < S32(0)) xor (S32(op1) < S32(op2)) );
};

op subs_xuxtb( 0b11101011001[11] : rm[5] : 0b000[3] : imm[3] : rn[5] : rd[5] );
subs_xuxtb.var reject : {Reject} = {imm >= 5}, format : {char const*} = {"base,422"};

subs_xuxtb.disasm = {
  if (rd == 31)
    sink << "cmp\t" << DisasmGSXR(rn) << ", " << DisasmGZWR(rm) << ", uxtb" << DisasmINZ(" ", imm);
  else
    sink << "subs\t" << DisasmGZXR(rd) << ", " << DisasmGSXR(rn) << ", " << DisasmGZWR(rm) << ", uxtb" << DisasmINZ(" ", imm);
};

subs_xuxtb.execute = {
  typedef typename ARCH::U8 U8;
  typedef typename ARCH::U64 U64;
  typedef typename ARCH::S64 S64;
  
  U64 op1( cpu.GetGSR(rn) ), op2( U64(U8(cpu.GetGZR(rm))) << imm ), res = op1 - op2;
  cpu.SetGZR(rd, res);
  cpu.SetNZCV( S64(res) < S64(0), op1 == op2, op1 >= op2, (S64(res) < S64(0)) xor (S64(op1) < S64(op2)) );
};

op subs_xuxth( 0b11101011001[11] : rm[5] : 0b001[3] : imm[3] : rn[5] : rd[5] );
subs_xuxth.var reject : {Reject} = {imm >= 5}, format : {char const*} = {"base,426"};

subs_xuxth.disasm = {
  if (rd == 31)
    sink << "cmp\t" << DisasmGSXR(rn) << ", " << DisasmGZWR(rm) << ", uxth" << DisasmINZ(" ", imm);
  else
    sink << "subs\t" << DisasmGZXR(rd) << ", " << DisasmGSXR(rn) << ", " << DisasmGZWR(rm) << ", uxth" << DisasmINZ(" ", imm);
};

subs_xuxth.execute = {
  typedef typename ARCH::U16 U16;
  typedef typename ARCH::U64 U64;
  typedef typename ARCH::S64 S64;
  
  U64 op1( cpu.GetGSR(rn) ), op2( U64(U16(cpu.GetGZR(rm))) << imm ), res = op1 - op2;
  cpu.SetGZR(rd, res);
  cpu.SetNZCV( S64(res) < S64(0), op1 == op2, op1 >= op2, (S64(res) < S64(0)) xor (S64(op1) < S64(op2)) );
};

op subs_xuxtw( 0b11101011001[11] : rm[5] : 0b010[3] : imm[3] : rn[5] : rd[5] );
subs_xuxtw.var reject : {Reject} = {imm >= 5}, format : {char const*} = {"base,430"};

subs_xuxtw.disasm = {
  if (rd == 31)
    sink << "cmp\t" << DisasmGSXR(rn) << ", " << DisasmGZWR(rm) << ", uxtw" << DisasmINZ(" ", imm);
  else
    sink << "subs\t" << DisasmGZXR(rd) << ", " << DisasmGSXR(rn) << ", " << DisasmGZWR(rm) << ", uxtw" << DisasmINZ(" ", imm);
};

subs_xuxtw.execute = {
  typedef typename ARCH::U32 U32;
  typedef typename ARCH::U64 U64;
  typedef typename ARCH::S64 S64;
  
  U64 op1( cpu.GetGSR(rn) ), op2( U64(U32(cpu.GetGZR(rm))) << imm ), res = op1 - op2;
  cpu.SetGZR(rd, res);
  cpu.SetNZCV( S64(res) < S64(0), op1 == op2, op1 >= op2, (S64(res) < S64(0)) xor (S64(op1) < S64(op2)) );
};

op subs_xuxtx( 0b11101011001[11] : rm[5] : 0b011[3] : imm[3] : rn[5] : rd[5] );
subs_xuxtx.var reject : {Reject} = {imm >= 5}, format : {char const*} = {"base,437"};

subs_xuxtx.disasm = {
  if (rd == 31)
    sink << "cmp\t" << DisasmGSXR(rn) << ", " << DisasmGZXR(rm) << ", uxtx" << DisasmINZ(" ", imm);
  else
    sink << "subs\t" << DisasmGZXR(rd) << ", " << DisasmGSXR(rn) << ", " << DisasmGZXR(rm) << ", uxtx" << DisasmINZ(" ", imm);
};

subs_xuxtx.execute = {
  typedef typename ARCH::U64 U64;
  typedef typename ARCH::S64 S64;
  
  U64 op1( cpu.GetGSR(rn) ), op2( U64(U64(cpu.GetGZR(rm))) << imm ), res = op1 - op2;
  cpu.SetGZR(rd, res);
  cpu.SetNZCV( S64(res) < S64(0), op1 == op2, op1 >= op2, (S64(res) < S64(0)) xor (S64(op1) < S64(op2)) );
};

op subs_xsxtb( 0b11101011001[11] : rm[5] : 0b100[3] : imm[3] : rn[5] : rd[5] );
subs_xsxtb.var reject : {Reject} = {imm >= 5}, format : {char const*} = {"base,410"};

subs_xsxtb.disasm = {
  if (rd == 31)
    sink << "cmp\t" << DisasmGSXR(rn) << ", " << DisasmGZWR(rm) << ", sxtb" << DisasmINZ(" ", imm);
  else
    sink << "subs\t" << DisasmGZXR(rd) << ", " << DisasmGSXR(rn) << ", " << DisasmGZWR(rm) << ", sxtb" << DisasmINZ(" ", imm);
};

subs_xsxtb.execute = {
  typedef typename ARCH::S8 S8;
  typedef typename ARCH::S64 S64;
  typedef typename ARCH::U64 U64;
  
  U64 op1( cpu.GetGSR(rn) ), op2( S64(S8(cpu.GetGZR(rm))) << imm ), res = op1 - op2;
  cpu.SetGZR(rd, res);
  cpu.SetNZCV( S64(res) < S64(0), op1 == op2, op1 >= op2, (S64(res) < S64(0)) xor (S64(op1) < S64(op2)) );
};

op subs_xsxth( 0b11101011001[11] : rm[5] : 0b101[3] : imm[3] : rn[5] : rd[5] );
subs_xsxth.var reject : {Reject} = {imm >= 5}, format : {char const*} = {"base,414"};

subs_xsxth.disasm = {
  if (rd == 31)
    sink << "cmp\t" << DisasmGSXR(rn) << ", " << DisasmGZWR(rm) << ", sxth" << DisasmINZ(" ", imm);
  else
    sink << "subs\t" << DisasmGZXR(rd) << ", " << DisasmGSXR(rn) << ", " << DisasmGZWR(rm) << ", sxth" << DisasmINZ(" ", imm);
};

subs_xsxth.execute = {
  typedef typename ARCH::S16 S16;
  typedef typename ARCH::S64 S64;
  typedef typename ARCH::U64 U64;
  
  U64 op1( cpu.GetGSR(rn) ), op2( S64(S16(cpu.GetGZR(rm))) << imm ), res = op1 - op2;
  cpu.SetGZR(rd, res);
  cpu.SetNZCV( S64(res) < S64(0), op1 == op2, op1 >= op2, (S64(res) < S64(0)) xor (S64(op1) < S64(op2)) );
};

op subs_xsxtw( 0b11101011001[11] : rm[5] : 0b110[3] : imm[3] : rn[5] : rd[5] );
subs_xsxtw.var reject : {Reject} = {imm >= 5}, format : {char const*} = {"base,418"};

subs_xsxtw.disasm = {
  if (rd == 31)
    sink << "cmp\t" << DisasmGSXR(rn) << ", " << DisasmGZWR(rm) << ", sxtw" << DisasmINZ(" ", imm);
  else
    sink << "subs\t" << DisasmGZXR(rd) << ", " << DisasmGSXR(rn) << ", " << DisasmGZWR(rm) << ", sxtw" << DisasmINZ(" ", imm);
};

subs_xsxtw.execute = {
  typedef typename ARCH::S32 S32;
  typedef typename ARCH::S64 S64;
  typedef typename ARCH::U64 U64;
  
  U64 op1( cpu.GetGSR(rn) ), op2( S64(S32(cpu.GetGZR(rm))) << imm ), res = op1 - op2;
  cpu.SetGZR(rd, res);
  cpu.SetNZCV( S64(res) < S64(0), op1 == op2, op1 >= op2, (S64(res) < S64(0)) xor (S64(op1) < S64(op2)) );
};

op subs_xsxtx( 0b11101011001[11] : rm[5] : 0b111[3] : imm[3] : rn[5] : rd[5] );
subs_xsxtx.var reject : {Reject} = {imm >= 5}, format : {char const*} = {"base,434"};

subs_xsxtx.disasm = {
  if (rd == 31)
    sink << "cmp\t" << DisasmGSXR(rn) << ", " << DisasmGZXR(rm) << ", sxtx" << DisasmINZ(" ", imm);
  else
    sink << "subs\t" << DisasmGZXR(rd) << ", " << DisasmGSXR(rn) << ", " << DisasmGZXR(rm) << ", sxtx" << DisasmINZ(" ", imm);
};

subs_xsxtx.execute = {
  typedef typename ARCH::S64 S64;
  typedef typename ARCH::U64 U64;
  
  U64 op1( cpu.GetGSR(rn) ), op2( S64(S64(cpu.GetGZR(rm))) << imm ), res = op1 - op2;
  cpu.SetGZR(rd, res);
  cpu.SetNZCV( S64(res) < S64(0), op1 == op2, op1 >= op2, (S64(res) < S64(0)) xor (S64(op1) < S64(op2)) );
};

/*
 * end of SUBS (extended register)
 *******************************************************************/

/*******************************************************************
 * SUBS (immediate)
 *
 * Sub (immediate), setting the condition flags: Rd = Rn + shift(imm)
 */

op subs_wi( 0b011100010[9] : shl12[1] : imm0[12] : rn[5] : rd[5] );
subs_wi.var imm : {uint32_t} = {shl12 ? (imm0 << 12) : imm0}, format : {char const*} = {"base,22"};

subs_wi.disasm = {
  if (rd == 31)
    sink << "cmp\t" << DisasmGSWR(rn) << ", " << DisasmI(imm,16/*?*/);
  else
    sink << "subs\t" << DisasmGZWR(rd) << ", " << DisasmGSWR(rn) << ", " << DisasmI(imm,16/*?*/);
};

subs_wi.execute = {
  typedef typename ARCH::S32 S32;
  typedef typename ARCH::U32 U32;
  
  U32 op1(cpu.GetGSR(rn)), op2(imm), res = op1 - op2;
  cpu.SetGZR(rd, res);
  cpu.SetNZCV( S32(res) < S32(0), op1 == op2, op1 >= op2, (S32(res) < S32(0)) xor (S32(op1) < S32(op2)) );
};

op subs_xi( 0b111100010[9] : shl12[1] : imm0[12] : rn[5] : rd[5] );
subs_xi.var imm : {uint32_t} = {shl12 ? (imm0 << 12) : imm0}, format : {char const*} = {"base,31"};

subs_xi.disasm = {
  if (rd == 31)
    sink << "cmp\t" << DisasmGSXR(rn) << ", " << DisasmI(imm,16/*?*/);
  else
    sink << "subs\t" << DisasmGZXR(rd) << ", " << DisasmGSXR(rn) << ", " << DisasmI(imm,16/*?*/);
};

subs_xi.execute = {
  typedef typename ARCH::S64 S64;
  typedef typename ARCH::U64 U64;
  
  U64 op1(cpu.GetGSR(rn)), op2(imm), res = op1 - op2;
  cpu.SetGZR(rd, res);
  cpu.SetNZCV( S64(res) < S64(0), op1 == op2, op1 >= op2, (S64(res) < S64(0)) xor (S64(op1) < S64(op2)) );
};

/*
 * end of SUBS (immediate)
 *******************************************************************/

/*******************************************************************
 * SUBS (shifted register)
 * 
 * Subtract (shifted register), setting the condition flags: Rd = Rn - shift(Rm, amount)
 */

op subs_wlsl( 0b01101011000[11] : rm[5] : 0b0[1] : imm[5] : rn[5] : rd[5] );
subs_wlsl.var format : {char const*} = {"base,192"};

subs_wlsl.disasm = {
  if (rd == 31)
    sink << "cmp\t" << DisasmGZWR(rn) << ", " << DisasmGZWR(rm) << DisasmINZ(", lsl ",imm);
  else if (rn == 31)
    sink << "negs\t" << DisasmGZWR(rd) << ", " << DisasmGZWR(rm) << DisasmINZ(", lsl ",imm);
  else
    sink << "subs\t" << DisasmGZWR(rd) << ", " << DisasmGZWR(rn) << ", " << DisasmGZWR(rm) << DisasmINZ(", lsl ",imm);
};

subs_wlsl.execute = {
  typedef typename ARCH::U32 U32;
  typedef typename ARCH::S32 S32;
  
  U32 op1( cpu.GetGZR(rn) ), op2( cpu.GetGZR(rm) << imm ), res = op1 - op2;
  cpu.SetGZR(rd, res);
  cpu.SetNZCV( S32(res) < S32(0), op1 == op2, op1 >= op2, (S32(res) < S32(0)) xor (S32(op1) < S32(op2)) );
};

op subs_wlsr( 0b01101011010[11] : rm[5] : 0b0[1] : imm[5] : rn[5] : rd[5] );
subs_wlsr.var format : {char const*} = {"base,202"};

subs_wlsr.disasm = {
  if (rd == 31)
    sink << "cmp\t" << DisasmGZWR(rn) << ", " << DisasmGZWR(rm) << ", lsr " << DisasmI(imm);
  else if (rn == 31)
    sink << "negs\t" << DisasmGZWR(rd) << ", " << DisasmGZWR(rm) << ", lsr " << DisasmI(imm);
  else
    sink << "subs\t" << DisasmGZWR(rd) << ", " << DisasmGZWR(rn) << ", " << DisasmGZWR(rm) << ", lsr " << DisasmI(imm);
};

subs_wlsr.execute = {
  typedef typename ARCH::U32 U32;
  typedef typename ARCH::S32 S32;
  
  U32 op1( cpu.GetGZR(rn) ), op2( cpu.GetGZR(rm) >> imm ), res = op1 - op2;
  cpu.SetGZR(rd, res);
  cpu.SetNZCV( S32(res) < S32(0), op1 == op2, op1 >= op2, (S32(res) < S32(0)) xor (S32(op1) < S32(op2)) );
};

op subs_wasr( 0b01101011100[11] : rm[5] : 0b0[1] : imm[5] : rn[5] : rd[5] );
subs_wasr.var format : {char const*} = {"base,178"};

subs_wasr.disasm = {
  if (rd == 31)
    sink << "cmp\t" << DisasmGZWR(rn) << ", " << DisasmGZWR(rm) << ", asr " << DisasmI(imm);
  else if (rn == 31)
    sink << "negs\t" << DisasmGZWR(rd) << ", " << DisasmGZWR(rm) << ", asr " << DisasmI(imm);
  else
    sink << "subs\t" << DisasmGZWR(rd) << ", " << DisasmGZWR(rn) << ", " << DisasmGZWR(rm) << ", asr " << DisasmI(imm);
};

subs_wasr.execute = {
  typedef typename ARCH::U32 U32;
  typedef typename ARCH::S32 S32;
  
  U32 op1( cpu.GetGZR(rn) ), op2( S32(cpu.GetGZR(rm)) >> imm ), res = op1 - op2;
  cpu.SetGZR(rd, res);
  cpu.SetNZCV( S32(res) < S32(0), op1 == op2, op1 >= op2, (S32(res) < S32(0)) xor (S32(op1) < S32(op2)) );
};

op subs_xlsl( 0b11101011000[11] : rm[5] : imm[6] : rn[5] : rd[5] );
subs_xlsl.var format : {char const*} = {"base,133"};

subs_xlsl.disasm = {
  if (rd == 31)
    sink << "cmp\t" << DisasmGZXR(rn) << ", " << DisasmGZXR(rm) << DisasmINZ(", lsl ",imm);
  else if (rn == 31)
    sink << "negs\t" << DisasmGZXR(rd) << ", " << DisasmGZXR(rm) << DisasmINZ(", lsl ",imm);
  else
    sink << "subs\t" << DisasmGZXR(rd) << ", " << DisasmGZXR(rn) << ", " << DisasmGZXR(rm) << DisasmINZ(", lsl ",imm);
};

subs_xlsl.execute = {
  typedef typename ARCH::U64 U64;
  typedef typename ARCH::S64 S64;
  
  U64 op1( cpu.GetGZR(rn) ), op2( cpu.GetGZR(rm) << imm ), res = op1 - op2;
  cpu.SetGZR(rd, res);
  cpu.SetNZCV( S64(res) < S64(0), op1 == op2, op1 >= op2, (S64(res) < S64(0)) xor (S64(op1) < S64(op2)) );
};

op subs_xlsr( 0b11101011010[11] : rm[5] : imm[6] : rn[5] : rd[5] );
subs_xlsr.var format : {char const*} = {"base,142"};

subs_xlsr.disasm = {
  if (rd == 31)
    sink << "cmp\t" << DisasmGZXR(rn) << ", " << DisasmGZXR(rm) << ", lsr " << DisasmI(imm);
  else if (rn == 31)
    sink << "negs\t" << DisasmGZXR(rd) << ", " << DisasmGZXR(rm) << ", lsr " << DisasmI(imm);
  else
    sink << "subs\t" << DisasmGZXR(rd) << ", " << DisasmGZXR(rn) << ", " << DisasmGZXR(rm) << ", lsr " << DisasmI(imm);
};

subs_xlsr.execute = {
  typedef typename ARCH::U64 U64;
  typedef typename ARCH::S64 S64;
  
  U64 op1( cpu.GetGZR(rn) ), op2( cpu.GetGZR(rm) >> imm ), res = op1 - op2;
  cpu.SetGZR(rd, res);
  cpu.SetNZCV( S64(res) < S64(0), op1 == op2, op1 >= op2, (S64(res) < S64(0)) xor (S64(op1) < S64(op2)) );
};

op subs_xasr( 0b11101011100[11] : rm[5] : imm[6] : rn[5] : rd[5] );
subs_xasr.var format : {char const*} = {"base,118"};

subs_xasr.disasm = {
  if (rd == 31)
    sink << "cmp\t" << DisasmGZXR(rn) << ", " << DisasmGZXR(rm) << ", asr " << DisasmI(imm);
  else if (rn == 31)
    sink << "negs\t" << DisasmGZXR(rd) << ", " << DisasmGZXR(rm) << ", asr " << DisasmI(imm);
  else
    sink << "subs\t" << DisasmGZXR(rd) << ", " << DisasmGZXR(rn) << ", " << DisasmGZXR(rm) << ", asr " << DisasmI(imm);
};

subs_xasr.execute = {
  typedef typename ARCH::U64 U64;
  typedef typename ARCH::S64 S64;
  
  U64 op1( cpu.GetGZR(rn) ), op2( S64(cpu.GetGZR(rm)) >> imm ), res = op1 - op2;
  cpu.SetGZR(rd, res);
  cpu.SetNZCV( S64(res) < S64(0), op1 == op2, op1 >= op2, (S64(res) < S64(0)) xor (S64(op1) < S64(op2)) );
};

/*
 * end of SUBS (shifted register)
 *******************************************************************/

/*******************************************************************
 * SVC
 *
 * Generate exception targeting exception level 1
 */

op svc( 0b11010100000[11] : imm[16] : 0b00001[5] );
svc.var format : {char const*} = {"base,577"};

svc.disasm = {
  sink << "svc\t" << DisasmI(imm,16);
};

svc.execute = {
  cpu.CallSupervisor( imm );
};

/*
 * end of SVC
 *******************************************************************/

/*******************************************************************
 * SYS
 *
 * System instruction
 */

op sys( 0b1101010100001[13] : op1[3] : crn[4] : crm[4] : op2[3] : rt[5] );
sys.var format : {char const*} = {"base,352"};

sys.disasm = {
  sink << "sys\t" << DisasmI(op1) << ", " << DisasmC(crn) << ", " << DisasmC(crm) << ", " << DisasmI(op2) << ", " << DisasmGZXR(rt);
};

/*
 * end of SYS
 *******************************************************************/

/*******************************************************************
 * SYSL
 *
 * System instruction with result
 */

op sysl( 0b1101010100101[13] : op1[3] : crn[4] : crm[4] : op2[3] : rt[5] );
sysl.var format : {char const*} = {"base,353"};

sysl.disasm = {
  sink << "sysl\t" << DisasmGZXR(rt) << ", " << DisasmI(op1) << ", " << DisasmC(crn) << ", " << DisasmC(crm) << ", " << DisasmI(op2);
};

/*
 * end of SYSL
 *******************************************************************/

/*******************************************************************
 * TB[N]Z
 * 
 * Test bit and branch if [non]zero to a label at a PC-relative
 * offset, without affecting the condition flags, and with a hint that
 * this is not a subroutine call or return
 */

op tb( shl<5> pos1[1] : 0b011011[6] : bitval[1] : pos0[5] : shl<2> sext imm[14] : rt[5] );
tb.var pos : {unsigned} = {pos1|pos0}, format : {char const*} = {"base,5"};

tb.disasm = {
  sink << "tb" << (bitval?"nz\t":"z\t");
  if (not pos1)  sink << DisasmGZWR(rt);
  else           sink << DisasmGZXR(rt);
  sink << ", " << DisasmI(pos) << ", 0x" << std::hex << (this->GetAddr()+imm);
};

tb.execute = {
  typedef typename ARCH::U64 U64;
  typedef typename ARCH::S64 S64;
  
  U64 operand( cpu.GetGZR(rt) );
  if (cpu.Test( ((operand >> pos) & U64(1)) == U64(bitval) ))
    cpu.BranchTo( cpu.GetPC() + U64(S64(imm)), ARCH::B_JMP );
};


/*
 * end of SUBS (shifted register)
 *******************************************************************/

/*******************************************************************
 * UBFM
 *
 * Unsigned bitfield move, with zeros to left and right
 */

op ubfm_w( 0b01010011000[11] : immr[5] : 0b0[1] : imms[5] : rn[5] : rd[5] );
ubfm_w.var format : {char const*} = {"base,164"};

ubfm_w.disasm = {
  if (imms == 0b11111)
    sink << "lsr\t" << DisasmGZWR(rd) << ", " << DisasmGZWR(rn) << ", " << DisasmI(immr);
  else if (immr == (imms+1))
    sink << "lsl\t" << DisasmGZWR(rd) << ", " << DisasmGZWR(rn) << ", " << DisasmI(31-imms);
  else if (imms < immr)
    sink << "ubfiz\t" << DisasmGZWR(rd) << ", " << DisasmGZWR(rn) << ", " << DisasmI(-immr&31) << ", " << DisasmI(imms+1);
  else if ((immr == 0) and (imms == 0b111))
    sink << "uxtb\t" << DisasmGZWR(rd) << ", " << DisasmGZWR(rn);
  else if ((immr == 0) and (imms == 0b1111))
    sink << "uxth\t" << DisasmGZWR(rd) << ", " << DisasmGZWR(rn);
  else
    sink << "ubfx\t" << DisasmGZWR(rd) << ", " << DisasmGZWR(rn) << ", " << DisasmI(immr) << ", " << DisasmI(imms+1-immr);
};

ubfm_w.execute = {
  typedef typename ARCH::U32 U32;
  unsigned l = (imms ^ 31), r = (l + immr) & 31;
  
  U32 src( cpu.GetGZR(rn) ), res( (src << l) >> r );
  cpu.SetGZR(rd, res);
};

op ubfm_x( 0b1101001101[10] : immr[6] : imms[6] : rn[5] : rd[5] );
ubfm_x.var format : {char const*} = {"base,92"};

ubfm_x.disasm = {
  if (imms == 0b111111)
    sink << "lsr\t" << DisasmGZXR(rd) << ", " << DisasmGZXR(rn) << ", " << DisasmI(immr);
  else if (immr == (imms+1))
    sink << "lsl\t" << DisasmGZXR(rd) << ", " << DisasmGZXR(rn) << ", " << DisasmI(63-imms);
  else if (imms < immr)
    sink << "ubfiz\t" << DisasmGZXR(rd) << ", " << DisasmGZXR(rn) << ", " << DisasmI(-immr&63) << ", " << DisasmI(imms+1);
  // else if ((immr == 0) and (imms == 0b111))
  //   sink << "uxtb\t" << DisasmGZXR(rd) << ", " << DisasmGZXR(rn);
  // else if ((immr == 0) and (imms == 0b1111))
  //   sink << "uxth\t" << DisasmGZXR(rd) << ", " << DisasmGZXR(rn);
  else
    sink << "ubfx\t" << DisasmGZXR(rd) << ", " << DisasmGZXR(rn) << ", " << DisasmI(immr) << ", " << DisasmI(imms+1-immr);
};

ubfm_x.execute = {
  typedef typename ARCH::U64 U64;
  unsigned l = (imms ^ 63), r = (l + immr) & 63;
  
  U64 src( cpu.GetGZR(rn) ), res( (src << l) >> r );
  cpu.SetGZR(rd, res);
};

/*
 * end of UBFM
 *******************************************************************/

/*******************************************************************
 * UDIV
 *
 * Unsigned divide: Rd = Rn / Rm
 */

op udiv_www( 0b00011010110[11] : rm[5] : 0b000010[6] : rn[5] : rd[5] );
udiv_www.var format : {char const*} = {"base,1471"};

udiv_www.disasm = {
  sink << "udiv\t" << DisasmGZWR(rd) << ", " << DisasmGZWR(rn) << ", " << DisasmGZWR(rm);
};

udiv_www.execute = {
  typedef typename ARCH::U32 U32;
  
  U32 const zero(0);
  U32 op1( cpu.GetGZR(rn) ), op2( cpu.GetGZR(rm) ), res = cpu.Test(op2 == zero) ? zero : (op1 / op2);
  cpu.SetGZR(rd, res);
};

op udiv_xxx( 0b10011010110[11] : rm[5] : 0b000010[6] : rn[5] : rd[5] );
udiv_xxx.var format : {char const*} = {"base,1618"};

udiv_xxx.disasm = {
  sink << "udiv\t" << DisasmGZXR(rd) << ", " << DisasmGZXR(rn) << ", " << DisasmGZXR(rm);
};

udiv_xxx.execute = {
  typedef typename ARCH::U64 U64;
  
  U64 const zero(0);
  U64 op1( cpu.GetGZR(rn) ), op2( cpu.GetGZR(rm) ), res = cpu.Test(op2 == zero) ? zero : (op1 / op2);
  cpu.SetGZR(rd, res);
};

/*
 * end of UDIV
 *******************************************************************/

op umaddl_xw( 0b10011011101[11] : rm[5] : 0b0[1] : ra[5] : rn[5] : rd[5] );
umaddl_xw.var format : {char const*} = {"base,237"};

umaddl_xw.disasm = {
  if (ra == 31)
    sink << "umull\t" << DisasmGZXR(rd) << ", " << DisasmGZWR(rn) << ", " << DisasmGZWR(rm);
  else
    sink << "umaddl\t" << DisasmGZXR(rd) << ", " << DisasmGZWR(rn) << ", " << DisasmGZWR(rm) << ", " << DisasmGZXR(ra);
};

op umsubl_xw( 0b10011011101[11] : rm[5] : 0b1[1] : ra[5] : rn[5] : rd[5] );
umsubl_xw.var format : {char const*} = {"base,238"};

umsubl_xw.disasm = {
  if (ra == 31)
    sink << "umnegl\t" << DisasmGZXR(rd) << ", " << DisasmGZWR(rn) << ", " << DisasmGZWR(rm);
  else
    sink << "umsubl\t" << DisasmGZXR(rd) << ", " << DisasmGZWR(rn) << ", " << DisasmGZWR(rm) << ", " << DisasmGZXR(ra);
};

/*******************************************************************
 * UMULH
 *
 * Unsigned multiply high: Xd = bits<127:64> of Xn * Xm
 */

op umulh( 0b10011011110[11] : rm[5] : 0b0[1] : ra[5] : rn[5] : rd[5] );
umulh.var format : {char const*} = {"base,240"};

umulh.disasm = {
  sink << "umulh\t" << DisasmGZXR(rd) << ", " << DisasmGZXR(rn) << ", " << DisasmGZXR(rm);
};

umulh.execute = {
  typedef typename ARCH::U64 U64;
  
  U64 op1( cpu.GetGZR(rn) ), op2( cpu.GetGZR(rm) ), res( UnsignedMultiplyHigh64( cpu, op1, op2 ) );
  
  cpu.SetGZR(rd, res);
};

/*
 * end of UMULH
 *******************************************************************/

op wfe( 0b11010101000000110010000001011111[32] );
wfe.var format : {char const*} = {"base,2951"};

wfe.disasm = {
  sink << "wfe";
};

op wfi( 0b11010101000000110010000001111111[32] );
wfi.var format : {char const*} = {"base,2952"};

wfi.disasm = {
  sink << "wfi";
};

op yield( 0b11010101000000110010000000111111[32] );
yield.var format : {char const*} = {"base,2953"};

yield.disasm = {
  sink << "yield";
};

