/*
 *  Copyright (c) 2007-2016,
 *  Commissariat a l'Energie Atomique (CEA)
 *  All rights reserved.
 *
 *  Redistribution and use in source and binary forms, with or without modification,
 *  are permitted provided that the following conditions are met:
 *
 *   - Redistributions of source code must retain the above copyright notice, this
 *     list of conditions and the following disclaimer.
 *
 *   - Redistributions in binary form must reproduce the above copyright notice,
 *     this list of conditions and the following disclaimer in the documentation
 *     and/or other materials provided with the distribution.
 *
 *   - Neither the name of CEA nor the names of its contributors may be used to
 *     endorse or promote products derived from this software without specific prior
 *     written permission.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 *  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 *  DISCLAIMED.
 *  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
 *  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 *  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 *  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 *  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
 *  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * Authors: Yves Lhuillier (yves.lhuillier@cea.fr), Daniel Gracia Perez (daniel.gracia-perez@cea.fr), 
 */
 
/**********************************************

         LOAD AND STORE INSTRUCTIONS

**********************************************/

/*******************************************************************
 * ldr instruction
 */

op ldr_imm( cond[4]: 0b010[3]: p[1]: u[1]: 0b0[1]: w[1]: 0b1[1]: rn[4]: rt[4]: offset[12] );
ldr_imm.var imm : {int32_t} = {u?offset:-offset};
ldr_imm.var reject : {Reject} = {(not p and w) or ((not p or w) and ((rn == 15) or (rn == rt)))};

ldr_imm.disasm = {
  buffer << "ldr" << DisasmCondition(cond) << '\t' << DisasmRegister(rt) << ", " << DisasmMemoryRI( rn, imm, p, w );
};

ldr_imm.execute = {
  if (unlikely( not CheckCondition(cpu, cond) )) return;
  
  typedef typename ARCH::U32 U32;
  U32 addr = cpu.GetGPR( rn ), oaddr = addr+ U32(imm);
  cpu.SetGPR_mem( rt, cpu.MemURead32( p?oaddr:addr ) );
  if (not p or w) cpu.SetGPR( rn, oaddr );
};

op ldr_reg( cond[4]: 0b011[3]: p[1]: u[1]: 0b0[1]: w[1]: 0b1[1]: rn[4]: rt[4]: imm[5]: shift[2]: 0b0[1]: rm[4] );
ldr_reg.var reject : {Reject} = {(not p and w) or (rm == 15) or
                                 ((not p or w) and ((rn == 15) or (rn == rt) or ((ARCH::Config::model < ARMV6) and (rm == rn))))};

ldr_reg.disasm = {
  buffer << "ldr" << DisasmCondition(cond) << '\t'
         << DisasmRegister(rt) << ", "
         << DisasmMemoryRRI( rn, rm, shift, imm, p, u, w );
};

ldr_reg.execute = {
  if (unlikely( not CheckCondition(cpu, cond) )) return;
  
  typedef typename ARCH::U32 U32;
  U32 isval = ComputeImmShift( cpu, cpu.GetGPR( rm ), shift, imm ),
           addr = cpu.GetGPR( rn ), oaddr = addr + (u?isval:-isval);
  cpu.SetGPR_mem( rt, cpu.MemURead32( p?oaddr:addr ) );
  if (not p or w) cpu.SetGPR( rn, oaddr );
};

/*
 * end of ldr instruction
 *******************************************************************/

/*******************************************************************
 * ldrh instruction
 */

op ldrh_imm( cond[4]: 0b000[3]: p[1]: u[1]: 0b1[1]: w[1]: 0b1[1]: rn[4]: rt[4]: shl<4> im1[4]: 0b1011[4]: im0[4] );
ldrh_imm.var imm : {int32_t} = {u?(im1|im0):-(im1|im0)};
ldrh_imm.var reject : {Reject} = {(not p and w) or (rt == 15) or ((not p or w) and ((rn == 15) or (rn == rt)))};

ldrh_imm.disasm = {
  buffer << "ldrh" << DisasmCondition(cond) << '\t' << DisasmRegister(rt) << ", " << DisasmMemoryRI( rn, imm, p, w );
};

ldrh_imm.execute = {
  if (unlikely( not CheckCondition(cpu, cond) )) return;
  
  typedef typename ARCH::U32 U32;
  U32 addr = cpu.GetGPR( rn ), oaddr = addr+ U32(imm);
  cpu.SetGPR_mem( rt, U32( cpu.MemURead16( p?oaddr:addr ) ) );
  if (not p or w) cpu.SetGPR( rn, oaddr );
};

op ldrh_reg( cond[4]: 0b000[3]: p[1]: u[1]: 0b0[1]: w[1]: 0b1[1]: rn[4]: rt[4]: 0b0000[4]: 0b1011[4]: rm[4] );
ldrh_reg.var reject : {Reject} = {(not p and w) or (rm == 15) or (rt == 15) or
                                 ((not p or w) and ((rn == 15) or (rn == rt) or ((ARCH::Config::model < ARMV6) and (rm == rn))))};

ldrh_reg.disasm = {
  buffer << "ldrh" << DisasmCondition(cond) << '\t' << DisasmRegister(rt) << ", " << DisasmMemoryRR( rn, rm, p, u, w );
};

ldrh_reg.execute = {
  if (unlikely( not CheckCondition(cpu, cond) )) return;

  typedef typename ARCH::U32 U32;
  U32 rmval = cpu.GetGPR( rm ), addr = cpu.GetGPR( rn ), oaddr = addr + (u?rmval:-rmval);
  cpu.SetGPR_mem( rt, U32( cpu.MemURead16( p?oaddr:addr ) ) );
  if (not p or w) cpu.SetGPR( rn, oaddr );
};

/*
 * end of ldrh instruction
 *******************************************************************/

/*******************************************************************
 * ldrsh instruction
 */

op ldrsh_imm( cond[4]: 0b000[3]: p[1]: u[1]: 0b1[1]: w[1]: 0b1[1]: rn[4]: rt[4]: shl<4> im1[4]: 0b1111[4]: im0[4] );
ldrsh_imm.var imm : {int32_t} = {u?(im1|im0):-(im1|im0)};
ldrsh_imm.var reject : {Reject} = {(not p and w) or (rt == 15) or ((not p or w) and ((rn == 15) or (rn == rt)))};

ldrsh_imm.disasm = {
  buffer << "ldrsh" << DisasmCondition(cond) << '\t' << DisasmRegister(rt) << ", " << DisasmMemoryRI( rn, imm, p, w );
};

ldrsh_imm.execute = {
  if (unlikely( not CheckCondition(cpu, cond) )) return;
  
  typedef typename ARCH::U32 U32;
  typedef typename ARCH::S32 S32;
  typedef typename ARCH::S16 S16;
  U32 addr = cpu.GetGPR( rn ), oaddr = addr+ U32(imm);
  cpu.SetGPR_mem( rt, U32( S32( S16( cpu.MemURead16( p?oaddr:addr ) ) ) ) );
  if (not p or w) cpu.SetGPR( rn, oaddr );
};

op ldrsh_reg( cond[4]: 0b000[3]: p[1]: u[1]: 0b0[1]: w[1]: 0b1[1]: rn[4]: rt[4]: 0b0000[4]: 0b1111[4]: rm[4] );
ldrsh_reg.var reject : {Reject} = {(not p and w) or (rm == 15) or (rt == 15) or
                                   ((not p or w) and ((rn == 15) or (rn == rt) or ((ARCH::Config::model < ARMV6) and (rm == rn))))};

ldrsh_reg.disasm = {
  buffer << "ldrsh" << DisasmCondition(cond) << '\t' << DisasmRegister(rt) << ", " << DisasmMemoryRR( rn, rm, p, u, w );
};

ldrsh_reg.execute = {
  if (unlikely( not CheckCondition(cpu, cond) )) return;

  typedef typename ARCH::U32 U32;
  typedef typename ARCH::S32 S32;
  typedef typename ARCH::S16 S16;
  U32 rmval = cpu.GetGPR( rm ),
           addr = cpu.GetGPR( rn ), oaddr = addr + (u?rmval:-rmval);
  cpu.SetGPR_mem( rt, U32( S32( S16( cpu.MemURead16( p?oaddr:addr ) ) ) ) );
  if (not p or w) cpu.SetGPR( rn, oaddr );
};

/*
 * end of ldrsh instruction
 *******************************************************************/

/*******************************************************************
 * ldrb instruction
 */

op ldrb_imm( cond[4]: 0b010[3]: p[1]: u[1]: 0b1[1]: w[1]: 0b1[1]: rn[4]: rt[4]: offset[12] );
ldrb_imm.var imm : {int32_t} = {u?offset:-offset};
ldrb_imm.var reject : {Reject} = {(not p and w) or (rt == 15) or ((not p or w) and ((rn == 15) or (rn == rt)))};

ldrb_imm.disasm = {
  buffer << "ldrb" << DisasmCondition(cond) << '\t' << DisasmRegister(rt) << ", " << DisasmMemoryRI( rn, imm, p, w );
};

ldrb_imm.execute = {
  if (unlikely( not CheckCondition(cpu, cond) )) return;
  
  typedef typename ARCH::U32 U32;
  U32 addr = cpu.GetGPR( rn ), oaddr = addr+ U32(imm);
  cpu.SetGPR_mem( rt, U32( cpu.MemRead8( p?oaddr:addr ) ) );
  if (not p or w) cpu.SetGPR( rn, oaddr );
};

op ldrb_reg( cond[4]: 0b011[3]: p[1]: u[1]: 0b1[1]: w[1]: 0b1[1]: rn[4]: rt[4]: imm[5]: shift[2]: 0b0[1]: rm[4] );
ldrb_reg.var reject : {Reject} = {(not p and w) or (rm == 15) or (rt == 15) or
                                  ((not p or w) and ((rn == 15) or (rn == rt) or ((ARCH::Config::model < ARMV6) and (rm == rn))))};

ldrb_reg.disasm = {
  buffer << "ldrb" << DisasmCondition(cond) << '\t' << DisasmRegister(rt) << ", "
         << DisasmMemoryRRI( rn, rm, shift, imm, p, u, w );
};

ldrb_reg.execute = {
  if (unlikely( not CheckCondition(cpu, cond) )) return;

  typedef typename ARCH::U32 U32;
  U32 isval = ComputeImmShift( cpu, cpu.GetGPR( rm ), shift, imm ),
           addr = cpu.GetGPR( rn ), oaddr = addr + (u?isval:-isval);
  cpu.SetGPR_mem( rt, U32( cpu.MemRead8( p?oaddr:addr ) ) );
  if (not p or w) cpu.SetGPR( rn, oaddr );
};

/*
 * end of ldrb instruction
 *******************************************************************/

/*******************************************************************
 * ldrsb instruction
 */

op ldrsb_imm( cond[4]: 0b000[3]: p[1]: u[1]: 0b1[1]: w[1]: 0b1[1]: rn[4]: rt[4]: shl<4> im1[4]: 0b1101[4]: im0[4] );
ldrsb_imm.var imm : {int32_t} = {u?(im1|im0):-(im1|im0)};
ldrsb_imm.var reject : {Reject} = {(not p and w) or (rt == 15) or ((not p or w) and ((rn == 15) or (rn == rt)))};

ldrsb_imm.disasm = {
  buffer << "ldrsb" << DisasmCondition(cond) << '\t' << DisasmRegister(rt) << ", " << DisasmMemoryRI( rn, imm, p, w );
};

ldrsb_imm.execute = {
  if (unlikely( not CheckCondition(cpu, cond) )) return;
  
  typedef typename ARCH::U32 U32;
  typedef typename ARCH::S32 S32;
  typedef typename ARCH::S8  S8;
  U32 addr = cpu.GetGPR( rn ), oaddr = addr+ U32(imm);
  cpu.SetGPR_mem( rt, U32( S32( S8( cpu.MemRead8( p?oaddr:addr ) ) ) ) );
  if (not p or w) cpu.SetGPR( rn, oaddr );
};

op ldrsb_reg( cond[4]: 0b000[3]: p[1]: u[1]: 0b0[1]: w[1]: 0b1[1]: rn[4]: rt[4]: 0b0000[4]: 0b1101[4]: rm[4] );
ldrsb_reg.var reject : {Reject} = {(not p and w) or (rm == 15) or (rt == 15) or
                                  ((not p or w) and ((rn == 15) or (rn == rt) or ((ARCH::Config::model < ARMV6) and (rm == rn))))};

ldrsb_reg.disasm = {
  buffer << "ldrsb" << DisasmCondition(cond) << '\t' << DisasmRegister(rt) << ", " << DisasmMemoryRR( rn, rm, p, u, w );
};

ldrsb_reg.execute = {
  if (unlikely( not CheckCondition(cpu, cond) )) return;

  typedef typename ARCH::U32 U32;
  typedef typename ARCH::S32 S32;
  typedef typename ARCH::S8  S8;
  U32 rmval = cpu.GetGPR( rm ),
           addr = cpu.GetGPR( rn ), oaddr = addr + (u?rmval:-rmval);
  cpu.SetGPR_mem( rt, U32( S32( S8( cpu.MemRead8( p?oaddr:addr ) ) ) ) );
  if (not p or w) cpu.SetGPR( rn, oaddr );
};

/*
 * end of ldrsb instruction
 *******************************************************************/

/*******************************************************************
 * ldrd instruction
 */

{ ARCH::Config::insns5E }: \
op ldrd_imm( cond[4]: 0b000[3]: p[1]: u[1]: 0b1[1]: w[1]: 0b0[1]: rn[4]: rt[4]: shl<4> im1[4]: 0b1101[4]: im0[4] );
ldrd_imm.var imm : {int32_t} = {u?(im1|im0):-(im1|im0)};
ldrd_imm.var reject : {Reject} = {(not p and w) or (rt & 1) or (rt == 14) or
                                  ((not p or w) and ((rn == 15) or ((rn & 0xe) == rt)))};

ldrd_imm.disasm = {
  buffer << "ldrd" << DisasmCondition(cond) << '\t' << DisasmRegister(rt) << ", " << DisasmMemoryRI( rn, imm, p, w );
};

ldrd_imm.execute = {
  if (unlikely( not CheckCondition(cpu, cond) )) return;
  
  typedef typename ARCH::U32 U32;
  U32 addr = cpu.GetGPR( rn ), oaddr = addr+ U32(imm);
  cpu.SetGPR_mem( (rt+0) & 0xf, cpu.MemRead32( (p?oaddr:addr) + U32(0) ) );
  cpu.SetGPR_mem( (rt+1) & 0xf, cpu.MemRead32( (p?oaddr:addr) + U32(4) ) );
  if (not p or w) cpu.SetGPR( rn, oaddr );
};

{ ARCH::Config::insns5E }: \
op ldrd_reg( cond[4]: 0b000[3]: p[1]: u[1]: 0b0[1]: w[1]: 0b0[1]: rn[4]: rt[4]: 0b0000[4]: 0b1101[4]: rm[4] );
ldrd_reg.var reject : {Reject} = {(not p and w) or (rt & 1) or (rt == 14) or (rm == 15) or ((rm & 0xe) == rt) or
                                  ((not p or w) and ((rn == 15) or ((rn & 0xe) == rt) or ((ARCH::Config::model < ARMV6) and (rm == rn))))};

ldrd_reg.disasm = {
  buffer << "ldrd" << DisasmCondition(cond) << '\t' << DisasmRegister(rt) << ", " << DisasmMemoryRR( rn, rm, p, u, w );
};

ldrd_reg.execute = {
  if (unlikely( not CheckCondition(cpu, cond) )) return;

  typedef typename ARCH::U32 U32;
  U32 rmval = cpu.GetGPR( rm ),
           addr = cpu.GetGPR( rn ), oaddr = addr + (u?rmval:-rmval);
  cpu.SetGPR_mem( (rt+0) & 0xf, cpu.MemRead32( (p?oaddr:addr) + U32(0) ) );
  cpu.SetGPR_mem( (rt+1) & 0xf, cpu.MemRead32( (p?oaddr:addr) + U32(4) ) );
  if (not p or w) cpu.SetGPR( rn, oaddr );
};

/*
 * end of ldrd instruction
 *******************************************************************/

/*******************************************************************
 * str instruction
 */

op str_imm( cond[4]: 0b010[3]: p[1]: u[1]: 0b0[1]: w[1]: 0b0[1]: rn[4]: rt[4]: offset[12] );
str_imm.var imm : {int32_t} = {u?offset:-offset};
str_imm.var reject : {Reject} = {(not p and w) or ((not p or w) and ((rn == 15) or (rn == rt)))};

str_imm.disasm = {
  buffer << "str" << DisasmCondition(cond) << '\t' << DisasmRegister(rt) << ", " << DisasmMemoryRI( rn, imm, p, w );
};

str_imm.execute = {
  if (unlikely( not CheckCondition(cpu, cond) )) return;
  
  typedef typename ARCH::U32 U32;
  U32 addr = cpu.GetGPR( rn ), oaddr = addr+ U32(imm);
  cpu.MemUWrite32( p?oaddr:addr, cpu.GetGPR( rt ) );
  if (not p or w) cpu.SetGPR( rn, oaddr );
};

op str_reg( cond[4]: 0b011[3]: p[1]: u[1]: 0b0[1]: w[1]: 0b0[1]: rn[4]: rt[4]: imm[5]: shift[2]: 0b0[1]: rm[4] );
str_reg.var reject : {Reject} = {(not p and w)or (rm == 15) or
                                 ((not p or w) and ((rn == 15) or (rn == rt) or ((ARCH::Config::model < ARMV6) and (rm == rn))))};


str_reg.disasm = {
  buffer << "str" << DisasmCondition(cond) << '\t' << DisasmRegister(rt) << ", "
         << DisasmMemoryRRI( rn, rm, shift, imm, p, u, w );
};

str_reg.execute = {
  if (unlikely( not CheckCondition(cpu, cond) )) return;

  typedef typename ARCH::U32 U32;
  U32 isval = ComputeImmShift( cpu, cpu.GetGPR( rm ), shift, imm ),
      addr = cpu.GetGPR( rn ), oaddr = addr + (u?isval:-isval);
  cpu.MemUWrite32( p?oaddr:addr, cpu.GetGPR( rt ) );
  if (not p or w) cpu.SetGPR( rn, oaddr );
};

/*
 * end of str instruction
 *******************************************************************/

/*******************************************************************
 * strh instruction
 */

op strh_imm( cond[4]: 0b000[3]: p[1]: u[1]: 0b1[1]: w[1]: 0b0[1]: rn[4]: rt[4]: shl<4> im1[4]: 0b1011[4]: im0[4] );
strh_imm.var imm : {int32_t} = {u?(im1|im0):-(im1|im0)};
strh_imm.var reject : {Reject} = {(not p and w) or (rt == 15) or ((not p or w) and ((rn == 15) or (rn == rt)))};

strh_imm.disasm = {
  buffer << "strh" << DisasmCondition(cond) << '\t' << DisasmRegister(rt) << ", " << DisasmMemoryRI( rn, imm, p, w );
};

strh_imm.execute = {
  if (unlikely( not CheckCondition(cpu, cond) )) return;
  
  typedef typename ARCH::U32 U32;
  typedef typename ARCH::U16 U16;
  U32 addr = cpu.GetGPR( rn ), oaddr = addr + U32(imm);
  cpu.MemUWrite16( p?oaddr:addr, U16(cpu.GetGPR( rt )) );
  if (not p or w) cpu.SetGPR( rn, oaddr );
};

op strh_reg( cond[4]: 0b000[3]: p[1]: u[1]: 0b0[1]: w[1]: 0b0[1]: rn[4]: rt[4]: 0b0000[4]: 0b1011[4]: rm[4] );
strh_reg.var reject : {Reject} = {(not p and w)or (rm == 15) or (rt == 15) or
                                  ((not p or w) and ((rn == 15) or (rn == rt) or ((ARCH::Config::model < ARMV6) and (rm == rn))))};

strh_reg.disasm = {
  buffer << "strh" << DisasmCondition(cond) << '\t' << DisasmRegister(rt) << ", " << DisasmMemoryRR( rn, rm, p, u, w );
};

strh_reg.execute = {
  if (unlikely( not CheckCondition(cpu, cond) )) return;

  typedef typename ARCH::U32 U32;
  typedef typename ARCH::U16 U16;
  U32 rmval = cpu.GetGPR( rm ),
           addr = cpu.GetGPR( rn ), oaddr = addr + (u?rmval:-rmval);
  cpu.MemUWrite16( p?oaddr:addr, U16(cpu.GetGPR( rt )) );
  if (not p or w) cpu.SetGPR( rn, oaddr );
};

/*
 * end of strh instruction
 *******************************************************************/

/*******************************************************************
 * strb instruction
 */

op strb_imm( cond[4]: 0b010[3]: p[1]: u[1]: 0b1[1]: w[1]: 0b0[1]: rn[4]: rt[4]: offset[12] );
strb_imm.var imm : {int32_t} = {u?offset:-offset};
strb_imm.var reject : {Reject} = {(not p and w) or (rt == 15) or ((not p or w) and ((rn == 15) or (rn == rt)))};

strb_imm.disasm = {
  buffer << "strb" << DisasmCondition(cond) << '\t' << DisasmRegister(rt) << ", " << DisasmMemoryRI( rn, imm, p, w );
};

strb_imm.execute = {
  if (unlikely( not CheckCondition(cpu, cond) )) return;
  
  typedef typename ARCH::U32 U32;
  typedef typename ARCH::U8  U8;
  U32 addr = cpu.GetGPR( rn ), oaddr = addr+ U32(imm);
  cpu.MemWrite8( p?oaddr:addr, U8(cpu.GetGPR( rt )) );
  if (not p or w) cpu.SetGPR( rn, oaddr );
};

op strb_reg( cond[4]: 0b011[3]: p[1]: u[1]: 0b1[1]: w[1]: 0b0[1]: rn[4]: rt[4]: imm[5]: shift[2]: 0b0[1]: rm[4] );
strb_reg.var reject : {Reject} = {(not p and w)or (rm == 15) or (rt == 15) or
                                  ((not p or w) and ((rn == 15) or (rn == rt) or ((ARCH::Config::model < ARMV6) and (rm == rn))))};

strb_reg.disasm = {
  buffer << "strb" << DisasmCondition(cond) << '\t' << DisasmRegister(rt) << ", "
         << DisasmMemoryRRI( rn, rm, shift, imm, p, u, w );
};

strb_reg.execute = {
  if (unlikely( not CheckCondition(cpu, cond) )) return;

  typedef typename ARCH::U32 U32;
  typedef typename ARCH::U8  U8;
  U32 isval = ComputeImmShift( cpu, cpu.GetGPR( rm ), shift, imm ),
           addr = cpu.GetGPR( rn ), oaddr = addr + (u?isval:-isval);
  cpu.MemWrite8( p?oaddr:addr, U8(cpu.GetGPR( rt )) );
  if (not p or w) cpu.SetGPR( rn, oaddr );
};

/*
 * end of strb instruction
 *******************************************************************/

/*******************************************************************
 * strd instruction
 */

{ ARCH::Config::insns5E }: \
op strd_imm( cond[4]: 0b000[3]: p[1]: u[1]: 0b1[1]: w[1]: 0b0[1]: rn[4]: rt[4]: shl<4> im1[4]: 0b1111[4]: im0[4] );
strd_imm.var imm : {int32_t} = {u?(im1|im0):-(im1|im0)};
strd_imm.var reject : {Reject} = {(not p and w) or (rt & 1) or (rt == 14) or
                                  ((not p or w) and ((rn == 15) or ((rn & 0xe) == rt)))};

strd_imm.disasm = {
  buffer << "strd" << DisasmCondition(cond) << '\t' << DisasmRegister(rt) << ", " << DisasmMemoryRI( rn, imm, p, w );
};

strd_imm.execute = {
  if (unlikely( not CheckCondition(cpu, cond) )) return;
  
  typedef typename ARCH::U32 U32;
  U32 addr = cpu.GetGPR( rn ), oaddr = addr+ U32(imm);
  cpu.MemWrite32( (p?oaddr:addr) + U32(0), cpu.GetGPR( (rt+0) & 0xf ) );
  cpu.MemWrite32( (p?oaddr:addr) + U32(4), cpu.GetGPR( (rt+1) & 0xf ) );
  if (not p or w) cpu.SetGPR( rn, oaddr );
};

{ ARCH::Config::insns5E }: \
op strd_reg( cond[4]: 0b000[3]: p[1]: u[1]: 0b0[1]: w[1]: 0b0[1]: rn[4]: rt[4]: 0b0000[4]: 0b1111[4]: rm[4] );
strd_reg.var reject : {Reject} = {(not p and w) or (rt & 1) or (rt == 14) or (rm == 15) or
                                  ((not p or w) and ((rn == 15) or ((rn & 0xe) == rt) or ((ARCH::Config::model < ARMV6) and (rm == rn))))};

strd_reg.disasm = {
  buffer << "strd" << DisasmCondition(cond) << '\t' << DisasmRegister(rt) << ", " << DisasmMemoryRR( rn, rm, p, u, w );
};

strd_reg.execute = {
  if (unlikely( not CheckCondition(cpu, cond) )) return;

  typedef typename ARCH::U32 U32;
  U32 rmval = cpu.GetGPR( rm ),
           addr = cpu.GetGPR( rn ), oaddr = addr + (u?rmval:-rmval);
  cpu.MemWrite32( (p?oaddr:addr) + U32(0), cpu.GetGPR( (rt+0) & 0xf ) );
  cpu.MemWrite32( (p?oaddr:addr) + U32(4), cpu.GetGPR( (rt+1) & 0xf ) );
  if (not p or w) cpu.SetGPR( rn, oaddr );
};

/*
 * end of strd instruction
 *******************************************************************/

/*******************************************************************
 * ldrt instruction
 * TODO: check running mode
 */

op ldrt_imm( cond[4]: 0b0100[4]: u[1]: 0b011[3]: rn[4]: rt[4]: offset[12] );
ldrt_imm.var imm : {int32_t} = {u?offset:-offset};
ldrt_imm.var reject : {Reject} = {(rt == 15) or (rn == 15) or (rn == rt)};

ldrt_imm.disasm = {
  buffer << "ldrt" << DisasmCondition(cond) << '\t' << DisasmRegister(rt) << ", " << DisasmMemoryRI(rn,imm,false,false);
};

ldrt_imm.execute = {
  if (unlikely( not CheckCondition(cpu, cond) )) return;
  
  typedef typename ARCH::U32 U32;
  U32 addr = cpu.GetGPR( rn );
  cpu.SetGPR_mem( rt, cpu.MemURead32( addr ) );
  cpu.SetGPR( rn, addr+ U32(imm) );
};

op ldrt_reg( cond[4]: 0b0110[4]: u[1]: 0b011[3]: rn[4]: rt[4]: imm[5]: shift[2]: 0b0[1]: rm[4] );
ldrt_reg.var reject : {Reject} = {(rt == 15) or (rn == 15) or (rn == rt) or (rm == 15)};

ldrt_reg.disasm = {
  buffer << "ldrt" << DisasmCondition(cond) << '\t' << DisasmRegister(rt) << ", " << DisasmMemoryRRI(rn,rm,shift,imm,false,u,true);
};

ldrt_reg.execute = {
  if (unlikely( not CheckCondition(cpu, cond) )) return;

  typedef typename ARCH::U32 U32;
  U32 isval = ComputeImmShift( cpu, cpu.GetGPR( rm ), shift, imm ),
           addr = cpu.GetGPR( rn ), oaddr = addr + (u?isval:-isval);
  cpu.SetGPR_mem( rt, cpu.MemURead32( addr ) );
  cpu.SetGPR( rn, oaddr );
};

/*
 * end of ldrt instruction
 *******************************************************************/

/*******************************************************************
 * ldrht instruction
 * TODO: force user running mode access
 */

op ldrht_imm( cond[4]: 0b0000[4]: u[1]: 0b111[3]: rn[4]: rt[4]: shl<4> im1[4]: 0b1011[4]: im0[4] );
ldrht_imm.var imm : {int32_t} = {u?(im1|im0):-(im1|im0)};
ldrht_imm.var reject : {Reject} = {(rt == 15) or (rn == 15) or (rn == rt)};

ldrht_imm.disasm = {
  buffer << "ldrht" << DisasmCondition(cond) << '\t' << DisasmRegister(rt) << ", " << DisasmMemoryRI(rn,imm,false,false);
};

ldrht_imm.execute = {
  if (unlikely( not CheckCondition(cpu, cond) )) return;
  
  typedef typename ARCH::U32 U32;
  U32 addr = cpu.GetGPR( rn );
  cpu.SetGPR_mem( rt, U32( cpu.MemURead16( addr ) ) );
  cpu.SetGPR( rn, addr+ U32(imm) );
};

op ldrht_reg( cond[4]: 0b0000[4]: u[1]: 0b011[3]: rn[4]: rt[4]: 0b0000[4]: 0b1011[4]: rm[4] );
ldrht_reg.var reject : {Reject} = {(rt == 15) or (rn == 15) or (rn == rt) or (rm == 15)};

ldrht_reg.disasm = {
  buffer << "ldrht" << DisasmCondition(cond) << '\t' << DisasmRegister(rt) << ", " << DisasmMemoryRR(rn,rm,false,u,true);
};

ldrht_reg.execute = {
  if (unlikely( not CheckCondition(cpu, cond) )) return;

  typedef typename ARCH::U32 U32;
  U32 rmval = cpu.GetGPR( rm ), addr = cpu.GetGPR( rn ), oaddr = addr + (u?rmval:-rmval);
  cpu.SetGPR_mem( rt, U32( cpu.MemURead16( addr ) ) );
  cpu.SetGPR( rn, oaddr );
};

/*
 * end of ldrht instruction
 *******************************************************************/

/*******************************************************************
 * ldrsht instruction
 * TODO: force user running mode access
 */

op ldrsht_imm( cond[4]: 0b0000[4]: u[1]: 0b111[3]: rn[4]: rt[4]: shl<4> im1[4]: 0b1111[4]: im0[4] );
ldrsht_imm.var imm : {int32_t} = {u?(im1|im0):-(im1|im0)};
ldrsht_imm.var reject : {Reject} = {(rt == 15) or (rn == 15) or (rn == rt)};

ldrsht_imm.disasm = {
  buffer << "ldrsht" << DisasmCondition(cond) << '\t' << DisasmRegister(rt) << ", " << DisasmMemoryRI(rn,imm,false,false);
};

ldrsht_imm.execute = {
  if (unlikely( not CheckCondition(cpu, cond) )) return;
  
  typedef typename ARCH::U32 U32;
  typedef typename ARCH::S32 S32;
  typedef typename ARCH::S16 S16;
  U32 addr = cpu.GetGPR( rn );
  cpu.SetGPR_mem( rt, U32( S32( S16( cpu.MemURead16( addr ) ) ) ) );
  cpu.SetGPR( rn, addr+ U32(imm) );
};

op ldrsht_reg( cond[4]: 0b0000[4]: u[1]: 0b011[3]: rn[4]: rt[4]: 0b0000[4]: 0b1111[4]: rm[4] );
ldrsht_reg.var reject : {Reject} = {(rt == 15) or (rn == 15) or (rn == rt) or (rm == 15)};

ldrsht_reg.disasm = {
  buffer << "ldrsht" << DisasmCondition(cond) << '\t' << DisasmRegister(rt) << ", " << DisasmMemoryRR(rn,rm,false,u,true);
};

ldrsht_reg.execute = {
  if (unlikely( not CheckCondition(cpu, cond) )) return;

  typedef typename ARCH::U32 U32;
  typedef typename ARCH::S32 S32;
  typedef typename ARCH::S16 S16;
  U32 rmval = cpu.GetGPR( rm ),
           addr = cpu.GetGPR( rn ), oaddr = addr + (u?rmval:-rmval);
  cpu.SetGPR_mem( rt, U32( S32( S16( cpu.MemURead16( addr ) ) ) ) );
  cpu.SetGPR( rn, oaddr );
};

/*
 * end of ldrsht instruction
 *******************************************************************/

/*******************************************************************
 * ldrbt instruction
 * TODO: force user running mode access
 */

op ldrbt_imm( cond[4]: 0b0100[4]: u[1]: 0b111[3]: rn[4]: rt[4]: offset[12] );
ldrbt_imm.var imm : {int32_t} = {u?offset:-offset};
ldrbt_imm.var reject : {Reject} = {(rt == 15) or (rn == 15) or (rn == rt)};

ldrbt_imm.disasm = {
  buffer << "ldrbt" << DisasmCondition(cond) << '\t' << DisasmRegister(rt) << ", " << DisasmMemoryRI(rn,imm,false,false);
};

ldrbt_imm.execute = {
  if (unlikely( not CheckCondition(cpu, cond) )) return;

  typedef typename ARCH::U32 U32;
  U32 addr = cpu.GetGPR( rn );
  cpu.SetGPR_mem( rt, U32( cpu.MemRead8( addr ) ) );
  cpu.SetGPR( rn, addr+ U32(imm) );
};

op ldrbt_reg( cond[4]: 0b0110[4]: u[1]: 0b111[3]: rn[4]: rt[4]: imm[5]: shift[2]: 0b0[1]: rm[4] );
ldrbt_reg.var reject : {Reject} = {(rt == 15) or (rn == 15) or (rn == rt) or (rm == 15)};

ldrbt_reg.disasm = {
  buffer << "ldrbt" << DisasmCondition(cond) << '\t' << DisasmRegister(rt) << ", " << DisasmMemoryRRI(rn,rm,shift,imm,false,u,true);
};

ldrbt_reg.execute = {
  if (unlikely( not CheckCondition(cpu, cond) )) return;

  typedef typename ARCH::U32 U32;
  U32 isval = ComputeImmShift( cpu, cpu.GetGPR( rm ), shift, imm ),
           addr = cpu.GetGPR( rn ), oaddr = addr + (u?isval:-isval);
  cpu.SetGPR_mem( rt, U32( cpu.MemRead8( addr ) ) );
  cpu.SetGPR( rn, oaddr );
};

/*
 * end of ldrbt instruction
 *******************************************************************/

/*******************************************************************
 * ldrsbt instruction
 * TODO: force user running mode access
 */

op ldrsbt_imm( cond[4]: 0b0000[4]: u[1]: 0b111[3]: rn[4]: rt[4]: shl<4> im1[4]: 0b1101[4]: im0[4] );
ldrsbt_imm.var imm : {int32_t} = {u?(im1|im0):-(im1|im0)};
ldrsbt_imm.var reject : {Reject} = {(rt == 15) or (rn == 15) or (rn == rt)};

ldrsbt_imm.disasm = {
  buffer << "ldrsbt" << DisasmCondition(cond) << '\t' << DisasmRegister(rt) << ", " << DisasmMemoryRI(rn,imm,false,false);
};

ldrsbt_imm.execute = {
  if (unlikely( not CheckCondition(cpu, cond) )) return;
  
  typedef typename ARCH::U32 U32;
  typedef typename ARCH::S32 S32;
  typedef typename ARCH::S8  S8;
  U32 addr = cpu.GetGPR( rn );
  cpu.SetGPR_mem( rt, U32( S32( S8( cpu.MemRead8( addr ) ) ) ) );
  cpu.SetGPR( rn, addr+ U32(imm) );
};

op ldrsbt_reg( cond[4]: 0b0000[4]: u[1]: 0b011[3]: rn[4]: rt[4]: 0b0000[4]: 0b1101[4]: rm[4] );
ldrsbt_reg.var reject : {Reject} = {(rt == 15) or (rn == 15) or (rn == rt) or (rm == 15)};

ldrsbt_reg.disasm = {
  buffer << "ldrsbt" << DisasmCondition(cond) << '\t' << DisasmRegister(rt) << ", " << DisasmMemoryRR(rn,rm,false,u,true);
};

ldrsbt_reg.execute = {
  if (unlikely( not CheckCondition(cpu, cond) )) return;

  typedef typename ARCH::U32 U32;
  typedef typename ARCH::S32 S32;
  typedef typename ARCH::S8  S8;
  U32 rmval = cpu.GetGPR( rm ),
           addr = cpu.GetGPR( rn ), oaddr = addr + (u?rmval:-rmval);
  cpu.SetGPR_mem( rt, U32( S32( S8( cpu.MemRead8( addr ) ) ) ) );
  cpu.SetGPR( rn, oaddr );
};

/*
 * end of ldrsbt instruction
 *******************************************************************/

/*******************************************************************
 * strt instruction
 * TODO: force user running mode access
 */

op strt_imm( cond[4]: 0b010[3]: 0b0[1]: u[1]: 0b0[1]: 0b1[1]: 0b0[1]: rn[4]: rt[4]: offset[12] );
strt_imm.var imm : {int32_t} = {u?offset:-offset};
strt_imm.var reject : {Reject} = {(rn == 15) or (rn == rt)};

strt_imm.disasm = {
  buffer << "strt" << DisasmCondition(cond) << '\t' << DisasmRegister(rt) << ", " << DisasmMemoryRI(rn,imm,false,false);
};

strt_imm.execute = {
  if (unlikely( not CheckCondition(cpu, cond) )) return;

  typedef typename ARCH::U32 U32;
  U32 addr = cpu.GetGPR( rn );
  cpu.MemUWrite32( addr, cpu.GetGPR( rt ) );
  cpu.SetGPR( rn, addr+ U32(imm) );
};

op strt_reg( cond[4]: 0b011[3]: 0b0[1]: u[1]: 0b0[1]: 0b1[1]: 0b0[1]: rn[4]: rt[4]: imm[5]: shift[2]: 0b0[1]: rm[4] );
strt_reg.var reject : {Reject} = {(rn == 15) or (rn == rt) or (rm == 15)};

strt_reg.disasm = {
  buffer << "strt" << DisasmCondition(cond) << '\t' << DisasmRegister(rt) << ", " << DisasmMemoryRRI(rn,rm,shift,imm,false,u,true);
};

strt_reg.execute = {
  if (unlikely( not CheckCondition(cpu, cond) )) return;

  typedef typename ARCH::U32 U32;
  U32 isval = ComputeImmShift( cpu, cpu.GetGPR( rm ), shift, imm ),
           addr = cpu.GetGPR( rn ), oaddr = addr + (u?isval:-isval);
  cpu.MemUWrite32( addr, cpu.GetGPR( rt ) );
  cpu.SetGPR( rn, oaddr );
};

/*
 * end of strt instruction
 *******************************************************************/

/*******************************************************************
 * strht instruction
 * TODO: force user running mode access
 */

op strht_imm( cond[4]: 0b0000[4]: u[1]: 0b110[3]: rn[4]: rt[4]: shl<4> im1[4]: 0b1011[4]: im0[4] );
strht_imm.var imm : {int32_t} = {u?(im1|im0):-(im1|im0)};
strht_imm.var reject : {Reject} = {(rt == 15) or (rn == 15) or (rn == rt)};

strht_imm.disasm = {
  buffer << "strht" << DisasmCondition(cond) << '\t' << DisasmRegister(rt) << ", " << DisasmMemoryRI(rn,imm,false,false);
};

strht_imm.execute = {
  if (unlikely( not CheckCondition(cpu, cond) )) return;

  typedef typename ARCH::U32 U32;
  typedef typename ARCH::U16 U16;
  U32 addr = cpu.GetGPR( rn );
  cpu.MemUWrite16( addr, U16(cpu.GetGPR( rt )) );
  cpu.SetGPR( rn, addr+ U32(imm) );
};

op strht_reg( cond[4]: 0b0000[4]: u[1]: 0b010[3]: rn[4]: rt[4]: 0b0000[4]: 0b1011[4]: rm[4] );
strht_reg.var reject : {Reject} = {(rt == 15) or (rn == 15) or (rn == rt) or (rm == 15)};

strht_reg.disasm = {
  buffer << "strht" << DisasmCondition(cond) << '\t' << DisasmRegister(rt) << ", " << DisasmMemoryRR(rn,rm,false,u,true);
};

strht_reg.execute = {
  if (unlikely( not CheckCondition(cpu, cond) )) return;

  typedef typename ARCH::U32 U32;
  typedef typename ARCH::U16 U16;
  U32 rmval = cpu.GetGPR( rm ),
           addr = cpu.GetGPR( rn ), oaddr = addr + (u?rmval:-rmval);
  cpu.MemUWrite16( addr, U16(cpu.GetGPR( rt )) );
  cpu.SetGPR( rn, oaddr );
};

/*
 * end of strht instruction
 *******************************************************************/

/*******************************************************************
 * strbt instruction
 * TODO: force user running mode access
 */

op strbt_imm( cond[4]: 0b010[3]: 0b0[1]: u[1]: 0b1[1]: 0b1[1]: 0b0[1]: rn[4]: rt[4]: offset[12] );
strbt_imm.var imm : {int32_t} = {u?offset:-offset};
strbt_imm.var reject : {Reject} = {(rt == 15) or (rn == 15) or (rn == rt)};

strbt_imm.disasm = {
  buffer << "strbt" << DisasmCondition(cond) << '\t' << DisasmRegister(rt) << ", " << DisasmMemoryRI(rn,imm,false,false);
};

strbt_imm.execute = {
  if (unlikely( not CheckCondition(cpu, cond) )) return;
  
  typedef typename ARCH::U32 U32;
  typedef typename ARCH::U8  U8;
  U32 addr = cpu.GetGPR( rn );
  cpu.MemWrite8( addr, U8(cpu.GetGPR( rt )) );
  cpu.SetGPR( rn, addr + U32(imm) );
};

op strbt_reg( cond[4]: 0b011[3]: 0b0[1]: u[1]: 0b1[1]: 0b1[1]: 0b0[1]: rn[4]: rt[4]: imm[5]: shift[2]: 0b0[1]: rm[4] );
strbt_reg.var reject : {Reject} = {(rt == 15) or (rn == 15) or (rn == rt) or (rm == 15)};

strbt_reg.disasm = {
  buffer << "strbt" << DisasmCondition(cond) << '\t' << DisasmRegister(rt) << ", " << DisasmMemoryRRI(rn,rm,shift,imm,false,u,true);
};

strbt_reg.execute = {
  if (unlikely( not CheckCondition(cpu, cond) )) return;

  typedef typename ARCH::U32 U32;
  typedef typename ARCH::U8  U8;
  U32 isval = ComputeImmShift( cpu, cpu.GetGPR( rm ), shift, imm ),
           addr = cpu.GetGPR( rn ), oaddr = addr + (u?isval:-isval);
  cpu.MemWrite8( addr, U8(cpu.GetGPR( rt )) );
  cpu.SetGPR( rn, oaddr );
};

/*
 * end of strbt instruction
 *******************************************************************/

/*******************************************************************
 * pld (Preload Data) instruction
 *
 * PLD signals the memory system that data memory accesses from a
 * specified address are likely in the near future. The memory system
 * can respond by taking actions that are expected to speed up the
 * memory accesses when they do occur, such as pre-loading the cache
 * line containing the specified address into the data cache.
 *
 * TODO: Implement prefetching
 */

op pld_imm( 0b1111[4]: 0b01[2]: 0b0[1]: 0b1[1]: u[1]: r[1]: 0b0[1]: 0b1[1]: rn[4]: 0b1111[4]: offset[12] );
pld_imm.var imm : {int32_t} = {u?offset:-offset};

pld_imm.disasm = {
  buffer << "pld" << (r?"":"w") << "\t" << DisasmMemoryRI(rn,imm,true,false);
};

pld_imm.execute = { /*ignore for now*/ };

op pld_reg( 0b1111[4]: 0b01[2]: 0b1[1]: 0b1[1]: u[1]: r[1]: 0b0[1]: 0b1[1]: rn[4]: 0b1111[4]: imm[5]: shift[2]: 0b0[1]: rm[4] );

pld_reg.disasm = {
  buffer << "pld" << (r?"":"w") << "\t" << DisasmMemoryRRI( rn, rm, shift, imm, true, u, false );
};

pld_reg.execute = { /*ignore for now*/ };

/*
 * end of pld (Preload Data) instruction
 *******************************************************************/

/*******************************************************************
 * pli (Preload Instruction) instruction
 *
 * PLI signals the memory system that instruction memory accesses from
 * a specified address are likely in the near future. The memory
 * system can respond by taking actions that are expected to speed up
 * the memory accesses when they do occur, such as pre-loading the
 * cache line containing the specified address into the instruction
 * cache.
 *
 * TODO: Implement prefetching
 */

op pli_imm( 0b1111[4]: 0b0100[4]: u[1]: 0b101[3]: rn[4]: 0b1111[4]: offset[12] );
pli_imm.var imm : {int32_t} = {u?offset:-offset};

pli_imm.disasm = {
  buffer << "pli" << "\t"
         << DisasmMemoryRI(rn,imm,true,false);
};

pli_imm.execute = { /*ignore for now*/ };

op pli_reg( 0b1111[4]: 0b0110[4]: u[1]: 0b101[3]: rn[4]: 0b1111[4]: imm[5]: shift[2]: 0b0[1]: rm[4] );

pli_reg.disasm = {
  buffer << "pli" << "\t" << DisasmMemoryRRI( rn, rm, shift, imm, true, u, false );
};

pli_reg.execute = { /*ignore for now*/ };

/*
 * end of pli (Preload Instruction) instruction
 *******************************************************************/

/*******************************************************************
 * ldm (Load Multiple) instruction
 *
 * LDM loads multiple registers from consecutive memory locations
 * using an address from a base register. The end-bound address of
 * those locations can optionally be written back to the base
 * register. The registers loaded can include the PC, causing a branch
 * to a loaded address.
 */

op ldm( cond[4]: 0b100[3]: mod[2]: 0b0[1]: w[1]: 0b1[1]: rn[4]: reglist[16] );
ldm.var reject : {Reject} = {(rn == 15) or (reglist == 0)};

ldm.disasm = {
  buffer << "ldm" << DisasmLSMMode(mod) << DisasmCondition(cond) << '\t' << DisasmRegister(rn) << (w?"!":"")
         << ", {" << DisasmRegList(reglist) << "}";
};

ldm.execute = {
  if (unlikely( not CheckCondition(cpu, cond) )) return;
  
  typedef typename ARCH::U32 U32;
  U32 base = cpu.GetGPR( rn );
  LSMIter itr(mod, reglist);
  while (itr.next()) {
    cpu.SetGPR_mem( itr.reg(), cpu.MemRead32( base + U32(itr.offset()) ) );
  }
  
  bool overwritten = (reglist >> rn) & 1;
  if (w and not overwritten) cpu.SetGPR( rn, base + U32(itr.offset()) );
};

/*
 * end of ldm instruction
 *******************************************************************/

/*******************************************************************
 * stm (Store Multiple) instruction
 *
 * STM stores multiple registers to consecutive memory locations using
 * an address from a base register. The end-bound address of those
 * locations can optionally be written back to the base register.
 */

op stm( cond[4]: 0b100[3]: mod[2]: 0b0[1]: w[1]: 0b0[1]: rn[4]: reglist[16] );
stm.var reject : {Reject} = {(rn == 15) or (reglist == 0) or (w and (((reglist & (reglist-1)) >> rn) & 1))};

stm.disasm = {
  buffer << "stm" << DisasmLSMMode(mod) << DisasmCondition(cond) << '\t' << DisasmRegister(rn) << (w?"!":"")
         << ", {" << DisasmRegList(reglist) << "}";
};

stm.execute = {
  if (unlikely( not CheckCondition(cpu, cond) )) return;
  
  typedef typename ARCH::U32 U32;
  typedef typename ARCH::U32 U32;
  U32 base = cpu.GetGPR( rn );
  LSMIter itr(mod, reglist);
  while (itr.next()) {
    cpu.MemWrite32( base + U32(itr.offset()), cpu.GetGPR( itr.reg() ) );
  }
  
  if (w) cpu.SetGPR( rn, base + U32(itr.offset()) );
};

/*
 * end of stm instruction
 *******************************************************************/

/*******************************************************************
 * ldm ^ (Load Multiple User Registers) instruction 
 */

op ldm_usr( cond[4]: 0b100[3]: mod[2]: 0b1[1]: 0b0[1]: 0b1[1]: rn[4]: 0b0[1]: reglist[15] );
ldm_usr.var reject : {Reject} = {(rn == 15) or (reglist == 0)};

ldm_usr.disasm = {
  buffer << "ldm" << DisasmLSMMode(mod) << DisasmCondition(cond) << '\t' << DisasmRegister(rn)
         << ", {" << DisasmRegList(reglist) << "}^";
};

ldm_usr.execute = {
  if (unlikely( not CheckCondition(cpu, cond) )) return;
  
  typedef typename ARCH::U32 U32;
  
  U32 runmode = cpu.CPSR().Get(M);
  if (unlikely( cpu.Test(runmode == U32(cpu.HYPERVISOR_MODE)) ))
    {
      cpu.UndefinedInstruction( this );
      return;
    }
  if (unlikely( cpu.Test((runmode == U32(cpu.USER_MODE)) or (runmode == U32(cpu.SYSTEM_MODE))) ))
    {
      cpu.UnpredictableInsnBehaviour();
      return;
    }
  
  U32 base = cpu.GetGPR( rn );
  LSMIter itr(mod, reglist);
  while (itr.next()) {
    cpu.SetBankedRegister( cpu.USER_MODE, itr.reg(), cpu.MemRead32( base + U32(itr.offset()) ) );
  }
};

op ldm_rfe( cond[4]: 0b100[3]: mod[2]: 0b1[1]: w[1]: 0b1[1]: rn[4]: 0b1[1]: regnpclist[15] );
ldm_rfe.var reglist : {uint32_t} = {regnpclist | 0x8000};
ldm_rfe.var reject : {Reject} = {(rn == 15) or ((reglist >> rn) & w)};

ldm_rfe.disasm = {
  buffer << "ldm" << DisasmLSMMode(mod) << DisasmCondition(cond) << '\t' << DisasmRegister(rn) << (w?"!":"")
         << ", {" << DisasmRegList(reglist) << "}^";
};

ldm_rfe.execute = {
  if (unlikely( not CheckCondition(cpu, cond) )) return;
  
  typedef typename ARCH::U32 U32;
  
  U32 runmode = cpu.CPSR().Get(M);
  if (unlikely( cpu.Test( runmode == U32(ARCH::HYPERVISOR_MODE) ) ))
    {
      cpu.UndefinedInstruction( this );
      return;
    }
  if (unlikely( cpu.Test((runmode == U32(ARCH::USER_MODE)) or (runmode == U32(ARCH::SYSTEM_MODE))) ))
    {
      cpu.UnpredictableInsnBehaviour();
      return;
    }
  
  U32 base = cpu.GetGPR( rn );
  LSMIter itr(mod, reglist);
  U32 new_pc_value = U32(1); //< Illegal address to be sure that value is overwritten
  while (itr.next()) {
    U32 value = cpu.MemRead32( base + U32(itr.offset()) );
    if (itr.reg() != 15) cpu.SetGPR( itr.reg(), value );
    else                 new_pc_value = value;
  }
  if (w) cpu.SetGPR( rn, base + U32(itr.offset()) );
  
  CPSRWriteByInstr( cpu, cpu.CurrentMode().GetSPSR(), 0xffffffff );
  // Cannot return to Hyp mode and ThumbEE state
  if (unlikely( cpu.Test((cpu.CPSR().Get(M) == U32(cpu.HYPERVISOR_MODE)) and
                               (cpu.CPSR().Get(J) == U32(1)) and (cpu.CPSR().Get(T) == U32(1))) ))
    cpu.UnpredictableInsnBehaviour();
  
  cpu.BranchExchange( new_pc_value, ARCH::B_RFE );
};

/*
 * end of ldm ^ (Load Multiple User Registers) instruction
 *******************************************************************/

/*******************************************************************
 * stm ^ (Store Multiple User Registers) instruction 
 */

op stm_usr( cond[4]: 0b100[3]: mod[2]: 0b1[1]: 0b0[1]: 0b0[1]: rn[4]: reglist[16] );
stm_usr.var reject : {Reject} = {(rn == 15) or (reglist == 0)};

stm_usr.disasm = {
  buffer << "stm" << DisasmLSMMode(mod) << DisasmCondition(cond) << '\t' << DisasmRegister(rn)
         << ", {" << DisasmRegList(reglist) << "}^";
};

stm_usr.execute = {
  if (unlikely( not CheckCondition(cpu, cond) )) return;

  typedef typename ARCH::U32 U32;
  
  U32 runmode = cpu.CPSR().Get(M);
  if (unlikely( cpu.Test(runmode == U32(cpu.HYPERVISOR_MODE)) ))
    {
      cpu.UndefinedInstruction( this );
      return;
    }
  if (unlikely( cpu.Test((runmode == U32(cpu.USER_MODE)) or (runmode == U32(cpu.SYSTEM_MODE))) ))
    {
      cpu.UnpredictableInsnBehaviour();
      return;
    }
  
  U32 base = cpu.GetGPR( rn );
  LSMIter itr(mod, reglist);
  while (itr.next()) {
    cpu.MemWrite32( base + U32(itr.offset()), cpu.GetBankedRegister( cpu.USER_MODE, itr.reg() ) );
  }
};

/*
 * end of stm ^ (Store Multiple User Registers) instruction
 *******************************************************************/

/**********************************************

           ATOMIC INSTRUCTIONS

**********************************************/

/*******************************************************************
 * swp instruction
 */

op swp( cond[4]: 0b00010000[8]: rn[4]: rt[4]: 0b0000[4]: 0b1001[4]: rt2[4] );

swp.disasm = {
  buffer << "swp" << DisasmCondition(cond) << '\t' << DisasmRegister(rt) << ", "
         << DisasmRegister(rt2) << ", "
         << "[" << DisasmRegister(rn) << "]";
};

swp.execute = {
  if (unlikely( not CheckCondition(cpu, cond) )) return;
  
  typedef typename ARCH::U32 U32;
  
  U32 address = cpu.GetGPR(rn);
  /* bus lock */
  U32 data = cpu.MemRead32(address);
  cpu.MemWrite32(address, cpu.GetGPR(rt2));
  /* bus unlock */
  cpu.SetGPR_mem( rt, data );
};

/*
 * end of swp instruction
 *******************************************************************/

/*******************************************************************
 * swpb instruction
 */

op swpb( cond[4]: 0b00010100[8]: rn[4]: rt[4]: 0b0000[4]: 0b1001[4]: rt2[4] );

swpb.disasm = {
  buffer << "swpb" << DisasmCondition(cond) << '\t' << DisasmRegister(rt) << ", "
         << DisasmRegister(rt2) << ", "
         << "[" << DisasmRegister(rn) << "]";
};

swpb.execute = {
  if (unlikely( not CheckCondition(cpu, cond) )) return;
  
  typedef typename ARCH::U32 U32;
  typedef typename ARCH::U8 U8;
  
  U32 address = cpu.GetGPR(rn);
  /* bus lock */
  U8 data( cpu.MemRead8(address) );
  cpu.MemWrite8(address, U8(cpu.GetGPR(rt2)));
  /* bus unlock */
  cpu.SetGPR_mem( rt, U32( data ) );
};

/*
 * end of swpb instruction
 *******************************************************************/

/*******************************************************************
 * ldrex (Load Register Exclusive) instruction
 *
 * LDREX calculates an address from a base register value and an
 * immediate offset, loads a word from memory, writes it to a register
 * and: 1. if the address has the Shared Memory attribute, marks the
 * physical address as exclusive access for the executing processor in
 * a monitor, 2. causes the executing processor to indicate an active
 * exclusive access in the local monitor.
 */

op ldrex( cond[4]: 0b0001100[7]: 0b1[1]: rn[4]: rt[4]: 0b1111[4]: 0b1001[4]: 0b1111[4] );
ldrex.var reject : {Reject} = {(rt == 15) or (rn == 15)};

ldrex.disasm = {
  buffer << "ldrex" << DisasmCondition(cond) << '\t' << DisasmRegister(rt) << ", " << "[" << DisasmRegister(rn) << "]";
};

ldrex.execute = {
  if (unlikely( not CheckCondition(cpu, cond) )) return;
  
  typename ARCH::U32 addr = cpu.GetGPR( rn );
  
  cpu.SetExclusiveMonitors( addr, 4 );
  cpu.SetGPR_mem( rt, cpu.MemRead32( addr ) );
};

/*
 * end of ldrex instruction
 *******************************************************************/

/*******************************************************************
 * ldrexh (Load Register Exclusive Halfword) instruction
 */

op ldrexh( cond[4]: 0b0001111[7]: 0b1[1]: rn[4]: rt[4]: 0b1111[4]: 0b1001[4]: 0b1111[4] );
ldrexh.var reject : {Reject} = {(rt == 15) or (rn == 15)};

ldrexh.disasm = {
  buffer << "ldrexh" << DisasmCondition(cond) << '\t' << DisasmRegister(rt) << ", "
         << "[" << DisasmRegister(rn) << "]";
};

ldrexh.execute = {
  if (unlikely( not CheckCondition(cpu, cond) )) return;
  
  typedef typename ARCH::U32 U32;
  
  U32 addr = cpu.GetGPR( rn );
  
  cpu.SetExclusiveMonitors( addr, 2 );
  cpu.SetGPR_mem( rt, U32( cpu.MemRead16( addr ) ) );
};

/*
 * end of ldrexh instruction
 *******************************************************************/

/*******************************************************************
 * ldrexb (Load Register Exclusive Byte) instruction
 */

op ldrexb( cond[4]: 0b0001110[7]: 0b1[1]: rn[4]: rt[4]: 0b1111[4]: 0b1001[4]: 0b1111[4] );
ldrexb.var reject : {Reject} = {(rt == 15) or (rn == 15)};

ldrexb.disasm = {
  buffer << "ldrexb" << DisasmCondition(cond) << '\t' << DisasmRegister(rt) << ", "
         << "[" << DisasmRegister(rn) << "]";
};

ldrexb.execute = {
  if (unlikely( not CheckCondition(cpu, cond) )) return;
  
  typedef typename ARCH::U32 U32;
  
  U32 addr = cpu.GetGPR( rn );
  
  cpu.SetExclusiveMonitors( addr, 1 );
  cpu.SetGPR_mem( rt, U32( cpu.MemRead8( addr ) ) );
};

/*
 * end of ldrexb instruction
 *******************************************************************/

/*******************************************************************
 * ldrexd (Load Register Exclusive Doubleword) instruction
 */

op ldrexd( cond[4]: 0b0001101[7]: 0b1[1]: rn[4]: rt[4]: 0b1111[4]: 0b1001[4]: 0b1111[4] );
ldrexd.var reject : {Reject} = {(rt & 1) or (rt == 14) or (rn == 15)};

ldrexd.disasm = {
  buffer << "ldrexd" << DisasmCondition(cond) << '\t' << DisasmRegister(rt) << ", "
         << "[" << DisasmRegister(rn) << "]";
};

ldrexd.execute = {
  if (unlikely( not CheckCondition(cpu, cond) )) return;
  
  typedef typename ARCH::U32 U32;
  U32 addr = cpu.GetGPR( rn );
  
  cpu.SetExclusiveMonitors( addr, 8 );
  cpu.SetGPR_mem( (rt+0) & 0xf, cpu.MemRead32( addr + U32(0) ) );
  cpu.SetGPR_mem( (rt+1) & 0xf, cpu.MemRead32( addr + U32(4) ) );
};

/*
 * end of ldrexd instruction
 *******************************************************************/

/*******************************************************************
 * strex (Store Register Exclusive) instruction
 *
 * STREX calculates an address from a base register value and an
 * immediate offset, and stores a word from a register to memory if
 * the executing processor has exclusive access to the memory
 * addressed.
 */

op strex( cond[4]: 0b0001100[7]: 0b0[1]: rn[4]: rd[4]: 0b1111[4]: 0b1001[4]: rt[4] );
strex.var reject : {Reject} = {(rd == 15) or (rt == 15) or (rn == 15) or (rd == rn) or (rd == rt)};

strex.disasm = {
  buffer << "strex" << DisasmCondition(cond) << '\t' << DisasmRegister(rd) << ", "
         << DisasmRegister(rt) << ", "
         << "[" << DisasmRegister(rn) << "]";
};

strex.execute = {
  if (unlikely( not CheckCondition(cpu, cond) )) return;
  
  typedef typename ARCH::U32 U32;
  U32 addr = cpu.GetGPR( rn );
  
  if (cpu.ExclusiveMonitorsPass(addr, 4)) {
    cpu.MemWrite32( addr, cpu.GetGPR( rt ) );
    cpu.SetGPR( rd, U32(0) );
  } else {
    cpu.SetGPR( rd, U32(1) );
  }
};

/*
 * end of strex instruction
 *******************************************************************/

/*******************************************************************
 * strexh (Store Register Exclusive Halfword) instruction
 */

op strexh( cond[4]: 0b0001111[7]: 0b0[1]: rn[4]: rd[4]: 0b1111[4]: 0b1001[4]: rt[4] );
strexh.var reject : {Reject} = {(rd == 15) or (rt == 15) or (rn == 15) or (rd == rn) or (rd == rt)};

strexh.disasm = {
  buffer << "strexh" << DisasmCondition(cond) << '\t' << DisasmRegister(rd) << ", "
         << DisasmRegister(rt) << ", "
         << "[" << DisasmRegister(rn) << "]";
};

strexh.execute = {
  if (unlikely( not CheckCondition(cpu, cond) )) return;
  
  typedef typename ARCH::U32 U32;
  U32 addr = cpu.GetGPR( rn );
  
  if (cpu.ExclusiveMonitorsPass(addr, 2)) {
    cpu.MemWrite16( addr, typename ARCH::U16(cpu.GetGPR( rt )) );
    cpu.SetGPR( rd, U32(0) );
  } else {
    cpu.SetGPR( rd, U32(1) );
  }
};

/*
 * end of strexh instruction
 *******************************************************************/

/*******************************************************************
 * strexb (Store Register Exclusive Byte) instruction
 */

op strexb( cond[4]: 0b0001110[7]: 0b0[1]: rn[4]: rd[4]: 0b1111[4]: 0b1001[4]: rt[4] );
strexb.var reject : {Reject} = {(rd == 15) or (rt == 15) or (rn == 15) or (rd == rn) or (rd == rt)};

strexb.disasm = {
  buffer << "strexb" << DisasmCondition(cond) << '\t' << DisasmRegister(rd) << ", "
         << DisasmRegister(rt) << ", "
         << "[" << DisasmRegister(rn) << "]";
};

strexb.execute = {
  if (unlikely( not CheckCondition(cpu, cond) )) return;
  
  typedef typename ARCH::U32 U32;
  U32 addr = cpu.GetGPR( rn );
  
  if (cpu.ExclusiveMonitorsPass(addr, 1)) {
    cpu.MemWrite8( addr, typename ARCH::U8(cpu.GetGPR( rt )) );
    cpu.SetGPR( rd, U32(0) );
  } else {
    cpu.SetGPR( rd, U32(1) );
  }
};

/*
 * end of strexb instruction
 *******************************************************************/

/*******************************************************************
 * strexd (Store Register Exclusive Doubleword) instruction
 */

op strexd( cond[4]: 0b0001101[7]: 0b0[1]: rn[4]: rd[4]: 0b1111[4]: 0b1001[4]: rt[4] );
strexd.var reject : {Reject} = {(rd == 15) or (rt & 1) or (rt == 14) or (rn == 15) or
                                (rd == rn) or ((rd & 0xe) == rt)};

strexd.disasm = {
  buffer << "strexd" << DisasmCondition(cond) << '\t' << DisasmRegister(rd) << ", "
         << DisasmRegister(rt) << ", "
         << "[" << DisasmRegister(rn) << "]";
};

strexd.execute = {
  if (unlikely( not CheckCondition(cpu, cond) )) return;
  
  typedef typename ARCH::U32 U32;
  U32 addr = cpu.GetGPR( rn );
  
  if (cpu.ExclusiveMonitorsPass(addr, 8)) {
    cpu.MemWrite32( addr + U32(0), cpu.GetGPR( (rt+0) & 0xf ) );
    cpu.MemWrite32( addr + U32(4), cpu.GetGPR( (rt+1) & 0xf ) );
    cpu.SetGPR( rd, U32(0) );
  } else {
    cpu.SetGPR( rd, U32(1) );
  }
};

/*
 * end of strexd instruction
 *******************************************************************/

/*******************************************************************
 * clrex (Clear Exclusive) instruction
 *
 * CLREX clears the local record of the executing processor that an
 * address has had a request for an exclusive access.
 */

op clrex( 0b1111[4]: 0b01010111[8]: 0b1111[4]: 0b1111[4]: 0b0000[4]: 0b0001[4]: 0b1111[4] );

clrex.disasm = {
  buffer << "clrex";
};

clrex.execute = {
  cpu.ClearExclusiveLocal();
};

/*
 * end of strexd instruction
 *******************************************************************/

