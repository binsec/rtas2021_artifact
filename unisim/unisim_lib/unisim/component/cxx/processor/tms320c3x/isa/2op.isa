/*
 *  Copyright (c) 2009,
 *  Commissariat a l'Energie Atomique (CEA)
 *  All rights reserved.
 *
 *  Redistribution and use in source and binary forms, with or without modification,
 *  are permitted provided that the following conditions are met:
 *
 *   - Redistributions of source code must retain the above copyright notice, this
 *     list of conditions and the following disclaimer.
 *
 *   - Redistributions in binary form must reproduce the above copyright notice,
 *     this list of conditions and the following disclaimer in the documentation
 *     and/or other materials provided with the distribution.
 *
 *   - Neither the name of CEA nor the names of its contributors may be used to
 *     endorse or promote products derived from this software without specific prior
 *     written permission.
 *
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 *  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 *  DISCLAIMED.
 *  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,
 *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
 *  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 *  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
 *  OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 *  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
 *  EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * Authors: Daniel Gracia Perez (daniel.gracia-perez@cea.fr)
 *          Gilles Mouchard (gilles.mouchard@cea.fr)
 */

/* List of 2 operands operations:
 * - ABSF         absolute value of a floating-point number
 * - ABSI         absolute value of an integer
 * - ADDC         add integers with carry
 * - ADDF         add floating-point values
 * - ADDI         add integers
 * - AND          bitwise-logical AND
 * - ANDN         bitwise-logical AND with complement
 * - ASH          arithmetic shift
 * - CMPF         compare floating-point values
 * - CMPI         compare integers
 * - FIX          convert floating-point value to integer
 * - FLOAT        convert integer to floating-point value
 * - LSH          logical shift
 * - MPYF         multiply floating-point values
 * - MPYI         multiply integers
 * - NEGB         negate integer with borrow
 * - NEGF         negate floating-point value
 * - NEGI         negate integer
 * - NORM         normalize floating-point value
 * - NOT          bitwise-logical complement
 * - OR           bitwise-logical OR
 * - RND          round floating-point value
 * - ROL          rotate left
 * - ROLC         rotate left through carry
 * - ROR          rotate right
 * - RORC         rotate right through carry
 * - SUBB         subtract integers with borrow
 * - SUBC         subtract integers conditionally
 * - SUBF         subtract floating-point values
 * - SUBI         subtract integer
 * - SUBRB        subtract reverse integer with borrow
 * - SUBRF        subtract reverse floating-point value
 * - SUBRI        subtract reverse integer
 * - TSTB         test bit fields
 * - XOR          bitwise-exclusive OR
 */

/**********************************************************
 * ABSF (absolute value of a floating-point number)
 * op ABSF(0b000[3]:0b000000[6]:g[2]:dst[5]:src[16])
 */
 
op ABSF_reg  (0b000[3]:0b000000[6]:0b00[2]:dst[5]:0[11]:src[5])
op ABSF_dir  (0b000[3]:0b000000[6]:0b01[2]:dst[5]:direct[16])
op ABSF_indir(0b000[3]:0b000000[6]:0b10[2]:dst[5]:mod[5]:ar[3]:disp[8])
op ABSF_imm  (0b000[3]:0b000000[6]:0b11[2]:dst[5]:imm[16])

ABSF_reg.disasm = {
	const char *dst_name = REG_NAME[dst];
	const char *src_name = REG_NAME[src];
	
	if (!dst_name || !src_name)
		return false;
	
	os << "ABSF " << src_name << ", " << dst_name;
	return true;
}

ABSF_dir.disasm = {
	const char *dst_name = REG_NAME[dst];

	if(!dst_name)
		return false;
	
	os << "ABSF @0x" << hex << cpu.DisasmDir(Operation<CONFIG, DEBUG>::GetAddr() / 4, direct) << dec << ", " << dst_name;
	
	return true;
}

ABSF_indir.disasm = {
	string disasm_src_indir;
	const char *dst_name = REG_NAME[dst];

	if (!dst_name || !cpu.DisasmIndir(disasm_src_indir, Operation<CONFIG, DEBUG>::GetAddr() / 4, mod, ar, disp)) 
		return false;

	os << "ABSF " << disasm_src_indir << ", " << dst_name;
	return true;
}

ABSF_imm.disasm = {
	const char *dst_name = REG_NAME[dst];

	if (!dst_name)
		return false;

	os << "ABSF " << cpu.DisasmShortFloat(imm) << ", " << dst_name;
	return true;
}

ABSF_reg.execute = {
	// Check that destination and source registers are valid
	if (likely(!cpu.EnableFloatOpsWithNonExtRegs())) {
		if (unlikely(!cpu.IsExtReg(dst) || !cpu.IsExtReg(src)))
			throw BogusOpcodeException<CONFIG, DEBUG>(this);
	} 
	else
	{
		if(unlikely(!cpu.HasReg(dst) || !cpu.HasReg(src)))
		{
			throw BogusOpcodeException<CONFIG, DEBUG>(this);
		}
	}

	// get source register
	Register& src_reg = cpu.GetExtReg(src);
	
	// get destination register
	Register& dst_reg = cpu.GetExtReg(dst);
	
	if (unlikely(!cpu.IsExtReg(src)))
	{
		src_reg.SetHiWriteMask(0, (uint8_t)0x10);
		if (unlikely(!cpu.IsExtReg(dst)))
			dst_reg.SetHiWriteMask(0, (uint8_t)0x10);
	}
	else
		if (unlikely(!cpu.IsExtReg(dst)))
			dst_reg.SetHiWriteMask(0, (uint8_t)0);

	// Compute the result
	uint32_t overflow;
	
	dst_reg.Absf(src_reg, overflow);
	
	// Generate flags (into ST)
	if (likely(cpu.IsExtReg(dst)))
		cpu.GenFlags(dst_reg,
			 M_ST_UF | M_ST_N | M_ST_Z | M_ST_V,  // reset mask
			 M_ST_LV | M_ST_Z | M_ST_V,    // or mask
			 overflow, 0, 0
			 );
}

ABSF_dir.execute = {
	// Check that destination register is valid
	if (likely(!cpu.EnableFloatOpsWithNonExtRegs()))
	{
		if (unlikely(!cpu.IsExtReg(dst)))
			throw BogusOpcodeException<CONFIG, DEBUG>(this);
	}
	else
	{
		if (unlikely(!cpu.HasReg(dst)))
			throw BogusOpcodeException<CONFIG, DEBUG>(this);
	}
	
	// get destination register
	Register& dst_reg = cpu.GetExtReg(dst);
	if (unlikely(!cpu.IsExtReg(dst)))
		dst_reg.SetHiWriteMask(0, (uint8_t)0);
	
	// Compute the source operand effective address
	typename CONFIG::address_t ea = cpu.ComputeDirEA(direct);
	
	// Read the source operand from memory
	uint32_t src_value = cpu.IntLoad(ea);
	
	// Compute the result
	uint32_t overflow;

	dst_reg.Absf32(src_value, overflow);
	
	// Generate flags (into ST)
	if (likely(cpu.IsExtReg(dst)))
		cpu.GenFlags(dst_reg,
			 M_ST_UF | M_ST_N | M_ST_Z | M_ST_V,  // reset mask
			 M_ST_LV | M_ST_Z | M_ST_V,    // or mask
			 overflow, 0, 0
			 );
}

ABSF_indir.execute = {
	// Check that destination register is valid
	if (likely(!cpu.EnableFloatOpsWithNonExtRegs()))
	{
		if (unlikely(!cpu.IsExtReg(dst)))
			throw BogusOpcodeException<CONFIG, DEBUG>(this);
	}
	else
	{
		if (unlikely(!cpu.HasReg(dst)))
			throw BogusOpcodeException<CONFIG, DEBUG>(this);
	}
	
	// Check that indirect addressing mode is valid and compute the effective address of the source operand
	typename CONFIG::address_t ea;        // The effective address
	bool update_ar;                       // Whether to update ARn
	typename CONFIG::address_t output_ar; // New value of ARn if it is updated
	
	if(unlikely(!cpu.ComputeIndirEA(ea, update_ar, output_ar, mod, ar, disp)))
	{
		throw BogusOpcodeException<CONFIG, DEBUG>(this);
	}
	
	if(update_ar)
	{
		// Write back ARn
		cpu.SetAR23_0(ar, output_ar);
	}
	
	// get destination register
	Register& dst_reg = cpu.GetExtReg(dst);
	if (unlikely(!cpu.IsExtReg(dst)))
		dst_reg.SetHiWriteMask(0, (uint8_t)0x08);

	// Read the source operand from memory
	uint32_t src_value = cpu.IntLoad(ea);
	
	// Compute the result
	uint32_t overflow;
	
	dst_reg.Absf32(src_value, overflow);
	
	// Generate flags (into ST)
	if (likely(cpu.IsExtReg(dst)))
		cpu.GenFlags(dst_reg,
			 M_ST_UF | M_ST_N | M_ST_Z | M_ST_V,  // reset mask
			 M_ST_LV | M_ST_Z | M_ST_V,    // or mask
			 overflow, 0, 0
			 );
}

ABSF_imm.execute = {
	// Check that destination register is valid
	if (likely(!cpu.EnableFloatOpsWithNonExtRegs()))
	{
		if (unlikely(!cpu.IsExtReg(dst)))
			throw BogusOpcodeException<CONFIG, DEBUG>(this);
	}
	else
	{
		if (unlikely(!cpu.HasReg(dst)))
			throw BogusOpcodeException<CONFIG, DEBUG>(this);
	}
	
	// get destination register
	Register& dst_reg = cpu.GetExtReg(dst);
	if (unlikely(!cpu.IsExtReg(dst)))
		dst_reg.SetHiWriteMask(0, (uint8_t)0x10);
	
	// Compute the result
	uint32_t overflow;
	dst_reg.Absf16(imm, overflow);
	
	// Generate flags (into ST)
	if (likely(cpu.IsExtReg(dst)))
		cpu.GenFlags(dst_reg,
			 M_ST_UF | M_ST_N | M_ST_Z | M_ST_V,  // reset mask
			 M_ST_LV | M_ST_Z | M_ST_V,    // or mask
			 overflow, 0, 0
			 );
}

/* end of ABSF (absolute value of a floating-point number)
 **********************************************************/

/**********************************************************
 * ABSI (absolute value of an integer)
 * op ABSI(0b000[3]:0b000001[6]:g[2]:dst[5]:src[16])
 */
 
op ABSI_reg  (0b000[3]:0b000001[6]:0b00[2]:dst[5]:0[11]:src[5])
op ABSI_dir  (0b000[3]:0b000001[6]:0b01[2]:dst[5]:direct[16])
op ABSI_indir(0b000[3]:0b000001[6]:0b10[2]:dst[5]:mod[5]:ar[3]:disp[8])
op ABSI_imm  (0b000[3]:0b000001[6]:0b11[2]:dst[5]:sext<32> imm[16])

ABSI_reg.disasm = {
	const char *dst_name = REG_NAME[dst];
	const char *src_name = REG_NAME[src];
	
	if (!dst_name || !src_name)
		return false;
	
	os << "ABSI " << src_name << ", " << dst_name;
	return true;
}

ABSI_dir.disasm = {
	const char *dst_name = REG_NAME[dst];

	if(!dst_name)
		return false;
	
	os << "ABSI " << hex << cpu.DisasmDir(Operation<CONFIG, DEBUG>::GetAddr() / 4, direct) << dec << ", " << dst_name;
	
	return true;
}

ABSI_indir.disasm = {
	string disasm_src_indir;
	const char *dst_name = REG_NAME[dst];

	if (!dst_name || !cpu.DisasmIndir(disasm_src_indir, Operation<CONFIG, DEBUG>::GetAddr() / 4, mod, ar, disp)) 
		return false;

	os << "ABSI " << disasm_src_indir << ", " << dst_name;
	return true;
}

ABSI_imm.disasm = {
	const char *dst_name = REG_NAME[dst];

	if (!dst_name)
		return false;

	os << "ABSI " << imm << ", " << dst_name;
	return true;
}

ABSI_reg.execute = {
	// Check that source and destination registers are valid
	if(unlikely(!cpu.HasReg(src) || !cpu.HasReg(dst)))
	{
		throw BogusOpcodeException<CONFIG, DEBUG>(this);
	}

	// Read source operand
	uint32_t src_value = cpu.GetReg(src);

	// Compute the result
	uint32_t result;      // the 32-bit result
	uint8_t overflow;     // the overflow (0 or 1)

	if(src_value == 0x80000000)
	{
		overflow = 1;
		// Depending on overflow mode do signed saturation or not 
		result = cpu.GetST_OVM() ? 0x7fffffff : 0x80000000;
	}
	else
	{
		overflow = 0;
		result = ((int32_t) src_value >= 0) ? src_value : -src_value;
	}

	// Write back result
	cpu.SetReg(dst, result);

	// Check whether destination operand is an extended precision register
	if(cpu.IsExtReg(dst))
	{
		// Generate flags (into ST)
		cpu.GenFlags(
			result,
			M_ST_UF | M_ST_N | M_ST_Z | M_ST_V,  // reset mask
			M_ST_Z | M_ST_V,    // or mask
			0, // carry out
			0, //negative
			overflow
		);
	}
}

ABSI_dir.execute = {
	// Check that destination register is valid
	if(unlikely(!cpu.HasReg(dst)))
	{
		throw BogusOpcodeException<CONFIG, DEBUG>(this);
	}

	// Compute the source operand effective address
	typename CONFIG::address_t ea = cpu.ComputeDirEA(direct);

	// Read the source operand from memory
	uint32_t src_value = cpu.IntLoad(ea);

	// Compute the result
	uint32_t result;      // the 32-bit result
	uint8_t overflow;     // the overflow (0 or 1)

	if(src_value == 0x80000000)
	{
		overflow = 1;
		// Depending on overflow mode do signed saturation or not 
		result = cpu.GetST_OVM() ? 0x7fffffff : 0x80000000;
	}
	else
	{
		overflow = 0;
		result = ((int32_t) src_value >= 0) ? src_value : -src_value;
	}

	// Write back result
	cpu.SetReg(dst, result);

	// Check whether destination operand is an extended precision register
	if(cpu.IsExtReg(dst))
	{
		// Generate flags (into ST)
		cpu.GenFlags(
			result,
			M_ST_UF | M_ST_N | M_ST_Z | M_ST_V,  // reset mask
			M_ST_Z | M_ST_V,    // or mask
			0, // carry out
			0, //negative
			overflow
		);
	}
}

ABSI_indir.execute = {
	// Check that destination register is valid
	if(unlikely(!cpu.HasReg(dst)))
	{
		throw BogusOpcodeException<CONFIG, DEBUG>(this);
	}

	// Check that indirect addressing mode is valid and compute the effective address of the source operand
	typename CONFIG::address_t ea;        // The effective address
	bool update_ar;                       // Whether to update ARn
	typename CONFIG::address_t output_ar; // New value of ARn if it is updated

	if(unlikely(!cpu.ComputeIndirEA(ea, update_ar, output_ar, mod, ar, disp)))
	{
		throw BogusOpcodeException<CONFIG, DEBUG>(this);
	}

	if(update_ar)
	{
		// Write back ARn
		cpu.SetAR23_0(ar, output_ar);
	}

	// Read the source operand from memory
	uint32_t src_value = cpu.IntLoad(ea);

	// Compute the result
	uint32_t result;      // the 32-bit result
	uint8_t overflow;     // the overflow (0 or 1)

	if(src_value == 0x80000000)
	{
		overflow = 1;
		// Depending on overflow mode do signed saturation or not 
		result = cpu.GetST_OVM() ? 0x7fffffff : 0x80000000;
	}
	else
	{
		overflow = 0;
		result = ((int32_t) src_value >= 0) ? src_value : -src_value;
	}

	// Write back result
	cpu.SetReg(dst, result);

	// Check whether destination operand is an extended precision register
	if(cpu.IsExtReg(dst))
	{
		// Generate flags (into ST)
		cpu.GenFlags(
			result,
			M_ST_UF | M_ST_N | M_ST_Z | M_ST_V,  // reset mask
			M_ST_Z | M_ST_V,    // or mask
			0, // carry out
			0, //negative
			overflow
		);
	}
}

ABSI_imm.execute = {
	// Check that destination register is valid
	if(unlikely(!cpu.HasReg(dst)))
	{
		throw BogusOpcodeException<CONFIG, DEBUG>(this);
	}

	// Compute the result
	uint32_t result;      // the 32-bit result
	uint8_t overflow;     // the overflow (0 or 1)

	if((uint32_t) imm == 0x80000000)
	{
		overflow = 1;
		// Depending on overflow mode do signed saturation or not 
		result = cpu.GetST_OVM() ? 0x7fffffff : 0x80000000;
	}
	else
	{
		overflow = 0;
		result = (imm >= 0) ? imm : -imm;
	}

	// Write back result
	cpu.SetReg(dst, result);

	// Check whether destination operand is an extended precision register
	if(cpu.IsExtReg(dst))
	{
		// Generate flags (into ST)
		cpu.GenFlags(
			result,
			M_ST_UF | M_ST_N | M_ST_Z | M_ST_V,  // reset mask
			M_ST_Z | M_ST_V,    // or mask
			0, // carry out
			0, //negative
			overflow
		);
	}
}

/* end of ABSI (absolute value of an integer)
 **********************************************************/

/**********************************************************
 * ADDC (add integers with carry)
 * op ADDC(0b000[3]:0b000010[6]:g[2]:dst[5]:src[16])
 */

op ADDC_reg  (0b000[3]:0b000010[6]:0b00[2]:dst[5]:0[11]:src[5])
op ADDC_dir  (0b000[3]:0b000010[6]:0b01[2]:dst[5]:direct[16])
op ADDC_indir(0b000[3]:0b000010[6]:0b10[2]:dst[5]:mod[5]:ar[3]:disp[8])
op ADDC_imm  (0b000[3]:0b000010[6]:0b11[2]:dst[5]:sext<32> imm[16])

ADDC_reg.disasm = {
	const char *dst_name = REG_NAME[dst];
	const char *src_name = REG_NAME[src];
	
	if (!dst_name || !src_name)
		return false;
	
	os << "ADDC " << src_name << ", " << dst_name;
	return true;
}

ADDC_dir.disasm = {
	const char *dst_name = REG_NAME[dst];

	if(!dst_name)
		return false;
	
	os << "ADDC " << hex << cpu.DisasmDir(Operation<CONFIG, DEBUG>::GetAddr() / 4, direct) << dec << ", " << dst_name;
	
	return true;
}

ADDC_indir.disasm = {
	string disasm_src_indir;
	const char *dst_name = REG_NAME[dst];

	if (!dst_name || !cpu.DisasmIndir(disasm_src_indir, Operation<CONFIG, DEBUG>::GetAddr() / 4, mod, ar, disp)) 
		return false;

	os << "ADDC " << disasm_src_indir << ", " << dst_name;

	return true;
}

ADDC_imm.disasm = {
	const char *dst_name = REG_NAME[dst];

	if (!dst_name)
		return false;

	os << "ADDC " << imm << ", " << dst_name;
	return true;
}

ADDC_reg.execute = {
	// Check that source and destination registers are valid
	if(unlikely(!cpu.HasReg(src) || !cpu.HasReg(dst)))
	{
		throw BogusOpcodeException<CONFIG, DEBUG>(this);
	}

	// Read source operand
	uint32_t src_value = cpu.GetReg(src);

	// Read destination operand
	uint32_t dst_value = cpu.GetReg(dst);

	// Read carry in
	uint8_t carry_in = cpu.GetST_C();

	// Compute the result
	uint32_t result;      // the 32-bit result
	uint8_t carry_out;    // the carry out (0 or 1)
	uint8_t overflow;     // the overflow (0 or 1)
	uint8_t sign;         // the sign (0 or 1)

	// Depending on overflow mode do signed saturation or not 
	if(cpu.GetST_OVM())
	{
		SignedSatAdd32(result, carry_out, overflow, sign, dst_value, src_value, carry_in);
	}
	else
	{
		SignedAdd32(result, carry_out, overflow, sign, dst_value, src_value, carry_in);
		sign = sign ^ overflow;
	}

	// Write back result
	cpu.SetReg(dst, result);

	// Check whether destination operand is an extended precision register
	if(cpu.IsExtReg(dst))
	{
		// Generate flags (into ST)
		cpu.GenFlags(
			result,
			M_ST_UF | M_ST_N | M_ST_Z | M_ST_V | M_ST_C,  // reset mask
			M_ST_LV | M_ST_N | M_ST_Z | M_ST_V | M_ST_C,  // or mask
			sign,
			carry_out,
			overflow
		);
	}
}

ADDC_dir.execute = {
	// Check that destination register is valid
	if(unlikely(!cpu.HasReg(dst)))
	{
		throw BogusOpcodeException<CONFIG, DEBUG>(this);
	}

	// Read destination operand
	uint32_t dst_value = cpu.GetReg(dst);

	// Compute the source operand effective address
	typename CONFIG::address_t ea = cpu.ComputeDirEA(direct);

	// Read the source operand from memory
	uint32_t src_value = cpu.IntLoad(ea);

	// Read carry in
	uint8_t carry_in = cpu.GetST_C();

	// Compute the result
	uint32_t result;      // the 32-bit result
	uint8_t carry_out;    // the carry out (0 or 1)
	uint8_t overflow;     // the overflow (0 or 1)
	uint8_t sign;         // the sign (0 or 1)

	// Depending on overflow mode do signed saturation or not 
	if(cpu.GetST_OVM())
	{
		SignedSatAdd32(result, carry_out, overflow, sign, dst_value, src_value, carry_in);
	}
	else
	{
		SignedAdd32(result, carry_out, overflow, sign, dst_value, src_value, carry_in);
		sign = sign ^ overflow;
	}

	// Write back result
	cpu.SetReg(dst, result);

	// Check whether destination operand is an extended precision register
	if(cpu.IsExtReg(dst))
	{
		// Generate flags (into ST)
		cpu.GenFlags(
			result,
			M_ST_UF | M_ST_N | M_ST_Z | M_ST_V | M_ST_C,  // reset mask
			M_ST_LV | M_ST_N | M_ST_Z | M_ST_V | M_ST_C,  // or mask
			sign,
			carry_out,
			overflow
		);
	}
}

ADDC_indir.execute = {
	// Check that destination register is valid
	if(unlikely(!cpu.HasReg(dst)))
	{
		throw BogusOpcodeException<CONFIG, DEBUG>(this);
	}

	// Check that indirect addressing mode is valid and compute the effective address of the source operand
	typename CONFIG::address_t ea;        // The effective address
	bool update_ar;                       // Whether to update ARn
	typename CONFIG::address_t output_ar; // New value of ARn if it is updated

	if(unlikely(!cpu.ComputeIndirEA(ea, update_ar, output_ar, mod, ar, disp)))
	{
		throw BogusOpcodeException<CONFIG, DEBUG>(this);
	}

	if(update_ar)
	{
		// Write back ARn
		cpu.SetAR23_0(ar, output_ar);
	}

	// Read destination operand
	uint32_t dst_value = cpu.GetReg(dst);

	// Read the source operand from memory
	uint32_t src_value = cpu.IntLoad(ea);

	// Read carry in
	uint8_t carry_in = cpu.GetST_C();

	// Compute the result
	uint32_t result;      // the 32-bit result
	uint8_t carry_out;    // the carry out (0 or 1)
	uint8_t overflow;     // the overflow (0 or 1)
	uint8_t sign;         // the sign (0 or 1)

	// Depending on overflow mode do signed saturation or not 
	if(cpu.GetST_OVM())
	{
		SignedSatAdd32(result, carry_out, overflow, sign, dst_value, src_value, carry_in);
	}
	else
	{
		SignedAdd32(result, carry_out, overflow, sign, dst_value, src_value, carry_in);
		sign = sign ^ overflow;
	}

	// Write back result
	cpu.SetReg(dst, result);

	// Check whether destination operand is an extended precision register
	if(cpu.IsExtReg(dst))
	{
		// Generate flags (into ST)
		cpu.GenFlags(
			result,
			M_ST_UF | M_ST_N | M_ST_Z | M_ST_V | M_ST_C,  // reset mask
			M_ST_LV | M_ST_N | M_ST_Z | M_ST_V | M_ST_C,  // or mask
			sign,
			carry_out,
			overflow
		);
	}
}

ADDC_imm.execute = {
	// Check that destination register is valid
	if(unlikely(!cpu.HasReg(dst)))
	{
		throw BogusOpcodeException<CONFIG, DEBUG>(this);
	}

	// Read destination operand
	uint32_t dst_value = cpu.GetReg(dst);

	// Read carry in
	uint8_t carry_in = cpu.GetST_C();

	// Compute the result
	uint32_t result;      // the 32-bit result
	uint8_t carry_out;    // the carry out (0 or 1)
	uint8_t overflow;     // the overflow (0 or 1)
	uint8_t sign;         // the sign (0 or 1)

	// Depending on overflow mode do signed saturation or not 
	if(cpu.GetST_OVM())
	{
		SignedSatAdd32(result, carry_out, overflow, sign, dst_value, imm, carry_in);
	}
	else
	{
		SignedAdd32(result, carry_out, overflow, sign, dst_value, imm, carry_in);
		sign = sign ^ overflow;
	}

	// Write back result
	cpu.SetReg(dst, result);

	// Check whether destination operand is an extended precision register
	if(cpu.IsExtReg(dst))
	{
		// Generate flags (into ST)
		cpu.GenFlags(
			result,
			M_ST_UF | M_ST_N | M_ST_Z | M_ST_V | M_ST_C,  // reset mask
			M_ST_LV | M_ST_N | M_ST_Z | M_ST_V | M_ST_C,  // or mask
			sign,
			carry_out,
			overflow
		);
	}
}

/* end of ADDC (add integers with carry)
 **********************************************************/

/**********************************************************
 * ADDF (add floating-point values)
 * op ADDF(0b000[3]:0b000011[6]:g[2]:dst[5]:src[16])
 */

op ADDF_reg  (0b000[3]:0b000011[6]:0b00[2]:dst[5]:0[11]:src[5])
op ADDF_dir  (0b000[3]:0b000011[6]:0b01[2]:dst[5]:direct[16])
op ADDF_indir(0b000[3]:0b000011[6]:0b10[2]:dst[5]:mod[5]:ar[3]:disp[8])
op ADDF_imm  (0b000[3]:0b000011[6]:0b11[2]:dst[5]:imm[16])

ADDF_reg.disasm = {
	const char *dst_name = REG_NAME[dst];
	const char *src_name = REG_NAME[src];
	
	if (!dst_name || !src_name)
		return false;
	
	os << "ADDF " << src_name << ", " << dst_name;
	return true;
}

ADDF_dir.disasm = {
	const char *dst_name = REG_NAME[dst];

	if(!dst_name)
		return false;
	
	os << "ADDF " << hex << cpu.DisasmDir(Operation<CONFIG, DEBUG>::GetAddr() / 4, direct) << dec << ", " << dst_name;
	
	return true;
}

ADDF_indir.disasm = {
	string disasm_src_indir;
	const char *dst_name = REG_NAME[dst];

	if (!dst_name || !cpu.DisasmIndir(disasm_src_indir, Operation<CONFIG, DEBUG>::GetAddr() / 4, mod, ar, disp)) 
		return false;

	os << "ADDF " << disasm_src_indir << ", " << dst_name;
	return true;
}

ADDF_imm.disasm = {
	const char *dst_name = REG_NAME[dst];

	if (!dst_name)
		return false;

	os << "ADDF " << cpu.DisasmShortFloat(imm) << ", " << dst_name;
	return true;
}

ADDF_reg.execute = {
	// Check that destination and source registers are valid
	if (likely(!cpu.EnableFloatOpsWithNonExtRegs())) {
		if (unlikely(!cpu.IsExtReg(dst) || !cpu.IsExtReg(src)))
			throw BogusOpcodeException<CONFIG, DEBUG>(this);
	} 
	else
	{
		if(unlikely(!cpu.HasReg(dst) || !cpu.HasReg(src)))
		{
			throw BogusOpcodeException<CONFIG, DEBUG>(this);
		}
	}

	// get source register
	Register& src_reg = cpu.GetExtReg(src);
	
	// get destination register
	Register& dst_reg = cpu.GetExtReg(dst);
	
	if (unlikely(!cpu.IsExtReg(src)))
	{
		src_reg.SetHiWriteMask(0, (uint8_t)0x8);
		if (unlikely(!cpu.IsExtReg(dst)))
			dst_reg.SetHiWriteMask(0, (uint8_t)0x8);
	}
	else
		if (unlikely(!cpu.IsExtReg(dst)))
			dst_reg.SetHiWriteMask(0, (uint8_t)0);

	// compute
	uint32_t underflow;
	uint32_t overflow;
	uint32_t neg;
	dst_reg.Addf(src_reg, overflow, underflow, neg);

	// Generate flags (into ST)
	if (likely(cpu.IsExtReg(dst)))
		cpu.GenFlags(
		 	dst_reg,
			M_ST_UF | M_ST_N | M_ST_Z | M_ST_V,  // reset mask
			M_ST_LUF | M_ST_LV | M_ST_UF | M_ST_N | M_ST_Z | M_ST_V,  // or mask
			overflow, underflow, neg
		);
}

ADDF_dir.execute = {
	// Check that destination register is valid
	if (likely(!cpu.EnableFloatOpsWithNonExtRegs()))
	{
		if (unlikely(!cpu.IsExtReg(dst)))
			throw BogusOpcodeException<CONFIG, DEBUG>(this);
	}
	else
	{
		if (unlikely(!cpu.HasReg(dst)))
			throw BogusOpcodeException<CONFIG, DEBUG>(this);
	}
	
	// get destination register
	Register& dst_reg = cpu.GetExtReg(dst);
	
	// Compute the source operand effective address
	typename CONFIG::address_t ea = cpu.ComputeDirEA(direct);

	// Read the source operand from memory
	uint32_t src_value = cpu.IntLoad(ea);

	if (unlikely(!cpu.IsExtReg(dst)))
	{
		Register tmp_reg;
		tmp_reg.SetFromSinglePrecisionFPFormat(src_value);
		dst_reg.SetHiWriteMask(0, tmp_reg.GetHi());
	}

	// compute
	uint32_t underflow;
	uint32_t overflow;
	uint32_t neg;
	dst_reg.Addf32(src_value, overflow, underflow, neg);

	// Generate flags (into ST)
	if (likely(cpu.IsExtReg(dst)))
		cpu.GenFlags(
			dst_reg,
			M_ST_UF | M_ST_N | M_ST_Z | M_ST_V,  // reset mask
			M_ST_LUF | M_ST_LV | M_ST_UF | M_ST_N | M_ST_Z | M_ST_V,  // or mask
			overflow, underflow, neg
		);
}

ADDF_indir.execute = {
	// Check that destination register is valid
	if (likely(!cpu.EnableFloatOpsWithNonExtRegs()))
	{
		if (unlikely(!cpu.IsExtReg(dst)))
			throw BogusOpcodeException<CONFIG, DEBUG>(this);
	}
	else
	{
		if (unlikely(!cpu.HasReg(dst)))
			throw BogusOpcodeException<CONFIG, DEBUG>(this);
	}
	
	// Check that indirect addressing mode is valid and compute the effective address of the source operand
	typename CONFIG::address_t ea;        // The effective address
	bool update_ar;                       // Whether to update ARn
	typename CONFIG::address_t output_ar; // New value of ARn if it is updated

	if(unlikely(!cpu.ComputeIndirEA(ea, update_ar, output_ar, mod, ar, disp)))
	{
		throw BogusOpcodeException<CONFIG, DEBUG>(this);
	}

	if(update_ar)
	{
		// Write back ARn
		cpu.SetAR23_0(ar, output_ar);
	}
	
	// Read the source operand from memory
	uint32_t src_value = cpu.IntLoad(ea);

	// get destination register
	Register& dst_reg = cpu.GetExtReg(dst);
	if (unlikely(!cpu.IsExtReg(dst)))
		dst_reg.SetHiWriteMask(0, (uint8_t)0x08);

	// compute
	uint32_t underflow;
	uint32_t overflow;
	uint32_t neg;
	dst_reg.Addf32(src_value, overflow, underflow, neg);

	// Generate flags (into ST)
	if (likely(cpu.IsExtReg(dst)))
		cpu.GenFlags(
			dst_reg,
			M_ST_UF | M_ST_N | M_ST_Z | M_ST_V,  // reset mask
			M_ST_LUF | M_ST_LV | M_ST_UF | M_ST_N | M_ST_Z | M_ST_V,  // or mask
			overflow, underflow, neg
		);
}

ADDF_imm.execute = {
	// Check that destination register is valid
	if (likely(!cpu.EnableFloatOpsWithNonExtRegs()))
	{
		if (unlikely(!cpu.IsExtReg(dst)))
			throw BogusOpcodeException<CONFIG, DEBUG>(this);
	}
	else
	{
		if (unlikely(!cpu.HasReg(dst)))
			throw BogusOpcodeException<CONFIG, DEBUG>(this);
	}
	
	// Check that destination register is valid
	if (unlikely(!cpu.HasReg(dst)))
	{
		throw BogusOpcodeException<CONFIG, DEBUG>(this);
	}
	
	// get destination register
	Register& dst_reg = cpu.GetExtReg(dst);
	if (unlikely(!cpu.IsExtReg(dst)))
		dst_reg.SetHiWriteMask(0, (uint8_t)0x10);

	// compute
	uint32_t underflow;
	uint32_t overflow;
	uint32_t neg;
	dst_reg.Addf16((uint16_t)imm, overflow, underflow, neg);

	// Generate flags (into ST)
	if (likely(cpu.IsExtReg(dst)))
		cpu.GenFlags(
			dst_reg,
			M_ST_UF | M_ST_N | M_ST_Z | M_ST_V,  // reset mask
			M_ST_LUF | M_ST_LV | M_ST_UF | M_ST_N | M_ST_Z | M_ST_V,  // or mask
			overflow, underflow, neg
		);
}

/* end of ADDF (add floating-point values)
 **********************************************************/

/**********************************************************
 * ADDI (add integers)
 * op ADDI(0b000[3]:0b000100[6]:g[2]:dst[5]:src[16])
 */

op ADDI_reg  (0b000[3]:0b000100[6]:0b00[2]:dst[5]:0[11]:src[5])
op ADDI_dir  (0b000[3]:0b000100[6]:0b01[2]:dst[5]:direct[16])
op ADDI_indir(0b000[3]:0b000100[6]:0b10[2]:dst[5]:mod[5]:ar[3]:disp[8])
op ADDI_imm  (0b000[3]:0b000100[6]:0b11[2]:dst[5]:sext<32> imm[16])

ADDI_reg.disasm = {
	const char *dst_name = REG_NAME[dst];
	const char *src_name = REG_NAME[src];
	
	if (!dst_name || !src_name)
		return false;
	
	os << "ADDI " << src_name << ", " << dst_name;
	return true;
}

ADDI_dir.disasm = {
	const char *dst_name = REG_NAME[dst];

	if(!dst_name)
		return false;
	
	os << "ADDI " << hex << cpu.DisasmDir(Operation<CONFIG, DEBUG>::GetAddr() / 4, direct) << dec << ", " << dst_name;
	
	return true;
}

ADDI_indir.disasm = {
	string disasm_src_indir;
	const char *dst_name = REG_NAME[dst];

	if (!dst_name || !cpu.DisasmIndir(disasm_src_indir, Operation<CONFIG, DEBUG>::GetAddr() / 4, mod, ar, disp)) 
		return false;

	os << "ADDI " << disasm_src_indir << ", " << dst_name;

	return true;
}

ADDI_imm.disasm = {
	const char *dst_name = REG_NAME[dst];

	if (!dst_name)
		return false;

	os << "ADDI " << imm << ", " << dst_name;
	return true;
}

ADDI_reg.execute = {
	// Check that source and destination registers are valid
	if(unlikely(!cpu.HasReg(src) || !cpu.HasReg(dst)))
	{
		throw BogusOpcodeException<CONFIG, DEBUG>(this);
	}

	// Read source operand
	uint32_t src_value = cpu.GetReg(src);

	// Read destination operand
	uint32_t dst_value = cpu.GetReg(dst);

	// Compute the result
	uint32_t result;      // the 32-bit result
	uint8_t carry_out;    // the carry out (0 or 1)
	uint8_t overflow;     // the overflow (0 or 1)
	uint8_t sign;         // the sign (0 or 1)

	// Depending on overflow mode do signed saturation or not 
	if(cpu.GetST_OVM())
	{
		SignedSatAdd32(result, carry_out, overflow, sign, dst_value, src_value, 0);
	}
	else
	{
		SignedAdd32(result, carry_out, overflow, sign, dst_value, src_value, 0);
		sign = sign ^ overflow;
	}

	// Write back result
	cpu.SetReg(dst, result);

	// Check whether destination operand is an extended precision register
	if(cpu.IsExtReg(dst))
	{
		// Generate flags (into ST)
		cpu.GenFlags(
			result,
			M_ST_UF | M_ST_N | M_ST_Z | M_ST_V | M_ST_C,  // reset mask
			M_ST_LV | M_ST_N | M_ST_Z | M_ST_V | M_ST_C,  // or mask
			sign,
			carry_out,
			overflow
		);
	}
}

ADDI_dir.execute = {
	// Check that destination register is valid
	if(unlikely(!cpu.HasReg(dst)))
	{
		throw BogusOpcodeException<CONFIG, DEBUG>(this);
	}

	// Read destination operand
	uint32_t dst_value = cpu.GetReg(dst);

	// Compute the source operand effective address
	typename CONFIG::address_t ea = cpu.ComputeDirEA(direct);

	// Read the source operand from memory
	uint32_t src_value = cpu.IntLoad(ea);

	// Compute the result
	uint32_t result;      // the 32-bit result
	uint8_t carry_out;    // the carry out (0 or 1)
	uint8_t overflow;     // the overflow (0 or 1)
	uint8_t sign;         // the sign (0 or 1)

	// Depending on overflow mode do signed saturation or not 
	if(cpu.GetST_OVM())
	{
		SignedSatAdd32(result, carry_out, overflow, sign, dst_value, src_value, 0);
	}
	else
	{
		SignedAdd32(result, carry_out, overflow, sign, dst_value, src_value, 0);
		sign = sign ^ overflow;
	}

	// Write back result
	cpu.SetReg(dst, result);

	// Check whether destination operand is an extended precision register
	if(cpu.IsExtReg(dst))
	{
		// Generate flags (into ST)
		cpu.GenFlags(
			result,
			M_ST_UF | M_ST_N | M_ST_Z | M_ST_V | M_ST_C,  // reset mask
			M_ST_LV | M_ST_N | M_ST_Z | M_ST_V | M_ST_C,  // or mask
			sign,
			carry_out,
			overflow
		);
	}
}

ADDI_indir.execute = {
	// Check that destination register is valid
	if(unlikely(!cpu.HasReg(dst)))
	{
		throw BogusOpcodeException<CONFIG, DEBUG>(this);
	}

	// Check that indirect addressing mode is valid and compute the effective address of the source operand
	typename CONFIG::address_t ea;        // The effective address
	bool update_ar;                       // Whether to update ARn
	typename CONFIG::address_t output_ar; // New value of ARn if it is updated

	if(unlikely(!cpu.ComputeIndirEA(ea, update_ar, output_ar, mod, ar, disp)))
	{
		throw BogusOpcodeException<CONFIG, DEBUG>(this);
	}

	if(update_ar)
	{
		// Write back ARn
		cpu.SetAR23_0(ar, output_ar);
	}

	// Read destination operand
	uint32_t dst_value = cpu.GetReg(dst);

	// Read the source operand from memory
	uint32_t src_value = cpu.IntLoad(ea);

	// Compute the result
	uint32_t result;      // the 32-bit result
	uint8_t carry_out;    // the carry out (0 or 1)
	uint8_t overflow;     // the overflow (0 or 1)
	uint8_t sign;         // the sign (0 or 1)

	// Depending on overflow mode do signed saturation or not 
	if(cpu.GetST_OVM())
	{
		SignedSatAdd32(result, carry_out, overflow, sign, dst_value, src_value, 0);
	}
	else
	{
		SignedAdd32(result, carry_out, overflow, sign, dst_value, src_value, 0);
		sign = sign ^ overflow;
	}

	// Write back result
	cpu.SetReg(dst, result);

	// Check whether destination operand is an extended precision register
	if(cpu.IsExtReg(dst))
	{
		// Generate flags (into ST)
		cpu.GenFlags(
			result,
			M_ST_UF | M_ST_N | M_ST_Z | M_ST_V | M_ST_C,  // reset mask
			M_ST_LV | M_ST_N | M_ST_Z | M_ST_V | M_ST_C,  // or mask
			sign,
			carry_out,
			overflow
		);
	}
}

ADDI_imm.execute = {
	// Check that destination register is valid
	if(unlikely(!cpu.HasReg(dst)))
	{
		throw BogusOpcodeException<CONFIG, DEBUG>(this);
	}

	// Read destination operand
	uint32_t dst_value = cpu.GetReg(dst);

	// Compute the result
	uint32_t result;      // the 32-bit result
	uint8_t carry_out;    // the carry out (0 or 1)
	uint8_t overflow;     // the overflow (0 or 1)
	uint8_t sign;         // the sign (0 or 1)

	// Depending on overflow mode do signed saturation or not 
	if(cpu.GetST_OVM())
	{
		SignedSatAdd32(result, carry_out, overflow, sign, dst_value, imm, 0);
	}
	else
	{
		SignedAdd32(result, carry_out, overflow, sign, dst_value, imm, 0);
		sign = sign ^ overflow;
	}

	// Write back result
	cpu.SetReg(dst, result);

	// Check whether destination operand is an extended precision register
	if(cpu.IsExtReg(dst))
	{
		// Generate flags (into ST)
		cpu.GenFlags(
			result,
			M_ST_UF | M_ST_N | M_ST_Z | M_ST_V | M_ST_C,  // reset mask
			M_ST_LV | M_ST_N | M_ST_Z | M_ST_V | M_ST_C,  // or mask
			sign,
			carry_out,
			overflow
		);
	}
}

/* end of ADDI (add integers)
 **********************************************************/

/**********************************************************
 * AND (bitwise-logical AND)
 * op AND(0b000[3]:0b000101[6]:g[2]:dst[5]:src[16])
 */

op AND_reg  (0b000[3]:0b000101[6]:0b00[2]:dst[5]:0[11]:src[5])
op AND_dir  (0b000[3]:0b000101[6]:0b01[2]:dst[5]:direct[16])
op AND_indir(0b000[3]:0b000101[6]:0b10[2]:dst[5]:mod[5]:ar[3]:disp[8])
op AND_imm  (0b000[3]:0b000101[6]:0b11[2]:dst[5]:<32> imm[16])

AND_reg.disasm = {
	const char *dst_name = REG_NAME[dst];
	const char *src_name = REG_NAME[src];
	
	if (!dst_name || !src_name)
		return false;
	
	os << "AND " << src_name << ", " << dst_name;
	return true;
}

AND_dir.disasm = {
	const char *dst_name = REG_NAME[dst];

	if(!dst_name)
		return false;
	
	os << "AND " << hex << cpu.DisasmDir(Operation<CONFIG, DEBUG>::GetAddr() / 4, direct) << dec << ", " << dst_name;
	
	return true;
}

AND_indir.disasm = {
	string disasm_src_indir;
	const char *dst_name = REG_NAME[dst];

	if (!dst_name || !cpu.DisasmIndir(disasm_src_indir, Operation<CONFIG, DEBUG>::GetAddr() / 4, mod, ar, disp)) 
		return false;

	os << "AND " << disasm_src_indir << ", " << dst_name;

	return true;
}

AND_imm.disasm = {
	const char *dst_name = REG_NAME[dst];

	if (!dst_name)
		return false;

	os << "AND " << imm << ", " << dst_name;
	return true;
}

AND_reg.execute = {
	// Check that source and destination registers are valid
	if(unlikely(!cpu.HasReg(src) || !cpu.HasReg(dst)))
	{
		throw BogusOpcodeException<CONFIG, DEBUG>(this);
	}

	// Read source operand
	uint32_t src_value = cpu.GetReg(src);

	// Read destination operand
	uint32_t dst_value = cpu.GetReg(dst);

	// Compute the result
	uint32_t result = src_value & dst_value;
	uint8_t sign = (int32_t) result < 0;

	// Write back result
	cpu.SetReg(dst, result);

	// Check whether destination operand is an extended precision register
	if(cpu.IsExtReg(dst))
	{
		// Generate flags (into ST)
		cpu.GenFlags(
			result,
			M_ST_UF | M_ST_N | M_ST_Z | M_ST_V,  // reset mask
			M_ST_N | M_ST_Z,   // or mask
			sign
		);
	}
}

AND_dir.execute = {
	// Check that destination register is valid
	if(unlikely(!cpu.HasReg(dst)))
	{
		throw BogusOpcodeException<CONFIG, DEBUG>(this);
	}

	// Read destination operand
	uint32_t dst_value = cpu.GetReg(dst);

	// Compute the source operand effective address
	typename CONFIG::address_t ea = cpu.ComputeDirEA(direct);

	// Read the source operand from memory
	uint32_t src_value = cpu.IntLoad(ea);

	// Compute the result
	uint32_t result = src_value & dst_value;
	uint8_t sign = (int32_t) result < 0;

	// Write back result
	cpu.SetReg(dst, result);

	// Check whether destination operand is an extended precision register
	if(cpu.IsExtReg(dst))
	{
		// Generate flags (into ST)
		cpu.GenFlags(
			result,
			M_ST_UF | M_ST_N | M_ST_Z | M_ST_V,  // reset mask
			M_ST_N | M_ST_Z,   // or mask
			sign
		);
	}
}

AND_indir.execute = {
	// Check that destination register is valid
	if(unlikely(!cpu.HasReg(dst)))
	{
		throw BogusOpcodeException<CONFIG, DEBUG>(this);
	}

	// Check that indirect addressing mode is valid and compute the effective address of the source operand
	typename CONFIG::address_t ea;        // The effective address
	bool update_ar;                       // Whether to update ARn
	typename CONFIG::address_t output_ar; // New value of ARn if it is updated

	if(unlikely(!cpu.ComputeIndirEA(ea, update_ar, output_ar, mod, ar, disp)))
	{
		throw BogusOpcodeException<CONFIG, DEBUG>(this);
	}

	if(update_ar)
	{
		// Write back ARn
		cpu.SetAR23_0(ar, output_ar);
	}

	// Read destination operand
	uint32_t dst_value = cpu.GetReg(dst);

	// Read the source operand from memory
	uint32_t src_value = cpu.IntLoad(ea);

	// Compute the result
	uint32_t result = src_value & dst_value;
	uint8_t sign = (int32_t) result < 0;

	// Write back result
	cpu.SetReg(dst, result);

	// Check whether destination operand is an extended precision register
	if(cpu.IsExtReg(dst))
	{
		// Generate flags (into ST)
		cpu.GenFlags(
			result,
			M_ST_UF | M_ST_N | M_ST_Z | M_ST_V,  // reset mask
			M_ST_N | M_ST_Z,   // or mask
			sign
		);
	}
}

AND_imm.execute = {
	// Check that destination register is valid
	if(unlikely(!cpu.HasReg(dst)))
	{
		throw BogusOpcodeException<CONFIG, DEBUG>(this);
	}

	// Read destination operand
	uint32_t dst_value = cpu.GetReg(dst);

	// Compute the result
	uint32_t result = imm & dst_value;
	uint8_t sign = (int32_t) result < 0;

	// Write back result
	cpu.SetReg(dst, result);

	// Check whether destination operand is an extended precision register
	if(cpu.IsExtReg(dst))
	{
		// Generate flags (into ST)
		cpu.GenFlags(
			result,
			M_ST_UF | M_ST_N | M_ST_Z | M_ST_V,  // reset mask
			M_ST_N | M_ST_Z,   // or mask
			sign
		);
	}
}

/* end of AND (bitwise-logical AND)
 **********************************************************/

/**********************************************************
 * ANDN (bitwise-logical AND with complement)
 * op ANDN(0b000[3]:0b000110[6]:g[2]:dst[5]:src[16])
 */

op ANDN_reg  (0b000[3]:0b000110[6]:0b00[2]:dst[5]:0[11]:src[5])
op ANDN_dir  (0b000[3]:0b000110[6]:0b01[2]:dst[5]:direct[16])
op ANDN_indir(0b000[3]:0b000110[6]:0b10[2]:dst[5]:mod[5]:ar[3]:disp[8])
op ANDN_imm  (0b000[3]:0b000110[6]:0b11[2]:dst[5]:<32> imm[16])

ANDN_reg.disasm = {
	const char *dst_name = REG_NAME[dst];
	const char *src_name = REG_NAME[src];
	
	if (!dst_name || !src_name)
		return false;
	
	os << "ANDN " << src_name << ", " << dst_name;
	return true;
}

ANDN_dir.disasm = {
	const char *dst_name = REG_NAME[dst];

	if(!dst_name)
		return false;
	
	os << "ANDN " << hex << cpu.DisasmDir(Operation<CONFIG, DEBUG>::GetAddr() / 4, direct) << dec << ", " << dst_name;
	
	return true;
}

ANDN_indir.disasm = {
	string disasm_src_indir;
	const char *dst_name = REG_NAME[dst];

	if (!dst_name || !cpu.DisasmIndir(disasm_src_indir, Operation<CONFIG, DEBUG>::GetAddr() / 4, mod, ar, disp)) 
		return false;

	os << "ANDN " << disasm_src_indir << ", " << dst_name;

	return true;
}

ANDN_imm.disasm = {
	const char *dst_name = REG_NAME[dst];

	if (!dst_name)
		return false;

	os << "ANDN " << imm << ", " << dst_name;
	return true;
}

ANDN_reg.execute = {
	// Check that source and destination registers are valid
	if(unlikely(!cpu.HasReg(src) || !cpu.HasReg(dst)))
	{
		throw BogusOpcodeException<CONFIG, DEBUG>(this);
	}

	// Read source operand
	uint32_t src_value = cpu.GetReg(src);

	// Read destination operand
	uint32_t dst_value = cpu.GetReg(dst);

	// Compute the result
	uint32_t result = ~src_value & dst_value;
	uint8_t sign = (int32_t) result < 0;

	// Write back result
	cpu.SetReg(dst, result);

	// Check whether destination operand is an extended precision register
	if(cpu.IsExtReg(dst))
	{
		// Generate flags (into ST)
		cpu.GenFlags(
			result,
			M_ST_UF | M_ST_N | M_ST_Z | M_ST_V,  // reset mask
			M_ST_N | M_ST_Z,   // or mask
			sign
		);
	}
}

ANDN_dir.execute = {
	// Check that destination register is valid
	if(unlikely(!cpu.HasReg(dst)))
	{
		throw BogusOpcodeException<CONFIG, DEBUG>(this);
	}

	// Read destination operand
	uint32_t dst_value = cpu.GetReg(dst);

	// Compute the source operand effective address
	typename CONFIG::address_t ea = cpu.ComputeDirEA(direct);

	// Read the source operand from memory
	uint32_t src_value = cpu.IntLoad(ea);

	// Compute the result
	uint32_t result = ~src_value & dst_value;
	uint8_t sign = (int32_t) result < 0;

	// Write back result
	cpu.SetReg(dst, result);

	// Check whether destination operand is an extended precision register
	if(cpu.IsExtReg(dst))
	{
		// Generate flags (into ST)
		cpu.GenFlags(
			result,
			M_ST_UF | M_ST_N | M_ST_Z | M_ST_V,  // reset mask
			M_ST_N | M_ST_Z,   // or mask
			sign
		);
	}
}

ANDN_indir.execute = {
	// Check that destination register is valid
	if(unlikely(!cpu.HasReg(dst)))
	{
		throw BogusOpcodeException<CONFIG, DEBUG>(this);
	}

	// Check that indirect addressing mode is valid and compute the effective address of the source operand
	typename CONFIG::address_t ea;        // The effective address
	bool update_ar;                       // Whether to update ARn
	typename CONFIG::address_t output_ar; // New value of ARn if it is updated

	if(unlikely(!cpu.ComputeIndirEA(ea, update_ar, output_ar, mod, ar, disp)))
	{
		throw BogusOpcodeException<CONFIG, DEBUG>(this);
	}

	if(update_ar)
	{
		// Write back ARn
		cpu.SetAR23_0(ar, output_ar);
	}

	// Read destination operand
	uint32_t dst_value = cpu.GetReg(dst);

	// Read the source operand from memory
	uint32_t src_value = cpu.IntLoad(ea);

	// Compute the result
	uint32_t result = ~src_value & dst_value;
	uint8_t sign = (int32_t) result < 0;

	// Write back result
	cpu.SetReg(dst, result);

	// Check whether destination operand is an extended precision register
	if(cpu.IsExtReg(dst))
	{
		// Generate flags (into ST)
		cpu.GenFlags(
			result,
			M_ST_UF | M_ST_N | M_ST_Z | M_ST_V,  // reset mask
			M_ST_N | M_ST_Z,   // or mask
			sign
		);
	}
}

ANDN_imm.execute = {
	// Check that destination register is valid
	if(unlikely(!cpu.HasReg(dst)))
	{
		throw BogusOpcodeException<CONFIG, DEBUG>(this);
	}

	// Read destination operand
	uint32_t dst_value = cpu.GetReg(dst);

	// Compute the result
	uint32_t result = ~imm & dst_value;
	uint8_t sign = (int32_t) result < 0;

	// Write back result
	cpu.SetReg(dst, result);

	// Check whether destination operand is an extended precision register
	if(cpu.IsExtReg(dst))
	{
		// Generate flags (into ST)
		cpu.GenFlags(
			result,
			M_ST_UF | M_ST_N | M_ST_Z | M_ST_V,  // reset mask
			M_ST_N | M_ST_Z,   // or mask
			sign
		);
	}
}

/* end of ANDN (bitwise-logical AND with complement)
 **********************************************************/

/**********************************************************
 * ASH (arithmetic shift)
 * op ASH(0b000[3]:0b000111[6]:g[2]:dst[5]:count[16])
 */

op ASH_reg  (0b000[3]:0b000111[6]:0b00[2]:dst[5]:0[11]:src[5])
op ASH_dir  (0b000[3]:0b000111[6]:0b01[2]:dst[5]:direct[16])
op ASH_indir(0b000[3]:0b000111[6]:0b10[2]:dst[5]:mod[5]:ar[3]:disp[8])
op ASH_imm  (0b000[3]:0b000111[6]:0b11[2]:dst[5]:<32> imm[16])

ASH_reg.disasm = {
	const char *dst_name = REG_NAME[dst];
	const char *src_name = REG_NAME[src];
	
	if (!dst_name || !src_name)
		return false;
	
	os << "ASH " << src_name << ", " << dst_name;
	return true;
}

ASH_dir.disasm = {
	const char *dst_name = REG_NAME[dst];

	if(!dst_name)
		return false;
	
	os << "ASH " << hex << cpu.DisasmDir(Operation<CONFIG, DEBUG>::GetAddr() / 4, direct) << dec << ", " << dst_name;
	
	return true;
}

ASH_indir.disasm = {
	string disasm_src_indir;
	const char *dst_name = REG_NAME[dst];

	if (!dst_name || !cpu.DisasmIndir(disasm_src_indir, Operation<CONFIG, DEBUG>::GetAddr() / 4, mod, ar, disp)) 
		return false;

	os << "ASH " << disasm_src_indir << ", " << dst_name;
	return true;
}

ASH_imm.disasm = {
	const char *dst_name = REG_NAME[dst];

	if (!dst_name)
		return false;

	os << "ASH " << imm << ", " << dst_name;
	return true;
}

ASH_reg.execute = {
	// Check whether the source and destination registers are valid
	if(unlikely(!cpu.HasReg(src) || !cpu.HasReg(dst)))
	{
		throw BogusOpcodeException<CONFIG, DEBUG>(this);
	}

	// Read the source operand
	uint32_t src_value = cpu.GetReg(src);

	// Read the destination operand
	uint32_t dst_value = cpu.GetReg(dst);

	// Sign extend the 7 LSB of the source operand value to get the shift count
	int32_t count = SignExtend(src_value, 7);

	// Compute the result
	uint8_t carry_out;
	uint8_t sign;
	uint8_t overflow;
	uint32_t result;

	if(count == 0)
	{
		result = dst_value;
		carry_out = 0;
		overflow = 0;
	}
	else if(count >= 0)
	{
		if(count >= 32)
		{
			result = 0;
			carry_out = (dst_value & 1); // last shifted out bit
			overflow = dst_value != 0;   // any lost "one" is an overflow
		}
		else
		{
			result = ShiftLeft(dst_value, count, carry_out);
			uint32_t shifted_out_mask = ((int32_t) 0x80000000UL >> count);  // mask lost bits
			overflow = ((dst_value & shifted_out_mask) ? (dst_value & shifted_out_mask) != shifted_out_mask : (dst_value & shifted_out_mask) != 0);   // overflow = whether lost bits are significative or not
		}
	}
	else
	{
		count = -count;
		if(count >= 32)
		{
			result = (dst_value & 0x80000000UL) ? 0xffffffffUL : 0;
			carry_out = dst_value >> 31; // last shifted out bit
			overflow = 0; // no overflow
		}
		else
		{
			result = ShiftArithmeticRight(dst_value, count, carry_out);
			overflow = 0; // no overflow
		}
	}

	sign = (int32_t) result < 0;
	
	// Write back result
	cpu.SetReg(dst, result);

	// Check whether destination operand is an extended precision register
	if(cpu.IsExtReg(dst))
	{
		// Generate flags (into ST)
		cpu.GenFlags(
			result,
			M_ST_UF | M_ST_N | M_ST_Z | M_ST_V | M_ST_C,  // reset mask
			M_ST_LV | M_ST_N | M_ST_Z | M_ST_V | M_ST_C,  // or mask
			sign,
			carry_out,
			overflow
		);
	}
}

ASH_dir.execute = {
	// Check whether the source and destination registers are valid
	if(unlikely(!cpu.HasReg(dst)))
	{
		throw BogusOpcodeException<CONFIG, DEBUG>(this);
	}

	// Read the destination operand
	uint32_t dst_value = cpu.GetReg(dst);

	// Compute the source operand effective address
	typename CONFIG::address_t ea = cpu.ComputeDirEA(direct);

	// Read the source operand from memory
	uint32_t src_value = cpu.IntLoad(ea);

	// Sign extend the 7 LSB of the source operand value to get the shift count
	int32_t count = SignExtend(src_value, 7);

	// Compute the result
	uint8_t carry_out;
	uint8_t sign;
	uint8_t overflow;
	uint32_t result;

	if(count == 0)
	{
		result = dst_value;
		carry_out = 0;
		overflow = 0;
	}
	else if(count >= 0)
	{
		if(count >= 32)
		{
			result = 0;
			carry_out = (dst_value & 1); // last shifted out bit
			overflow = dst_value != 0;   // any lost "one" is an overflow
		}
		else
		{
			result = ShiftLeft(dst_value, count, carry_out);
			uint32_t shifted_out_mask = ((int32_t) 0x80000000UL >> count);  // mask lost bits
			overflow = ((dst_value & shifted_out_mask) ? (dst_value & shifted_out_mask) != shifted_out_mask : (dst_value & shifted_out_mask) != 0);   // overflow = whether lost bits are significative or not
		}
	}
	else
	{
		count = -count;
		if(count >= 32)
		{
			result = (dst_value & 0x80000000UL) ? 0xffffffffUL : 0;
			carry_out = dst_value >> 31; // last shifted out bit
			overflow = 0; // no overflow
		}
		else
		{
			result = ShiftArithmeticRight(dst_value, count, carry_out);
			overflow = 0; // no overflow
		}
	}

	sign = (int32_t) result < 0;

	// Write back result
	cpu.SetReg(dst, result);

	// Check whether destination operand is an extended precision register
	if(cpu.IsExtReg(dst))
	{
		// Generate flags (into ST)
		cpu.GenFlags(
			result,
			M_ST_UF | M_ST_N | M_ST_Z | M_ST_V | M_ST_C,  // reset mask
			M_ST_LV | M_ST_N | M_ST_Z | M_ST_V | M_ST_C,  // or mask
			sign,
			carry_out,
			overflow
		);
	}
}

ASH_indir.execute = {
	// Check whether the source and destination registers are valid
	if(unlikely(!cpu.HasReg(dst)))
	{
		throw BogusOpcodeException<CONFIG, DEBUG>(this);
	}

	// Check that indirect addressing mode is valid and compute the effective address of the source operand
	typename CONFIG::address_t ea;        // The effective address
	bool update_ar;                       // Whether to update ARn
	typename CONFIG::address_t output_ar; // New value of ARn if it is updated

	if(unlikely(!cpu.ComputeIndirEA(ea, update_ar, output_ar, mod, ar, disp)))
	{
		throw BogusOpcodeException<CONFIG, DEBUG>(this);
	}

	if(update_ar)
	{
		// Write back ARn
		cpu.SetAR23_0(ar, output_ar);
	}

	// Read the destination operand
	uint32_t dst_value = cpu.GetReg(dst);

	// Read the source operand from memory
	uint32_t src_value = cpu.IntLoad(ea);

	// Sign extend the 7 LSB of the source operand value to get the shift count
	int32_t count = SignExtend(src_value, 7);

	// Compute the result
	uint8_t carry_out;
	uint8_t sign;
	uint8_t overflow;
	uint32_t result;

	if(count == 0)
	{
		result = dst_value;
		carry_out = 0;
		overflow = 0;
	}
	else if(count >= 0)
	{
		if(count >= 32)
		{
			result = 0;
			carry_out = (dst_value & 1); // last shifted out bit
			overflow = dst_value != 0;   // any lost "one" is an overflow
		}
		else
		{
			result = ShiftLeft(dst_value, count, carry_out);
			uint32_t shifted_out_mask = ((int32_t) 0x80000000UL >> count);  // mask lost bits
			overflow = ((dst_value & shifted_out_mask) ? (dst_value & shifted_out_mask) != shifted_out_mask : (dst_value & shifted_out_mask) != 0);   // overflow = whether lost bits are significative or not
		}
	}
	else
	{
		count = -count;
		if(count >= 32)
		{
			result = (dst_value & 0x80000000UL) ? 0xffffffffUL : 0;
			carry_out = dst_value >> 31; // last shifted out bit
			overflow = 0; // no overflow
		}
		else
		{
			result = ShiftArithmeticRight(dst_value, count, carry_out);
			overflow = 0; // no overflow
		}
	}

	sign = (int32_t) result < 0;

	// Write back result
	cpu.SetReg(dst, result);

	// Check whether destination operand is an extended precision register
	if(cpu.IsExtReg(dst))
	{
		// Generate flags (into ST)
		cpu.GenFlags(
			result,
			M_ST_UF | M_ST_N | M_ST_Z | M_ST_V | M_ST_C,  // reset mask
			M_ST_LV | M_ST_N | M_ST_Z | M_ST_V | M_ST_C,  // or mask
			sign,
			carry_out,
			overflow
		);
	}
}

ASH_imm.execute = {
	// Check whether the source and destination registers are valid
	if(unlikely(!cpu.HasReg(dst)))
	{
		throw BogusOpcodeException<CONFIG, DEBUG>(this);
	}

	// Read the destination operand
	uint32_t dst_value = cpu.GetReg(dst);

	// Sign extend the 7 LSB of the immediate value to get the shift count
	int32_t count = SignExtend(imm, 7);

	// Compute the result
	uint8_t carry_out;
	uint8_t sign;
	uint8_t overflow;
	uint32_t result;

	if(count == 0)
	{
		result = dst_value;
		carry_out = 0;
		overflow = 0;
	}
	else if(count >= 0)
	{
		if(count >= 32)
		{
			result = 0;
			carry_out = (dst_value & 1); // last shifted out bit
			overflow = dst_value != 0;   // any lost "one" is an overflow
		}
		else
		{
			result = ShiftLeft(dst_value, count, carry_out);
			uint32_t shifted_out_mask = ((int32_t) 0x80000000UL >> count);  // mask lost bits
			overflow = ((dst_value & shifted_out_mask) ? (dst_value & shifted_out_mask) != shifted_out_mask : (dst_value & shifted_out_mask) != 0);   // overflow = whether lost bits are significative or not
		}
	}
	else
	{
		count = -count;
		if(count >= 32)
		{
			result = (dst_value & 0x80000000UL) ? 0xffffffffUL : 0;
			carry_out = dst_value >> 31; // last shifted out bit
			overflow = 0; // no overflow
		}
		else
		{
			result = ShiftArithmeticRight(dst_value, count, carry_out);
			overflow = 0; // no overflow
		}
	}

	sign = (int32_t) result < 0;

	// Write back result
	cpu.SetReg(dst, result);

	// Check whether destination operand is an extended precision register
	if(cpu.IsExtReg(dst))
	{
		// Generate flags (into ST)
		cpu.GenFlags(
			result,
			M_ST_UF | M_ST_N | M_ST_Z | M_ST_V | M_ST_C,  // reset mask
			M_ST_LV | M_ST_N | M_ST_Z | M_ST_V | M_ST_C,  // or mask
			sign,
			carry_out,
			overflow
		);
	}
}

/* end of ASH (arithmetic shift)
 **********************************************************/

/**********************************************************
 * CMPF (compare floating-point values)
 * op CMPF(0b000[3]:0b001000[6]:g[2]:dst[5]:src[16])
 */

op CMPF_reg  (0b000[3]:0b001000[6]:0b00[2]:dst[5]:0[11]:src[5])
op CMPF_dir  (0b000[3]:0b001000[6]:0b01[2]:dst[5]:direct[16])
op CMPF_indir(0b000[3]:0b001000[6]:0b10[2]:dst[5]:mod[5]:ar[3]:disp[8])
op CMPF_imm  (0b000[3]:0b001000[6]:0b11[2]:dst[5]:imm[16])

CMPF_reg.disasm = {
	const char *dst_name = REG_NAME[dst];
	const char *src_name = REG_NAME[src];
	
	if (!dst_name || !src_name)
		return false;
	
	os << "CMPF " << src_name << ", " << dst_name;
	return true;
}

CMPF_dir.disasm = {
	const char *dst_name = REG_NAME[dst];

	if(!dst_name)
		return false;
	
	os << "CMPF " << hex << cpu.DisasmDir(Operation<CONFIG, DEBUG>::GetAddr() / 4, direct) << dec << ", " << dst_name;
	
	return true;
}

CMPF_indir.disasm = {
	string disasm_src_indir;
	const char *dst_name = REG_NAME[dst];

	if (!dst_name || !cpu.DisasmIndir(disasm_src_indir, Operation<CONFIG, DEBUG>::GetAddr() / 4, mod, ar, disp)) 
		return false;

	os << "CMPF " << disasm_src_indir << ", " << dst_name;
	return true;
}

CMPF_imm.disasm = {
	const char *dst_name = REG_NAME[dst];

	if (!dst_name)
		return false;

	os << "CMPF " << cpu.DisasmShortFloat(imm) << ", " << dst_name;
	return true;
}

CMPF_reg.execute = {
	// Check that destination and source registers are valid
	if (likely(!cpu.EnableFloatOpsWithNonExtRegs())) {
		if (unlikely(!cpu.IsExtReg(dst) || !cpu.IsExtReg(src)))
			throw BogusOpcodeException<CONFIG, DEBUG>(this);
	} 
	else
	{
		if(unlikely(!cpu.HasReg(dst) || !cpu.HasReg(src)))
		{
			throw BogusOpcodeException<CONFIG, DEBUG>(this);
		}
	}

	// get source register
	Register& src_reg = cpu.GetExtReg(src);
	
	// get destination register
	Register& dst_reg = cpu.GetExtReg(dst);
	
	if (unlikely(!cpu.IsExtReg(src)))
	{
		src_reg.SetHiWriteMask(0, (uint8_t)0x10);
		if (unlikely(!cpu.IsExtReg(dst)))
			dst_reg.SetHiWriteMask(0, (uint8_t)0x10);
	}
	else
		if (unlikely(!cpu.IsExtReg(dst)))
			dst_reg.SetHiWriteMask(0, (uint8_t)0);

	// a fake register is needed to keep the compare result
	Register result_reg;
	
	// compute
	uint32_t underflow;
	uint32_t overflow;
	uint32_t neg;
	result_reg.Subf(dst_reg, src_reg, overflow, underflow, neg);
	
	// Generate flags (into ST)
	cpu.GenFlags(result_reg,
		 M_ST_UF | M_ST_N | M_ST_Z | M_ST_V,  // reset mask
		 M_ST_LUF | M_ST_LV | M_ST_UF | M_ST_N | M_ST_Z | M_ST_V,  // or mask
		 overflow, underflow, neg
		 );
}

CMPF_dir.execute = {
	// Check that destination register is valid
	if (likely(!cpu.EnableFloatOpsWithNonExtRegs()))
	{
		if (unlikely(!cpu.IsExtReg(dst)))
			throw BogusOpcodeException<CONFIG, DEBUG>(this);
	}
	else
	{
		if (unlikely(!cpu.HasReg(dst)))
			throw BogusOpcodeException<CONFIG, DEBUG>(this);
	}
	
	// get destination register
	Register& dst_reg = cpu.GetExtReg(dst);
	
	// a fake register is needed to keep the compare result
	Register result_reg;
	
	// Compute the source operand effective address
	typename CONFIG::address_t ea = cpu.ComputeDirEA(direct);
	
	// Read the source operand from memory
	uint32_t src_value = cpu.IntLoad(ea);
	
	if (unlikely(!cpu.IsExtReg(dst)))
	{
		Register tmp_reg;
		tmp_reg.SetFromSinglePrecisionFPFormat(src_value);
		dst_reg.SetHiWriteMask(0, tmp_reg.GetHi());
	}

	// compute
	uint32_t underflow;
	uint32_t overflow;
	uint32_t neg;
	result_reg.Subf32(dst_reg, src_value, overflow, underflow, neg);
	
	// Generate flags (into ST)
	cpu.GenFlags(result_reg,
		 M_ST_UF | M_ST_N | M_ST_Z | M_ST_V,  // reset mask
		 M_ST_LUF | M_ST_LV | M_ST_UF | M_ST_N | M_ST_Z | M_ST_V,  // or mask
		 overflow, underflow, neg
		 );
}

CMPF_indir.execute = {
	// Check that destination register is valid
	if (likely(!cpu.EnableFloatOpsWithNonExtRegs()))
	{
		if (unlikely(!cpu.IsExtReg(dst)))
			throw BogusOpcodeException<CONFIG, DEBUG>(this);
	}
	else
	{
		if (unlikely(!cpu.HasReg(dst)))
			throw BogusOpcodeException<CONFIG, DEBUG>(this);
	}
	
	// Check that indirect addressing mode is valid and compute the effective address of the source operand
	typename CONFIG::address_t ea;        // The effective address
	bool update_ar;                       // Whether to update ARn
	typename CONFIG::address_t output_ar; // New value of ARn if it is updated
	
	if(unlikely(!cpu.ComputeIndirEA(ea, update_ar, output_ar, mod, ar, disp)))
	{
		throw BogusOpcodeException<CONFIG, DEBUG>(this);
	}
	
	if(update_ar)
	{
		// Write back ARn
		cpu.SetAR23_0(ar, output_ar);
	}
	
	// get destination register
	Register& dst_reg = cpu.GetExtReg(dst);
	if (unlikely(!cpu.IsExtReg(dst)))
		dst_reg.SetHiWriteMask(0, (uint8_t)0x10);

	// a fake register is needed to keep the compare result
	Register result_reg;
	
	// Read the source operand from memory
	uint32_t src_value = cpu.IntLoad(ea);
	
	// compute
	uint32_t underflow;
	uint32_t overflow;
	uint32_t neg;
	result_reg.Subf32(dst_reg, src_value, overflow, underflow, neg);
	
	// Generate flags (into ST)
	cpu.GenFlags(result_reg,
		M_ST_UF | M_ST_N | M_ST_Z | M_ST_V,  // reset mask
		M_ST_LUF | M_ST_LV | M_ST_UF | M_ST_N | M_ST_Z | M_ST_V,  // or mask
		overflow, underflow, neg
		);
}

CMPF_imm.execute = {
	// Check that destination register is valid
	if (likely(!cpu.EnableFloatOpsWithNonExtRegs()))
	{
		if (unlikely(!cpu.IsExtReg(dst)))
			throw BogusOpcodeException<CONFIG, DEBUG>(this);
	}
	else
	{
		if (unlikely(!cpu.HasReg(dst)))
			throw BogusOpcodeException<CONFIG, DEBUG>(this);
	}
	
	// get destination register
	Register& dst_reg = cpu.GetExtReg(dst);
	if (unlikely(!cpu.IsExtReg(dst)))
		dst_reg.SetHiWriteMask(0, (uint8_t)0x10);

	// a fake register is needed to keep the compare result
	Register result_reg;
	
	// compute
	uint32_t underflow;
	uint32_t overflow;
	uint32_t neg;
	result_reg.Subf16(dst_reg, (uint16_t)imm, overflow, underflow, neg);
	
	// Generate flags (into ST)
	cpu.GenFlags(result_reg,
		M_ST_UF | M_ST_N | M_ST_Z | M_ST_V,  // reset mask
		M_ST_LUF | M_ST_LV | M_ST_UF | M_ST_N | M_ST_Z | M_ST_V,  // or mask
		overflow, underflow, neg
		);
}

/* end of CMPF (compare floating-point values)
 **********************************************************/

/**********************************************************
 * CMPI (compare integers)
 * op CMPI(0b000[3]:0b001001[6]:g[2]:dst[5]:src[16])
 */

op CMPI_reg  (0b000[3]:0b001001[6]:0b00[2]:dst[5]:0[11]:src[5])
op CMPI_dir  (0b000[3]:0b001001[6]:0b01[2]:dst[5]:direct[16])
op CMPI_indir(0b000[3]:0b001001[6]:0b10[2]:dst[5]:mod[5]:ar[3]:disp[8])
op CMPI_imm  (0b000[3]:0b001001[6]:0b11[2]:dst[5]:sext<32> imm[16])

CMPI_reg.disasm = {
	const char *dst_name = REG_NAME[dst];
	const char *src_name = REG_NAME[src];
	
	if (!dst_name || !src_name)
		return false;
	
	os << "CMPI " << src_name << ", " << dst_name;
	return true;
}

CMPI_dir.disasm = {
	const char *dst_name = REG_NAME[dst];

	if(!dst_name)
		return false;
	
	os << "CMPI " << hex << cpu.DisasmDir(Operation<CONFIG, DEBUG>::GetAddr() / 4, direct) << dec << ", " << dst_name;
	
	return true;
}

CMPI_indir.disasm = {
	string disasm_src_indir;
	const char *dst_name = REG_NAME[dst];

	if (!dst_name || !cpu.DisasmIndir(disasm_src_indir, Operation<CONFIG, DEBUG>::GetAddr() / 4, mod, ar, disp)) 
		return false;

	os << "CMPI " << disasm_src_indir << ", " << dst_name;

	return true;
}

CMPI_imm.disasm = {
	const char *dst_name = REG_NAME[dst];

	if (!dst_name)
		return false;

	os << "CMPI " << imm << ", " << dst_name;
	return true;
}

CMPI_reg.execute = {
	// Check that source and destination registers are valid
	if(unlikely(!cpu.HasReg(src) || !cpu.HasReg(dst)))
	{
		throw BogusOpcodeException<CONFIG, DEBUG>(this);
	}

	// Read source operand
	uint32_t src_value = cpu.GetReg(src);

	// Read destination operand
	uint32_t dst_value = cpu.GetReg(dst);

	// Compute the result
	uint32_t result;      // the 32-bit result
	uint8_t borrow_out;   // the borrow out (0 or 1)
	uint8_t overflow;     // the overflow (0 or 1)
	uint8_t sign;         // the sign (0 or 1)

	SignedSub32(result, borrow_out, overflow, sign, dst_value, src_value, 0);
	sign = sign ^ overflow;

	// Generate flags (into ST)
	cpu.GenFlags(
		result,
		M_ST_UF | M_ST_N | M_ST_Z | M_ST_V | M_ST_C,  // reset mask
		M_ST_LV | M_ST_N | M_ST_Z | M_ST_V | M_ST_C,  // or mask
		sign,
		borrow_out,
		overflow
	);
}

CMPI_dir.execute = {
	// Check that destination register is valid
	if(unlikely(!cpu.HasReg(dst)))
	{
		throw BogusOpcodeException<CONFIG, DEBUG>(this);
	}

	// Read destination operand
	uint32_t dst_value = cpu.GetReg(dst);

	// Compute the source operand effective address
	typename CONFIG::address_t ea = cpu.ComputeDirEA(direct);

	// Read the source operand from memory
	uint32_t src_value = cpu.IntLoad(ea);

	// Compute the result
	uint32_t result;      // the 32-bit result
	uint8_t borrow_out;   // the borrow out (0 or 1)
	uint8_t overflow;     // the overflow (0 or 1)
	uint8_t sign;         // the sign (0 or 1)

	SignedSub32(result, borrow_out, overflow, sign, dst_value, src_value, 0);
	sign = sign ^ overflow;

	// Generate flags (into ST)
	cpu.GenFlags(
		result,
		M_ST_UF | M_ST_N | M_ST_Z | M_ST_V | M_ST_C,  // reset mask
		M_ST_LV | M_ST_N | M_ST_Z | M_ST_V | M_ST_C,  // or mask
		sign,
		borrow_out,
		overflow
	);
}

CMPI_indir.execute = {
	// Check that destination register is valid
	if(unlikely(!cpu.HasReg(dst)))
	{
		throw BogusOpcodeException<CONFIG, DEBUG>(this);
	}

	// Check that indirect addressing mode is valid and compute the effective address of the source operand
	typename CONFIG::address_t ea;        // The effective address
	bool update_ar;                       // Whether to update ARn
	typename CONFIG::address_t output_ar; // New value of ARn if it is updated

	if(unlikely(!cpu.ComputeIndirEA(ea, update_ar, output_ar, mod, ar, disp)))
	{
		throw BogusOpcodeException<CONFIG, DEBUG>(this);
	}

	if(update_ar)
	{
		// Write back ARn
		cpu.SetAR23_0(ar, output_ar);
	}

	// Read destination operand
	uint32_t dst_value = cpu.GetReg(dst);

	// Read the source operand from memory
	uint32_t src_value = cpu.IntLoad(ea);

	// Compute the result
	uint32_t result;      // the 32-bit result
	uint8_t borrow_out;   // the borrow out (0 or 1)
	uint8_t overflow;     // the overflow (0 or 1)
	uint8_t sign;         // the sign (0 or 1)

	SignedSub32(result, borrow_out, overflow, sign, dst_value, src_value, 0);
	sign = sign ^ overflow;

	// Generate flags (into ST)
	cpu.GenFlags(
		result,
		M_ST_UF | M_ST_N | M_ST_Z | M_ST_V | M_ST_C,  // reset mask
		M_ST_LV | M_ST_N | M_ST_Z | M_ST_V | M_ST_C,  // or mask
		sign,
		borrow_out,
		overflow
	);
}

CMPI_imm.execute = {
	// Check that destination register is valid
	if(unlikely(!cpu.HasReg(dst)))
	{
		throw BogusOpcodeException<CONFIG, DEBUG>(this);
	}

	// Read destination operand
	uint32_t dst_value = cpu.GetReg(dst);

	// Compute the result
	uint32_t result;      // the 32-bit result
	uint8_t borrow_out;   // the borrow out (0 or 1)
	uint8_t overflow;     // the overflow (0 or 1)
	uint8_t sign;         // the sign (0 or 1)

	SignedSub32(result, borrow_out, overflow, sign, dst_value, imm, 0);
	sign = sign ^ overflow;

	// Generate flags (into ST)
	cpu.GenFlags(
		result,
		M_ST_UF | M_ST_N | M_ST_Z | M_ST_V | M_ST_C,  // reset mask
		M_ST_LV | M_ST_N | M_ST_Z | M_ST_V | M_ST_C,  // or mask
		sign,
		borrow_out,
		overflow
	);
}

/* end of CMPI (compare integers)
 **********************************************************/

/**********************************************************
 * FIX (convert floating-point value to integer)
 * op FIX(0b000[3]:0b001010[6]:g[2]:dst[5]:src[16])
 */

op FIX_reg  (0b000[3]:0b001010[6]:0b00[2]:dst[5]:0[11]:src[5])
op FIX_dir  (0b000[3]:0b001010[6]:0b01[2]:dst[5]:direct[16])
op FIX_indir(0b000[3]:0b001010[6]:0b10[2]:dst[5]:mod[5]:ar[3]:disp[8])
op FIX_imm  (0b000[3]:0b001010[6]:0b11[2]:dst[5]:imm[16])

FIX_reg.disasm = {
	const char *dst_name = REG_NAME[dst];
	const char *src_name = REG_NAME[src];
	
	if (!dst_name || !src_name)
		return false;
	
	os << "FIX " << src_name << ", " << dst_name;
	return true;
}

FIX_dir.disasm = {
	const char *dst_name = REG_NAME[dst];

	if(!dst_name)
		return false;
	
	os << "FIX " << hex << cpu.DisasmDir(Operation<CONFIG, DEBUG>::GetAddr() / 4, direct) << dec << ", " << dst_name;
	
	return true;
}

FIX_indir.disasm = {
	string disasm_src_indir;
	const char *dst_name = REG_NAME[dst];

	if (!dst_name || !cpu.DisasmIndir(disasm_src_indir, Operation<CONFIG, DEBUG>::GetAddr() / 4, mod, ar, disp)) 
		return false;

	os << "FIX " << disasm_src_indir << ", " << dst_name;
	return true;
}

FIX_imm.disasm = {
	const char *dst_name = REG_NAME[dst];

	if (!dst_name)
		return false;

	os << "FIX " << cpu.DisasmShortFloat(imm) << ", " << dst_name;
	return true;
}

FIX_reg.execute = {
	// Check that destination and source registers are valid
	if (likely(!cpu.EnableFloatOpsWithNonExtRegs())) {
		if (unlikely(!cpu.HasReg(dst) || !cpu.IsExtReg(src)))
			throw BogusOpcodeException<CONFIG, DEBUG>(this);
	} 
	else
	{
		if(unlikely(!cpu.HasReg(dst) || !cpu.HasReg(src)))
			throw BogusOpcodeException<CONFIG, DEBUG>(this);
	}

	// Read source operand
	Register &src_reg = cpu.GetExtReg(src);
	if (unlikely(!cpu.IsExtReg(src)))
		src_reg.SetHiWriteMask(0, (uint8_t)0x10);

	// Perform computation
	uint32_t overflow;
	uint32_t neg;
	uint32_t result = src_reg.Fix(overflow, neg);

	// Set destination register
	cpu.SetReg(dst, result);

	// Generate flags (into ST) only if destination register is R0-R7
	if (cpu.IsExtReg(dst))
		cpu.GenFlags(
			result,
			M_ST_UF | M_ST_N | M_ST_Z | M_ST_V,  // reset mask
			M_ST_LV | M_ST_N | M_ST_Z | M_ST_V, // or mask
			neg,
			0, // carry
			overflow
		);
}

FIX_dir.execute = {
	// Check that destination register is valid
	if(unlikely(!cpu.HasReg(dst)))
	{
		throw BogusOpcodeException<CONFIG, DEBUG>(this);
	}

	// Compute the source operand effective address
	typename CONFIG::address_t ea = cpu.ComputeDirEA(direct);

	// Read the source operand from memory
	uint32_t src_value = cpu.IntLoad(ea);

	// Convert value into a float
	Register tmp_reg;
	tmp_reg.SetFromSinglePrecisionFPFormat(src_value);

	// Perform computation
	uint32_t overflow;
	uint32_t neg;
	uint32_t result = tmp_reg.Fix(overflow, neg);

	// Set destination register
	cpu.SetReg(dst, result);

	// Generate flags (into ST) only if destination register is R0-R7
	if (cpu.IsExtReg(dst))
		cpu.GenFlags(
			result,
			M_ST_UF | M_ST_N | M_ST_Z | M_ST_V,  // reset mask
			M_ST_LV | M_ST_N | M_ST_Z | M_ST_V, // or mask
			neg,
			0, // carry
			overflow
		);
}

FIX_indir.execute = {
	// Check that destination register is valid
	if(unlikely(!cpu.HasReg(dst)))
	{
		throw BogusOpcodeException<CONFIG, DEBUG>(this);
	}

	// Check that indirect addressing mode is valid and compute the effective address of the source operand
	typename CONFIG::address_t ea;        // The effective address
	bool update_ar;                       // Whether to update ARn
	typename CONFIG::address_t output_ar; // New value of ARn if it is updated

	if(unlikely(!cpu.ComputeIndirEA(ea, update_ar, output_ar, mod, ar, disp)))
	{
		throw BogusOpcodeException<CONFIG, DEBUG>(this);
	}

	// Update AR if necessary
	if(update_ar)
	{
		// Write back ARn
		cpu.SetAR23_0(ar, output_ar);
	}

	// Read the source operand from memory
	uint32_t src_value = cpu.IntLoad(ea);

	// Convert value into a float
	Register tmp_reg;
	tmp_reg.SetFromSinglePrecisionFPFormat(src_value);

	// Perform computation
	uint32_t overflow;
	uint32_t neg;
	uint32_t result = tmp_reg.Fix(overflow, neg);

	// Set destination register
	cpu.SetReg(dst, result);

	// Generate flags (into ST) only if destination register is R0-R7
	if (cpu.IsExtReg(dst))
		cpu.GenFlags(
			result,
			M_ST_UF | M_ST_N | M_ST_Z | M_ST_V,  // reset mask
			M_ST_LV | M_ST_N | M_ST_Z | M_ST_V, // or mask
			neg,
			0, // carry
			overflow
		);
}

FIX_imm.execute = {
	// Check that destination register is valid
	if(unlikely(!cpu.HasReg(dst)))
	{
		throw BogusOpcodeException<CONFIG, DEBUG>(this);
	}

	// Convert immediate into a float
	Register tmp_reg;
	tmp_reg.SetFromShortFPFormat(imm);

	// Perform computation
	uint32_t overflow;
	uint32_t neg;
	uint32_t result = tmp_reg.Fix(overflow, neg);

	// Set destination register
	cpu.SetReg(dst, result);

	// Generate flags (into ST) only if destination register is R0-R7
	if (cpu.IsExtReg(dst))
		cpu.GenFlags(
			result,
			M_ST_UF | M_ST_N | M_ST_Z | M_ST_V,  // reset mask
			M_ST_LV | M_ST_N | M_ST_Z | M_ST_V, // or mask
			neg,
			0, // carry
			overflow
		);
}

/* end of FIX (convert floating-point value to integer)
 **********************************************************/

/**********************************************************
 * FLOAT (convert integer to floating-point value)
 * op FLOAT(0b000[3]:0b001011[6]:g[2]:dst[5]:src[16])
 */

op FLOAT_reg  (0b000[3]:0b001011[6]:0b00[2]:dst[5]:0[11]:src[5])
op FLOAT_dir  (0b000[3]:0b001011[6]:0b01[2]:dst[5]:direct[16])
op FLOAT_indir(0b000[3]:0b001011[6]:0b10[2]:dst[5]:mod[5]:ar[3]:disp[8])
op FLOAT_imm  (0b000[3]:0b001011[6]:0b11[2]:dst[5]:sext<32> imm[16])

FLOAT_reg.disasm = {
	const char *dst_name = REG_NAME[dst];
	const char *src_name = REG_NAME[src];
	
	if (!dst_name || !src_name)
		return false;
	
	os << "FLOAT " << src_name << ", " << dst_name;
	return true;
}

FLOAT_dir.disasm = {
	const char *dst_name = REG_NAME[dst];

	if(!dst_name)
		return false;
	
	os << "FLOAT " << hex << cpu.DisasmDir(Operation<CONFIG, DEBUG>::GetAddr() / 4, direct) << dec << ", " << dst_name;
	
	return true;
}

FLOAT_indir.disasm = {
	string disasm_src_indir;
	const char *dst_name = REG_NAME[dst];

	if (!dst_name || !cpu.DisasmIndir(disasm_src_indir, Operation<CONFIG, DEBUG>::GetAddr() / 4, mod, ar, disp)) 
		return false;

	os << "FLOAT " << disasm_src_indir << ", " << dst_name;
	return true;
}

FLOAT_imm.disasm = {
	const char *dst_name = REG_NAME[dst];

	if (!dst_name)
		return false;

	os << "FLOAT " << cpu.DisasmShortFloat(imm) << ", " << dst_name;
	return true;
}

FLOAT_reg.execute = {
	// Check that destination and source registers are valid
	if (likely(!cpu.EnableFloatOpsWithNonExtRegs())) {
		if (unlikely(!cpu.IsExtReg(dst) || !cpu.HasReg(src)))
			throw BogusOpcodeException<CONFIG, DEBUG>(this);
	} 
	else
	{
		if(unlikely(!cpu.HasReg(dst) || !cpu.HasReg(src)))
			throw BogusOpcodeException<CONFIG, DEBUG>(this);
	}

	// Read source operand
	uint32_t src_value = cpu.GetReg(src);

	// Read destination operand
	Register& dst_reg = cpu.GetExtReg(dst);
	if (unlikely(!cpu.IsExtReg(dst)))
		dst_reg.SetHiWriteMask(0, (uint8_t)0);
	
	// Perform the conversion
	uint32_t neg;
	dst_reg.Float(src_value, neg);

	// Generate flags (into ST)
	if (likely(cpu.IsExtReg(dst)))
		cpu.GenFlags(
			dst_reg,
			M_ST_UF | M_ST_N | M_ST_Z | M_ST_V,  // reset mask
			M_ST_N | M_ST_Z, // or mask
			0, 0, neg
		);
}

FLOAT_dir.execute = {
	// Check that destination register is valid
	if (likely(!cpu.EnableFloatOpsWithNonExtRegs()))
	{
		if (unlikely(!cpu.IsExtReg(dst)))
			throw BogusOpcodeException<CONFIG, DEBUG>(this);
	}
	else
	{
		if (unlikely(!cpu.HasReg(dst)))
			throw BogusOpcodeException<CONFIG, DEBUG>(this);
	}
	
	// Compute the source operand effective address
	typename CONFIG::address_t ea = cpu.ComputeDirEA(direct);

	// Read the source operand from memory
	uint32_t src_value = cpu.IntLoad(ea);

	// Read destination operand
	Register& dst_reg = cpu.GetExtReg(dst);
	if (unlikely(!cpu.IsExtReg(dst)))
		dst_reg.SetHiWriteMask(0, (uint8_t)0);

	// Perform the conversion
	uint32_t neg;
	dst_reg.Float(src_value, neg);

	// Generate flags (into ST)
	if (likely(cpu.IsExtReg(dst)))
		cpu.GenFlags(
			dst_reg,
			M_ST_UF | M_ST_N | M_ST_Z | M_ST_V,  // reset mask
			M_ST_N | M_ST_Z, // or mask
			0, 0, neg
		);
}

FLOAT_indir.execute = {
	// Check that destination register is valid
	if (likely(!cpu.EnableFloatOpsWithNonExtRegs()))
	{
		if (unlikely(!cpu.IsExtReg(dst)))
			throw BogusOpcodeException<CONFIG, DEBUG>(this);
	}
	else
	{
		if (unlikely(!cpu.HasReg(dst)))
			throw BogusOpcodeException<CONFIG, DEBUG>(this);
	}
	
	// Check that indirect addressing mode is valid and compute the effective address of the source operand
	typename CONFIG::address_t ea;        // The effective address
	bool update_ar;                       // Whether to update ARn
	typename CONFIG::address_t output_ar; // New value of ARn if it is updated

	if(unlikely(!cpu.ComputeIndirEA(ea, update_ar, output_ar, mod, ar, disp)))
	{
		throw BogusOpcodeException<CONFIG, DEBUG>(this);
	}

	// Update AR if necessary
	if(update_ar)
	{
		// Write back ARn
		cpu.SetAR23_0(ar, output_ar);
	}

	// Read the source operand from memory
	uint32_t src_value = cpu.IntLoad(ea);

	// Read destination operand
	Register& dst_reg = cpu.GetExtReg(dst);
	if (unlikely(!cpu.IsExtReg(dst)))
		dst_reg.SetHiWriteMask(0, (uint8_t)0);
	
	// Perform the conversion
	uint32_t neg;
	dst_reg.Float((uint32_t)src_value, neg);

	// Generate flags (into ST)
	if (likely(cpu.IsExtReg(dst)))
		cpu.GenFlags(
			dst_reg,
			M_ST_UF | M_ST_N | M_ST_Z | M_ST_V,  // reset mask
			M_ST_N | M_ST_Z, // or mask
			0, 0, neg
		);
}

FLOAT_imm.execute = {
	// Check that destination register is valid
	if (likely(!cpu.EnableFloatOpsWithNonExtRegs()))
	{
		if (unlikely(!cpu.IsExtReg(dst)))
			throw BogusOpcodeException<CONFIG, DEBUG>(this);
	}
	else
	{
		if (unlikely(!cpu.HasReg(dst)))
			throw BogusOpcodeException<CONFIG, DEBUG>(this);
	}
	
	// Read destination operand
	Register& dst_reg = cpu.GetExtReg(dst);
	if (unlikely(!cpu.IsExtReg(dst)))
		dst_reg.SetHiWriteMask(0, (uint8_t)0);
	
	// Perform the conversion
	uint32_t neg;
	dst_reg.Float((uint32_t)imm, neg);

	// Generate flags (into ST)
	if (likely(cpu.IsExtReg(dst)))
		cpu.GenFlags(
			dst_reg,
			M_ST_UF | M_ST_N | M_ST_Z | M_ST_V,  // reset mask
			M_ST_N | M_ST_Z, // or mask
			0, 0, neg
		);
}

/* end of FLOAT (convert integer to floating-point value)
 **********************************************************/

/**********************************************************
 * LSH (logical shift)
 * op LSH(0b000[3]:0b010011[6]:g[2]:dst[5]:count[16])
 */

op LSH_reg  (0b000[3]:0b010011[6]:0b00[2]:dst[5]:0[11]:src[5])
op LSH_dir  (0b000[3]:0b010011[6]:0b01[2]:dst[5]:direct[16])
op LSH_indir(0b000[3]:0b010011[6]:0b10[2]:dst[5]:mod[5]:ar[3]:disp[8])
op LSH_imm  (0b000[3]:0b010011[6]:0b11[2]:dst[5]:?[9]:<32> imm[7])

LSH_reg.disasm = {
	const char *dst_name = REG_NAME[dst];
	const char *src_name = REG_NAME[src];
	
	if (!dst_name || !src_name)
		return false;
	
	os << "LSH " << src_name << ", " << dst_name;
	return true;
}

LSH_dir.disasm = {
	const char *dst_name = REG_NAME[dst];

	if(!dst_name)
		return false;
	
	os << "LSH " << hex << cpu.DisasmDir(Operation<CONFIG, DEBUG>::GetAddr() / 4, direct) << dec << ", " << dst_name;
	
	return true;
}

LSH_indir.disasm = {
	string disasm_src_indir;
	const char *dst_name = REG_NAME[dst];

	if (!dst_name || !cpu.DisasmIndir(disasm_src_indir, Operation<CONFIG, DEBUG>::GetAddr() / 4, mod, ar, disp)) 
		return false;

	os << "LSH " << disasm_src_indir << ", " << dst_name;
	return true;
}

LSH_imm.disasm = {
	const char *dst_name = REG_NAME[dst];

	if (!dst_name)
		return false;

	os << "LSH " << imm << ", " << dst_name;
	return true;
}

LSH_reg.execute = {
	// Check whether the source and destination registers are valid
	if(unlikely(!cpu.HasReg(src) || !cpu.HasReg(dst)))
	{
		throw BogusOpcodeException<CONFIG, DEBUG>(this);
	}

	// Read the source operand
	uint32_t src_value = cpu.GetReg(src);

	// Read the destination operand
	uint32_t dst_value = cpu.GetReg(dst);

	// Sign extend the 7 LSB of the source operand value to get the shift count
	int32_t count = SignExtend(src_value, 7);

	// Compute the result
	uint8_t bit_out;
	uint32_t result;
	uint8_t sign;

	if(count == 0)
	{
		result = dst_value;
		bit_out = 0;
	}
	else if(count >= 0)
	{
		if(count >= 32)
		{
			result = 0;
			bit_out = (dst_value & 1); // last shifted out bit
		}
		else
		{
			result = ShiftLeft(dst_value, count, bit_out);
		}
	}
	else
	{
		count = -count;
		if(count >= 32)
		{
			result = 0;
			bit_out = (count == 32) ? (dst_value >> 31) : 0; // last shifted out bit
		}
		else
		{
			result = ShiftRight(dst_value, count, bit_out);
		}
	}

	sign = (int32_t) result < 0;

	// Write back result
	cpu.SetReg(dst, result);

	// Check whether destination operand is an extended precision register
	if(cpu.IsExtReg(dst))
	{
		// Generate flags (into ST)
		cpu.GenFlags(
			result,
			M_ST_UF | M_ST_N | M_ST_Z | M_ST_V | M_ST_C,  // reset mask
			M_ST_N | M_ST_Z | M_ST_C,  // or mask
			sign,
			bit_out
		);
	}
}

LSH_dir.execute = {
	// Check whether the source and destination registers are valid
	if(unlikely(!cpu.HasReg(dst)))
	{
		throw BogusOpcodeException<CONFIG, DEBUG>(this);
	}

	// Read the destination operand
	uint32_t dst_value = cpu.GetReg(dst);

	// Compute the source operand effective address
	typename CONFIG::address_t ea = cpu.ComputeDirEA(direct);

	// Read the source operand from memory
	uint32_t src_value = cpu.IntLoad(ea);

	// Sign extend the 7 LSB of the source operand value to get the shift count
	int32_t count = SignExtend(src_value, 7);

	// Compute the result
	uint8_t bit_out;
	uint32_t result;
	uint8_t sign;

	if(count == 0)
	{
		result = dst_value;
		bit_out = 0;
	}
	else if(count >= 0)
	{
		if(count >= 32)
		{
			result = 0;
			bit_out = (dst_value & 1); // last shifted out bit
		}
		else
		{
			result = ShiftLeft(dst_value, count, bit_out);
		}
	}
	else
	{
		count = -count;
		if(count >= 32)
		{
			result = 0;
			bit_out = (count == 32) ? (dst_value >> 31) : 0; // last shifted out bit
		}
		else
		{
			result = ShiftRight(dst_value, count, bit_out);
		}
	}

	sign = (int32_t) result < 0;

	// Write back result
	cpu.SetReg(dst, result);

	// Check whether destination operand is an extended precision register
	if(cpu.IsExtReg(dst))
	{
		// Generate flags (into ST)
		cpu.GenFlags(
			result,
			M_ST_UF | M_ST_N | M_ST_Z | M_ST_V | M_ST_C,  // reset mask
			M_ST_N | M_ST_Z | M_ST_C,  // or mask
			sign,
			bit_out
		);
	}
}

LSH_indir.execute = {
	// Check whether the source and destination registers are valid
	if(unlikely(!cpu.HasReg(dst)))
	{
		throw BogusOpcodeException<CONFIG, DEBUG>(this);
	}

	// Check that indirect addressing mode is valid and compute the effective address of the source operand
	typename CONFIG::address_t ea;        // The effective address
	bool update_ar;                       // Whether to update ARn
	typename CONFIG::address_t output_ar; // New value of ARn if it is updated

	if(unlikely(!cpu.ComputeIndirEA(ea, update_ar, output_ar, mod, ar, disp)))
	{
		throw BogusOpcodeException<CONFIG, DEBUG>(this);
	}

	if(update_ar)
	{
		// Write back ARn
		cpu.SetAR23_0(ar, output_ar);
	}

	// Read the destination operand
	uint32_t dst_value = cpu.GetReg(dst);

	// Read the source operand from memory
	uint32_t src_value = cpu.IntLoad(ea);

	// Sign extend the 7 LSB of the source operand value to get the shift count
	int32_t count = SignExtend(src_value, 7);

	// Compute the result
	uint8_t bit_out;
	uint32_t result;
	uint8_t sign;

	if(count == 0)
	{
		result = dst_value;
		bit_out = 0;
	}
	else if(count >= 0)
	{
		if(count >= 32)
		{
			result = 0;
			bit_out = (dst_value & 1); // last shifted out bit
		}
		else
		{
			result = ShiftLeft(dst_value, count, bit_out);
		}
	}
	else
	{
		count = -count;
		if(count >= 32)
		{
			result = 0;
			bit_out = (count == 32) ? (dst_value >> 31) : 0; // last shifted out bit
		}
		else
		{
			result = ShiftRight(dst_value, count, bit_out);
		}
	}

	sign = (int32_t) result < 0;

	// Write back result
	cpu.SetReg(dst, result);

	// Check whether destination operand is an extended precision register
	if(cpu.IsExtReg(dst))
	{
		// Generate flags (into ST)
		cpu.GenFlags(
			result,
			M_ST_UF | M_ST_N | M_ST_Z | M_ST_V | M_ST_C,  // reset mask
			M_ST_N | M_ST_Z | M_ST_C,  // or mask
			sign,
			bit_out
		);
	}
}

LSH_imm.execute = {
	// Check whether the source and destination registers are valid
	if(unlikely(!cpu.HasReg(dst)))
	{
		throw BogusOpcodeException<CONFIG, DEBUG>(this);
	}

	// Read the destination operand
	uint32_t dst_value = cpu.GetReg(dst);

	// Sign extend the 7 LSB of the immediate value to get the shift count
	int32_t count = SignExtend(imm, 7);

	// Compute the result
	uint8_t bit_out;
	uint32_t result;
	uint8_t sign;

	if(count == 0)
	{
		result = dst_value;
		bit_out = 0;
	}
	else if(count >= 0)
	{
		if(count >= 32)
		{
			result = 0;
			bit_out = (dst_value & 1); // last shifted out bit
		}
		else
		{
			result = ShiftLeft(dst_value, count, bit_out);
		}
	}
	else
	{
		count = -count;
		if(count >= 32)
		{
			result = 0;
			bit_out = (count == 32) ? (dst_value >> 31) : 0; // last shifted out bit
		}
		else
		{
			result = ShiftRight(dst_value, count, bit_out);
		}
	}

	sign = (int32_t) result < 0;

	// Write back result
	cpu.SetReg(dst, result);

	// Check whether destination operand is an extended precision register
	if(cpu.IsExtReg(dst))
	{
		// Generate flags (into ST)
		cpu.GenFlags(
			result,
			M_ST_UF | M_ST_N | M_ST_Z | M_ST_V | M_ST_C,  // reset mask
			M_ST_N | M_ST_Z | M_ST_C,  // or mask
			sign,
			bit_out
		);
	}
}

/* end of LSH (logical shift)
 **********************************************************/

/**********************************************************
 * MPYF (multiply floating-point values)
 * op MPYF(0b000[3]:0b010100[6]:g[2]:dst[5]:src[16])
 */

op MPYF_reg  (0b000[3]:0b010100[6]:0b00[2]:dst[5]:0[11]:src[5])
op MPYF_dir  (0b000[3]:0b010100[6]:0b01[2]:dst[5]:direct[16])
op MPYF_indir(0b000[3]:0b010100[6]:0b10[2]:dst[5]:mod[5]:ar[3]:disp[8])
op MPYF_imm  (0b000[3]:0b010100[6]:0b11[2]:dst[5]:imm[16])

MPYF_reg.disasm = {
	const char *dst_name = REG_NAME[dst];
	const char *src_name = REG_NAME[src];
	
	if (!dst_name || !src_name)
		return false;
	
	os << "MPYF " << src_name << ", " << dst_name;
	return true;
}

MPYF_dir.disasm = {
	const char *dst_name = REG_NAME[dst];

	if(!dst_name)
		return false;
	
	os << "MPYF " << hex << cpu.DisasmDir(Operation<CONFIG, DEBUG>::GetAddr() / 4, direct) << dec << ", " << dst_name;
	
	return true;
}

MPYF_indir.disasm = {
	string disasm_src_indir;
	const char *dst_name = REG_NAME[dst];

	if (!dst_name || !cpu.DisasmIndir(disasm_src_indir, Operation<CONFIG, DEBUG>::GetAddr() / 4, mod, ar, disp)) 
		return false;

	os << "MPYF " << disasm_src_indir << ", " << dst_name;
	return true;
}

MPYF_imm.disasm = {
	const char *dst_name = REG_NAME[dst];

	if (!dst_name)
		return false;

	os << "MPYF " << cpu.DisasmShortFloat(imm) << ", " << dst_name;
	return true;
}

MPYF_reg.execute = {
	// Check that destination and source registers are valid
	if (likely(!cpu.EnableFloatOpsWithNonExtRegs())) {
		if (unlikely(!cpu.IsExtReg(dst) || !cpu.IsExtReg(src)))
			throw BogusOpcodeException<CONFIG, DEBUG>(this);
	} 
	else
	{
		if(unlikely(!cpu.HasReg(dst) || !cpu.HasReg(src)))
			throw BogusOpcodeException<CONFIG, DEBUG>(this);
	}

	// get source register
	Register& src_reg = cpu.GetExtReg(src);
	
	// get destination register
	Register& dst_reg = cpu.GetExtReg(dst);
	
	if (unlikely(!cpu.IsExtReg(src)))
	{
		src_reg.SetHiWriteMask(0, (uint8_t)0x8);
		if (unlikely(!cpu.IsExtReg(dst)))
			dst_reg.SetHiWriteMask(0, (uint8_t)0x8);
	}
	else
		if (unlikely(!cpu.IsExtReg(dst)))
			dst_reg.SetHiWriteMask(0, (uint8_t)0);

	// Compute result and flags
	uint32_t overflow;
	uint32_t underflow;
	uint32_t neg;
	dst_reg.Mpyf(src_reg, overflow, underflow, neg);

	// Generate flags (into ST)
	if (likely(cpu.IsExtReg(dst)))
		cpu.GenFlags(
			dst_reg,
			M_ST_UF | M_ST_N | M_ST_Z | M_ST_V,  // reset mask
			M_ST_LUF | M_ST_LV | M_ST_UF | M_ST_N | M_ST_Z | M_ST_V,  // or mask
			overflow, underflow, neg
		);
}

MPYF_dir.execute = {
	// Check that destination register is valid
	if (likely(!cpu.EnableFloatOpsWithNonExtRegs()))
	{
		if (unlikely(!cpu.IsExtReg(dst)))
			throw BogusOpcodeException<CONFIG, DEBUG>(this);
	}
	else
	{
		if (unlikely(!cpu.HasReg(dst)))
			throw BogusOpcodeException<CONFIG, DEBUG>(this);
	}
	
	// get destination register
	Register& dst_reg = cpu.GetExtReg(dst);
	
	// Compute the source operand effective address
	typename CONFIG::address_t ea = cpu.ComputeDirEA(direct);

	// Read the source operand from memory and sign extend value from 24 bits to 64 bits
	uint32_t src_value = cpu.IntLoad(ea);

	if (unlikely(!cpu.IsExtReg(dst)))
	{
		Register tmp_reg;
		tmp_reg.SetFromSinglePrecisionFPFormat(src_value);
		dst_reg.SetHiWriteMask(0, tmp_reg.GetHi());
	}

	// Compute result and flags
	uint32_t overflow;
	uint32_t underflow;
	uint32_t neg;
	dst_reg.Mpyf32(src_value, overflow, underflow, neg);

	// Generate flags (into ST)
	if (likely(cpu.IsExtReg(dst)))
		cpu.GenFlags(
			dst_reg,
			M_ST_UF | M_ST_N | M_ST_Z | M_ST_V,  // reset mask
			M_ST_LUF | M_ST_LV | M_ST_UF | M_ST_N | M_ST_Z | M_ST_V,  // or mask
			overflow, underflow, neg
		);
}

MPYF_indir.execute = {
	// Check that destination register is valid
	if (likely(!cpu.EnableFloatOpsWithNonExtRegs()))
	{
		if (unlikely(!cpu.IsExtReg(dst)))
			throw BogusOpcodeException<CONFIG, DEBUG>(this);
	}
	else
	{
		if (unlikely(!cpu.HasReg(dst)))
			throw BogusOpcodeException<CONFIG, DEBUG>(this);
	}
	
	// Check that indirect addressing mode is valid and compute the effective address of the source operand
	typename CONFIG::address_t ea;        // The effective address
	bool update_ar;                       // Whether to update ARn
	typename CONFIG::address_t output_ar; // New value of ARn if it is updated

	if(unlikely(!cpu.ComputeIndirEA(ea, update_ar, output_ar, mod, ar, disp)))
	{
		throw BogusOpcodeException<CONFIG, DEBUG>(this);
	}

	if(update_ar)
	{
		// Write back ARn
		cpu.SetAR23_0(ar, output_ar);
	}

	// Read the source operand from memory
	uint32_t src_value = cpu.IntLoad(ea);

	// get destination register
	Register& dst_reg = cpu.GetExtReg(dst);
	if (unlikely(!cpu.IsExtReg(dst)))
		dst_reg.SetHiWriteMask(0, (uint8_t)0x08);

	// Compute result and flags
	uint32_t overflow;
	uint32_t underflow;
	uint32_t neg;
	dst_reg.Mpyf32(src_value, overflow, underflow, neg);
	
	// Generate flags (into ST)
	if (likely(cpu.IsExtReg(dst)))
		cpu.GenFlags(
			dst_reg,
			M_ST_UF | M_ST_N | M_ST_Z | M_ST_V,  // reset mask
			M_ST_LUF | M_ST_LV | M_ST_UF | M_ST_N | M_ST_Z | M_ST_V,  // or mask
			overflow, underflow, neg
		);
}

MPYF_imm.execute = {
	// Check that destination register is valid
	if (likely(!cpu.EnableFloatOpsWithNonExtRegs()))
	{
		if (unlikely(!cpu.IsExtReg(dst)))
			throw BogusOpcodeException<CONFIG, DEBUG>(this);
	}
	else
	{
		if (unlikely(!cpu.HasReg(dst)))
			throw BogusOpcodeException<CONFIG, DEBUG>(this);
	}
	
	// get destination register
	Register& dst_reg = cpu.GetExtReg(dst);
	if (unlikely(!cpu.IsExtReg(dst)))
		dst_reg.SetHiWriteMask(0, (uint8_t)0x10);

	// Compute result and flags
	uint32_t overflow;
	uint32_t underflow;
	uint32_t neg;
	dst_reg.Mpyf16((uint16_t)imm, overflow, underflow, neg);

	// Generate flags (into ST)
	if (likely(cpu.IsExtReg(dst)))
		cpu.GenFlags(
			dst_reg,
			M_ST_UF | M_ST_N | M_ST_Z | M_ST_V,  // reset mask
			M_ST_LUF | M_ST_LV | M_ST_UF | M_ST_N | M_ST_Z | M_ST_V,  // or mask
			overflow, underflow, neg
		);

}

/* end of MPYF (multiply floating-point values)
 **********************************************************/

/**********************************************************
 * MPYI (multiply integers)
 * op MPYI(0b000[3]:0b010101[6]:g[2]:dst[5]:src[16])
 */

op MPYI_reg  (0b000[3]:0b010101[6]:0b00[2]:dst[5]:0[11]:src[5])
op MPYI_dir  (0b000[3]:0b010101[6]:0b01[2]:dst[5]:direct[16])
op MPYI_indir(0b000[3]:0b010101[6]:0b10[2]:dst[5]:mod[5]:ar[3]:disp[8])
op MPYI_imm  (0b000[3]:0b010101[6]:0b11[2]:dst[5]:sext<32> imm[16])

MPYI_reg.disasm = {
	const char *dst_name = REG_NAME[dst];
	const char *src_name = REG_NAME[src];
	
	if (!dst_name || !src_name)
		return false;
	
	os << "MPYI " << src_name << ", " << dst_name;
	return true;
}

MPYI_dir.disasm = {
	const char *dst_name = REG_NAME[dst];

	if(!dst_name)
		return false;
	
	os << "MPYI " << hex << cpu.DisasmDir(Operation<CONFIG, DEBUG>::GetAddr() / 4, direct) << dec << ", " << dst_name;
	
	return true;
}

MPYI_indir.disasm = {
	string disasm_src_indir;
	const char *dst_name = REG_NAME[dst];

	if (!dst_name || !cpu.DisasmIndir(disasm_src_indir, Operation<CONFIG, DEBUG>::GetAddr() / 4, mod, ar, disp)) 
		return false;

	os << "MPYI " << disasm_src_indir << ", " << dst_name;
	return true;
}

MPYI_imm.disasm = {
	const char *dst_name = REG_NAME[dst];

	if (!dst_name)
		return false;

	os << "MPYI " << imm << ", " << dst_name;
	return true;
}

MPYI_reg.execute = {
	// Check that source and destination registers are valid
	if(unlikely(!cpu.HasReg(src) || !cpu.HasReg(dst)))
	{
		throw BogusOpcodeException<CONFIG, DEBUG>(this);
	}

	// Read source operand and sign extend value from 24 bits to 64 bits
	int64_t src_value = SignExtend((uint64_t)(cpu.GetReg(src) & 0xffffff), 24);

	// Read destination operand and sign extend value from 24 bits to 64 bits
	int64_t dst_value = SignExtend((uint64_t)(cpu.GetReg(dst) & 0xffffff), 24);

	// Compute the 32-bit result and overflow
	int64_t result64 = src_value * dst_value;   // Only 48 bits are useful
	int32_t lo32 = (int32_t) result64;          // the 32 LSBs of the result
	int32_t hi32 = (int32_t) (result64 >> 32);  // the 32 MSBs of the result
	// An overflow occurs if any of the 32-bit MSB of the result differ from MSB of the 32-bit output value
	// An arithmetic shift of 31 bits is used to duplicate 32 times the MSB of lo32
	uint8_t overflow = ((lo32 >> 31) != hi32);
	uint32_t result;
	uint8_t sign = result64 < 0;
	
	if(cpu.GetST_OVM() && overflow)
		result = (result64 < 0) ? 0x80000000 : 0x7fffffff; // Saturate the result
	else
		result = lo32;                                     // No saturation

	// Write back result
	cpu.SetReg(dst, result);

	// Check whether destination operand is an extended precision register
	if(cpu.IsExtReg(dst))
	{
		// Generate flags (into ST)
		cpu.GenFlags(
			result,
			M_ST_UF | M_ST_N | M_ST_Z | M_ST_V,  // reset mask
			M_ST_LV | M_ST_N | M_ST_Z | M_ST_V,  // or mask
			sign,
			0,
			overflow
		);
	}
}

MPYI_dir.execute = {
	// Check that destination register is valid
	if(unlikely(!cpu.HasReg(dst)))
	{
		throw BogusOpcodeException<CONFIG, DEBUG>(this);
	}

	// Read destination operand and sign extend value from 24 bits to 64 bits
	int64_t dst_value = SignExtend((uint64_t)(cpu.GetReg(dst) & 0xffffff), 24);

	// Compute the source operand effective address
	typename CONFIG::address_t ea = cpu.ComputeDirEA(direct);

	// Read the source operand from memory and sign extend value from 24 bits to 64 bits
	int64_t src_value = SignExtend((uint64_t)(cpu.IntLoad(ea) & 0xffffff), 24);

	// Compute the 32-bit result and overflow
	int64_t result64 = src_value * dst_value;   // Only 48 bits are useful
	int32_t lo32 = (int32_t) result64;          // the 32 LSBs of the result
	int32_t hi32 = (int32_t) (result64 >> 32);  // the 32 MSBs of the result
	// An overflow occurs if any of the 32-bit MSB of the result differ from MSB of the 32-bit output value
	// An arithmetic shift of 31 bits is used to duplicate 32 times the MSB of lo32
	uint8_t overflow = ((lo32 >> 31) != hi32);
	uint32_t result;
	uint8_t sign = result64 < 0;
	
	if(cpu.GetST_OVM() && overflow)
		result = (result64 < 0) ? 0x80000000 : 0x7fffffff; // Saturate the result
	else
		result = lo32;                                     // No saturation

	// Write back result
	cpu.SetReg(dst, result);

	// Check whether destination operand is an extended precision register
	if(cpu.IsExtReg(dst))
	{
		// Generate flags (into ST)
		cpu.GenFlags(
			result,
			M_ST_UF | M_ST_N | M_ST_Z | M_ST_V,  // reset mask
			M_ST_LV | M_ST_N | M_ST_Z | M_ST_V,  // or mask
			sign,
			0,
			overflow
		);
	}
}

MPYI_indir.execute = {
	// Check that destination register is valid
	if(unlikely(!cpu.HasReg(dst)))
	{
		throw BogusOpcodeException<CONFIG, DEBUG>(this);
	}

	// Check that indirect addressing mode is valid and compute the effective address of the source operand
	typename CONFIG::address_t ea;        // The effective address
	bool update_ar;                       // Whether to update ARn
	typename CONFIG::address_t output_ar; // New value of ARn if it is updated

	if(unlikely(!cpu.ComputeIndirEA(ea, update_ar, output_ar, mod, ar, disp)))
	{
		throw BogusOpcodeException<CONFIG, DEBUG>(this);
	}

	if(update_ar)
	{
		// Write back ARn
		cpu.SetAR23_0(ar, output_ar);
	}

	// Read destination operand and sign extend value from 24 bits to 64 bits
	int64_t dst_value = SignExtend((uint64_t)(cpu.GetReg(dst) & 0xffffff), 24);

	// Read the source operand from memory and sign extend value from 24 bits to 64 bits
	int64_t src_value = SignExtend((uint64_t)(cpu.IntLoad(ea) & 0xffffff), 24);

	// Compute the 32-bit result and overflow
	int64_t result64 = src_value * dst_value;   // Only 48 bits are useful
	int32_t lo32 = (int32_t) result64;          // the 32 LSBs of the result
	int32_t hi32 = (int32_t) (result64 >> 32);  // the 32 MSBs of the result
	// An overflow occurs if any of the 32-bit MSB of the result differ from MSB of the 32-bit output value
	// An arithmetic shift of 31 bits is used to duplicate 32 times the MSB of lo32
	uint8_t overflow = ((lo32 >> 31) != hi32);
	uint32_t result;
	uint8_t sign = result64 < 0;
	
	if(cpu.GetST_OVM() && overflow)
		result = (result64 < 0) ? 0x80000000 : 0x7fffffff; // Saturate the result
	else
		result = lo32;                                     // No saturation

	// Write back result
	cpu.SetReg(dst, result);

	// Check whether destination operand is an extended precision register
	if(cpu.IsExtReg(dst))
	{
		// Generate flags (into ST)
		cpu.GenFlags(
			result,
			M_ST_UF | M_ST_N | M_ST_Z | M_ST_V,  // reset mask
			M_ST_LV | M_ST_N | M_ST_Z | M_ST_V,  // or mask
			sign,
			0,
			overflow
		);
	}
}

MPYI_imm.execute = {
	// Check that destination register is valid
	if(unlikely(!cpu.HasReg(dst)))
	{
		throw BogusOpcodeException<CONFIG, DEBUG>(this);
	}

	// Read destination operand and sign extend value from 24 bits to 64 bits
	int64_t dst_value = SignExtend((uint64_t)(cpu.GetReg(dst) & 0xffffff), 24);

	// Compute the 32-bit result and overflow
	// Note: imm has been sign extended from 16 bits to 32 bits the decoder
	// Below, imm is sign extended from 32 bits to 64 bits
	int64_t result64 = imm * dst_value;         // Only 48 bits are useful
	int32_t lo32 = (int32_t) result64;          // the 32 LSBs of the result
	int32_t hi32 = (int32_t) (result64 >> 32);  // the 32 MSBs of the result
	// An overflow occurs if any of the 32-bit MSB of the result differ from MSB of the 32-bit output value
	// An arithmetic shift of 31 bits is used to duplicate 32 times the MSB of lo32
	uint8_t overflow = ((lo32 >> 31) != hi32);
	uint32_t result;
	uint8_t sign = result64 < 0;
	
	if(cpu.GetST_OVM() && overflow)
		result = (result64 < 0) ? 0x80000000 : 0x7fffffff; // Saturate the result
	else
		result = lo32;                                     // No saturation

	// Write back result
	cpu.SetReg(dst, result);

	// Check whether destination operand is an extended precision register
	if(cpu.IsExtReg(dst))
	{
		// Generate flags (into ST)
		cpu.GenFlags(
			result,
			M_ST_UF | M_ST_N | M_ST_Z | M_ST_V,  // reset mask
			M_ST_LV | M_ST_N | M_ST_Z | M_ST_V,  // or mask
			sign,
			0,
			overflow
		);
	}
}

/* end of MPYI (multiply integers)
 **********************************************************/

/**********************************************************
 * NEGB (negate integer with borrow)
 * op NEGB(0b000[3]:0b010110[6]:g[2]:dst[5]:src[16])
 */

op NEGB_reg  (0b000[3]:0b010110[6]:0b00[2]:dst[5]:0[11]:src[5])
op NEGB_dir  (0b000[3]:0b010110[6]:0b01[2]:dst[5]:direct[16])
op NEGB_indir(0b000[3]:0b010110[6]:0b10[2]:dst[5]:mod[5]:ar[3]:disp[8])
op NEGB_imm  (0b000[3]:0b010110[6]:0b11[2]:dst[5]:sext<32> imm[16])

NEGB_reg.disasm = {
	const char *dst_name = REG_NAME[dst];
	const char *src_name = REG_NAME[src];
	
	if (!dst_name || !src_name)
		return false;
	
	os << "NEGB " << src_name << ", " << dst_name;
	return true;
}

NEGB_dir.disasm = {
	const char *dst_name = REG_NAME[dst];

	if(!dst_name)
		return false;
	
	os << "NEGB " << hex << cpu.DisasmDir(Operation<CONFIG, DEBUG>::GetAddr() / 4, direct) << dec << ", " << dst_name;
	
	return true;
}

NEGB_indir.disasm = {
	string disasm_src_indir;
	const char *dst_name = REG_NAME[dst];

	if (!dst_name || !cpu.DisasmIndir(disasm_src_indir, Operation<CONFIG, DEBUG>::GetAddr() / 4, mod, ar, disp)) 
		return false;

	os << "NEGB " << disasm_src_indir << ", " << dst_name;
	return true;
}

NEGB_imm.disasm = {
	const char *dst_name = REG_NAME[dst];

	if (!dst_name)
		return false;

	os << "NEGB " << imm << ", " << dst_name;
	return true;
}

NEGB_reg.execute = {
	// Check that source and destination registers are valid
	if(unlikely(!cpu.HasReg(src) || !cpu.HasReg(dst)))
	{
		throw BogusOpcodeException<CONFIG, DEBUG>(this);
	}

	// Read source operand
	uint32_t src_value = cpu.GetReg(src);

	// Read borrow in
	uint8_t borrow_in = cpu.GetST_C();

	// Compute the result
	uint32_t result;      // the 32-bit result
	uint8_t borrow_out;   // the borrow out (0 or 1)
	uint8_t overflow;     // the overflow (0 or 1)
	uint8_t sign;         // the sign (0 or 1)

	// Depending on overflow mode do signed saturation or not 
	if(cpu.GetST_OVM())
	{
		SignedSatSub32(result, borrow_out, overflow, sign, 0, src_value, borrow_in);
	}
	else
	{
		SignedSub32(result, borrow_out, overflow, sign, 0, src_value, borrow_in);
		sign = sign ^ overflow;
	}

	// Write back result
	cpu.SetReg(dst, result);

	// Check whether destination operand is an extended precision register
	if(cpu.IsExtReg(dst))
	{
		// Generate flags (into ST)
		cpu.GenFlags(
			result,
			M_ST_UF | M_ST_N | M_ST_Z | M_ST_V | M_ST_C,  // reset mask
			M_ST_LV | M_ST_N | M_ST_Z | M_ST_V | M_ST_C,  // or mask
			sign,
			borrow_out,
			overflow
		);
	}
}

NEGB_dir.execute = {
	// Check that destination register is valid
	if(unlikely(!cpu.HasReg(dst)))
	{
		throw BogusOpcodeException<CONFIG, DEBUG>(this);
	}

	// Compute the source operand effective address
	typename CONFIG::address_t ea = cpu.ComputeDirEA(direct);

	// Read the source operand from memory
	uint32_t src_value = cpu.IntLoad(ea);

	// Read borrow in
	uint8_t borrow_in = cpu.GetST_C();

	// Compute the result
	uint32_t result;      // the 32-bit result
	uint8_t borrow_out;   // the borrow out (0 or 1)
	uint8_t overflow;     // the overflow (0 or 1)
	uint8_t sign;         // the sign (0 or 1)

	// Depending on overflow mode do signed saturation or not 
	if(cpu.GetST_OVM())
	{
		SignedSatSub32(result, borrow_out, overflow, sign, 0, src_value, borrow_in);
	}
	else
	{
		SignedSub32(result, borrow_out, overflow, sign, 0, src_value, borrow_in);
		sign = sign ^ overflow;
	}

	// Write back result
	cpu.SetReg(dst, result);

	// Check whether destination operand is an extended precision register
	if(cpu.IsExtReg(dst))
	{
		// Generate flags (into ST)
		cpu.GenFlags(
			result,
			M_ST_UF | M_ST_N | M_ST_Z | M_ST_V | M_ST_C,  // reset mask
			M_ST_LV | M_ST_N | M_ST_Z | M_ST_V | M_ST_C,  // or mask
			sign,
			borrow_out,
			overflow
		);
	}
}

NEGB_indir.execute = {
	// Check that destination register is valid
	if(unlikely(!cpu.HasReg(dst)))
	{
		throw BogusOpcodeException<CONFIG, DEBUG>(this);
	}

	// Check that indirect addressing mode is valid and compute the effective address of the source operand
	typename CONFIG::address_t ea;        // The effective address
	bool update_ar;                       // Whether to update ARn
	typename CONFIG::address_t output_ar; // New value of ARn if it is updated

	if(unlikely(!cpu.ComputeIndirEA(ea, update_ar, output_ar, mod, ar, disp)))
	{
		throw BogusOpcodeException<CONFIG, DEBUG>(this);
	}

	if(update_ar)
	{
		// Write back ARn
		cpu.SetAR23_0(ar, output_ar);
	}

	// Read the source operand from memory
	uint32_t src_value = cpu.IntLoad(ea);

	// Read borrow in
	uint8_t borrow_in = cpu.GetST_C();

	// Compute the result
	uint32_t result;      // the 32-bit result
	uint8_t borrow_out;   // the borrow out (0 or 1)
	uint8_t overflow;     // the overflow (0 or 1)
	uint8_t sign;         // the sign (0 or 1)

	// Depending on overflow mode do signed saturation or not 
	if(cpu.GetST_OVM())
	{
		SignedSatSub32(result, borrow_out, overflow, sign, 0, src_value, borrow_in);
	}
	else
	{
		SignedSub32(result, borrow_out, overflow, sign, 0, src_value, borrow_in);
		sign = sign ^ overflow;
	}

	// Write back result
	cpu.SetReg(dst, result);

	// Check whether destination operand is an extended precision register
	if(cpu.IsExtReg(dst))
	{
		// Generate flags (into ST)
		cpu.GenFlags(
			result,
			M_ST_UF | M_ST_N | M_ST_Z | M_ST_V | M_ST_C,  // reset mask
			M_ST_LV | M_ST_N | M_ST_Z | M_ST_V | M_ST_C,  // or mask
			sign,
			borrow_out,
			overflow
		);
	}
}

NEGB_imm.execute = {
	// Check that destination register is valid
	if(unlikely(!cpu.HasReg(dst)))
	{
		throw BogusOpcodeException<CONFIG, DEBUG>(this);
	}

	// Read borrow in
	uint8_t borrow_in = cpu.GetST_C();

	// Compute the result
	uint32_t result;      // the 32-bit result
	uint8_t borrow_out;   // the borrow out (0 or 1)
	uint8_t overflow;     // the overflow (0 or 1)
	uint8_t sign;         // the sign (0 or 1)

	// Depending on overflow mode do signed saturation or not 
	if(cpu.GetST_OVM())
	{
		SignedSatSub32(result, borrow_out, overflow, sign, 0, imm, borrow_in);
	}
	else
	{
		SignedSub32(result, borrow_out, overflow, sign, 0, imm, borrow_in);
		sign = sign ^ overflow;
	}

	// Write back result
	cpu.SetReg(dst, result);

	// Check whether destination operand is an extended precision register
	if(cpu.IsExtReg(dst))
	{
		// Generate flags (into ST)
		cpu.GenFlags(
			result,
			M_ST_UF | M_ST_N | M_ST_Z | M_ST_V | M_ST_C,  // reset mask
			M_ST_LV | M_ST_N | M_ST_Z | M_ST_V | M_ST_C,  // or mask
			sign,
			borrow_out,
			overflow
		);
	}
}

/* end of NEGB (negate integer with borrow)
 **********************************************************/

/**********************************************************
 * NEGF (negate floating-point value)
 * op NEGF(0b000[3]:0b010111[6]:g[2]:dst[5]:src[16])
 */

op NEGF_reg  (0b000[3]:0b010111[6]:0b00[2]:dst[5]:0[11]:src[5])
op NEGF_dir  (0b000[3]:0b010111[6]:0b01[2]:dst[5]:direct[16])
op NEGF_indir(0b000[3]:0b010111[6]:0b10[2]:dst[5]:mod[5]:ar[3]:disp[8])
op NEGF_imm  (0b000[3]:0b010111[6]:0b11[2]:dst[5]:imm[16])

NEGF_reg.disasm = {
	const char *dst_name = REG_NAME[dst];
	const char *src_name = REG_NAME[src];
	
	if (!dst_name || !src_name)
		return false;
	
	os << "NEGF " << src_name << ", " << dst_name;
	return true;
}

NEGF_dir.disasm = {
	const char *dst_name = REG_NAME[dst];

	if(!dst_name)
		return false;
	
	os << "NEGF " << hex << cpu.DisasmDir(Operation<CONFIG, DEBUG>::GetAddr() / 4, direct) << dec << ", " << dst_name;
	
	return true;
}

NEGF_indir.disasm = {
	string disasm_src_indir;
	const char *dst_name = REG_NAME[dst];

	if (!dst_name || !cpu.DisasmIndir(disasm_src_indir, Operation<CONFIG, DEBUG>::GetAddr() / 4, mod, ar, disp)) 
		return false;

	os << "NEGF " << disasm_src_indir << ", " << dst_name;
	return true;
}

NEGF_imm.disasm = {
	const char *dst_name = REG_NAME[dst];

	if (!dst_name)
		return false;

	os << "NEGF " << cpu.DisasmShortFloat(imm) << ", " << dst_name;
	return true;
}

NEGF_reg.execute = {
	// Check that destination and source registers are valid
	if (likely(!cpu.EnableFloatOpsWithNonExtRegs())) {
		if (unlikely(!cpu.IsExtReg(dst) || !cpu.IsExtReg(src)))
			throw BogusOpcodeException<CONFIG, DEBUG>(this);
	} 
	else
	{
		if(unlikely(!cpu.HasReg(dst) || !cpu.HasReg(src)))
			throw BogusOpcodeException<CONFIG, DEBUG>(this);
	}

	// get source register
	Register& src_reg = cpu.GetExtReg(src);
	
	// get destination register
	Register& dst_reg = cpu.GetExtReg(dst);
	
	if (unlikely(!cpu.IsExtReg(src)))
	{
		src_reg.SetHiWriteMask(0, (uint8_t)0x10);
		if (unlikely(!cpu.IsExtReg(dst)))
			dst_reg.SetHiWriteMask(0, (uint8_t)0x10);
	}
	else
		if (unlikely(!cpu.IsExtReg(dst)))
			dst_reg.SetHiWriteMask(0, (uint8_t)0);

	// compute
	uint32_t underflow;
	uint32_t overflow;
	uint32_t neg;
	dst_reg.Negf(src_reg, overflow, underflow, neg);
	
	// Generate flags (into ST)
	if (likely(cpu.IsExtReg(dst)))
		cpu.GenFlags(dst_reg,
			 M_ST_UF | M_ST_N | M_ST_Z | M_ST_V,  // reset mask
			 M_ST_LUF | M_ST_LV | M_ST_UF | M_ST_N | M_ST_Z | M_ST_V,  // or mask
			 overflow, underflow, neg
			 );
}

NEGF_dir.execute = {
	// Check that destination register is valid
	if (likely(!cpu.EnableFloatOpsWithNonExtRegs()))
	{
		if (unlikely(!cpu.IsExtReg(dst)))
			throw BogusOpcodeException<CONFIG, DEBUG>(this);
	}
	else
	{
		if (unlikely(!cpu.HasReg(dst)))
			throw BogusOpcodeException<CONFIG, DEBUG>(this);
	}
	
	// get destination register
	Register& dst_reg = cpu.GetExtReg(dst);
	if (unlikely(!cpu.IsExtReg(dst)))
		dst_reg.SetHiWriteMask(0, (uint8_t)0);
	
	// Compute the source operand effective address
	typename CONFIG::address_t ea = cpu.ComputeDirEA(direct);
	
	// Read the source operand from memory
	uint32_t src_value = cpu.IntLoad(ea);
	
	// compute
	uint32_t underflow;
	uint32_t overflow;
	uint32_t neg;
	dst_reg.Negf32(src_value, overflow, underflow, neg);
	
	// Generate flags (into ST)
	if (likely(cpu.IsExtReg(dst)))
		cpu.GenFlags(dst_reg,
			 M_ST_UF | M_ST_N | M_ST_Z | M_ST_V,  // reset mask
			 M_ST_LUF | M_ST_LV | M_ST_UF | M_ST_N | M_ST_Z | M_ST_V,  // or mask
			 overflow, underflow, neg
			 );
}

NEGF_indir.execute = {
	// Check that destination register is valid
	if (likely(!cpu.EnableFloatOpsWithNonExtRegs()))
	{
		if (unlikely(!cpu.IsExtReg(dst)))
			throw BogusOpcodeException<CONFIG, DEBUG>(this);
	}
	else
	{
		if (unlikely(!cpu.HasReg(dst)))
			throw BogusOpcodeException<CONFIG, DEBUG>(this);
	}
	
	// Check that indirect addressing mode is valid and compute the effective address of the source operand
	typename CONFIG::address_t ea;        // The effective address
	bool update_ar;                       // Whether to update ARn
	typename CONFIG::address_t output_ar; // New value of ARn if it is updated
	
	if(unlikely(!cpu.ComputeIndirEA(ea, update_ar, output_ar, mod, ar, disp)))
	{
		throw BogusOpcodeException<CONFIG, DEBUG>(this);
	}
	
	if(update_ar)
	{
		// Write back ARn
		cpu.SetAR23_0(ar, output_ar);
	}
	
	// get destination register
	Register& dst_reg = cpu.GetExtReg(dst);
	if (unlikely(!cpu.IsExtReg(dst)))
		dst_reg.SetHiWriteMask(0, (uint8_t)0x08);

	// Read the source operand from memory
	uint32_t src_value = cpu.IntLoad(ea);
	
	// compute
	uint32_t underflow;
	uint32_t overflow;
	uint32_t neg;
	dst_reg.Negf32(src_value, overflow, underflow, neg);
	
	// Generate flags (into ST)
	if (likely(cpu.IsExtReg(dst)))
		cpu.GenFlags(dst_reg,
			 M_ST_UF | M_ST_N | M_ST_Z | M_ST_V,  // reset mask
			 M_ST_LUF | M_ST_LV | M_ST_UF | M_ST_N | M_ST_Z | M_ST_V,  // or mask
			 overflow, underflow, neg
			 );
}

NEGF_imm.execute = {
	// Check that destination register is valid
	if (likely(!cpu.EnableFloatOpsWithNonExtRegs()))
	{
		if (unlikely(!cpu.IsExtReg(dst)))
			throw BogusOpcodeException<CONFIG, DEBUG>(this);
	}
	else
	{
		if (unlikely(!cpu.HasReg(dst)))
			throw BogusOpcodeException<CONFIG, DEBUG>(this);
	}
	
	// get destination register
	Register& dst_reg = cpu.GetExtReg(dst);
	if (unlikely(!cpu.IsExtReg(dst)))
		dst_reg.SetHiWriteMask(0, (uint8_t)0x10);

	// compute
	uint32_t underflow;
	uint32_t overflow;
	uint32_t neg;
	dst_reg.Negf16((uint16_t)imm, overflow, underflow, neg);
	
	// Generate flags (into ST)
	if (likely(cpu.IsExtReg(dst)))
		cpu.GenFlags(dst_reg,
			 M_ST_UF | M_ST_N | M_ST_Z | M_ST_V,  // reset mask
			 M_ST_LUF | M_ST_LV | M_ST_UF | M_ST_N | M_ST_Z | M_ST_V,  // or mask
			 overflow, underflow, neg
			 );
}

/* end of NEGF (negate floating-point value)
 **********************************************************/

/**********************************************************
 * NEGI (negate integer)
 * op NEGI(0b000[3]:0b011000[6]:g[2]:dst[5]:src[16])
 */

op NEGI_reg  (0b000[3]:0b011000[6]:0b00[2]:dst[5]:0[11]:src[5])
op NEGI_dir  (0b000[3]:0b011000[6]:0b01[2]:dst[5]:direct[16])
op NEGI_indir(0b000[3]:0b011000[6]:0b10[2]:dst[5]:mod[5]:ar[3]:disp[8])
op NEGI_imm  (0b000[3]:0b011000[6]:0b11[2]:dst[5]:sext<32> imm[16])

NEGI_reg.disasm = {
	const char *dst_name = REG_NAME[dst];
	const char *src_name = REG_NAME[src];
	
	if (!dst_name || !src_name)
		return false;
	
	os << "NEGI " << src_name << ", " << dst_name;
	return true;
}

NEGI_dir.disasm = {
	const char *dst_name = REG_NAME[dst];

	if(!dst_name)
		return false;
	
	os << "NEGI " << hex << cpu.DisasmDir(Operation<CONFIG, DEBUG>::GetAddr() / 4, direct) << dec << ", " << dst_name;
	
	return true;
}

NEGI_indir.disasm = {
	string disasm_src_indir;
	const char *dst_name = REG_NAME[dst];

	if (!dst_name || !cpu.DisasmIndir(disasm_src_indir, Operation<CONFIG, DEBUG>::GetAddr() / 4, mod, ar, disp)) 
		return false;

	os << "NEGI " << disasm_src_indir << ", " << dst_name;
	return true;
}

NEGI_imm.disasm = {
	const char *dst_name = REG_NAME[dst];

	if (!dst_name)
		return false;

	os << "NEGI " << imm << ", " << dst_name;
	return true;
}

NEGI_reg.execute = {
	// Check that source and destination registers are valid
	if(unlikely(!cpu.HasReg(src) || !cpu.HasReg(dst)))
	{
		throw BogusOpcodeException<CONFIG, DEBUG>(this);
	}

	// Read source operand
	uint32_t src_value = cpu.GetReg(src);

	// Compute the result
	uint32_t result;      // the 32-bit result
	uint8_t borrow_out;   // the borrow out (0 or 1)
	uint8_t overflow;     // the overflow (0 or 1)
	uint8_t sign;         // the sign (0 or 1)

	// Depending on overflow mode do signed saturation or not 
	if(cpu.GetST_OVM())
	{
		SignedSatSub32(result, borrow_out, overflow, sign, 0, src_value, 0);
	}
	else
	{
		SignedSub32(result, borrow_out, overflow, sign, 0, src_value, 0);
		sign = sign ^ overflow;
	}

	// Write back result
	cpu.SetReg(dst, result);

	// Check whether destination operand is an extended precision register
	if(cpu.IsExtReg(dst))
	{
		// Generate flags (into ST)
		cpu.GenFlags(
			result,
			M_ST_UF | M_ST_N | M_ST_Z | M_ST_V | M_ST_C,  // reset mask
			M_ST_LV | M_ST_N | M_ST_Z | M_ST_V | M_ST_C,  // or mask
			sign,
			borrow_out,
			overflow
		);
	}
}

NEGI_dir.execute = {
	// Check that destination register is valid
	if(unlikely(!cpu.HasReg(dst)))
	{
		throw BogusOpcodeException<CONFIG, DEBUG>(this);
	}

	// Compute the source operand effective address
	typename CONFIG::address_t ea = cpu.ComputeDirEA(direct);

	// Read the source operand from memory
	uint32_t src_value = cpu.IntLoad(ea);

	// Compute the result
	uint32_t result;      // the 32-bit result
	uint8_t borrow_out;   // the borrow out (0 or 1)
	uint8_t overflow;     // the overflow (0 or 1)
	uint8_t sign;         // the sign (0 or 1)

	// Depending on overflow mode do signed saturation or not 
	if(cpu.GetST_OVM())
	{
		SignedSatSub32(result, borrow_out, overflow, sign, 0, src_value, 0);
	}
	else
	{
		SignedSub32(result, borrow_out, overflow, sign, 0, src_value, 0);
		sign = sign ^ overflow;
	}

	// Write back result
	cpu.SetReg(dst, result);

	// Check whether destination operand is an extended precision register
	if(cpu.IsExtReg(dst))
	{
		// Generate flags (into ST)
		cpu.GenFlags(
			result,
			M_ST_UF | M_ST_N | M_ST_Z | M_ST_V | M_ST_C,  // reset mask
			M_ST_LV | M_ST_N | M_ST_Z | M_ST_V | M_ST_C,  // or mask
			sign,
			borrow_out,
			overflow
		);
	}
}

NEGI_indir.execute = {
	// Check that destination register is valid
	if(unlikely(!cpu.HasReg(dst)))
	{
		throw BogusOpcodeException<CONFIG, DEBUG>(this);
	}

	// Check that indirect addressing mode is valid and compute the effective address of the source operand
	typename CONFIG::address_t ea;        // The effective address
	bool update_ar;                       // Whether to update ARn
	typename CONFIG::address_t output_ar; // New value of ARn if it is updated

	if(unlikely(!cpu.ComputeIndirEA(ea, update_ar, output_ar, mod, ar, disp)))
	{
		throw BogusOpcodeException<CONFIG, DEBUG>(this);
	}

	if(update_ar)
	{
		// Write back ARn
		cpu.SetAR23_0(ar, output_ar);
	}

	// Read the source operand from memory
	uint32_t src_value = cpu.IntLoad(ea);

	// Compute the result
	uint32_t result;      // the 32-bit result
	uint8_t borrow_out;   // the borrow out (0 or 1)
	uint8_t overflow;     // the overflow (0 or 1)
	uint8_t sign;         // the sign (0 or 1)

	// Depending on overflow mode do signed saturation or not 
	if(cpu.GetST_OVM())
	{
		SignedSatSub32(result, borrow_out, overflow, sign, 0, src_value, 0);
	}
	else
	{
		SignedSub32(result, borrow_out, overflow, sign, 0, src_value, 0);
		sign = sign ^ overflow;
	}

	// Write back result
	cpu.SetReg(dst, result);

	// Check whether destination operand is an extended precision register
	if(cpu.IsExtReg(dst))
	{
		// Generate flags (into ST)
		cpu.GenFlags(
			result,
			M_ST_UF | M_ST_N | M_ST_Z | M_ST_V | M_ST_C,  // reset mask
			M_ST_LV | M_ST_N | M_ST_Z | M_ST_V | M_ST_C,  // or mask
			sign,
			borrow_out,
			overflow
		);
	}
}

NEGI_imm.execute = {
	// Check that destination register is valid
	if(unlikely(!cpu.HasReg(dst)))
	{
		throw BogusOpcodeException<CONFIG, DEBUG>(this);
	}

	// Compute the result
	uint32_t result;      // the 32-bit result
	uint8_t borrow_out;   // the borrow out (0 or 1)
	uint8_t overflow;     // the overflow (0 or 1)
	uint8_t sign;         // the sign (0 or 1)

	// Depending on overflow mode do signed saturation or not 
	if(cpu.GetST_OVM())
	{
		SignedSatSub32(result, borrow_out, overflow, sign, 0, imm, 0);
	}
	else
	{
		SignedSub32(result, borrow_out, overflow, sign, 0, imm, 0);
		sign = sign ^ overflow;
	}

	// Write back result
	cpu.SetReg(dst, result);

	// Check whether destination operand is an extended precision register
	if(cpu.IsExtReg(dst))
	{
		// Generate flags (into ST)
		cpu.GenFlags(
			result,
			M_ST_UF | M_ST_N | M_ST_Z | M_ST_V | M_ST_C,  // reset mask
			M_ST_LV | M_ST_N | M_ST_Z | M_ST_V | M_ST_C,  // or mask
			sign,
			borrow_out,
			overflow
		);
	}
}

/* end of NEGI (negate integer)
 **********************************************************/

/**********************************************************
 * NORM (normalize floating-point value)
 * op NORM(0b000[3]:0b011010[6]:g[2]:dst[5]:src[16])
 */

op NORM_reg  (0b000[3]:0b011010[6]:0b00[2]:dst[5]:0[11]:src[5])
op NORM_dir  (0b000[3]:0b011010[6]:0b01[2]:dst[5]:direct[16])
op NORM_indir(0b000[3]:0b011010[6]:0b10[2]:dst[5]:mod[5]:ar[3]:disp[8])
op NORM_imm  (0b000[3]:0b011010[6]:0b11[2]:dst[5]:sext<32> imm[16])

NORM_reg.disasm = {
	const char *dst_name = REG_NAME[dst];
	const char *src_name = REG_NAME[src];
	
	if (!dst_name || !src_name)
		return false;
	
	os << "NORM " << src_name << ", " << dst_name;
	return true;
}

NORM_dir.disasm = {
	const char *dst_name = REG_NAME[dst];

	if(!dst_name)
		return false;
	
	os << "NORM " << hex << cpu.DisasmDir(Operation<CONFIG, DEBUG>::GetAddr() / 4, direct) << dec << ", " << dst_name;
	
	return true;
}

NORM_indir.disasm = {
	string disasm_src_indir;
	const char *dst_name = REG_NAME[dst];

	if (!dst_name || !cpu.DisasmIndir(disasm_src_indir, Operation<CONFIG, DEBUG>::GetAddr() / 4, mod, ar, disp)) 
		return false;

	os << "NORM " << disasm_src_indir << ", " << dst_name;
	return true;
}

NORM_imm.disasm = {
	const char *dst_name = REG_NAME[dst];

	if (!dst_name)
		return false;

	os << "NORM " << imm << ", " << dst_name;
	return true;
}

NORM_reg.execute = {
	// Check that destination and source registers are valid
	if (likely(!cpu.EnableFloatOpsWithNonExtRegs())) {
		if (unlikely(!cpu.IsExtReg(dst) || !cpu.IsExtReg(src)))
			throw BogusOpcodeException<CONFIG, DEBUG>(this);
	} 
	else
	{
		if(unlikely(!cpu.HasReg(dst) || !cpu.HasReg(src)))
			throw BogusOpcodeException<CONFIG, DEBUG>(this);
	}

	// get source register
	Register& src_reg = cpu.GetExtReg(src);
	
	// get destination register
	Register& dst_reg = cpu.GetExtReg(dst);
	
	if (unlikely(!cpu.IsExtReg(src)))
	{
		src_reg.SetHiWriteMask(0, (uint8_t)0x10);
		if (unlikely(!cpu.IsExtReg(dst)))
			dst_reg.SetHiWriteMask(0, (uint8_t)0x10);
	}
	else
		if (unlikely(!cpu.IsExtReg(dst)))
			dst_reg.SetHiWriteMask(0, (uint8_t)0);

	// compute
	uint32_t underflow;
	uint32_t neg;
	dst_reg.Normf(src_reg, underflow, neg);
	
	// Generate flags (into ST)
	if (likely(cpu.IsExtReg(dst)))
		cpu.GenFlags(dst_reg,
			 M_ST_UF | M_ST_N | M_ST_Z | M_ST_V,  // reset mask
			 M_ST_LUF | M_ST_UF | M_ST_N | M_ST_Z,  // or mask
			 0, underflow, neg
			 );
}

NORM_dir.execute = {
	// Check that destination register is valid
	if (likely(!cpu.EnableFloatOpsWithNonExtRegs()))
	{
		if (unlikely(!cpu.IsExtReg(dst)))
			throw BogusOpcodeException<CONFIG, DEBUG>(this);
	}
	else
	{
		if (unlikely(!cpu.HasReg(dst)))
			throw BogusOpcodeException<CONFIG, DEBUG>(this);
	}
	
	// get destination register
	Register& dst_reg = cpu.GetExtReg(dst);
	if (unlikely(!cpu.IsExtReg(dst)))
		dst_reg.SetHiWriteMask(0, (uint8_t)0);
	
	// Compute the source operand effective address
	typename CONFIG::address_t ea = cpu.ComputeDirEA(direct);
	
	// Read the source operand from memory
	uint32_t src_value = cpu.IntLoad(ea);
	
	// compute
	uint32_t underflow;
	uint32_t neg;
	dst_reg.Normf32(src_value, underflow, neg);
	
	// Generate flags (into ST)
	if (likely(cpu.IsExtReg(dst)))
		cpu.GenFlags(dst_reg,
			 M_ST_UF | M_ST_N | M_ST_Z | M_ST_V,  // reset mask
			 M_ST_LUF | M_ST_UF | M_ST_N | M_ST_Z,  // or mask
			 0, underflow, neg
			 );
}

NORM_indir.execute = {
	// Check that destination register is valid
	if (likely(!cpu.EnableFloatOpsWithNonExtRegs()))
	{
		if (unlikely(!cpu.IsExtReg(dst)))
			throw BogusOpcodeException<CONFIG, DEBUG>(this);
	}
	else
	{
		if (unlikely(!cpu.HasReg(dst)))
			throw BogusOpcodeException<CONFIG, DEBUG>(this);
	}
	
	// Check that indirect addressing mode is valid and compute the effective address of the source operand
	typename CONFIG::address_t ea;        // The effective address
	bool update_ar;                       // Whether to update ARn
	typename CONFIG::address_t output_ar; // New value of ARn if it is updated
	
	if(unlikely(!cpu.ComputeIndirEA(ea, update_ar, output_ar, mod, ar, disp)))
	{
		throw BogusOpcodeException<CONFIG, DEBUG>(this);
	}
	
	if(update_ar)
	{
		// Write back ARn
		cpu.SetAR23_0(ar, output_ar);
	}
	
	// get destination register
	Register& dst_reg = cpu.GetExtReg(dst);
	if (unlikely(!cpu.IsExtReg(dst)))
		dst_reg.SetHiWriteMask(0, (uint8_t)0x08);

	// Read the source operand from memory
	uint32_t src_value = cpu.IntLoad(ea);
	
	// compute
	uint32_t underflow;
	uint32_t neg;
	dst_reg.Normf32(src_value, underflow, neg);
	
	// Generate flags (into ST)
	if (likely(cpu.IsExtReg(dst)))
		cpu.GenFlags(dst_reg,
			 M_ST_UF | M_ST_N | M_ST_Z | M_ST_V,  // reset mask
			 M_ST_LUF | M_ST_UF | M_ST_N | M_ST_Z,  // or mask
			 0, underflow, neg
			 );
}

NORM_imm.execute = {
	// Check that destination register is valid
	if (likely(!cpu.EnableFloatOpsWithNonExtRegs()))
	{
		if (unlikely(!cpu.IsExtReg(dst)))
			throw BogusOpcodeException<CONFIG, DEBUG>(this);
	}
	else
	{
		if (unlikely(!cpu.HasReg(dst)))
			throw BogusOpcodeException<CONFIG, DEBUG>(this);
	}
	
	// get destination register
	Register& dst_reg = cpu.GetExtReg(dst);
	if (unlikely(!cpu.IsExtReg(dst)))
		dst_reg.SetHiWriteMask(0, (uint8_t)0x10);

	// compute
	uint32_t underflow;
	uint32_t neg;
	dst_reg.Normf16((uint16_t)imm, underflow, neg);
	
	// Generate flags (into ST)
	if (likely(cpu.IsExtReg(dst)))
		cpu.GenFlags(dst_reg,
			 M_ST_UF | M_ST_N | M_ST_Z | M_ST_V,  // reset mask
			 M_ST_LUF | M_ST_UF | M_ST_N | M_ST_Z,  // or mask
			 0, underflow, neg
			 );
}

/* end of NORM (normalize floating-point value)
 **********************************************************/

/**********************************************************
 * NOT (bitwise-logical complement)
 * op NOT(0b000[3]:0b011011[6]:g[2]:dst[5]:src[16])
 */

op NOT_reg  (0b000[3]:0b011011[6]:0b00[2]:dst[5]:0[11]:src[5])
op NOT_dir  (0b000[3]:0b011011[6]:0b01[2]:dst[5]:direct[16])
op NOT_indir(0b000[3]:0b011011[6]:0b10[2]:dst[5]:mod[5]:ar[3]:disp[8])
op NOT_imm  (0b000[3]:0b011011[6]:0b11[2]:dst[5]:<32> imm[16])

NOT_reg.disasm = {
	const char *dst_name = REG_NAME[dst];
	const char *src_name = REG_NAME[src];
	
	if (!dst_name || !src_name)
		return false;
	
	os << "NOT " << src_name << ", " << dst_name;
	return true;
}

NOT_dir.disasm = {
	const char *dst_name = REG_NAME[dst];

	if(!dst_name)
		return false;
	
	os << "NOT " << hex << cpu.DisasmDir(Operation<CONFIG, DEBUG>::GetAddr() / 4, direct) << dec << ", " << dst_name;
	
	return true;
}

NOT_indir.disasm = {
	string disasm_src_indir;
	const char *dst_name = REG_NAME[dst];

	if (!dst_name || !cpu.DisasmIndir(disasm_src_indir, Operation<CONFIG, DEBUG>::GetAddr() / 4, mod, ar, disp)) 
		return false;

	os << "NOT " << disasm_src_indir << ", " << dst_name;
	return true;
}

NOT_imm.disasm = {
	const char *dst_name = REG_NAME[dst];

	if (!dst_name)
		return false;

	os << "NOT " << imm << ", " << dst_name;
	return true;
}

NOT_reg.execute = {
	// Check that source and destination registers are valid
	if(unlikely(!cpu.HasReg(src) || !cpu.HasReg(dst)))
	{
		throw BogusOpcodeException<CONFIG, DEBUG>(this);
	}

	// Read source operand
	uint32_t src_value = cpu.GetReg(src);

	// Compute the result
	uint32_t result = ~src_value;
	uint8_t sign = (int32_t) result < 0;

	// Write back result
	cpu.SetReg(dst, result);

	// Check whether destination operand is an extended precision register
	if(cpu.IsExtReg(dst))
	{
		// Generate flags (into ST)
		cpu.GenFlags(
			result,
			M_ST_UF | M_ST_N | M_ST_Z | M_ST_V,  // reset mask
			M_ST_N | M_ST_Z,    // or mask
			sign
		);
	}
}

NOT_dir.execute = {
	// Check that destination register is valid
	if(unlikely(!cpu.HasReg(dst)))
	{
		throw BogusOpcodeException<CONFIG, DEBUG>(this);
	}

	// Compute the source operand effective address
	typename CONFIG::address_t ea = cpu.ComputeDirEA(direct);

	// Read the source operand from memory
	uint32_t src_value = cpu.IntLoad(ea);

	// Compute the result
	uint32_t result = ~src_value;
	uint8_t sign = (int32_t) result < 0;

	// Write back result
	cpu.SetReg(dst, result);

	// Check whether destination operand is an extended precision register
	if(cpu.IsExtReg(dst))
	{
		// Generate flags (into ST)
		cpu.GenFlags(
			result,
			M_ST_UF | M_ST_N | M_ST_Z | M_ST_V,  // reset mask
			M_ST_N | M_ST_Z,    // or mask
			sign
		);
	}
}

NOT_indir.execute = {
	// Check that destination register is valid
	if(unlikely(!cpu.HasReg(dst)))
	{
		throw BogusOpcodeException<CONFIG, DEBUG>(this);
	}

	// Check that indirect addressing mode is valid and compute the effective address of the source operand
	typename CONFIG::address_t ea;        // The effective address
	bool update_ar;                       // Whether to update ARn
	typename CONFIG::address_t output_ar; // New value of ARn if it is updated

	if(unlikely(!cpu.ComputeIndirEA(ea, update_ar, output_ar, mod, ar, disp)))
	{
		throw BogusOpcodeException<CONFIG, DEBUG>(this);
	}

	if(update_ar)
	{
		// Write back ARn
		cpu.SetAR23_0(ar, output_ar);
	}

	// Read the source operand from memory
	uint32_t src_value = cpu.IntLoad(ea);

	// Compute the result
	uint32_t result = ~src_value;
	uint8_t sign = (int32_t) result < 0;

	// Write back result
	cpu.SetReg(dst, result);

	// Check whether destination operand is an extended precision register
	if(cpu.IsExtReg(dst))
	{
		// Generate flags (into ST)
		cpu.GenFlags(
			result,
			M_ST_UF | M_ST_N | M_ST_Z | M_ST_V,  // reset mask
			M_ST_N | M_ST_Z,    // or mask
			sign
		);
	}
}

NOT_imm.execute = {
	// Check that destination register is valid
	if(unlikely(!cpu.HasReg(dst)))
	{
		throw BogusOpcodeException<CONFIG, DEBUG>(this);
	}

	// Compute the result
	uint32_t result = ~imm;
	uint8_t sign = (int32_t) result < 0;

	// Write back result
	cpu.SetReg(dst, result);

	// Check whether destination operand is an extended precision register
	if(cpu.IsExtReg(dst))
	{
		// Generate flags (into ST)
		cpu.GenFlags(
			result,
			M_ST_UF | M_ST_N | M_ST_Z | M_ST_V,  // reset mask
			M_ST_N | M_ST_Z,    // or mask
			sign
		);
	}
}

/* end of NOT (bitwise-logical complement)
 **********************************************************/

/**********************************************************
 * OR (bitwise-logical OR)
 * op OR(0b000[3]:0b100000[6]:g[2]:dst[5]:src[16])
 */

op OR_reg  (0b000[3]:0b100000[6]:0b00[2]:dst[5]:0[11]:src[5])
op OR_dir  (0b000[3]:0b100000[6]:0b01[2]:dst[5]:direct[16])
op OR_indir(0b000[3]:0b100000[6]:0b10[2]:dst[5]:mod[5]:ar[3]:disp[8])
op OR_imm  (0b000[3]:0b100000[6]:0b11[2]:dst[5]:<32> imm[16])

OR_reg.disasm = {
	const char *dst_name = REG_NAME[dst];
	const char *src_name = REG_NAME[src];
	
	if (!dst_name || !src_name)
		return false;
	
	os << "OR " << src_name << ", " << dst_name;
	return true;
}

OR_dir.disasm = {
	const char *dst_name = REG_NAME[dst];

	if(!dst_name)
		return false;
	
	os << "OR " << hex << cpu.DisasmDir(Operation<CONFIG, DEBUG>::GetAddr() / 4, direct) << dec << ", " << dst_name;
	
	return true;
}

OR_indir.disasm = {
	string disasm_src_indir;
	const char *dst_name = REG_NAME[dst];

	if (!dst_name || !cpu.DisasmIndir(disasm_src_indir, Operation<CONFIG, DEBUG>::GetAddr() / 4, mod, ar, disp)) 
		return false;

	os << "OR " << disasm_src_indir << ", " << dst_name;
	return true;
}

OR_imm.disasm = {
	const char *dst_name = REG_NAME[dst];

	if (!dst_name)
		return false;

	os << "OR " << imm << ", " << dst_name;
	return true;
}

OR_reg.execute = {
	// Check that source and destination registers are valid
	if(unlikely(!cpu.HasReg(src) || !cpu.HasReg(dst)))
	{
		throw BogusOpcodeException<CONFIG, DEBUG>(this);
	}

	// Read source operand
	uint32_t src_value = cpu.GetReg(src);

	// Read destination operand
	uint32_t dst_value = cpu.GetReg(dst);

	// Compute the result
	uint32_t result = src_value | dst_value;
	uint8_t sign = (int32_t) result < 0;

	// Write back result
	cpu.SetReg(dst, result);

	// Check whether destination operand is an extended precision register
	if(cpu.IsExtReg(dst))
	{
		// Generate flags (into ST)
		cpu.GenFlags(
			result,
			M_ST_UF | M_ST_N | M_ST_Z | M_ST_V,  // reset mask
			M_ST_N | M_ST_Z,    // or mask
			sign
		);
	}
}

OR_dir.execute = {
	// Check that destination register is valid
	if(unlikely(!cpu.HasReg(dst)))
	{
		throw BogusOpcodeException<CONFIG, DEBUG>(this);
	}

	// Read destination operand
	uint32_t dst_value = cpu.GetReg(dst);

	// Compute the source operand effective address
	typename CONFIG::address_t ea = cpu.ComputeDirEA(direct);

	// Read the source operand from memory
	uint32_t src_value = cpu.IntLoad(ea);

	// Compute the result
	uint32_t result = src_value | dst_value;
	uint8_t sign = (int32_t) result < 0;

	// Write back result
	cpu.SetReg(dst, result);

	// Check whether destination operand is an extended precision register
	if(cpu.IsExtReg(dst))
	{
		// Generate flags (into ST)
		cpu.GenFlags(
			result,
			M_ST_UF | M_ST_N | M_ST_Z | M_ST_V,  // reset mask
			M_ST_N | M_ST_Z,    // or mask
			sign
		);
	}
}

OR_indir.execute = {
	// Check that destination register is valid
	if(unlikely(!cpu.HasReg(dst)))
	{
		throw BogusOpcodeException<CONFIG, DEBUG>(this);
	}

	// Check that indirect addressing mode is valid and compute the effective address of the source operand
	typename CONFIG::address_t ea;        // The effective address
	bool update_ar;                       // Whether to update ARn
	typename CONFIG::address_t output_ar; // New value of ARn if it is updated

	if(unlikely(!cpu.ComputeIndirEA(ea, update_ar, output_ar, mod, ar, disp)))
	{
		throw BogusOpcodeException<CONFIG, DEBUG>(this);
	}

	if(update_ar)
	{
		// Write back ARn
		cpu.SetAR23_0(ar, output_ar);
	}

	// Read destination operand
	uint32_t dst_value = cpu.GetReg(dst);

	// Read the source operand from memory
	uint32_t src_value = cpu.IntLoad(ea);

	// Compute the result
	uint32_t result = src_value | dst_value;
	uint8_t sign = (int32_t) result < 0;

	// Write back result
	cpu.SetReg(dst, result);

	// Check whether destination operand is an extended precision register
	if(cpu.IsExtReg(dst))
	{
		// Generate flags (into ST)
		cpu.GenFlags(
			result,
			M_ST_UF | M_ST_N | M_ST_Z | M_ST_V,  // reset mask
			M_ST_N | M_ST_Z,    // or mask
			sign
		);
	}
}

OR_imm.execute = {
	// Check that destination register is valid
	if(unlikely(!cpu.HasReg(dst)))
	{
		throw BogusOpcodeException<CONFIG, DEBUG>(this);
	}

	// Read destination operand
	uint32_t dst_value = cpu.GetReg(dst);

	// Compute the result
	uint32_t result = imm | dst_value;
	uint8_t sign = (int32_t) result < 0;

	// Write back result
	cpu.SetReg(dst, result);

	// Check whether destination operand is an extended precision register
	if(cpu.IsExtReg(dst))
	{
		// Generate flags (into ST)
		cpu.GenFlags(
			result,
			M_ST_UF | M_ST_N | M_ST_Z | M_ST_V,  // reset mask
			M_ST_N | M_ST_Z,    // or mask
			sign
		);
	}
}

/* end of OR (bitwise-logical OR)
 **********************************************************/

/**********************************************************
 * RND (round floating-point value)
 * op RND(0b000[3]:0b100010[6]:g[2]:dst[5]:src[16])
 */

op RND_reg  (0b000[3]:0b100010[6]:0b00[2]:dst[5]:0[11]:src[5])
op RND_dir  (0b000[3]:0b100010[6]:0b01[2]:dst[5]:direct[16])
op RND_indir(0b000[3]:0b100010[6]:0b10[2]:dst[5]:mod[5]:ar[3]:disp[8])
op RND_imm  (0b000[3]:0b100010[6]:0b11[2]:dst[5]:sext<32> imm[16])

RND_reg.disasm = {
	const char *dst_name = REG_NAME[dst];
	const char *src_name = REG_NAME[src];
	
	if (!dst_name || !src_name)
		return false;
	
	os << "RND " << src_name << ", " << dst_name;
	return true;
}

RND_dir.disasm = {
	const char *dst_name = REG_NAME[dst];

	if(!dst_name)
		return false;
	
	os << "RND " << hex << cpu.DisasmDir(Operation<CONFIG, DEBUG>::GetAddr() / 4, direct) << dec << ", " << dst_name;
	
	return true;
}

RND_indir.disasm = {
	string disasm_src_indir;
	const char *dst_name = REG_NAME[dst];

	if (!dst_name || !cpu.DisasmIndir(disasm_src_indir, Operation<CONFIG, DEBUG>::GetAddr() / 4, mod, ar, disp)) 
		return false;

	os << "RND " << disasm_src_indir << ", " << dst_name;
	return true;
}

RND_imm.disasm = {
	const char *dst_name = REG_NAME[dst];

	if (!dst_name)
		return false;

	os << "RND " << imm << ", " << dst_name;
	return true;
}

RND_reg.execute = {
	// Check that destination and source registers are valid
	if (likely(!cpu.EnableFloatOpsWithNonExtRegs())) {
		if (unlikely(!cpu.IsExtReg(dst) || !cpu.IsExtReg(src)))
			throw BogusOpcodeException<CONFIG, DEBUG>(this);
	} 
	else
	{
		if(unlikely(!cpu.HasReg(dst) || !cpu.HasReg(src)))
			throw BogusOpcodeException<CONFIG, DEBUG>(this);
	}

	// get source register
	Register& src_reg = cpu.GetExtReg(src);
	
	// get destination register
	Register& dst_reg = cpu.GetExtReg(dst);
	
	if (unlikely(!cpu.IsExtReg(src)))
	{
		src_reg.SetHiWriteMask(0, (uint8_t)0x10);
		if (unlikely(!cpu.IsExtReg(dst)))
			dst_reg.SetHiWriteMask(0, (uint8_t)0x10);
	}
	else
		if (unlikely(!cpu.IsExtReg(dst)))
			dst_reg.SetHiWriteMask(0, (uint8_t)0);

	// compute
	uint32_t underflow;
	uint32_t overflow;
	uint32_t neg;
	dst_reg.Rndf(src_reg, overflow, underflow, neg);
	
	// Generate flags (into ST)
	// the documentation says that the rnd instruction doesn't touch the Z flag
	//   however the real hardware systematically sets Z to 0. We consider it
	//   a bug. The simulator user can chose the behavior to use using the 
	//   enable-rnd-bug parameter.
	if (likely(cpu.IsExtReg(dst)))
	{
		if (cpu.EnableRndBug())
			cpu.GenFlags(dst_reg,
				 M_ST_Z | M_ST_UF | M_ST_N | M_ST_V,  // reset mask
				 M_ST_LUF | M_ST_LV | M_ST_UF | M_ST_N | M_ST_V,  // or mask
				 overflow, underflow, neg
				 );
		else
			cpu.GenFlags(dst_reg,
				 M_ST_UF | M_ST_N | M_ST_V,  // reset mask
				 M_ST_LUF | M_ST_LV | M_ST_UF | M_ST_N | M_ST_V,  // or mask
				 overflow, underflow, neg
				 );
	}
}

RND_dir.execute = {
	// Check that destination register is valid
	if (likely(!cpu.EnableFloatOpsWithNonExtRegs()))
	{
		if (unlikely(!cpu.IsExtReg(dst)))
			throw BogusOpcodeException<CONFIG, DEBUG>(this);
	}
	else
	{
		if (unlikely(!cpu.HasReg(dst)))
			throw BogusOpcodeException<CONFIG, DEBUG>(this);
	}
	
	// get destination register
	Register& dst_reg = cpu.GetExtReg(dst);
	if (unlikely(!cpu.IsExtReg(dst)))
		dst_reg.SetHiWriteMask(0, (uint8_t)0);
	
	// Compute the source operand effective address
	typename CONFIG::address_t ea = cpu.ComputeDirEA(direct);
	
	// Read the source operand from memory
	uint32_t src_value = cpu.IntLoad(ea);
	
	// compute
	uint32_t underflow;
	uint32_t overflow;
	uint32_t neg;
	dst_reg.Rndf32(src_value, overflow, underflow, neg);
	
	// Generate flags (into ST)
	// the documentation says that the rnd instruction doesn't touch the Z flag
	//   however the real hardware systematically sets Z to 0. We consider it
	//   a bug. The simulator user can chose the behavior to use using the 
	//   enable-rnd-bug parameter.
	if (likely(cpu.IsExtReg(dst)))
	{
		if (cpu.EnableRndBug())
			cpu.GenFlags(dst_reg,
				 M_ST_Z | M_ST_UF | M_ST_N | M_ST_V,  // reset mask
				 M_ST_LUF | M_ST_LV | M_ST_UF | M_ST_N | M_ST_V,  // or mask
				 overflow, underflow, neg
				 );
		else
			cpu.GenFlags(dst_reg,
				 M_ST_UF | M_ST_N | M_ST_V,  // reset mask
				 M_ST_LUF | M_ST_LV | M_ST_UF | M_ST_N | M_ST_V,  // or mask
				 overflow, underflow, neg
				 );
	}
}

RND_indir.execute = {
	// Check that destination register is valid
	if (likely(!cpu.EnableFloatOpsWithNonExtRegs()))
	{
		if (unlikely(!cpu.IsExtReg(dst)))
			throw BogusOpcodeException<CONFIG, DEBUG>(this);
	}
	else
	{
		if (unlikely(!cpu.HasReg(dst)))
			throw BogusOpcodeException<CONFIG, DEBUG>(this);
	}
	
	// Check that indirect addressing mode is valid and compute the effective address of the source operand
	typename CONFIG::address_t ea;        // The effective address
	bool update_ar;                       // Whether to update ARn
	typename CONFIG::address_t output_ar; // New value of ARn if it is updated
	
	if(unlikely(!cpu.ComputeIndirEA(ea, update_ar, output_ar, mod, ar, disp)))
	{
		throw BogusOpcodeException<CONFIG, DEBUG>(this);
	}
	
	if(update_ar)
	{
		// Write back ARn
		cpu.SetAR23_0(ar, output_ar);
	}
	
	// get destination register
	Register& dst_reg = cpu.GetExtReg(dst);
	if (unlikely(!cpu.IsExtReg(dst)))
		dst_reg.SetHiWriteMask(0, (uint8_t)0x08);

	// Read the source operand from memory
	uint32_t src_value = cpu.IntLoad(ea);
	
	// compute
	uint32_t underflow;
	uint32_t overflow;
	uint32_t neg;
	dst_reg.Rndf32(src_value, overflow, underflow, neg);
	
	// Generate flags (into ST)
	// the documentation says that the rnd instruction doesn't touch the Z flag
	//   however the real hardware systematically sets Z to 0. We consider it
	//   a bug. The simulator user can chose the behavior to use using the 
	//   enable-rnd-bug parameter.
	if (likely(cpu.IsExtReg(dst)))
	{
		if (cpu.EnableRndBug())
			cpu.GenFlags(dst_reg,
				 M_ST_Z | M_ST_UF | M_ST_N | M_ST_V,  // reset mask
				 M_ST_LUF | M_ST_LV | M_ST_UF | M_ST_N | M_ST_V,  // or mask
				 overflow, underflow, neg
				 );
		else
			cpu.GenFlags(dst_reg,
				 M_ST_UF | M_ST_N | M_ST_V,  // reset mask
				 M_ST_LUF | M_ST_LV | M_ST_UF | M_ST_N | M_ST_V,  // or mask
				 overflow, underflow, neg
				 );
	}
}

RND_imm.execute = {
	// Check that destination register is valid
	if (likely(!cpu.EnableFloatOpsWithNonExtRegs()))
	{
		if (unlikely(!cpu.IsExtReg(dst)))
			throw BogusOpcodeException<CONFIG, DEBUG>(this);
	}
	else
	{
		if (unlikely(!cpu.HasReg(dst)))
			throw BogusOpcodeException<CONFIG, DEBUG>(this);
	}
	
	// get destination register
	Register& dst_reg = cpu.GetExtReg(dst);
	if (unlikely(!cpu.IsExtReg(dst)))
		dst_reg.SetHiWriteMask(0, (uint8_t)0x10);

	// compute
	uint32_t underflow;
	uint32_t overflow;
	uint32_t neg;
	dst_reg.Rndf16((uint16_t)imm, overflow, underflow, neg);
	
	// Generate flags (into ST)
	// the documentation says that the rnd instruction doesn't touch the Z flag
	//   however the real hardware systematically sets Z to 0. We consider it
	//   a bug. The simulator user can chose the behavior to use using the 
	//   enable-rnd-bug parameter.
	if (likely(cpu.IsExtReg(dst)))
	{
		if (cpu.EnableRndBug())
			cpu.GenFlags(dst_reg,
				 M_ST_Z | M_ST_UF | M_ST_N | M_ST_V,  // reset mask
				 M_ST_LUF | M_ST_LV | M_ST_UF | M_ST_N | M_ST_V,  // or mask
				 overflow, underflow, neg
				 );
		else
			cpu.GenFlags(dst_reg,
				 M_ST_UF | M_ST_N | M_ST_V,  // reset mask
				 M_ST_LUF | M_ST_LV | M_ST_UF | M_ST_N | M_ST_V,  // or mask
				 overflow, underflow, neg
				 );
	}
}

/* end of RND (round floating-point value)
 **********************************************************/

/**********************************************************
 * ROL (rotate left)
 * op ROL(0b000[3]:0b100011[6]:0b11[2]:dst[5]:0b0000000000000001[16])
 */

op ROL(0b000[3]:0b100011[6]:0b11[2]:dst[5]:0b0000000000000001[16])

ROL.disasm = {
	const char *dst_name = REG_NAME[dst];

	if (!dst_name)
		return false;

	os << "ROL " << dst_name;
	return true;
}

ROL.execute = {
	// Check whether the destination register is valid
	if(unlikely(!cpu.HasReg(dst)))
	{
		throw BogusOpcodeException<CONFIG, DEBUG>(this);
	}

	// Read the destination operand
	uint32_t dst_value = cpu.GetReg(dst);

	// Compute the result
	uint8_t carry_out;
	uint32_t result = RotateLeft(dst_value, 1, carry_out);
	uint8_t sign = (int32_t) result < 0;

	// Write back result
	cpu.SetReg(dst, result);

	// Check whether destination operand is an extended precision register
	if(cpu.IsExtReg(dst))
	{
		// Generate flags (into ST)
		cpu.GenFlags(
			result,
			M_ST_UF | M_ST_N | M_ST_Z | M_ST_V | M_ST_C,  // reset mask
			M_ST_N | M_ST_Z | M_ST_C,  // or mask
			sign,
			carry_out
		);
	}
}

/* end of ROL (rotate left)
 **********************************************************/

/**********************************************************
 * ROLC (rotate left through carry)
 * op ROLC(0b000[3]:0b100100[6]:0b11[2]:dst[5]:0b0000000000000001[16])
 */

op ROLC(0b000[3]:0b100100[6]:0b11[2]:dst[5]:0b0000000000000001[16])

ROLC.disasm = {
	const char *dst_name = REG_NAME[dst];

	if (!dst_name)
		return false;
	
	os << "ROLC " << dst_name;
	return true;
}

ROLC.execute = {
	// Check whether the destination register is valid
	if(unlikely(!cpu.HasReg(dst)))
	{
		throw BogusOpcodeException<CONFIG, DEBUG>(this);
	}

	// Read the destination operand
	uint32_t dst_value = cpu.GetReg(dst);

	// Read carry in
	uint8_t carry_in = cpu.GetST_C();

	// Compute the result
	uint8_t carry_out;
	uint32_t result = RotateLeft(dst_value, 1, carry_in, carry_out);
	uint8_t sign = (int32_t) result < 0;

	// Write back result
	cpu.SetReg(dst, result);

	// Check whether destination operand is an extended precision register
	if(cpu.IsExtReg(dst))
	{
		// Generate flags (into ST)
		cpu.GenFlags(
			result,
			M_ST_UF | M_ST_N | M_ST_Z | M_ST_V | M_ST_C,  // reset mask
			M_ST_N | M_ST_Z | M_ST_C,  // or mask
			sign,
			carry_out
		);
	}
}

/* end of ROLC (rotate left through carry)
 **********************************************************/

/**********************************************************
 * ROR (rotate right)
 * op ROR(0b000[3]:0b100101[6]:0b11[2]:dst[5]:0b1111111111111111[16])
 */

op ROR(0b000[3]:0b100101[6]:0b11[2]:dst[5]:0b1111111111111111[16])

ROR.disasm = {
	const char *dst_name = REG_NAME[dst];

	if (!dst_name)
		return false;
	
	os << "ROR " << dst_name;
	return true;
}

ROR.execute = {
	// Check whether the destination register is valid
	if(unlikely(!cpu.HasReg(dst)))
	{
		throw BogusOpcodeException<CONFIG, DEBUG>(this);
	}

	// Read the destination operand
	uint32_t dst_value = cpu.GetReg(dst);

	// Compute the result
	uint8_t carry_out;
	uint32_t result = RotateRight(dst_value, 1, carry_out);
	uint8_t sign = (int32_t) result < 0;

	// Write back result
	cpu.SetReg(dst, result);

	// Check whether destination operand is an extended precision register
	if(cpu.IsExtReg(dst))
	{
		// Generate flags (into ST)
		cpu.GenFlags(
			result,
			M_ST_UF | M_ST_N | M_ST_Z | M_ST_V | M_ST_C,  // reset mask
			M_ST_N | M_ST_Z | M_ST_C,  // or mask
			sign,
			carry_out
		);
	}
}

/* end of ROR (rotate right)
 **********************************************************/

/**********************************************************
 * RORC (rotate right through carry)
 * op RORC(0b000[3]:0b100110[6]:0b11[2]:dst[5]:0b1111111111111111[16])
 */

op RORC(0b000[3]:0b100110[6]:0b11[2]:dst[5]:0b1111111111111111[16])

RORC.disasm = {
	const char *dst_name = REG_NAME[dst];

	if (!dst_name)
		return false;
	
	os << "RORC " << dst_name;
	return true;
}

RORC.execute = {
	// Check whether the destination register is valid
	if(unlikely(!cpu.HasReg(dst)))
	{
		throw BogusOpcodeException<CONFIG, DEBUG>(this);
	}

	// Read the destination operand
	uint32_t dst_value = cpu.GetReg(dst);

	// Read carry in
	uint8_t carry_in = cpu.GetST_C();

	// Compute the result
	uint8_t carry_out;
	uint32_t result = RotateRight(dst_value, 1, carry_in, carry_out);
	uint8_t sign = (int32_t) result < 0;

	// Write back result
	cpu.SetReg(dst, result);

	// Check whether destination operand is an extended precision register
	if(cpu.IsExtReg(dst))
	{
		// Generate flags (into ST)
		cpu.GenFlags(
			result,
			M_ST_UF | M_ST_N | M_ST_Z | M_ST_V | M_ST_C,  // reset mask
			M_ST_N | M_ST_Z | M_ST_C,  // or mask
			sign,
			carry_out
		);
	}
}

/* end of RORC (rotate right through carry)
 **********************************************************/

/**********************************************************
 * SUBB (subtract integers with borrow)
 * op SUBB(0b000[3]:0b101101[6]:g[2]:dst[5]:src[16])
 */

op SUBB_reg  (0b000[3]:0b101101[6]:0b00[2]:dst[5]:0[11]:src[5])
op SUBB_dir  (0b000[3]:0b101101[6]:0b01[2]:dst[5]:direct[16])
op SUBB_indir(0b000[3]:0b101101[6]:0b10[2]:dst[5]:mod[5]:ar[3]:disp[8])
op SUBB_imm  (0b000[3]:0b101101[6]:0b11[2]:dst[5]:sext<32> imm[16])

SUBB_reg.disasm = {
	const char *dst_name = REG_NAME[dst];
	const char *src_name = REG_NAME[src];
	
	if (!dst_name || !src_name)
		return false;
	
	os << "SUBB " << src_name << ", " << dst_name;
	return true;
}

SUBB_dir.disasm = {
	const char *dst_name = REG_NAME[dst];

	if(!dst_name)
		return false;
	
	os << "SUBB " << hex << cpu.DisasmDir(Operation<CONFIG, DEBUG>::GetAddr() / 4, direct) << dec << ", " << dst_name;
	
	return true;
}

SUBB_indir.disasm = {
	string disasm_src_indir;
	const char *dst_name = REG_NAME[dst];

	if (!dst_name || !cpu.DisasmIndir(disasm_src_indir, Operation<CONFIG, DEBUG>::GetAddr() / 4, mod, ar, disp)) 
		return false;

	os << "SUBB " << disasm_src_indir << ", " << dst_name;

	return true;
}

SUBB_imm.disasm = {
	const char *dst_name = REG_NAME[dst];

	if (!dst_name)
		return false;

	os << "SUBB " << imm << ", " << dst_name;
	return true;
}

SUBB_reg.execute = {
	// Check that source and destination registers are valid
	if(unlikely(!cpu.HasReg(src) || !cpu.HasReg(dst)))
	{
		throw BogusOpcodeException<CONFIG, DEBUG>(this);
	}

	// Read source operand
	uint32_t src_value = cpu.GetReg(src);

	// Read destination operand
	uint32_t dst_value = cpu.GetReg(dst);

	// Read borrow in
	uint8_t borrow_in = cpu.GetST_C();

	// Compute the result
	uint32_t result;      // the 32-bit result
	uint8_t borrow_out;   // the borrow out (0 or 1)
	uint8_t overflow;     // the overflow (0 or 1)
	uint8_t sign;         // the sign (0 or 1)

	// Depending on overflow mode do signed saturation or not 
	if(cpu.GetST_OVM())
	{
		SignedSatSub32(result, borrow_out, overflow, sign, dst_value, src_value, borrow_in);
	}
	else
	{
		SignedSub32(result, borrow_out, overflow, sign, dst_value, src_value, borrow_in);
		sign = sign ^ overflow;
	}

	// Write back result
	cpu.SetReg(dst, result);

	// Check whether destination operand is an extended precision register
	if(cpu.IsExtReg(dst))
	{
		// Generate flags (into ST)
		cpu.GenFlags(
			result,
			M_ST_UF | M_ST_N | M_ST_Z | M_ST_V | M_ST_C,  // reset mask
			M_ST_LV | M_ST_N | M_ST_Z | M_ST_V | M_ST_C,  // or mask
			sign,
			borrow_out,
			overflow
		);
	}
}

SUBB_dir.execute = {
	// Check that destination register is valid
	if(unlikely(!cpu.HasReg(dst)))
	{
		throw BogusOpcodeException<CONFIG, DEBUG>(this);
	}

	// Read destination operand
	uint32_t dst_value = cpu.GetReg(dst);

	// Compute the source operand effective address
	typename CONFIG::address_t ea = cpu.ComputeDirEA(direct);

	// Read the source operand from memory
	uint32_t src_value = cpu.IntLoad(ea);

	// Read borrow in
	uint8_t borrow_in = cpu.GetST_C();

	// Compute the result
	uint32_t result;      // the 32-bit result
	uint8_t borrow_out;   // the borrow out (0 or 1)
	uint8_t overflow;     // the overflow (0 or 1)
	uint8_t sign;         // the sign (0 or 1)

	// Depending on overflow mode do signed saturation or not 
	if(cpu.GetST_OVM())
	{
		SignedSatSub32(result, borrow_out, overflow, sign, dst_value, src_value, borrow_in);
	}
	else
	{
		SignedSub32(result, borrow_out, overflow, sign, dst_value, src_value, borrow_in);
		sign = sign ^ overflow;
	}

	// Write back result
	cpu.SetReg(dst, result);

	// Check whether destination operand is an extended precision register
	if(cpu.IsExtReg(dst))
	{
		// Generate flags (into ST)
		cpu.GenFlags(
			result,
			M_ST_UF | M_ST_N | M_ST_Z | M_ST_V | M_ST_C,  // reset mask
			M_ST_LV | M_ST_N | M_ST_Z | M_ST_V | M_ST_C,  // or mask
			sign,
			borrow_out,
			overflow
		);
	}
}

SUBB_indir.execute = {
	// Check that destination register is valid
	if(unlikely(!cpu.HasReg(dst)))
	{
		throw BogusOpcodeException<CONFIG, DEBUG>(this);
	}

	// Check that indirect addressing mode is valid and compute the effective address of the source operand
	typename CONFIG::address_t ea;        // The effective address
	bool update_ar;                       // Whether to update ARn
	typename CONFIG::address_t output_ar; // New value of ARn if it is updated

	if(unlikely(!cpu.ComputeIndirEA(ea, update_ar, output_ar, mod, ar, disp)))
	{
		throw BogusOpcodeException<CONFIG, DEBUG>(this);
	}

	if(update_ar)
	{
		// Write back ARn
		cpu.SetAR23_0(ar, output_ar);
	}

	// Read destination operand
	uint32_t dst_value = cpu.GetReg(dst);

	// Read the source operand from memory
	uint32_t src_value = cpu.IntLoad(ea);

	// Read borrow in
	uint8_t borrow_in = cpu.GetST_C();

	// Compute the result
	uint32_t result;      // the 32-bit result
	uint8_t borrow_out;   // the borrow out (0 or 1)
	uint8_t overflow;     // the overflow (0 or 1)
	uint8_t sign;         // the sign (0 or 1)

	// Depending on overflow mode do signed saturation or not 
	if(cpu.GetST_OVM())
	{
		SignedSatSub32(result, borrow_out, overflow, sign, dst_value, src_value, borrow_in);
	}
	else
	{
		SignedSub32(result, borrow_out, overflow, sign, dst_value, src_value, borrow_in);
		sign = sign ^ overflow;
	}

	// Write back result
	cpu.SetReg(dst, result);

	// Check whether destination operand is an extended precision register
	if(cpu.IsExtReg(dst))
	{
		// Generate flags (into ST)
		cpu.GenFlags(
			result,
			M_ST_UF | M_ST_N | M_ST_Z | M_ST_V | M_ST_C,  // reset mask
			M_ST_LV | M_ST_N | M_ST_Z | M_ST_V | M_ST_C,  // or mask
			sign,
			borrow_out,
			overflow
		);
	}
}

SUBB_imm.execute = {
	// Check that destination register is valid
	if(unlikely(!cpu.HasReg(dst)))
	{
		throw BogusOpcodeException<CONFIG, DEBUG>(this);
	}

	// Read destination operand
	uint32_t dst_value = cpu.GetReg(dst);

	// Read borrow in
	uint8_t borrow_in = cpu.GetST_C();

	// Compute the result
	uint32_t result;      // the 32-bit result
	uint8_t borrow_out;   // the borrow out (0 or 1)
	uint8_t overflow;     // the overflow (0 or 1)
	uint8_t sign;         // the sign (0 or 1)

	// Depending on overflow mode do signed saturation or not 
	if(cpu.GetST_OVM())
	{
		SignedSatSub32(result, borrow_out, overflow, sign, dst_value, imm, borrow_in);
	}
	else
	{
		SignedSub32(result, borrow_out, overflow, sign, dst_value, imm, borrow_in);
		sign = sign ^ overflow;
	}

	// Write back result
	cpu.SetReg(dst, result);

	// Check whether destination operand is an extended precision register
	if(cpu.IsExtReg(dst))
	{
		// Generate flags (into ST)
		cpu.GenFlags(
			result,
			M_ST_UF | M_ST_N | M_ST_Z | M_ST_V | M_ST_C,  // reset mask
			M_ST_LV | M_ST_N | M_ST_Z | M_ST_V | M_ST_C,  // or mask
			sign,
			borrow_out,
			overflow
		);
	}
}

/* end of SUBB (subtract integers with borrow)
 **********************************************************/

/**********************************************************
 * SUBC (subtract integers conditionally)
 * op SUBC(0b000[3]:0b101110[6]:g[2]:dst[5]:src[16])
 */

op SUBC_reg  (0b000[3]:0b101110[6]:0b00[2]:dst[5]:0[11]:src[5])
op SUBC_dir  (0b000[3]:0b101110[6]:0b01[2]:dst[5]:direct[16])
op SUBC_indir(0b000[3]:0b101110[6]:0b10[2]:dst[5]:mod[5]:ar[3]:disp[8])
op SUBC_imm  (0b000[3]:0b101110[6]:0b11[2]:dst[5]:<32> imm[16])

SUBC_reg.disasm = {
	const char *dst_name = REG_NAME[dst];
	const char *src_name = REG_NAME[src];
	
	if (!dst_name || !src_name)
		return false;
	
	os << "SUBC " << src_name << ", " << dst_name;
	return true;
}

SUBC_dir.disasm = {
	const char *dst_name = REG_NAME[dst];

	if(!dst_name)
		return false;
	
	os << "SUBC " << hex << cpu.DisasmDir(Operation<CONFIG, DEBUG>::GetAddr() / 4, direct) << dec << ", " << dst_name;
	
	return true;
}

SUBC_indir.disasm = {
	string disasm_src_indir;
	const char *dst_name = REG_NAME[dst];

	if (!dst_name || !cpu.DisasmIndir(disasm_src_indir, Operation<CONFIG, DEBUG>::GetAddr() / 4, mod, ar, disp)) 
		return false;

	os << "SUBC " << disasm_src_indir << ", " << dst_name;
	return true;
}

SUBC_imm.disasm = {
	const char *dst_name = REG_NAME[dst];

	if (!dst_name)
		return false;

	os << "SUBC " << imm << ", " << dst_name;
	return true;
}

SUBC_reg.execute = {
	// Check that source and destination registers are valid
	if(unlikely(!cpu.HasReg(src) || !cpu.HasReg(dst)))
	{
		throw BogusOpcodeException<CONFIG, DEBUG>(this);
	}

	// Read source operand
	uint32_t src_value = cpu.GetReg(src);

	// Read destination operand
	uint32_t dst_value = cpu.GetReg(dst);

	// Compute the result
	uint32_t result;
	if(dst_value >= src_value)
		result = ((dst_value - src_value) << 1) | 1;
	else
		result = dst_value << 1;

	// Write back result
	cpu.SetReg(dst, result);
}

SUBC_dir.execute = {
	// Check that destination register is valid
	if(unlikely(!cpu.HasReg(dst)))
	{
		throw BogusOpcodeException<CONFIG, DEBUG>(this);
	}

	// Read destination operand
	uint32_t dst_value = cpu.GetReg(dst);

	// Compute the source operand effective address
	typename CONFIG::address_t ea = cpu.ComputeDirEA(direct);

	// Read the source operand from memory
	uint32_t src_value = cpu.IntLoad(ea);

	// Compute the result
	uint32_t result;
	if(dst_value >= src_value)
		result = ((dst_value - src_value) << 1) | 1;
	else
		result = dst_value << 1;

	// Write back result
	cpu.SetReg(dst, result);
}

SUBC_indir.execute = {
	// Check that destination register is valid
	if(unlikely(!cpu.HasReg(dst)))
	{
		throw BogusOpcodeException<CONFIG, DEBUG>(this);
	}

	// Check that indirect addressing mode is valid and compute the effective address of the source operand
	typename CONFIG::address_t ea;        // The effective address
	bool update_ar;                       // Whether to update ARn
	typename CONFIG::address_t output_ar; // New value of ARn if it is updated

	if(unlikely(!cpu.ComputeIndirEA(ea, update_ar, output_ar, mod, ar, disp)))
	{
		throw BogusOpcodeException<CONFIG, DEBUG>(this);
	}

	if(update_ar)
	{
		// Write back ARn
		cpu.SetAR23_0(ar, output_ar);
	}

	// Read destination operand
	uint32_t dst_value = cpu.GetReg(dst);

	// Read the source operand from memory
	uint32_t src_value = cpu.IntLoad(ea);

	// Compute the result
	uint32_t result;
	if(dst_value >= src_value)
		result = ((dst_value - src_value) << 1) | 1;
	else
		result = dst_value << 1;
	
	// Write back result
	cpu.SetReg(dst, result);
}

SUBC_imm.execute = {
	// Check that destination register is valid
	if(unlikely(!cpu.HasReg(dst)))
	{
		throw BogusOpcodeException<CONFIG, DEBUG>(this);
	}

	// Read destination operand
	uint32_t dst_value = cpu.GetReg(dst);

	// Compute the result
	uint32_t result;
	if(dst_value >= (uint32_t) imm)
		result = ((dst_value - (uint32_t) imm) << 1) | 1;
	else
		result = dst_value << 1;
	
	// Write back result
	cpu.SetReg(dst, result);
}

/* end of SUBC (subtract integers conditionally)
 **********************************************************/

/**********************************************************
 * SUBF (subtract floating-point values)
 * op SUBF(0b000[3]:0b101111[6]:g[2]:dst[5]:src[16])
 */

op SUBF_reg  (0b000[3]:0b101111[6]:0b00[2]:dst[5]:0[11]:src[5])
op SUBF_dir  (0b000[3]:0b101111[6]:0b01[2]:dst[5]:direct[16])
op SUBF_indir(0b000[3]:0b101111[6]:0b10[2]:dst[5]:mod[5]:ar[3]:disp[8])
op SUBF_imm  (0b000[3]:0b101111[6]:0b11[2]:dst[5]:imm[16])

SUBF_reg.disasm = {
	const char *dst_name = REG_NAME[dst];
	const char *src_name = REG_NAME[src];
	
	if (!dst_name || !src_name)
		return false;
	
	os << "SUBF " << src_name << ", " << dst_name;
	return true;
}

SUBF_dir.disasm = {
	const char *dst_name = REG_NAME[dst];

	if(!dst_name)
		return false;
	
	os << "SUBF " << hex << cpu.DisasmDir(Operation<CONFIG, DEBUG>::GetAddr() / 4, direct) << dec << ", " << dst_name;
	
	return true;
}

SUBF_indir.disasm = {
	string disasm_src_indir;
	const char *dst_name = REG_NAME[dst];

	if (!dst_name || !cpu.DisasmIndir(disasm_src_indir, Operation<CONFIG, DEBUG>::GetAddr() / 4, mod, ar, disp)) 
		return false;

	os << "SUBF " << disasm_src_indir << ", " << dst_name;
	return true;
}

SUBF_imm.disasm = {
	const char *dst_name = REG_NAME[dst];

	if (!dst_name)
		return false;

	os << "SUBF " << cpu.DisasmShortFloat(imm) << ", " << dst_name;
	return true;
}

SUBF_reg.execute = {
	// Check that destination and source registers are valid
	if (likely(!cpu.EnableFloatOpsWithNonExtRegs())) {
		if (unlikely(!cpu.IsExtReg(dst) || !cpu.IsExtReg(src)))
			throw BogusOpcodeException<CONFIG, DEBUG>(this);
	} 
	else
	{
		if(unlikely(!cpu.HasReg(dst) || !cpu.HasReg(src)))
			throw BogusOpcodeException<CONFIG, DEBUG>(this);
	}

	// get source register
	Register& src_reg = cpu.GetExtReg(src);
	
	// get destination register
	Register& dst_reg = cpu.GetExtReg(dst);
	
	if (unlikely(!cpu.IsExtReg(src)))
	{
		src_reg.SetHiWriteMask(0, (uint8_t)0x8);
		if (unlikely(!cpu.IsExtReg(dst)))
			dst_reg.SetHiWriteMask(0, (uint8_t)0x8);
	}
	else
		if (unlikely(!cpu.IsExtReg(dst)))
			dst_reg.SetHiWriteMask(0, (uint8_t)0);

	// compute
	uint32_t underflow;
	uint32_t overflow;
	uint32_t neg;
	dst_reg.Subf(src_reg, overflow, underflow, neg);

	// Generate flags (into ST)
	if (likely(cpu.IsExtReg(dst)))
		cpu.GenFlags(
			dst_reg,
			M_ST_UF | M_ST_N | M_ST_Z | M_ST_V,  // reset mask
			M_ST_LUF | M_ST_LV | M_ST_UF | M_ST_N | M_ST_Z | M_ST_V,  // or mask
			overflow, underflow, neg
		);
}

SUBF_dir.execute = {
	// Check that destination register is valid
	if (likely(!cpu.EnableFloatOpsWithNonExtRegs()))
	{
		if (unlikely(!cpu.IsExtReg(dst)))
			throw BogusOpcodeException<CONFIG, DEBUG>(this);
	}
	else
	{
		if (unlikely(!cpu.HasReg(dst)))
			throw BogusOpcodeException<CONFIG, DEBUG>(this);
	}
	
	// get destination register
	Register& dst_reg = cpu.GetExtReg(dst);
	
	// Compute the source operand effective address
	typename CONFIG::address_t ea = cpu.ComputeDirEA(direct);

	// Read the source operand from memory
	uint32_t src_value = cpu.IntLoad(ea);

	if (unlikely(!cpu.IsExtReg(dst)))
	{
		Register tmp_reg;
		tmp_reg.SetFromSinglePrecisionFPFormat(src_value);
		dst_reg.SetHiWriteMask(0, tmp_reg.GetHi());
	}

	// compute
	uint32_t underflow;
	uint32_t overflow;
	uint32_t neg;
	dst_reg.Subf32(src_value, overflow, underflow, neg);

	// Generate flags (into ST)
	if (likely(cpu.IsExtReg(dst)))
		cpu.GenFlags(
			dst_reg,
			M_ST_UF | M_ST_N | M_ST_Z | M_ST_V,  // reset mask
			M_ST_LUF | M_ST_LV | M_ST_UF | M_ST_N | M_ST_Z | M_ST_V,  // or mask
			overflow, underflow, neg
		);
}

SUBF_indir.execute = {
	// Check that destination register is valid
	if (likely(!cpu.EnableFloatOpsWithNonExtRegs()))
	{
		if (unlikely(!cpu.IsExtReg(dst)))
			throw BogusOpcodeException<CONFIG, DEBUG>(this);
	}
	else
	{
		if (unlikely(!cpu.HasReg(dst)))
			throw BogusOpcodeException<CONFIG, DEBUG>(this);
	}
	
	// Check that indirect addressing mode is valid and compute the effective address of the source operand
	typename CONFIG::address_t ea;        // The effective address
	bool update_ar;                       // Whether to update ARn
	typename CONFIG::address_t output_ar; // New value of ARn if it is updated

	if(unlikely(!cpu.ComputeIndirEA(ea, update_ar, output_ar, mod, ar, disp)))
	{
		throw BogusOpcodeException<CONFIG, DEBUG>(this);
	}

	if(update_ar)
	{
		// Write back ARn
		cpu.SetAR23_0(ar, output_ar);
	}
	
	// Read the source operand from memory
	uint32_t src_value = cpu.IntLoad(ea);

	// get destination register
	Register& dst_reg = cpu.GetExtReg(dst);
	if (unlikely(!cpu.IsExtReg(dst)))
		dst_reg.SetHiWriteMask(0, (uint8_t)0x08);

	// compute
	uint32_t underflow;
	uint32_t overflow;
	uint32_t neg;
	dst_reg.Subf32(src_value, overflow, underflow, neg);

	// Generate flags (into ST)
	if (likely(cpu.IsExtReg(dst)))
		cpu.GenFlags(
			dst_reg,
			M_ST_UF | M_ST_N | M_ST_Z | M_ST_V,  // reset mask
			M_ST_LUF | M_ST_LV | M_ST_UF | M_ST_N | M_ST_Z | M_ST_V,  // or mask
			overflow, underflow, neg
		);
}

SUBF_imm.execute = {
	// Check that destination register is valid
	if (likely(!cpu.EnableFloatOpsWithNonExtRegs()))
	{
		if (unlikely(!cpu.IsExtReg(dst)))
			throw BogusOpcodeException<CONFIG, DEBUG>(this);
	}
	else
	{
		if (unlikely(!cpu.HasReg(dst)))
			throw BogusOpcodeException<CONFIG, DEBUG>(this);
	}
	
	// get destination register
	Register& dst_reg = cpu.GetExtReg(dst);
	if (unlikely(!cpu.IsExtReg(dst)))
		dst_reg.SetHiWriteMask(0, (uint8_t)0x10);
	
	// compute
	uint32_t underflow;
	uint32_t overflow;
	uint32_t neg;
	dst_reg.Subf16((uint16_t)imm, overflow, underflow, neg);

	// Generate flags (into ST)
	if (likely(cpu.IsExtReg(dst)))
		cpu.GenFlags(
			dst_reg,
			M_ST_UF | M_ST_N | M_ST_Z | M_ST_V,  // reset mask
			M_ST_LUF | M_ST_LV | M_ST_UF | M_ST_N | M_ST_Z | M_ST_V,  // or mask
			overflow, underflow, neg
		);
}

/* end of SUBF (subtract floating-point values)
 **********************************************************/

/**********************************************************
 * SUBI (subtract integer)
 * op SUBI(0b000[3]:0b110000[6]:g[2]:dst[5]:src[16])
 */

op SUBI_reg  (0b000[3]:0b110000[6]:0b00[2]:dst[5]:0[11]:src[5])
op SUBI_dir  (0b000[3]:0b110000[6]:0b01[2]:dst[5]:direct[16])
op SUBI_indir(0b000[3]:0b110000[6]:0b10[2]:dst[5]:mod[5]:ar[3]:disp[8])
op SUBI_imm  (0b000[3]:0b110000[6]:0b11[2]:dst[5]:sext<32> imm[16])

SUBI_reg.disasm = {
	const char *dst_name = REG_NAME[dst];
	const char *src_name = REG_NAME[src];
	
	if (!dst_name || !src_name)
		return false;
	
	os << "SUBI " << src_name << ", " << dst_name;
	return true;
}

SUBI_dir.disasm = {
	const char *dst_name = REG_NAME[dst];

	if(!dst_name)
		return false;
	
	os << "SUBI " << hex << cpu.DisasmDir(Operation<CONFIG, DEBUG>::GetAddr() / 4, direct) << dec << ", " << dst_name;
	
	return true;
}

SUBI_indir.disasm = {
	string disasm_src_indir;
	const char *dst_name = REG_NAME[dst];

	if (!dst_name || !cpu.DisasmIndir(disasm_src_indir, Operation<CONFIG, DEBUG>::GetAddr() / 4, mod, ar, disp)) 
		return false;

	os << "SUBI " << disasm_src_indir << ", " << dst_name;

	return true;
}

SUBI_imm.disasm = {
	const char *dst_name = REG_NAME[dst];

	if (!dst_name)
		return false;

	os << "SUBI " << imm << ", " << dst_name;
	return true;
}

SUBI_reg.execute = {
	// Check that source and destination registers are valid
	if(unlikely(!cpu.HasReg(src) || !cpu.HasReg(dst)))
	{
		throw BogusOpcodeException<CONFIG, DEBUG>(this);
	}

	// Read source operand
	uint32_t src_value = cpu.GetReg(src);

	// Read destination operand
	uint32_t dst_value = cpu.GetReg(dst);

	// Compute the result
	uint32_t result;      // the 32-bit result
	uint8_t borrow_out;   // the borrow out (0 or 1)
	uint8_t overflow;     // the overflow (0 or 1)
	uint8_t sign;         // the sign (0 or 1)

	// Depending on overflow mode do signed saturation or not 
	if(cpu.GetST_OVM())
	{
		SignedSatSub32(result, borrow_out, overflow, sign, dst_value, src_value, 0);
	}
	else
	{
		SignedSub32(result, borrow_out, overflow, sign, dst_value, src_value, 0);
		sign = sign ^ overflow;
	}

	// Write back result
	cpu.SetReg(dst, result);

	// Check whether destination operand is an extended precision register
	if(cpu.IsExtReg(dst))
	{
		// Generate flags (into ST)
		cpu.GenFlags(
			result,
			M_ST_UF | M_ST_N | M_ST_Z | M_ST_V | M_ST_C,  // reset mask
			M_ST_LV | M_ST_N | M_ST_Z | M_ST_V | M_ST_C,  // or mask
			sign,
			borrow_out,
			overflow
		);
	}
}

SUBI_dir.execute = {
	// Check that destination register is valid
	if(unlikely(!cpu.HasReg(dst)))
	{
		throw BogusOpcodeException<CONFIG, DEBUG>(this);
	}

	// Read destination operand
	uint32_t dst_value = cpu.GetReg(dst);

	// Compute the source operand effective address
	typename CONFIG::address_t ea = cpu.ComputeDirEA(direct);

	// Read the source operand from memory
	uint32_t src_value = cpu.IntLoad(ea);

	// Compute the result
	uint32_t result;      // the 32-bit result
	uint8_t borrow_out;   // the borrow out (0 or 1)
	uint8_t overflow;     // the overflow (0 or 1)
	uint8_t sign;         // the sign (0 or 1)

	// Depending on overflow mode do signed saturation or not 
	if(cpu.GetST_OVM())
	{
		SignedSatSub32(result, borrow_out, overflow, sign, dst_value, src_value, 0);
	}
	else
	{
		SignedSub32(result, borrow_out, overflow, sign, dst_value, src_value, 0);
		sign = sign ^ overflow;
	}

	// Write back result
	cpu.SetReg(dst, result);

	// Check whether destination operand is an extended precision register
	if(cpu.IsExtReg(dst))
	{
		// Generate flags (into ST)
		cpu.GenFlags(
			result,
			M_ST_UF | M_ST_N | M_ST_Z | M_ST_V | M_ST_C,  // reset mask
			M_ST_LV | M_ST_N | M_ST_Z | M_ST_V | M_ST_C,  // or mask
			sign,
			borrow_out,
			overflow
		);
	}
}

SUBI_indir.execute = {
	// Check that destination register is valid
	if(unlikely(!cpu.HasReg(dst)))
	{
		throw BogusOpcodeException<CONFIG, DEBUG>(this);
	}

	// Check that indirect addressing mode is valid and compute the effective address of the source operand
	typename CONFIG::address_t ea;        // The effective address
	bool update_ar;                       // Whether to update ARn
	typename CONFIG::address_t output_ar; // New value of ARn if it is updated

	if(unlikely(!cpu.ComputeIndirEA(ea, update_ar, output_ar, mod, ar, disp)))
	{
		throw BogusOpcodeException<CONFIG, DEBUG>(this);
	}

	if(update_ar)
	{
		// Write back ARn
		cpu.SetAR23_0(ar, output_ar);
	}

	// Read destination operand
	uint32_t dst_value = cpu.GetReg(dst);

	// Read the source operand from memory
	uint32_t src_value = cpu.IntLoad(ea);

	// Compute the result
	uint32_t result;      // the 32-bit result
	uint8_t borrow_out;   // the borrow out (0 or 1)
	uint8_t overflow;     // the overflow (0 or 1)
	uint8_t sign;         // the sign (0 or 1)

	// Depending on overflow mode do signed saturation or not 
	if(cpu.GetST_OVM())
	{
		SignedSatSub32(result, borrow_out, overflow, sign, dst_value, src_value, 0);
	}
	else
	{
		SignedSub32(result, borrow_out, overflow, sign, dst_value, src_value, 0);
		sign = sign ^ overflow;
	}

	// Write back result
	cpu.SetReg(dst, result);

	// Check whether destination operand is an extended precision register
	if(cpu.IsExtReg(dst))
	{
		// Generate flags (into ST)
		cpu.GenFlags(
			result,
			M_ST_UF | M_ST_N | M_ST_Z | M_ST_V | M_ST_C,  // reset mask
			M_ST_LV | M_ST_N | M_ST_Z | M_ST_V | M_ST_C,  // or mask
			sign,
			borrow_out,
			overflow
		);
	}
}

SUBI_imm.execute = {
	// Check that destination register is valid
	if(unlikely(!cpu.HasReg(dst)))
	{
		throw BogusOpcodeException<CONFIG, DEBUG>(this);
	}

	// Read destination operand
	uint32_t dst_value = cpu.GetReg(dst);

	// Compute the result
	uint32_t result;      // the 32-bit result
	uint8_t borrow_out;   // the borrow out (0 or 1)
	uint8_t overflow;     // the overflow (0 or 1)
	uint8_t sign;         // the sign (0 or 1)

	// Depending on overflow mode do signed saturation or not 
	if(cpu.GetST_OVM())
	{
		SignedSatSub32(result, borrow_out, overflow, sign, dst_value, imm, 0);
	}
	else
	{
		SignedSub32(result, borrow_out, overflow, sign, dst_value, imm, 0);
		sign = sign ^ overflow;
	}

	// Write back result
	cpu.SetReg(dst, result);

	// Check whether destination operand is an extended precision register
	if(cpu.IsExtReg(dst))
	{
		// Generate flags (into ST)
		cpu.GenFlags(
			result,
			M_ST_UF | M_ST_N | M_ST_Z | M_ST_V | M_ST_C,  // reset mask
			M_ST_LV | M_ST_N | M_ST_Z | M_ST_V | M_ST_C,  // or mask
			sign,
			borrow_out,
			overflow
		);
	}
}

/* end of SUBI (subtract integer)
 **********************************************************/

/**********************************************************
 * SUBRB (subtract reverse integer with borrow)
 * op SUBRB(0b000[3]:0b110001[6]:g[2]:dst[5]:src[16])
 */

op SUBRB_reg  (0b000[3]:0b110001[6]:0b00[2]:dst[5]:0[11]:src[5])
op SUBRB_dir  (0b000[3]:0b110001[6]:0b01[2]:dst[5]:direct[16])
op SUBRB_indir(0b000[3]:0b110001[6]:0b10[2]:dst[5]:mod[5]:ar[3]:disp[8])
op SUBRB_imm  (0b000[3]:0b110001[6]:0b11[2]:dst[5]:sext<32> imm[16])

SUBRB_reg.disasm = {
	const char *dst_name = REG_NAME[dst];
	const char *src_name = REG_NAME[src];
	
	if (!dst_name || !src_name)
		return false;
	
	os << "SUBRB " << src_name << ", " << dst_name;
	return true;
}

SUBRB_dir.disasm = {
	const char *dst_name = REG_NAME[dst];

	if(!dst_name)
		return false;
	
	os << "SUBRB " << hex << cpu.DisasmDir(Operation<CONFIG, DEBUG>::GetAddr() / 4, direct) << dec << ", " << dst_name;
	
	return true;
}

SUBRB_indir.disasm = {
	string disasm_src_indir;
	const char *dst_name = REG_NAME[dst];

	if (!dst_name || !cpu.DisasmIndir(disasm_src_indir, Operation<CONFIG, DEBUG>::GetAddr() / 4, mod, ar, disp)) 
		return false;

	os << "SUBRB " << disasm_src_indir << ", " << dst_name;

	return true;
}

SUBRB_imm.disasm = {
	const char *dst_name = REG_NAME[dst];

	if (!dst_name)
		return false;

	os << "SUBRB " << imm << ", " << dst_name;
	return true;
}

SUBRB_reg.execute = {
	// Check that source and destination registers are valid
	if(unlikely(!cpu.HasReg(src) || !cpu.HasReg(dst)))
	{
		throw BogusOpcodeException<CONFIG, DEBUG>(this);
	}

	// Read source operand
	uint32_t src_value = cpu.GetReg(src);

	// Read destination operand
	uint32_t dst_value = cpu.GetReg(dst);

	// Read borrow in
	uint8_t borrow_in = cpu.GetST_C();

	// Compute the result
	uint32_t result;      // the 32-bit result
	uint8_t borrow_out;   // the borrow out (0 or 1)
	uint8_t overflow;     // the overflow (0 or 1)
	uint8_t sign;         // the sign (0 or 1)

	// Depending on overflow mode do signed saturation or not 
	if(cpu.GetST_OVM())
	{
		SignedSatSub32(result, borrow_out, overflow, sign, src_value, dst_value, borrow_in);
	}
	else
	{
		SignedSub32(result, borrow_out, overflow, sign, src_value, dst_value, borrow_in);
		sign = sign ^ overflow;
	}

	// Write back result
	cpu.SetReg(dst, result);

	// Check whether destination operand is an extended precision register
	if(cpu.IsExtReg(dst))
	{
		// Generate flags (into ST)
		cpu.GenFlags(
			result,
			M_ST_UF | M_ST_N | M_ST_Z | M_ST_V | M_ST_C,  // reset mask
			M_ST_LV | M_ST_N | M_ST_Z | M_ST_V | M_ST_C,  // or mask
			sign,
			borrow_out,
			overflow
		);
	}
}

SUBRB_dir.execute = {
	// Check that destination register is valid
	if(unlikely(!cpu.HasReg(dst)))
	{
		throw BogusOpcodeException<CONFIG, DEBUG>(this);
	}

	// Read destination operand
	uint32_t dst_value = cpu.GetReg(dst);

	// Compute the source operand effective address
	typename CONFIG::address_t ea = cpu.ComputeDirEA(direct);

	// Read the source operand from memory
	uint32_t src_value = cpu.IntLoad(ea);

	// Read borrow in
	uint8_t borrow_in = cpu.GetST_C();

	// Compute the result
	uint32_t result;      // the 32-bit result
	uint8_t borrow_out;   // the borrow out (0 or 1)
	uint8_t overflow;     // the overflow (0 or 1)
	uint8_t sign;         // the sign (0 or 1)

	// Depending on overflow mode do signed saturation or not 
	if(cpu.GetST_OVM())
	{
		SignedSatSub32(result, borrow_out, overflow, sign, src_value, dst_value, borrow_in);
	}
	else
	{
		SignedSub32(result, borrow_out, overflow, sign, src_value, dst_value, borrow_in);
		sign = sign ^ overflow;
	}

	// Write back result
	cpu.SetReg(dst, result);

	// Check whether destination operand is an extended precision register
	if(cpu.IsExtReg(dst))
	{
		// Generate flags (into ST)
		cpu.GenFlags(
			result,
			M_ST_UF | M_ST_N | M_ST_Z | M_ST_V | M_ST_C,  // reset mask
			M_ST_LV | M_ST_N | M_ST_Z | M_ST_V | M_ST_C,  // or mask
			sign,
			borrow_out,
			overflow
		);
	}
}

SUBRB_indir.execute = {
	// Check that destination register is valid
	if(unlikely(!cpu.HasReg(dst)))
	{
		throw BogusOpcodeException<CONFIG, DEBUG>(this);
	}

	// Check that indirect addressing mode is valid and compute the effective address of the source operand
	typename CONFIG::address_t ea;        // The effective address
	bool update_ar;                       // Whether to update ARn
	typename CONFIG::address_t output_ar; // New value of ARn if it is updated

	if(unlikely(!cpu.ComputeIndirEA(ea, update_ar, output_ar, mod, ar, disp)))
	{
		throw BogusOpcodeException<CONFIG, DEBUG>(this);
	}

	if(update_ar)
	{
		// Write back ARn
		cpu.SetAR23_0(ar, output_ar);
	}

	// Read destination operand
	uint32_t dst_value = cpu.GetReg(dst);

	// Read the source operand from memory
	uint32_t src_value = cpu.IntLoad(ea);

	// Read borrow in
	uint8_t borrow_in = cpu.GetST_C();

	// Compute the result
	uint32_t result;      // the 32-bit result
	uint8_t borrow_out;   // the borrow out (0 or 1)
	uint8_t overflow;     // the overflow (0 or 1)
	uint8_t sign;         // the sign (0 or 1)

	// Depending on overflow mode do signed saturation or not 
	if(cpu.GetST_OVM())
	{
		SignedSatSub32(result, borrow_out, overflow, sign, src_value, dst_value, borrow_in);
	}
	else
	{
		SignedSub32(result, borrow_out, overflow, sign, src_value, dst_value, borrow_in);
		sign = sign ^ overflow;
	}

	// Write back result
	cpu.SetReg(dst, result);

	// Check whether destination operand is an extended precision register
	if(cpu.IsExtReg(dst))
	{
		// Generate flags (into ST)
		cpu.GenFlags(
			result,
			M_ST_UF | M_ST_N | M_ST_Z | M_ST_V | M_ST_C,  // reset mask
			M_ST_LV | M_ST_N | M_ST_Z | M_ST_V | M_ST_C,  // or mask
			sign,
			borrow_out,
			overflow
		);
	}
}

SUBRB_imm.execute = {
	// Check that destination register is valid
	if(unlikely(!cpu.HasReg(dst)))
	{
		throw BogusOpcodeException<CONFIG, DEBUG>(this);
	}

	// Read destination operand
	uint32_t dst_value = cpu.GetReg(dst);

	// Read borrow in
	uint8_t borrow_in = cpu.GetST_C();

	// Compute the result
	uint32_t result;      // the 32-bit result
	uint8_t borrow_out;   // the borrow out (0 or 1)
	uint8_t overflow;     // the overflow (0 or 1)
	uint8_t sign;         // the sign (0 or 1)

	// Depending on overflow mode do signed saturation or not 
	if(cpu.GetST_OVM())
	{
		SignedSatSub32(result, borrow_out, overflow, sign, imm, dst_value, borrow_in);
	}
	else
	{
		SignedSub32(result, borrow_out, overflow, sign, imm, dst_value, borrow_in);
		sign = sign ^ overflow;
	}

	// Write back result
	cpu.SetReg(dst, result);

	// Check whether destination operand is an extended precision register
	if(cpu.IsExtReg(dst))
	{
		// Generate flags (into ST)
		cpu.GenFlags(
			result,
			M_ST_UF | M_ST_N | M_ST_Z | M_ST_V | M_ST_C,  // reset mask
			M_ST_LV | M_ST_N | M_ST_Z | M_ST_V | M_ST_C,  // or mask
			sign,
			borrow_out,
			overflow
		);
	}
}

/* end of SUBRB (subtract reverse integer with borrow)
 **********************************************************/

/**********************************************************
 * SUBRF (subtract reverse floating-point value)
 * op SUBRF(0b000[3]:0b110010[6]:g[2]:dst[5]:src[16])
 */

op SUBRF_reg  (0b000[3]:0b110010[6]:0b00[2]:dst[5]:0[11]:src[5])
op SUBRF_dir  (0b000[3]:0b110010[6]:0b01[2]:dst[5]:direct[16])
op SUBRF_indir(0b000[3]:0b110010[6]:0b10[2]:dst[5]:mod[5]:ar[3]:disp[8])
op SUBRF_imm  (0b000[3]:0b110010[6]:0b11[2]:dst[5]:imm[16])

SUBRF_reg.disasm = {
	const char *dst_name = REG_NAME[dst];
	const char *src_name = REG_NAME[src];
	
	if (!dst_name || !src_name)
		return false;
	
	os << "SUBRF " << src_name << ", " << dst_name;
	return true;
}

SUBRF_dir.disasm = {
	const char *dst_name = REG_NAME[dst];

	if(!dst_name)
		return false;
	
	os << "SUBRF " << hex << cpu.DisasmDir(Operation<CONFIG, DEBUG>::GetAddr() / 4, direct) << dec << ", " << dst_name;
	
	return true;
}

SUBRF_indir.disasm = {
	string disasm_src_indir;
	const char *dst_name = REG_NAME[dst];

	if (!dst_name || !cpu.DisasmIndir(disasm_src_indir, Operation<CONFIG, DEBUG>::GetAddr() / 4, mod, ar, disp)) 
		return false;

	os << "SUBRF " << disasm_src_indir << ", " << dst_name;
	return true;
}

SUBRF_imm.disasm = {
	const char *dst_name = REG_NAME[dst];

	if (!dst_name)
		return false;

	os << "SUBRF " << cpu.DisasmShortFloat(imm) << ", " << dst_name;
	return true;
}

SUBRF_reg.execute = {
	// Check that destination and source registers are valid
	if (likely(!cpu.EnableFloatOpsWithNonExtRegs())) {
		if (unlikely(!cpu.IsExtReg(dst) || !cpu.IsExtReg(src)))
			throw BogusOpcodeException<CONFIG, DEBUG>(this);
	} 
	else
	{
		if(unlikely(!cpu.HasReg(dst) || !cpu.HasReg(src)))
			throw BogusOpcodeException<CONFIG, DEBUG>(this);
	}

	// get source register
	Register& src_reg = cpu.GetExtReg(src);
	
	// get destination register
	Register& dst_reg = cpu.GetExtReg(dst);
	
	if (unlikely(!cpu.IsExtReg(src)))
	{
		src_reg.SetHiWriteMask(0, (uint8_t)0x8);
		if (unlikely(!cpu.IsExtReg(dst)))
			dst_reg.SetHiWriteMask(0, (uint8_t)0x8);
	}
	else
		if (unlikely(!cpu.IsExtReg(dst)))
			dst_reg.SetHiWriteMask(0, (uint8_t)0);

	// compute
	uint32_t underflow;
	uint32_t overflow;
	uint32_t neg;
	dst_reg.Subf(src_reg, dst_reg, overflow, underflow, neg);

	// Generate flags (into ST)
	if (likely(cpu.IsExtReg(dst)))
		cpu.GenFlags(
			dst_reg,
			M_ST_UF | M_ST_N | M_ST_Z | M_ST_V,  // reset mask
			M_ST_LUF | M_ST_LV | M_ST_UF | M_ST_N | M_ST_Z | M_ST_V,  // or mask
			overflow, underflow, neg
		);
}

SUBRF_dir.execute = {
	// Check that destination register is valid
	if (likely(!cpu.EnableFloatOpsWithNonExtRegs()))
	{
		if (unlikely(!cpu.IsExtReg(dst)))
			throw BogusOpcodeException<CONFIG, DEBUG>(this);
	}
	else
	{
		if (unlikely(!cpu.HasReg(dst)))
			throw BogusOpcodeException<CONFIG, DEBUG>(this);
	}
	
	// get destination register
	Register& dst_reg = cpu.GetExtReg(dst);
	
	// Compute the source operand effective address
	typename CONFIG::address_t ea = cpu.ComputeDirEA(direct);

	// Read the source operand from memory
	uint32_t src_value = cpu.IntLoad(ea);

	if (unlikely(!cpu.IsExtReg(dst)))
	{
		Register tmp_reg;
		tmp_reg.SetFromSinglePrecisionFPFormat(src_value);
		dst_reg.SetHiWriteMask(0, tmp_reg.GetHi());
	}

	// compute
	uint32_t underflow;
	uint32_t overflow;
	uint32_t neg;
	dst_reg.Subf32(src_value, dst_reg, overflow, underflow, neg);

	// Generate flags (into ST)
	if (likely(cpu.IsExtReg(dst)))
		cpu.GenFlags(
			dst_reg,
			M_ST_UF | M_ST_N | M_ST_Z | M_ST_V,  // reset mask
			M_ST_LUF | M_ST_LV | M_ST_UF | M_ST_N | M_ST_Z | M_ST_V,  // or mask
			overflow, underflow, neg
		);
}

SUBRF_indir.execute = {
	// Check that destination register is valid
	if (likely(!cpu.EnableFloatOpsWithNonExtRegs()))
	{
		if (unlikely(!cpu.IsExtReg(dst)))
			throw BogusOpcodeException<CONFIG, DEBUG>(this);
	}
	else
	{
		if (unlikely(!cpu.HasReg(dst)))
			throw BogusOpcodeException<CONFIG, DEBUG>(this);
	}
	
	// Check that indirect addressing mode is valid and compute the effective address of the source operand
	typename CONFIG::address_t ea;        // The effective address
	bool update_ar;                       // Whether to update ARn
	typename CONFIG::address_t output_ar; // New value of ARn if it is updated

	if(unlikely(!cpu.ComputeIndirEA(ea, update_ar, output_ar, mod, ar, disp)))
	{
		throw BogusOpcodeException<CONFIG, DEBUG>(this);
	}

	if(update_ar)
	{
		// Write back ARn
		cpu.SetAR23_0(ar, output_ar);
	}
	
	// Read the source operand from memory
	uint32_t src_value = cpu.IntLoad(ea);

	// get destination register
	Register& dst_reg = cpu.GetExtReg(dst);
	if (unlikely(!cpu.IsExtReg(dst)))
		dst_reg.SetHiWriteMask(0, (uint8_t)0x08);

	// compute
	uint32_t underflow;
	uint32_t overflow;
	uint32_t neg;
	dst_reg.Subf32(src_value, dst_reg, overflow, underflow, neg);

	// Generate flags (into ST)
	if (likely(cpu.IsExtReg(dst)))
		cpu.GenFlags(
			dst_reg,
			M_ST_UF | M_ST_N | M_ST_Z | M_ST_V,  // reset mask
			M_ST_LUF | M_ST_LV | M_ST_UF | M_ST_N | M_ST_Z | M_ST_V,  // or mask
			overflow, underflow, neg
		);
}

SUBRF_imm.execute = {
	// Check that destination register is valid
	if (likely(!cpu.EnableFloatOpsWithNonExtRegs()))
	{
		if (unlikely(!cpu.IsExtReg(dst)))
			throw BogusOpcodeException<CONFIG, DEBUG>(this);
	}
	else
	{
		if (unlikely(!cpu.HasReg(dst)))
			throw BogusOpcodeException<CONFIG, DEBUG>(this);
	}
	
	// get destination register
	Register& dst_reg = cpu.GetExtReg(dst);
	if (unlikely(!cpu.IsExtReg(dst)))
		dst_reg.SetHiWriteMask(0, (uint8_t)0x10);
	
	// compute
	uint32_t underflow;
	uint32_t overflow;
	uint32_t neg;
	dst_reg.Subf16((uint16_t)imm, dst_reg, overflow, underflow, neg);

	// Generate flags (into ST)
	if (likely(cpu.IsExtReg(dst)))
		cpu.GenFlags(
			dst_reg,
			M_ST_UF | M_ST_N | M_ST_Z | M_ST_V,  // reset mask
			M_ST_LUF | M_ST_LV | M_ST_UF | M_ST_N | M_ST_Z | M_ST_V,  // or mask
			overflow, underflow, neg
		);
}

/* end of SUBRF (subtract reverse floating-point value)
 **********************************************************/

/**********************************************************
 * SUBRI (subtract reverse integer)
 * op SUBRI(0b000[3]:0b110011[6]:g[2]:dst[5]:src[16])
 */

op SUBRI_reg  (0b000[3]:0b110011[6]:0b00[2]:dst[5]:0[11]:src[5])
op SUBRI_dir  (0b000[3]:0b110011[6]:0b01[2]:dst[5]:direct[16])
op SUBRI_indir(0b000[3]:0b110011[6]:0b10[2]:dst[5]:mod[5]:ar[3]:disp[8])
op SUBRI_imm  (0b000[3]:0b110011[6]:0b11[2]:dst[5]:sext<32> imm[16])

SUBRI_reg.disasm = {
	const char *dst_name = REG_NAME[dst];
	const char *src_name = REG_NAME[src];
	
	if (!dst_name || !src_name)
		return false;
	
	os << "SUBRI " << src_name << ", " << dst_name;
	return true;
}

SUBRI_dir.disasm = {
	const char *dst_name = REG_NAME[dst];

	if(!dst_name)
		return false;
	
	os << "SUBRI " << hex << cpu.DisasmDir(Operation<CONFIG, DEBUG>::GetAddr() / 4, direct) << dec << ", " << dst_name;
	
	return true;
}

SUBRI_indir.disasm = {
	string disasm_src_indir;
	const char *dst_name = REG_NAME[dst];

	if (!dst_name || !cpu.DisasmIndir(disasm_src_indir, Operation<CONFIG, DEBUG>::GetAddr() / 4, mod, ar, disp)) 
		return false;

	os << "SUBRI " << disasm_src_indir << ", " << dst_name;

	return true;
}

SUBRI_imm.disasm = {
	const char *dst_name = REG_NAME[dst];

	if (!dst_name)
		return false;

	os << "SUBRI " << imm << ", " << dst_name;
	return true;
}

SUBRI_reg.execute = {
	// Check that source and destination registers are valid
	if(unlikely(!cpu.HasReg(src) || !cpu.HasReg(dst)))
	{
		throw BogusOpcodeException<CONFIG, DEBUG>(this);
	}

	// Read source operand
	uint32_t src_value = cpu.GetReg(src);

	// Read destination operand
	uint32_t dst_value = cpu.GetReg(dst);

	// Compute the result
	uint32_t result;      // the 32-bit result
	uint8_t borrow_out;   // the borrow out (0 or 1)
	uint8_t overflow;     // the overflow (0 or 1)
	uint8_t sign;         // the sign (0 or 1)

	// Depending on overflow mode do signed saturation or not 
	if(cpu.GetST_OVM())
	{
		SignedSatSub32(result, borrow_out, overflow, sign, src_value, dst_value, 0);
	}
	else
	{
		SignedSub32(result, borrow_out, overflow, sign, src_value, dst_value, 0);
		sign = sign ^ overflow;
	}

	// Write back result
	cpu.SetReg(dst, result);

	// Check whether destination operand is an extended precision register
	if(cpu.IsExtReg(dst))
	{
		// Generate flags (into ST)
		cpu.GenFlags(
			result,
			M_ST_UF | M_ST_N | M_ST_Z | M_ST_V | M_ST_C,  // reset mask
			M_ST_LV | M_ST_N | M_ST_Z | M_ST_V | M_ST_C,  // or mask
			sign,
			borrow_out,
			overflow
		);
	}
}

SUBRI_dir.execute = {
	// Check that destination register is valid
	if(unlikely(!cpu.HasReg(dst)))
	{
		throw BogusOpcodeException<CONFIG, DEBUG>(this);
	}

	// Read destination operand
	uint32_t dst_value = cpu.GetReg(dst);

	// Compute the source operand effective address
	typename CONFIG::address_t ea = cpu.ComputeDirEA(direct);

	// Read the source operand from memory
	uint32_t src_value = cpu.IntLoad(ea);

	// Compute the result
	uint32_t result;      // the 32-bit result
	uint8_t borrow_out;   // the borrow out (0 or 1)
	uint8_t overflow;     // the overflow (0 or 1)
	uint8_t sign;         // the sign (0 or 1)

	// Depending on overflow mode do signed saturation or not 
	if(cpu.GetST_OVM())
	{
		SignedSatSub32(result, borrow_out, overflow, sign, src_value, dst_value, 0);
	}
	else
	{
		SignedSub32(result, borrow_out, overflow, sign, src_value, dst_value, 0);
		sign = sign ^ overflow;
	}

	// Write back result
	cpu.SetReg(dst, result);

	// Check whether destination operand is an extended precision register
	if(cpu.IsExtReg(dst))
	{
		// Generate flags (into ST)
		cpu.GenFlags(
			result,
			M_ST_UF | M_ST_N | M_ST_Z | M_ST_V | M_ST_C,  // reset mask
			M_ST_LV | M_ST_N | M_ST_Z | M_ST_V | M_ST_C,  // or mask
			sign,
			borrow_out,
			overflow
		);
	}
}

SUBRI_indir.execute = {
	// Check that destination register is valid
	if(unlikely(!cpu.HasReg(dst)))
	{
		throw BogusOpcodeException<CONFIG, DEBUG>(this);
	}

	// Check that indirect addressing mode is valid and compute the effective address of the source operand
	typename CONFIG::address_t ea;        // The effective address
	bool update_ar;                       // Whether to update ARn
	typename CONFIG::address_t output_ar; // New value of ARn if it is updated

	if(unlikely(!cpu.ComputeIndirEA(ea, update_ar, output_ar, mod, ar, disp)))
	{
		throw BogusOpcodeException<CONFIG, DEBUG>(this);
	}

	if(update_ar)
	{
		// Write back ARn
		cpu.SetAR23_0(ar, output_ar);
	}

	// Read destination operand
	uint32_t dst_value = cpu.GetReg(dst);

	// Read the source operand from memory
	uint32_t src_value = cpu.IntLoad(ea);

	// Compute the result
	uint32_t result;      // the 32-bit result
	uint8_t borrow_out;   // the borrow out (0 or 1)
	uint8_t overflow;     // the overflow (0 or 1)
	uint8_t sign;         // the sign (0 or 1)

	// Depending on overflow mode do signed saturation or not 
	if(cpu.GetST_OVM())
	{
		SignedSatSub32(result, borrow_out, overflow, sign, src_value, dst_value, 0);
	}
	else
	{
		SignedSub32(result, borrow_out, overflow, sign, src_value, dst_value, 0);
		sign = sign ^ overflow;
	}

	// Write back result
	cpu.SetReg(dst, result);

	// Check whether destination operand is an extended precision register
	if(cpu.IsExtReg(dst))
	{
		// Generate flags (into ST)
		cpu.GenFlags(
			result,
			M_ST_UF | M_ST_N | M_ST_Z | M_ST_V | M_ST_C,  // reset mask
			M_ST_LV | M_ST_N | M_ST_Z | M_ST_V | M_ST_C,  // or mask
			sign,
			borrow_out,
			overflow
		);
	}
}

SUBRI_imm.execute = {
	// Check that destination register is valid
	if(unlikely(!cpu.HasReg(dst)))
	{
		throw BogusOpcodeException<CONFIG, DEBUG>(this);
	}

	// Read destination operand
	uint32_t dst_value = cpu.GetReg(dst);

	// Compute the result
	uint32_t result;      // the 32-bit result
	uint8_t borrow_out;   // the borrow out (0 or 1)
	uint8_t overflow;     // the overflow (0 or 1)
	uint8_t sign;         // the sign (0 or 1)

	// Depending on overflow mode do signed saturation or not 
	if(cpu.GetST_OVM())
	{
		SignedSatSub32(result, borrow_out, overflow, sign, imm, dst_value, 0);
	}
	else
	{
		SignedSub32(result, borrow_out, overflow, sign, imm, dst_value, 0);
		sign = sign ^ overflow;
	}

	// Write back result
	cpu.SetReg(dst, result);

	// Check whether destination operand is an extended precision register
	if(cpu.IsExtReg(dst))
	{
		// Generate flags (into ST)
		cpu.GenFlags(
			result,
			M_ST_UF | M_ST_N | M_ST_Z | M_ST_V | M_ST_C,  // reset mask
			M_ST_LV | M_ST_N | M_ST_Z | M_ST_V | M_ST_C,  // or mask
			sign,
			borrow_out,
			overflow
		);
	}
}

/* end of SUBRI (subtract reverse integer)
 **********************************************************/

/**********************************************************
 * TSTB (test bit fields)
 * op TSTB(0b000[3]:0b110100[6]:g[2]:dst[5]:src[16])
 */

op TSTB_reg  (0b000[3]:0b110100[6]:0b00[2]:dst[5]:0[11]:src[5])
op TSTB_dir  (0b000[3]:0b110100[6]:0b01[2]:dst[5]:direct[16])
op TSTB_indir(0b000[3]:0b110100[6]:0b10[2]:dst[5]:mod[5]:ar[3]:disp[8])
op TSTB_imm  (0b000[3]:0b110100[6]:0b11[2]:dst[5]:<32> imm[16])

TSTB_reg.disasm = {
	const char *dst_name = REG_NAME[dst];
	const char *src_name = REG_NAME[src];
	
	if (!dst_name || !src_name)
		return false;
	
	os << "TSTB " << src_name << ", " << dst_name;
	return true;
}

TSTB_dir.disasm = {
	const char *dst_name = REG_NAME[dst];

	if(!dst_name)
		return false;
	
	os << "TSTB " << hex << cpu.DisasmDir(Operation<CONFIG, DEBUG>::GetAddr() / 4, direct) << dec << ", " << dst_name;
	
	return true;
}

TSTB_indir.disasm = {
	string disasm_src_indir;
	const char *dst_name = REG_NAME[dst];

	if (!dst_name || !cpu.DisasmIndir(disasm_src_indir, Operation<CONFIG, DEBUG>::GetAddr() / 4, mod, ar, disp)) 
		return false;

	os << "TSTB " << disasm_src_indir << ", " << dst_name;
	return true;
}

TSTB_imm.disasm = {
	const char *dst_name = REG_NAME[dst];

	if (!dst_name)
		return false;

	os << "TSTB " << imm << ", " << dst_name;
	return true;
}

TSTB_reg.execute = {
	// Check that source and destination registers are valid
	if(unlikely(!cpu.HasReg(src) || !cpu.HasReg(dst)))
	{
		throw BogusOpcodeException<CONFIG, DEBUG>(this);
	}

	// Read source operand
	uint32_t src_value = cpu.GetReg(src);

	// Read destination operand
	uint32_t dst_value = cpu.GetReg(dst);

	// Compute the result
	uint32_t result = src_value & dst_value;
	uint8_t sign = (int32_t) result < 0;

	// Generate flags (into ST)
	cpu.GenFlags(
		result,
		M_ST_UF | M_ST_N | M_ST_Z | M_ST_V,  // reset mask
		M_ST_N | M_ST_Z,    // or mask
		sign
	);
}

TSTB_dir.execute = {
	// Check that destination register is valid
	if(unlikely(!cpu.HasReg(dst)))
	{
		throw BogusOpcodeException<CONFIG, DEBUG>(this);
	}

	// Read destination operand
	uint32_t dst_value = cpu.GetReg(dst);

	// Compute the source operand effective address
	typename CONFIG::address_t ea = cpu.ComputeDirEA(direct);

	// Read the source operand from memory
	uint32_t src_value = cpu.IntLoad(ea);

	// Compute the result
	uint32_t result = src_value & dst_value;
	uint8_t sign = (int32_t) result < 0;

	// Generate flags (into ST)
	cpu.GenFlags(
		result,
		M_ST_UF | M_ST_N | M_ST_Z | M_ST_V,  // reset mask
		M_ST_N | M_ST_Z,    // or mask
		sign
	);
}

TSTB_indir.execute = {
	// Check that destination register is valid
	if(unlikely(!cpu.HasReg(dst)))
	{
		throw BogusOpcodeException<CONFIG, DEBUG>(this);
	}

	// Check that indirect addressing mode is valid and compute the effective address of the source operand
	typename CONFIG::address_t ea;        // The effective address
	bool update_ar;                       // Whether to update ARn
	typename CONFIG::address_t output_ar; // New value of ARn if it is updated

	if(unlikely(!cpu.ComputeIndirEA(ea, update_ar, output_ar, mod, ar, disp)))
	{
		throw BogusOpcodeException<CONFIG, DEBUG>(this);
	}

	if(update_ar)
	{
		// Write back ARn
		cpu.SetAR23_0(ar, output_ar);
	}

	// Read destination operand
	uint32_t dst_value = cpu.GetReg(dst);

	// Read the source operand from memory
	uint32_t src_value = cpu.IntLoad(ea);

	// Compute the result
	uint32_t result = src_value & dst_value;
	uint8_t sign = (int32_t) result < 0;

	// Generate flags (into ST)
	cpu.GenFlags(
		result,
		M_ST_UF | M_ST_N | M_ST_Z | M_ST_V,  // reset mask
		M_ST_N | M_ST_Z,    // or mask
		sign
	);
}

TSTB_imm.execute = {
	// Check that destination register is valid
	if(unlikely(!cpu.HasReg(dst)))
	{
		throw BogusOpcodeException<CONFIG, DEBUG>(this);
	}

	// Read destination operand
	uint32_t dst_value = cpu.GetReg(dst);

	// Compute the result
	uint32_t result = imm & dst_value;
	uint8_t sign = (int32_t) result < 0;

	// Generate flags (into ST)
	cpu.GenFlags(
		result,
		M_ST_UF | M_ST_N | M_ST_Z | M_ST_V,  // reset mask
		M_ST_N | M_ST_Z,    // or mask
		sign
	);
}

/* end of TSTB (test bit fields)
 **********************************************************/

/**********************************************************
 * XOR (bitwise-exclusive OR)
 * op XOR(0b000[3]:0b110101[6]:g[2]:dst[5]:src[16])
 */

op XOR_reg  (0b000[3]:0b110101[6]:0b00[2]:dst[5]:0[11]:src[5])
op XOR_dir  (0b000[3]:0b110101[6]:0b01[2]:dst[5]:direct[16])
op XOR_indir(0b000[3]:0b110101[6]:0b10[2]:dst[5]:mod[5]:ar[3]:disp[8])
op XOR_imm  (0b000[3]:0b110101[6]:0b11[2]:dst[5]:<32> imm[16])

XOR_reg.disasm = {
	const char *dst_name = REG_NAME[dst];
	const char *src_name = REG_NAME[src];
	
	if (!dst_name || !src_name)
		return false;
	
	os << "XOR " << src_name << ", " << dst_name;
	return true;
}

XOR_dir.disasm = {
	const char *dst_name = REG_NAME[dst];

	if(!dst_name)
		return false;
	
	os << "XOR " << hex << cpu.DisasmDir(Operation<CONFIG, DEBUG>::GetAddr() / 4, direct) << dec << ", " << dst_name;
	
	return true;
}

XOR_indir.disasm = {
	string disasm_src_indir;
	const char *dst_name = REG_NAME[dst];

	if (!dst_name || !cpu.DisasmIndir(disasm_src_indir, Operation<CONFIG, DEBUG>::GetAddr() / 4, mod, ar, disp)) 
		return false;

	os << "XOR " << disasm_src_indir << ", " << dst_name;
	return true;
}

XOR_imm.disasm = {
	const char *dst_name = REG_NAME[dst];

	if (!dst_name)
		return false;

	os << "XOR " << imm << ", " << dst_name;
	return true;
}

XOR_reg.execute = {
	// Check that source and destination registers are valid
	if(unlikely(!cpu.HasReg(src) || !cpu.HasReg(dst)))
	{
		throw BogusOpcodeException<CONFIG, DEBUG>(this);
	}

	// Read source operand
	uint32_t src_value = cpu.GetReg(src);

	// Read destination operand
	uint32_t dst_value = cpu.GetReg(dst);

	// Compute the result
	uint32_t result = src_value ^ dst_value;
	uint8_t sign = (int32_t) result < 0;

	// Write back result
	cpu.SetReg(dst, result);

	// Check whether destination operand is an extended precision register
	if(cpu.IsExtReg(dst))
	{
		// Generate flags (into ST)
		cpu.GenFlags(
			result,
			M_ST_UF | M_ST_N | M_ST_Z | M_ST_V,  // reset mask
			M_ST_N | M_ST_Z,    // or mask
			sign
		);
	}
}

XOR_dir.execute = {
	// Check that destination register is valid
	if(unlikely(!cpu.HasReg(dst)))
	{
		throw BogusOpcodeException<CONFIG, DEBUG>(this);
	}

	// Read destination operand
	uint32_t dst_value = cpu.GetReg(dst);

	// Compute the source operand effective address
	typename CONFIG::address_t ea = cpu.ComputeDirEA(direct);

	// Read the source operand from memory
	uint32_t src_value = cpu.IntLoad(ea);

	// Compute the result
	uint32_t result = src_value ^ dst_value;
	uint8_t sign = (int32_t) result < 0;

	// Write back result
	cpu.SetReg(dst, result);

	// Check whether destination operand is an extended precision register
	if(cpu.IsExtReg(dst))
	{
		// Generate flags (into ST)
		cpu.GenFlags(
			result,
			M_ST_UF | M_ST_N | M_ST_Z | M_ST_V,  // reset mask
			M_ST_N | M_ST_Z,    // or mask
			sign
		);
	}
}

XOR_indir.execute = {
	// Check that destination register is valid
	if(unlikely(!cpu.HasReg(dst)))
	{
		throw BogusOpcodeException<CONFIG, DEBUG>(this);
	}

	// Check that indirect addressing mode is valid and compute the effective address of the source operand
	typename CONFIG::address_t ea;        // The effective address
	bool update_ar;                       // Whether to update ARn
	typename CONFIG::address_t output_ar; // New value of ARn if it is updated

	if(unlikely(!cpu.ComputeIndirEA(ea, update_ar, output_ar, mod, ar, disp)))
	{
		throw BogusOpcodeException<CONFIG, DEBUG>(this);
	}

	if(update_ar)
	{
		// Write back ARn
		cpu.SetAR23_0(ar, output_ar);
	}

	// Read destination operand
	uint32_t dst_value = cpu.GetReg(dst);

	// Read the source operand from memory
	uint32_t src_value = cpu.IntLoad(ea);

	// Compute the result
	uint32_t result = src_value ^ dst_value;
	uint8_t sign = (int32_t) result < 0;

	// Write back result
	cpu.SetReg(dst, result);

	// Check whether destination operand is an extended precision register
	if(cpu.IsExtReg(dst))
	{
		// Generate flags (into ST)
		cpu.GenFlags(
			result,
			M_ST_UF | M_ST_N | M_ST_Z | M_ST_V,  // reset mask
			M_ST_N | M_ST_Z,    // or mask
			sign
		);
	}
}

XOR_imm.execute = {
	// Check that destination register is valid
	if(unlikely(!cpu.HasReg(dst)))
	{
		throw BogusOpcodeException<CONFIG, DEBUG>(this);
	}

	// Read destination operand
	uint32_t dst_value = cpu.GetReg(dst);

	// Compute the result
	uint32_t result = imm ^ dst_value;
	uint8_t sign = (int32_t) result < 0;

	// Write back result
	cpu.SetReg(dst, result);

	// Check whether destination operand is an extended precision register
	if(cpu.IsExtReg(dst))
	{
		// Generate flags (into ST)
		cpu.GenFlags(
			result,
			M_ST_UF | M_ST_N | M_ST_Z | M_ST_V,  // reset mask
			M_ST_N | M_ST_Z,    // or mask
			sign
		);
	}
}

/* end of XOR (bitwise-exclusive OR)
 **********************************************************/
