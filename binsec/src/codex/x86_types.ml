module Logger = Codex_logger

module Create () : Codex.Ctypes.Type_settings = struct
open Codex.Ctypes

let mk descr =
  { descr; const = false; pred = Pred.True }

let mkptr typ = Ptr { pointed = typ; index = Zero }

let ptr_notnull typ = { descr = mkptr typ; pred = Pred.neq (Const Z.zero); const = false }

let ptr_notnull_idx typ idx =
  { descr = Ptr {pointed = typ; index = idx}; pred = Pred.neq (Const Z.zero); const = false }

let const typ =
  { typ with const = true }

let with_ pred t =
  { t with pred }

let nb_cpu = Z.one

let cs_pred =
  let open Pred in
  (*
  let three = Val (Const (Z.of_int 0b11)) in
  let seven = Val (Const (Z.of_int 0b111)) in
  Cmp (Equal, (Binop (And, Self, seven)), three)
  *)
  Cmp (Equal, Self, Val (Const (Z.of_int64 @@ Int64.of_string
    (* index in GDT, in_ldt, RPL *)
    "0b11_0_11")))

(********** AUTOGENERATED **********)

let uint32_t = mk (Base (4, "unsigned int"))

let uint64_t = mk (Base (8, "long long unsigned int"))

let inter_privilege_interrupt_frame =
  mk (Structure {
    st_name = Some ("inter_privilege_interrupt_frame");
    st_byte_size = Some (20);
    st_members =
      [ (0, "eip", uint32_t);
        (*(4, "cs", uint32_t);*)
        (4, "cs", with_ cs_pred uint32_t);
        (8, "flags", uint32_t);
        (12, "esp", uint32_t);
        (*(16, "ss", uint32_t);*)
        (16, "ss", with_ (Pred.eq (Const (Z.of_int64 (Int64.of_string
          (* index in GDT, in_ldt, RPL *)
          "0b0100_0_11")))) uint32_t);
      ];
  })

let pusha =
  mk (Structure {
    st_name = Some ("pusha");
    st_byte_size = Some (32);
    st_members =
      [ (0, "edi", uint32_t);
        (4, "esi", uint32_t);
        (8, "ebp", uint32_t);
        (12, "esp", uint32_t);
        (16, "ebx", uint32_t);
        (20, "edx", uint32_t);
        (24, "ecx", uint32_t);
        (28, "eax", uint32_t);
      ];
  })

let segment_descriptor_t = uint64_t

let date_t =
  mk (Structure {
    st_name = Some "date_t_dummy";
    st_byte_size = Some 8;
    st_members =
      [ (0, "low", uint32_t);
        (4, "high", uint32_t);
      ];
  })

let hw_context =
  mk (Structure {
    st_name = Some ("hw_context");
    st_byte_size = Some (60);
    st_members =
      [ (0, "regs", pusha);
        (32, "iframe", inter_privilege_interrupt_frame);
        (* Gone in versions with dynamic task creation for some reason
        (52, "code_segment", with_ task_cs_desc_pred segment_descriptor_t);
        (60, "data_segment", segment_descriptor_t);
        *)

        (52, "start_address", with_ Pred.(ugeq (Sym "end_of_kernel")) uint32_t);
        (56, "memsize", uint32_t);
      ];
  })

let context =
  let sched_option = Codex_options.X86Types.get () in
  let dyn_thread_option = Codex_options.DynThreads.get () in
  Logger.debug ~level:2 "scheduling detected: %s" sched_option;
  Logger.debug ~level:2 "dynThreads parameter detected: %B" dyn_thread_option;
  if dyn_thread_option then
    if sched_option = "rr" then
      let rec context =
        { descr = (Structure {
          st_name = Some ("context");
          st_byte_size = Some (80);
          st_members =
            [ (0, "hw_context", hw_context);
              (60, "sched_context", scheduling_context);
              (72, "pid", mk (Base (4, "int")));
              (* XXX: hardcoded number of contexts per task *)
              (76, "range", with_ Pred.(uleq (Const (Z.of_int 8))) @@ mk (Base (4, "int")));
            ];
        }); const = false; pred = Pred.True; }

      and scheduling_context =
        { descr = (Structure {
          st_name = Some ("scheduling_context");
          st_byte_size = Some (12);
          st_members =
            [ (0, "wakeup_date", date_t);
              (8, "next", { descr = Ptr{pointed=(context);index=Zero}; pred = Pred.neq (Const Z.zero); const = false});
            ];
        }); const = false; pred = Pred.True; }
      in
      context
    else if sched_option = "edf" then
      let rec context =
        { descr = (Structure {
          st_name = Some ("context");
          st_byte_size = Some (88);
          st_members =
            [ (0, "hw_context", hw_context);
              (60, "sched_context", scheduling_context);
              (80, "pid", mk (Base (4, "int")));
              (* XXX: hardcoded number of contexts per task *)
              (84, "range", with_ Pred.(uleq (Const (Z.of_int 8))) @@ mk (Base (4, "int")));
            ];
        }); const = false; pred = Pred.True; }

      and scheduling_context =
        { descr = (Structure {
          st_name = Some ("scheduling_context");
          st_byte_size = Some (20);
          st_members =
            [ (0, "wakeup_date", date_t);
              (8, "deadline", date_t);
              (16, "next", { descr = Ptr{pointed=(context);index=Zero}; pred = Pred.True; const = false});
            ];
        }); const = false; pred = Pred.True; }
      in
      context
    else
      let rec context =
        { descr = (Structure {
          st_name = Some ("context");
          st_byte_size = Some (84);
          st_members =
            [ (0, "hw_context", hw_context);
              (60, "sched_context", scheduling_context);
              (76, "pid", mk (Base (4, "int")));
              (* XXX: hardcoded number of contexts per task *)
              (80, "range", with_ Pred.(uleq (Const (Z.of_int 8))) @@ mk (Base (4, "int")));
            ];
        }); const = false; pred = Pred.True; }

      and scheduling_context =
        { descr = (Structure {
          st_name = Some ("scheduling_context");
          st_byte_size = Some (16);
          st_members =
            [ (0, "wakeup_date", date_t);
              (8, "priority", mk (Base (4, "unsigned int")));
              (12, "next", {descr = Ptr {pointed = context; index = Zero};
                             const = false; pred =
                             Pred.True;});
            ];
        }); const = false; pred = Pred.True; }
      in
      context
  else
    if sched_option = "rr" then
      let rec context =
        { descr = (Structure {
          st_name = Some ("context");
          st_byte_size = Some (72);
          st_members =
            [ (0, "hw_context", hw_context);
              (60, "sched_context", scheduling_context);
            ];
        }); const = false; pred = Pred.True; }

      and scheduling_context =
        { descr = (Structure {
          st_name = Some ("scheduling_context");
          st_byte_size = Some (12);
          st_members =
            [ (0, "wakeup_date", date_t);
              (8, "next", { descr = Ptr{pointed=(context);index=Zero}; pred = Pred.neq (Const Z.zero); const = false});
            ];
        }); const = false; pred = Pred.True; }
      in
      context
    else if sched_option = "edf" then
      let rec context =
        { descr = (Structure {
          st_name = Some ("context");
          st_byte_size = Some (80);
          st_members =
            [ (0, "hw_context", hw_context);
              (60, "sched_context", scheduling_context);
            ];
        }); const = false; pred = Pred.True; }

      and scheduling_context =
        { descr = (Structure {
          st_name = Some ("scheduling_context");
          st_byte_size = Some (20);
          st_members =
            [ (0, "wakeup_date", date_t);
              (8, "deadline", date_t);
              (16, "next", { descr = Ptr{pointed=(context);index=Zero}; pred = Pred.True; const = false});
            ];
        }); const = false; pred = Pred.True; }
      in
      context
    else
      let rec context =
        { descr = (Structure {
          st_name = Some ("context");
          st_byte_size = Some (76);
          st_members =
            [ (0, "hw_context", hw_context);
              (60, "sched_context", scheduling_context);
            ];
        }); const = false; pred = Pred.True; }

      and scheduling_context =
        { descr = (Structure {
          st_name = Some ("scheduling_context");
          st_byte_size = Some (16);
          st_members =
            [ (0, "wakeup_date", date_t);
              (8, "priority", mk (Base (4, "unsigned int")));
              (12, "next", {descr = Ptr {pointed = context; index = Zero};
                             const = false; pred =
                             Pred.True;});
            ];
        }); const = false; pred = Pred.True; }
      in
      context

let task_description =
  mk (Structure {
    st_name = Some ("task_description");
    st_byte_size = (if Codex_options.X86Types.get () = "fp" then Some 20 else Some (16));
    st_members =
      [ (0, "context", const (ptr_notnull context));
        (4, "start_pc", const (uint32_t));
        (8, "task_begin", const (ptr_notnull (mk (Base (1, "char")))));
        (12, "task_end", const (ptr_notnull (mk (Base (1, "char")))));
      ] @ (if Codex_options.X86Types.get () = "fp" then
      [ (16, "priority", const (mk (Base (4, "unsigned int"))));
      ] else [])
      ;
  })


let user_tasks_image =
  mk (Structure {
    st_name = Some ("user_tasks_image");
    st_byte_size = Some (28);
    st_members =
      (*[ (0, "nb_tasks", const (mk (Base (4, "unsigned int"))));*)
      [ (0, "nb_tasks", const (with_ (Pred.eq (Sym "nb_tasks")) (mk @@ Base (4, "unsigned int"))));
        (4, "nb_contexts", const (mk (Base (4, "unsigned int"))));
        (*(4, "tasks", const (ptr_notnull (const (task_description))));*)
        (8, "tasks", const (ptr_notnull_idx (mk @@ Array (const (task_description), Some (Sym "nb_tasks"))) Zero));
        (*(8, "low_level", const (low_level_description));*)
        (*
        (8, "ready_heap_array", const (ptr_notnull (ptr_notnull (context))));
        (12, "waiting_heap_array", const (ptr_notnull (ptr_notnull (context))));
        *)
        (12, "idle_start", ptr_notnull (mk (Base (1, "char"))));
        (16, "idle_end", ptr_notnull (mk (Base (1, "char"))));
        (20, "idle_ctx_array", const (ptr_notnull (mk @@ Array (context, Some (Const nb_cpu)))));
        (24, "reserve", ptr_notnull (mk @@ Array (context, Some (Const (Z.of_int 10)))));
      ];
  })

(********** END OF AUTOGENERATED **********)

let unoption msg = function
| Some x -> x
| None -> raise (Invalid_argument ("unoption: " ^ msg))

let global_symbols =
  if Codex_options.AnalyzeKernel.get () then
    let _end_of_kernel = Loader_utils.address_of_symbol ~name:"_end_of_kernel"
      (Kernel_functions.get_img ()) |> unoption "no symbol _end_of_kernel"
    in
    [ ("nb_tasks", 32, Pred.(And (ugeq (Const Z.one), uleq (Const (Z.of_int 0x000f1234)))));
      ("end_of_kernel", 32, Pred.eq (Const (Z.of_int _end_of_kernel)));
    ]
  else
    []

let non_modifiable_types = []

let unique_array_types = []

let special_data_addrs = []
  (*
  let img = Kernel_functions.get_img () in
  let per_cpu = unoption "no symbol per_cpu" @@ Loader_utils.address_of_symbol ~name:"per_cpu" img in
  [per_cpu, (mk @@ Array (context, Some (Const nb_cpu)), 0)]
  *)

let root = ("user_tasks_image", user_tasks_image)

end
