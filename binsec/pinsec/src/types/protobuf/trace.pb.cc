// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: trace.proto

#include "trace.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
extern PROTOBUF_INTERNAL_EXPORT_common_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_memory_t_common_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_common_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_register_t_common_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_dba_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_dba_list_dba_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_libcall_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<31> scc_info_libcall_t_libcall_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_syscall_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<4> scc_info_syscall_t_syscall_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_trace_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<2> scc_info_body_t_trace_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_trace_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_header_t_trace_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_trace_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<4> scc_info_ins_con_info_t_trace_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_trace_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<2> scc_info_instruction_t_trace_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_trace_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_metadata_t_trace_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_trace_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_metadata_t_exception_t_trace_2eproto;
namespace trace_format {
class header_tDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<header_t> _instance;
} _header_t_default_instance_;
class metadata_t_exception_tDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<metadata_t_exception_t> _instance;
} _metadata_t_exception_t_default_instance_;
class metadata_tDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<metadata_t> _instance;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr module_metadata_;
  const ::trace_format::metadata_t_exception_t* exception_metadata_;
  ::PROTOBUF_NAMESPACE_ID::uint32 wave_metadata_;
} _metadata_t_default_instance_;
class ins_con_info_tDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<ins_con_info_t> _instance;
  const ::common::register_t* read_register_;
  const ::common::register_t* write_register_;
  const ::common::memory_t* load_memory_;
  const ::common::memory_t* store_memory_;
  const ::libcall_types::libcall_t* call_;
  const ::syscall_types::syscall_t* system_call_;
  ::PROTOBUF_NAMESPACE_ID::uint64 next_address_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr reserved_comment_;
  ::PROTOBUF_NAMESPACE_ID::uint32 wave_;
} _ins_con_info_t_default_instance_;
class instruction_tDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<instruction_t> _instance;
} _instruction_t_default_instance_;
class body_tDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<body_t> _instance;
  const ::trace_format::metadata_t* metadata_;
  const ::trace_format::instruction_t* instruction_;
} _body_t_default_instance_;
class chunk_tDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<chunk_t> _instance;
} _chunk_t_default_instance_;
class trace_tDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<trace_t> _instance;
} _trace_t_default_instance_;
}  // namespace trace_format
static void InitDefaultsscc_info_body_t_trace_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::trace_format::_body_t_default_instance_;
    new (ptr) ::trace_format::body_t();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::trace_format::body_t::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<2> scc_info_body_t_trace_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 2, InitDefaultsscc_info_body_t_trace_2eproto}, {
      &scc_info_metadata_t_trace_2eproto.base,
      &scc_info_instruction_t_trace_2eproto.base,}};

static void InitDefaultsscc_info_chunk_t_trace_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::trace_format::_chunk_t_default_instance_;
    new (ptr) ::trace_format::chunk_t();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::trace_format::chunk_t::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_chunk_t_trace_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 1, InitDefaultsscc_info_chunk_t_trace_2eproto}, {
      &scc_info_body_t_trace_2eproto.base,}};

static void InitDefaultsscc_info_header_t_trace_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::trace_format::_header_t_default_instance_;
    new (ptr) ::trace_format::header_t();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::trace_format::header_t::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_header_t_trace_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsscc_info_header_t_trace_2eproto}, {}};

static void InitDefaultsscc_info_ins_con_info_t_trace_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::trace_format::_ins_con_info_t_default_instance_;
    new (ptr) ::trace_format::ins_con_info_t();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::trace_format::ins_con_info_t::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<4> scc_info_ins_con_info_t_trace_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 4, InitDefaultsscc_info_ins_con_info_t_trace_2eproto}, {
      &scc_info_register_t_common_2eproto.base,
      &scc_info_memory_t_common_2eproto.base,
      &scc_info_libcall_t_libcall_2eproto.base,
      &scc_info_syscall_t_syscall_2eproto.base,}};

static void InitDefaultsscc_info_instruction_t_trace_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::trace_format::_instruction_t_default_instance_;
    new (ptr) ::trace_format::instruction_t();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::trace_format::instruction_t::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<2> scc_info_instruction_t_trace_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 2, InitDefaultsscc_info_instruction_t_trace_2eproto}, {
      &scc_info_ins_con_info_t_trace_2eproto.base,
      &scc_info_dba_list_dba_2eproto.base,}};

static void InitDefaultsscc_info_metadata_t_trace_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::trace_format::_metadata_t_default_instance_;
    new (ptr) ::trace_format::metadata_t();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::trace_format::metadata_t::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_metadata_t_trace_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 1, InitDefaultsscc_info_metadata_t_trace_2eproto}, {
      &scc_info_metadata_t_exception_t_trace_2eproto.base,}};

static void InitDefaultsscc_info_metadata_t_exception_t_trace_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::trace_format::_metadata_t_exception_t_default_instance_;
    new (ptr) ::trace_format::metadata_t_exception_t();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::trace_format::metadata_t_exception_t::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_metadata_t_exception_t_trace_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsscc_info_metadata_t_exception_t_trace_2eproto}, {}};

static void InitDefaultsscc_info_trace_t_trace_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::trace_format::_trace_t_default_instance_;
    new (ptr) ::trace_format::trace_t();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::trace_format::trace_t::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<2> scc_info_trace_t_trace_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 2, InitDefaultsscc_info_trace_t_trace_2eproto}, {
      &scc_info_header_t_trace_2eproto.base,
      &scc_info_body_t_trace_2eproto.base,}};

static ::PROTOBUF_NAMESPACE_ID::Metadata file_level_metadata_trace_2eproto[8];
static const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* file_level_enum_descriptors_trace_2eproto[4];
static constexpr ::PROTOBUF_NAMESPACE_ID::ServiceDescriptor const** file_level_service_descriptors_trace_2eproto = nullptr;

const ::PROTOBUF_NAMESPACE_ID::uint32 TableStruct_trace_2eproto::offsets[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  PROTOBUF_FIELD_OFFSET(::trace_format::header_t, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::trace_format::header_t, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::trace_format::header_t, architecture_),
  PROTOBUF_FIELD_OFFSET(::trace_format::header_t, address_size_),
  PROTOBUF_FIELD_OFFSET(::trace_format::header_t, kind_),
  0,
  1,
  2,
  PROTOBUF_FIELD_OFFSET(::trace_format::metadata_t_exception_t, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::trace_format::metadata_t_exception_t, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::trace_format::metadata_t_exception_t, type_exception_),
  PROTOBUF_FIELD_OFFSET(::trace_format::metadata_t_exception_t, handler_),
  1,
  0,
  PROTOBUF_FIELD_OFFSET(::trace_format::metadata_t, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::trace_format::metadata_t, _internal_metadata_),
  ~0u,  // no _extensions_
  PROTOBUF_FIELD_OFFSET(::trace_format::metadata_t, _oneof_case_[0]),
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::trace_format::metadata_t, typeid__),
  offsetof(::trace_format::metadata_tDefaultTypeInternal, module_metadata_),
  offsetof(::trace_format::metadata_tDefaultTypeInternal, exception_metadata_),
  offsetof(::trace_format::metadata_tDefaultTypeInternal, wave_metadata_),
  PROTOBUF_FIELD_OFFSET(::trace_format::metadata_t, metadata_content_),
  0,
  ~0u,
  ~0u,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::trace_format::ins_con_info_t, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::trace_format::ins_con_info_t, _internal_metadata_),
  ~0u,  // no _extensions_
  PROTOBUF_FIELD_OFFSET(::trace_format::ins_con_info_t, _oneof_case_[0]),
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::trace_format::ins_con_info_t, typeid__),
  offsetof(::trace_format::ins_con_info_tDefaultTypeInternal, read_register_),
  offsetof(::trace_format::ins_con_info_tDefaultTypeInternal, write_register_),
  offsetof(::trace_format::ins_con_info_tDefaultTypeInternal, load_memory_),
  offsetof(::trace_format::ins_con_info_tDefaultTypeInternal, store_memory_),
  offsetof(::trace_format::ins_con_info_tDefaultTypeInternal, call_),
  offsetof(::trace_format::ins_con_info_tDefaultTypeInternal, system_call_),
  offsetof(::trace_format::ins_con_info_tDefaultTypeInternal, next_address_),
  offsetof(::trace_format::ins_con_info_tDefaultTypeInternal, reserved_comment_),
  offsetof(::trace_format::ins_con_info_tDefaultTypeInternal, wave_),
  PROTOBUF_FIELD_OFFSET(::trace_format::ins_con_info_t, conc_info_content_),
  0,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::trace_format::instruction_t, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::trace_format::instruction_t, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::trace_format::instruction_t, thread_id_),
  PROTOBUF_FIELD_OFFSET(::trace_format::instruction_t, address_),
  PROTOBUF_FIELD_OFFSET(::trace_format::instruction_t, opcode_),
  PROTOBUF_FIELD_OFFSET(::trace_format::instruction_t, concrete_infos_),
  PROTOBUF_FIELD_OFFSET(::trace_format::instruction_t, dba_instrs_),
  3,
  2,
  0,
  ~0u,
  1,
  PROTOBUF_FIELD_OFFSET(::trace_format::body_t, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::trace_format::body_t, _internal_metadata_),
  ~0u,  // no _extensions_
  PROTOBUF_FIELD_OFFSET(::trace_format::body_t, _oneof_case_[0]),
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::trace_format::body_t, typeid__),
  offsetof(::trace_format::body_tDefaultTypeInternal, metadata_),
  offsetof(::trace_format::body_tDefaultTypeInternal, instruction_),
  PROTOBUF_FIELD_OFFSET(::trace_format::body_t, body_content_),
  0,
  ~0u,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::trace_format::chunk_t, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::trace_format::chunk_t, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::trace_format::chunk_t, body_),
  ~0u,
  PROTOBUF_FIELD_OFFSET(::trace_format::trace_t, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::trace_format::trace_t, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::trace_format::trace_t, header_),
  PROTOBUF_FIELD_OFFSET(::trace_format::trace_t, body_),
  0,
  ~0u,
};
static const ::PROTOBUF_NAMESPACE_ID::internal::MigrationSchema schemas[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  { 0, 8, sizeof(::trace_format::header_t)},
  { 11, 18, sizeof(::trace_format::metadata_t_exception_t)},
  { 20, 30, sizeof(::trace_format::metadata_t)},
  { 34, 50, sizeof(::trace_format::ins_con_info_t)},
  { 60, 70, sizeof(::trace_format::instruction_t)},
  { 75, 84, sizeof(::trace_format::body_t)},
  { 87, 93, sizeof(::trace_format::chunk_t)},
  { 94, 101, sizeof(::trace_format::trace_t)},
};

static ::PROTOBUF_NAMESPACE_ID::Message const * const file_default_instances[] = {
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::trace_format::_header_t_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::trace_format::_metadata_t_exception_t_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::trace_format::_metadata_t_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::trace_format::_ins_con_info_t_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::trace_format::_instruction_t_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::trace_format::_body_t_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::trace_format::_chunk_t_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::trace_format::_trace_t_default_instance_),
};

const char descriptor_table_protodef_trace_2eproto[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) =
  "\n\013trace.proto\022\014trace_format\032\tdba.proto\032\014"
  "common.proto\032\rsyscall.proto\032\rlibcall.pro"
  "to\"\300\001\n\010header_t\022;\n\014architecture\030\001 \002(\0162%."
  "trace_format.header_t.architecture_t\022*\n\014"
  "address_size\030\002 \002(\0162\024.common.proto_size_t"
  "\022$\n\004kind\030\003 \001(\0162\021.common.ir_kind_t:\003DBA\"%"
  "\n\016architecture_t\022\007\n\003X86\020\000\022\n\n\006X86_64\020\001\"\353\002"
  "\n\nmetadata_t\022:\n\006typeid\030\001 \002(\0162*.trace_for"
  "mat.metadata_t.typeid_metadata_t\022\031\n\017modu"
  "le_metadata\030\002 \001(\tH\000\022B\n\022exception_metadat"
  "a\030\003 \001(\0132$.trace_format.metadata_t.except"
  "ion_tH\000\022\027\n\rwave_metadata\030\004 \001(\rH\000\0326\n\013exce"
  "ption_t\022\026\n\016type_exception\030\001 \002(\r\022\017\n\007handl"
  "er\030\002 \002(\004\"]\n\021typeid_metadata_t\022\024\n\020INVALID"
  "_METADATA\020\000\022\022\n\016EXCEPTION_TYPE\020\001\022\017\n\013MODUL"
  "E_TYPE\020\002\022\r\n\tWAVE_TYPE\020\003B\022\n\020metadata_cont"
  "ent\"\336\004\n\016ins_con_info_t\022>\n\006typeid\030\001 \002(\0162."
  ".trace_format.ins_con_info_t.typeid_con_"
  "info_t\022+\n\rread_register\030\002 \001(\0132\022.common.r"
  "egister_tH\000\022,\n\016write_register\030\003 \001(\0132\022.co"
  "mmon.register_tH\000\022\'\n\013load_memory\030\004 \001(\0132\020"
  ".common.memory_tH\000\022(\n\014store_memory\030\005 \001(\013"
  "2\020.common.memory_tH\000\022(\n\004call\030\006 \001(\0132\030.lib"
  "call_types.libcall_tH\000\022/\n\013system_call\030\010 "
  "\001(\0132\030.syscall_types.syscall_tH\000\022\026\n\014next_"
  "address\030\t \001(\004H\000\022\032\n\020reserved_comment\030\n \001("
  "\tH\000\022\016\n\004wave\030\013 \001(\rH\000\"\251\001\n\021typeid_con_info_"
  "t\022\013\n\007INVALID\020\000\022\013\n\007REGREAD\020\001\022\014\n\010REGWRITE\020"
  "\002\022\013\n\007MEMLOAD\020\003\022\014\n\010MEMSTORE\020\004\022\010\n\004CALL\020\005\022\013"
  "\n\007SYSCALL\020\006\022\021\n\rNOT_RETRIEVED\020\007\022\020\n\014NEXT_A"
  "DDRESS\020\010\022\013\n\007COMMENT\020\t\022\010\n\004WAVE\020\nB\023\n\021conc_"
  "info_content\"\234\001\n\rinstruction_t\022\021\n\tthread"
  "_id\030\001 \002(\r\022\017\n\007address\030\002 \002(\004\022\016\n\006opcode\030\003 \002"
  "(\014\0224\n\016concrete_infos\030\004 \003(\0132\034.trace_forma"
  "t.ins_con_info_t\022!\n\ndba_instrs\030\005 \001(\0132\r.d"
  "ba.dba_list\"\336\001\n\006body_t\0222\n\006typeid\030\001 \002(\0162\""
  ".trace_format.body_t.typeid_body_t\022,\n\010me"
  "tadata\030\002 \001(\0132\030.trace_format.metadata_tH\000"
  "\0222\n\013instruction\030\003 \001(\0132\033.trace_format.ins"
  "truction_tH\000\".\n\rtypeid_body_t\022\014\n\010METADAT"
  "A\020\000\022\017\n\013INSTRUCTION\020\001B\016\n\014body_content\"-\n\007"
  "chunk_t\022\"\n\004body\030\001 \003(\0132\024.trace_format.bod"
  "y_t\"U\n\007trace_t\022&\n\006header\030\001 \002(\0132\026.trace_f"
  "ormat.header_t\022\"\n\004body\030\002 \003(\0132\024.trace_for"
  "mat.body_t"
  ;
static const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable*const descriptor_table_trace_2eproto_deps[4] = {
  &::descriptor_table_common_2eproto,
  &::descriptor_table_dba_2eproto,
  &::descriptor_table_libcall_2eproto,
  &::descriptor_table_syscall_2eproto,
};
static ::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase*const descriptor_table_trace_2eproto_sccs[8] = {
  &scc_info_body_t_trace_2eproto.base,
  &scc_info_chunk_t_trace_2eproto.base,
  &scc_info_header_t_trace_2eproto.base,
  &scc_info_ins_con_info_t_trace_2eproto.base,
  &scc_info_instruction_t_trace_2eproto.base,
  &scc_info_metadata_t_trace_2eproto.base,
  &scc_info_metadata_t_exception_t_trace_2eproto.base,
  &scc_info_trace_t_trace_2eproto.base,
};
static ::PROTOBUF_NAMESPACE_ID::internal::once_flag descriptor_table_trace_2eproto_once;
static bool descriptor_table_trace_2eproto_initialized = false;
const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_trace_2eproto = {
  &descriptor_table_trace_2eproto_initialized, descriptor_table_protodef_trace_2eproto, "trace.proto", 1770,
  &descriptor_table_trace_2eproto_once, descriptor_table_trace_2eproto_sccs, descriptor_table_trace_2eproto_deps, 8, 4,
  schemas, file_default_instances, TableStruct_trace_2eproto::offsets,
  file_level_metadata_trace_2eproto, 8, file_level_enum_descriptors_trace_2eproto, file_level_service_descriptors_trace_2eproto,
};

// Force running AddDescriptors() at dynamic initialization time.
static bool dynamic_init_dummy_trace_2eproto = (  ::PROTOBUF_NAMESPACE_ID::internal::AddDescriptors(&descriptor_table_trace_2eproto), true);
namespace trace_format {
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* header_t_architecture_t_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_trace_2eproto);
  return file_level_enum_descriptors_trace_2eproto[0];
}
bool header_t_architecture_t_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
constexpr header_t_architecture_t header_t::X86;
constexpr header_t_architecture_t header_t::X86_64;
constexpr header_t_architecture_t header_t::architecture_t_MIN;
constexpr header_t_architecture_t header_t::architecture_t_MAX;
constexpr int header_t::architecture_t_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* metadata_t_typeid_metadata_t_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_trace_2eproto);
  return file_level_enum_descriptors_trace_2eproto[1];
}
bool metadata_t_typeid_metadata_t_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
constexpr metadata_t_typeid_metadata_t metadata_t::INVALID_METADATA;
constexpr metadata_t_typeid_metadata_t metadata_t::EXCEPTION_TYPE;
constexpr metadata_t_typeid_metadata_t metadata_t::MODULE_TYPE;
constexpr metadata_t_typeid_metadata_t metadata_t::WAVE_TYPE;
constexpr metadata_t_typeid_metadata_t metadata_t::typeid_metadata_t_MIN;
constexpr metadata_t_typeid_metadata_t metadata_t::typeid_metadata_t_MAX;
constexpr int metadata_t::typeid_metadata_t_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ins_con_info_t_typeid_con_info_t_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_trace_2eproto);
  return file_level_enum_descriptors_trace_2eproto[2];
}
bool ins_con_info_t_typeid_con_info_t_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
constexpr ins_con_info_t_typeid_con_info_t ins_con_info_t::INVALID;
constexpr ins_con_info_t_typeid_con_info_t ins_con_info_t::REGREAD;
constexpr ins_con_info_t_typeid_con_info_t ins_con_info_t::REGWRITE;
constexpr ins_con_info_t_typeid_con_info_t ins_con_info_t::MEMLOAD;
constexpr ins_con_info_t_typeid_con_info_t ins_con_info_t::MEMSTORE;
constexpr ins_con_info_t_typeid_con_info_t ins_con_info_t::CALL;
constexpr ins_con_info_t_typeid_con_info_t ins_con_info_t::SYSCALL;
constexpr ins_con_info_t_typeid_con_info_t ins_con_info_t::NOT_RETRIEVED;
constexpr ins_con_info_t_typeid_con_info_t ins_con_info_t::NEXT_ADDRESS;
constexpr ins_con_info_t_typeid_con_info_t ins_con_info_t::COMMENT;
constexpr ins_con_info_t_typeid_con_info_t ins_con_info_t::WAVE;
constexpr ins_con_info_t_typeid_con_info_t ins_con_info_t::typeid_con_info_t_MIN;
constexpr ins_con_info_t_typeid_con_info_t ins_con_info_t::typeid_con_info_t_MAX;
constexpr int ins_con_info_t::typeid_con_info_t_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* body_t_typeid_body_t_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_trace_2eproto);
  return file_level_enum_descriptors_trace_2eproto[3];
}
bool body_t_typeid_body_t_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
constexpr body_t_typeid_body_t body_t::METADATA;
constexpr body_t_typeid_body_t body_t::INSTRUCTION;
constexpr body_t_typeid_body_t body_t::typeid_body_t_MIN;
constexpr body_t_typeid_body_t body_t::typeid_body_t_MAX;
constexpr int body_t::typeid_body_t_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)

// ===================================================================

void header_t::InitAsDefaultInstance() {
}
class header_t::_Internal {
 public:
  using HasBits = decltype(std::declval<header_t>()._has_bits_);
  static void set_has_architecture(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_address_size(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_kind(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

header_t::header_t()
  : ::PROTOBUF_NAMESPACE_ID::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:trace_format.header_t)
}
header_t::header_t(const header_t& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&architecture_, &from.architecture_,
    static_cast<size_t>(reinterpret_cast<char*>(&kind_) -
    reinterpret_cast<char*>(&architecture_)) + sizeof(kind_));
  // @@protoc_insertion_point(copy_constructor:trace_format.header_t)
}

void header_t::SharedCtor() {
  ::memset(&architecture_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&address_size_) -
      reinterpret_cast<char*>(&architecture_)) + sizeof(address_size_));
  kind_ = 1;
}

header_t::~header_t() {
  // @@protoc_insertion_point(destructor:trace_format.header_t)
  SharedDtor();
}

void header_t::SharedDtor() {
}

void header_t::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const header_t& header_t::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_header_t_trace_2eproto.base);
  return *internal_default_instance();
}


void header_t::Clear() {
// @@protoc_insertion_point(message_clear_start:trace_format.header_t)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    ::memset(&architecture_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&address_size_) -
        reinterpret_cast<char*>(&architecture_)) + sizeof(address_size_));
    kind_ = 1;
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* header_t::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // required .trace_format.header_t.architecture_t architecture = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::trace_format::header_t_architecture_t_IsValid(val))) {
            set_architecture(static_cast<::trace_format::header_t_architecture_t>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else goto handle_unusual;
        continue;
      // required .common.proto_size_t address_size = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::common::proto_size_t_IsValid(val))) {
            set_address_size(static_cast<::common::proto_size_t>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(2, val, mutable_unknown_fields());
          }
        } else goto handle_unusual;
        continue;
      // optional .common.ir_kind_t kind = 3 [default = DBA];
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::common::ir_kind_t_IsValid(val))) {
            set_kind(static_cast<::common::ir_kind_t>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(3, val, mutable_unknown_fields());
          }
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool header_t::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  // @@protoc_insertion_point(parse_start:trace_format.header_t)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .trace_format.header_t.architecture_t architecture = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (8 & 0xFF)) {
          int value = 0;
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   int, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::trace_format::header_t_architecture_t_IsValid(value)) {
            set_architecture(static_cast< ::trace_format::header_t_architecture_t >(value));
          } else {
            mutable_unknown_fields()->AddVarint(
                1, static_cast<::PROTOBUF_NAMESPACE_ID::uint64>(value));
          }
        } else {
          goto handle_unusual;
        }
        break;
      }

      // required .common.proto_size_t address_size = 2;
      case 2: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (16 & 0xFF)) {
          int value = 0;
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   int, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::common::proto_size_t_IsValid(value)) {
            set_address_size(static_cast< ::common::proto_size_t >(value));
          } else {
            mutable_unknown_fields()->AddVarint(
                2, static_cast<::PROTOBUF_NAMESPACE_ID::uint64>(value));
          }
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .common.ir_kind_t kind = 3 [default = DBA];
      case 3: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (24 & 0xFF)) {
          int value = 0;
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   int, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::common::ir_kind_t_IsValid(value)) {
            set_kind(static_cast< ::common::ir_kind_t >(value));
          } else {
            mutable_unknown_fields()->AddVarint(
                3, static_cast<::PROTOBUF_NAMESPACE_ID::uint64>(value));
          }
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:trace_format.header_t)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:trace_format.header_t)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void header_t::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:trace_format.header_t)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required .trace_format.header_t.architecture_t architecture = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnum(
      1, this->architecture(), output);
  }

  // required .common.proto_size_t address_size = 2;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnum(
      2, this->address_size(), output);
  }

  // optional .common.ir_kind_t kind = 3 [default = DBA];
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnum(
      3, this->kind(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:trace_format.header_t)
}

::PROTOBUF_NAMESPACE_ID::uint8* header_t::InternalSerializeWithCachedSizesToArray(
    ::PROTOBUF_NAMESPACE_ID::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:trace_format.header_t)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required .trace_format.header_t.architecture_t architecture = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      1, this->architecture(), target);
  }

  // required .common.proto_size_t address_size = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      2, this->address_size(), target);
  }

  // optional .common.ir_kind_t kind = 3 [default = DBA];
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      3, this->kind(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:trace_format.header_t)
  return target;
}

size_t header_t::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:trace_format.header_t)
  size_t total_size = 0;

  if (has_architecture()) {
    // required .trace_format.header_t.architecture_t architecture = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->architecture());
  }

  if (has_address_size()) {
    // required .common.proto_size_t address_size = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->address_size());
  }

  return total_size;
}
size_t header_t::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:trace_format.header_t)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  if (((_has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required .trace_format.header_t.architecture_t architecture = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->architecture());

    // required .common.proto_size_t address_size = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->address_size());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional .common.ir_kind_t kind = 3 [default = DBA];
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000004u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->kind());
  }

  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void header_t::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:trace_format.header_t)
  GOOGLE_DCHECK_NE(&from, this);
  const header_t* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<header_t>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:trace_format.header_t)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:trace_format.header_t)
    MergeFrom(*source);
  }
}

void header_t::MergeFrom(const header_t& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:trace_format.header_t)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      architecture_ = from.architecture_;
    }
    if (cached_has_bits & 0x00000002u) {
      address_size_ = from.address_size_;
    }
    if (cached_has_bits & 0x00000004u) {
      kind_ = from.kind_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void header_t::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:trace_format.header_t)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void header_t::CopyFrom(const header_t& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:trace_format.header_t)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool header_t::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;
  return true;
}

void header_t::InternalSwap(header_t* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(architecture_, other->architecture_);
  swap(address_size_, other->address_size_);
  swap(kind_, other->kind_);
}

::PROTOBUF_NAMESPACE_ID::Metadata header_t::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void metadata_t_exception_t::InitAsDefaultInstance() {
}
class metadata_t_exception_t::_Internal {
 public:
  using HasBits = decltype(std::declval<metadata_t_exception_t>()._has_bits_);
  static void set_has_type_exception(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_handler(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

metadata_t_exception_t::metadata_t_exception_t()
  : ::PROTOBUF_NAMESPACE_ID::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:trace_format.metadata_t.exception_t)
}
metadata_t_exception_t::metadata_t_exception_t(const metadata_t_exception_t& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&handler_, &from.handler_,
    static_cast<size_t>(reinterpret_cast<char*>(&type_exception_) -
    reinterpret_cast<char*>(&handler_)) + sizeof(type_exception_));
  // @@protoc_insertion_point(copy_constructor:trace_format.metadata_t.exception_t)
}

void metadata_t_exception_t::SharedCtor() {
  ::memset(&handler_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&type_exception_) -
      reinterpret_cast<char*>(&handler_)) + sizeof(type_exception_));
}

metadata_t_exception_t::~metadata_t_exception_t() {
  // @@protoc_insertion_point(destructor:trace_format.metadata_t.exception_t)
  SharedDtor();
}

void metadata_t_exception_t::SharedDtor() {
}

void metadata_t_exception_t::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const metadata_t_exception_t& metadata_t_exception_t::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_metadata_t_exception_t_trace_2eproto.base);
  return *internal_default_instance();
}


void metadata_t_exception_t::Clear() {
// @@protoc_insertion_point(message_clear_start:trace_format.metadata_t.exception_t)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&handler_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&type_exception_) -
        reinterpret_cast<char*>(&handler_)) + sizeof(type_exception_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* metadata_t_exception_t::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // required uint32 type_exception = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_type_exception(&has_bits);
          type_exception_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // required uint64 handler = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_handler(&has_bits);
          handler_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool metadata_t_exception_t::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  // @@protoc_insertion_point(parse_start:trace_format.metadata_t.exception_t)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 type_exception = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (8 & 0xFF)) {
          _Internal::set_has_type_exception(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32>(
                 input, &type_exception_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // required uint64 handler = 2;
      case 2: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (16 & 0xFF)) {
          _Internal::set_has_handler(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64>(
                 input, &handler_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:trace_format.metadata_t.exception_t)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:trace_format.metadata_t.exception_t)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void metadata_t_exception_t::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:trace_format.metadata_t.exception_t)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required uint32 type_exception = 1;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32(1, this->type_exception(), output);
  }

  // required uint64 handler = 2;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64(2, this->handler(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:trace_format.metadata_t.exception_t)
}

::PROTOBUF_NAMESPACE_ID::uint8* metadata_t_exception_t::InternalSerializeWithCachedSizesToArray(
    ::PROTOBUF_NAMESPACE_ID::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:trace_format.metadata_t.exception_t)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required uint32 type_exception = 1;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(1, this->type_exception(), target);
  }

  // required uint64 handler = 2;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(2, this->handler(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:trace_format.metadata_t.exception_t)
  return target;
}

size_t metadata_t_exception_t::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:trace_format.metadata_t.exception_t)
  size_t total_size = 0;

  if (has_handler()) {
    // required uint64 handler = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
        this->handler());
  }

  if (has_type_exception()) {
    // required uint32 type_exception = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
        this->type_exception());
  }

  return total_size;
}
size_t metadata_t_exception_t::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:trace_format.metadata_t.exception_t)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  if (((_has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required uint64 handler = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
        this->handler());

    // required uint32 type_exception = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
        this->type_exception());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void metadata_t_exception_t::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:trace_format.metadata_t.exception_t)
  GOOGLE_DCHECK_NE(&from, this);
  const metadata_t_exception_t* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<metadata_t_exception_t>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:trace_format.metadata_t.exception_t)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:trace_format.metadata_t.exception_t)
    MergeFrom(*source);
  }
}

void metadata_t_exception_t::MergeFrom(const metadata_t_exception_t& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:trace_format.metadata_t.exception_t)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      handler_ = from.handler_;
    }
    if (cached_has_bits & 0x00000002u) {
      type_exception_ = from.type_exception_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void metadata_t_exception_t::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:trace_format.metadata_t.exception_t)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void metadata_t_exception_t::CopyFrom(const metadata_t_exception_t& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:trace_format.metadata_t.exception_t)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool metadata_t_exception_t::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;
  return true;
}

void metadata_t_exception_t::InternalSwap(metadata_t_exception_t* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(handler_, other->handler_);
  swap(type_exception_, other->type_exception_);
}

::PROTOBUF_NAMESPACE_ID::Metadata metadata_t_exception_t::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void metadata_t::InitAsDefaultInstance() {
  ::trace_format::_metadata_t_default_instance_.module_metadata_.UnsafeSetDefault(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  ::trace_format::_metadata_t_default_instance_.exception_metadata_ = const_cast< ::trace_format::metadata_t_exception_t*>(
      ::trace_format::metadata_t_exception_t::internal_default_instance());
  ::trace_format::_metadata_t_default_instance_.wave_metadata_ = 0u;
}
class metadata_t::_Internal {
 public:
  using HasBits = decltype(std::declval<metadata_t>()._has_bits_);
  static void set_has_typeid_(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::trace_format::metadata_t_exception_t& exception_metadata(const metadata_t* msg);
};

const ::trace_format::metadata_t_exception_t&
metadata_t::_Internal::exception_metadata(const metadata_t* msg) {
  return *msg->metadata_content_.exception_metadata_;
}
void metadata_t::set_allocated_exception_metadata(::trace_format::metadata_t_exception_t* exception_metadata) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  clear_metadata_content();
  if (exception_metadata) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      exception_metadata = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, exception_metadata, submessage_arena);
    }
    set_has_exception_metadata();
    metadata_content_.exception_metadata_ = exception_metadata;
  }
  // @@protoc_insertion_point(field_set_allocated:trace_format.metadata_t.exception_metadata)
}
metadata_t::metadata_t()
  : ::PROTOBUF_NAMESPACE_ID::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:trace_format.metadata_t)
}
metadata_t::metadata_t(const metadata_t& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  typeid__ = from.typeid__;
  clear_has_metadata_content();
  switch (from.metadata_content_case()) {
    case kModuleMetadata: {
      set_module_metadata(from.module_metadata());
      break;
    }
    case kExceptionMetadata: {
      mutable_exception_metadata()->::trace_format::metadata_t_exception_t::MergeFrom(from.exception_metadata());
      break;
    }
    case kWaveMetadata: {
      set_wave_metadata(from.wave_metadata());
      break;
    }
    case METADATA_CONTENT_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:trace_format.metadata_t)
}

void metadata_t::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_metadata_t_trace_2eproto.base);
  typeid__ = 0;
  clear_has_metadata_content();
}

metadata_t::~metadata_t() {
  // @@protoc_insertion_point(destructor:trace_format.metadata_t)
  SharedDtor();
}

void metadata_t::SharedDtor() {
  if (has_metadata_content()) {
    clear_metadata_content();
  }
}

void metadata_t::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const metadata_t& metadata_t::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_metadata_t_trace_2eproto.base);
  return *internal_default_instance();
}


void metadata_t::clear_metadata_content() {
// @@protoc_insertion_point(one_of_clear_start:trace_format.metadata_t)
  switch (metadata_content_case()) {
    case kModuleMetadata: {
      metadata_content_.module_metadata_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
      break;
    }
    case kExceptionMetadata: {
      delete metadata_content_.exception_metadata_;
      break;
    }
    case kWaveMetadata: {
      // No need to clear
      break;
    }
    case METADATA_CONTENT_NOT_SET: {
      break;
    }
  }
  _oneof_case_[0] = METADATA_CONTENT_NOT_SET;
}


void metadata_t::Clear() {
// @@protoc_insertion_point(message_clear_start:trace_format.metadata_t)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  typeid__ = 0;
  clear_metadata_content();
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* metadata_t::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // required .trace_format.metadata_t.typeid_metadata_t typeid = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::trace_format::metadata_t_typeid_metadata_t_IsValid(val))) {
            set_typeid_(static_cast<::trace_format::metadata_t_typeid_metadata_t>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else goto handle_unusual;
        continue;
      // optional string module_metadata = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParserUTF8Verify(mutable_module_metadata(), ptr, ctx, "trace_format.metadata_t.module_metadata");
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .trace_format.metadata_t.exception_t exception_metadata = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26)) {
          ptr = ctx->ParseMessage(mutable_exception_metadata(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 wave_metadata = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 32)) {
          set_wave_metadata(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr));
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool metadata_t::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  // @@protoc_insertion_point(parse_start:trace_format.metadata_t)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .trace_format.metadata_t.typeid_metadata_t typeid = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (8 & 0xFF)) {
          int value = 0;
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   int, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::trace_format::metadata_t_typeid_metadata_t_IsValid(value)) {
            set_typeid_(static_cast< ::trace_format::metadata_t_typeid_metadata_t >(value));
          } else {
            mutable_unknown_fields()->AddVarint(
                1, static_cast<::PROTOBUF_NAMESPACE_ID::uint64>(value));
          }
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional string module_metadata = 2;
      case 2: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (18 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadString(
                input, this->mutable_module_metadata()));
          ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
            this->module_metadata().data(), static_cast<int>(this->module_metadata().length()),
            ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::PARSE,
            "trace_format.metadata_t.module_metadata");
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .trace_format.metadata_t.exception_t exception_metadata = 3;
      case 3: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (26 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadMessage(
               input, mutable_exception_metadata()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 wave_metadata = 4;
      case 4: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (32 & 0xFF)) {
          clear_metadata_content();
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32>(
                 input, &metadata_content_.wave_metadata_)));
          set_has_wave_metadata();
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:trace_format.metadata_t)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:trace_format.metadata_t)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void metadata_t::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:trace_format.metadata_t)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required .trace_format.metadata_t.typeid_metadata_t typeid = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnum(
      1, this->typeid_(), output);
  }

  switch (metadata_content_case()) {
    case kModuleMetadata:
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
        this->module_metadata().data(), static_cast<int>(this->module_metadata().length()),
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
        "trace_format.metadata_t.module_metadata");
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteStringMaybeAliased(
        2, this->module_metadata(), output);
      break;
    case kExceptionMetadata:
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteMessageMaybeToArray(
        3, _Internal::exception_metadata(this), output);
      break;
    case kWaveMetadata:
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32(4, this->wave_metadata(), output);
      break;
    default: ;
  }
  if (_internal_metadata_.have_unknown_fields()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:trace_format.metadata_t)
}

::PROTOBUF_NAMESPACE_ID::uint8* metadata_t::InternalSerializeWithCachedSizesToArray(
    ::PROTOBUF_NAMESPACE_ID::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:trace_format.metadata_t)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required .trace_format.metadata_t.typeid_metadata_t typeid = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      1, this->typeid_(), target);
  }

  switch (metadata_content_case()) {
    case kModuleMetadata:
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
        this->module_metadata().data(), static_cast<int>(this->module_metadata().length()),
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
        "trace_format.metadata_t.module_metadata");
      target =
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteStringToArray(
          2, this->module_metadata(), target);
      break;
    case kExceptionMetadata:
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessageToArray(
          3, _Internal::exception_metadata(this), target);
      break;
    case kWaveMetadata:
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(4, this->wave_metadata(), target);
      break;
    default: ;
  }
  if (_internal_metadata_.have_unknown_fields()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:trace_format.metadata_t)
  return target;
}

size_t metadata_t::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:trace_format.metadata_t)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  // required .trace_format.metadata_t.typeid_metadata_t typeid = 1;
  if (has_typeid_()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->typeid_());
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  switch (metadata_content_case()) {
    // optional string module_metadata = 2;
    case kModuleMetadata: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->module_metadata());
      break;
    }
    // optional .trace_format.metadata_t.exception_t exception_metadata = 3;
    case kExceptionMetadata: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *metadata_content_.exception_metadata_);
      break;
    }
    // optional uint32 wave_metadata = 4;
    case kWaveMetadata: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->wave_metadata());
      break;
    }
    case METADATA_CONTENT_NOT_SET: {
      break;
    }
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void metadata_t::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:trace_format.metadata_t)
  GOOGLE_DCHECK_NE(&from, this);
  const metadata_t* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<metadata_t>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:trace_format.metadata_t)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:trace_format.metadata_t)
    MergeFrom(*source);
  }
}

void metadata_t::MergeFrom(const metadata_t& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:trace_format.metadata_t)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from.has_typeid_()) {
    set_typeid_(from.typeid_());
  }
  switch (from.metadata_content_case()) {
    case kModuleMetadata: {
      set_module_metadata(from.module_metadata());
      break;
    }
    case kExceptionMetadata: {
      mutable_exception_metadata()->::trace_format::metadata_t_exception_t::MergeFrom(from.exception_metadata());
      break;
    }
    case kWaveMetadata: {
      set_wave_metadata(from.wave_metadata());
      break;
    }
    case METADATA_CONTENT_NOT_SET: {
      break;
    }
  }
}

void metadata_t::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:trace_format.metadata_t)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void metadata_t::CopyFrom(const metadata_t& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:trace_format.metadata_t)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool metadata_t::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;
  switch (metadata_content_case()) {
    case kModuleMetadata: {
      break;
    }
    case kExceptionMetadata: {
      if (has_exception_metadata()) {
        if (!this->exception_metadata().IsInitialized()) return false;
      }
      break;
    }
    case kWaveMetadata: {
      break;
    }
    case METADATA_CONTENT_NOT_SET: {
      break;
    }
  }
  return true;
}

void metadata_t::InternalSwap(metadata_t* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(typeid__, other->typeid__);
  swap(metadata_content_, other->metadata_content_);
  swap(_oneof_case_[0], other->_oneof_case_[0]);
}

::PROTOBUF_NAMESPACE_ID::Metadata metadata_t::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void ins_con_info_t::InitAsDefaultInstance() {
  ::trace_format::_ins_con_info_t_default_instance_.read_register_ = const_cast< ::common::register_t*>(
      ::common::register_t::internal_default_instance());
  ::trace_format::_ins_con_info_t_default_instance_.write_register_ = const_cast< ::common::register_t*>(
      ::common::register_t::internal_default_instance());
  ::trace_format::_ins_con_info_t_default_instance_.load_memory_ = const_cast< ::common::memory_t*>(
      ::common::memory_t::internal_default_instance());
  ::trace_format::_ins_con_info_t_default_instance_.store_memory_ = const_cast< ::common::memory_t*>(
      ::common::memory_t::internal_default_instance());
  ::trace_format::_ins_con_info_t_default_instance_.call_ = const_cast< ::libcall_types::libcall_t*>(
      ::libcall_types::libcall_t::internal_default_instance());
  ::trace_format::_ins_con_info_t_default_instance_.system_call_ = const_cast< ::syscall_types::syscall_t*>(
      ::syscall_types::syscall_t::internal_default_instance());
  ::trace_format::_ins_con_info_t_default_instance_.next_address_ = PROTOBUF_ULONGLONG(0);
  ::trace_format::_ins_con_info_t_default_instance_.reserved_comment_.UnsafeSetDefault(
      &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  ::trace_format::_ins_con_info_t_default_instance_.wave_ = 0u;
}
class ins_con_info_t::_Internal {
 public:
  using HasBits = decltype(std::declval<ins_con_info_t>()._has_bits_);
  static void set_has_typeid_(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::common::register_t& read_register(const ins_con_info_t* msg);
  static const ::common::register_t& write_register(const ins_con_info_t* msg);
  static const ::common::memory_t& load_memory(const ins_con_info_t* msg);
  static const ::common::memory_t& store_memory(const ins_con_info_t* msg);
  static const ::libcall_types::libcall_t& call(const ins_con_info_t* msg);
  static const ::syscall_types::syscall_t& system_call(const ins_con_info_t* msg);
};

const ::common::register_t&
ins_con_info_t::_Internal::read_register(const ins_con_info_t* msg) {
  return *msg->conc_info_content_.read_register_;
}
const ::common::register_t&
ins_con_info_t::_Internal::write_register(const ins_con_info_t* msg) {
  return *msg->conc_info_content_.write_register_;
}
const ::common::memory_t&
ins_con_info_t::_Internal::load_memory(const ins_con_info_t* msg) {
  return *msg->conc_info_content_.load_memory_;
}
const ::common::memory_t&
ins_con_info_t::_Internal::store_memory(const ins_con_info_t* msg) {
  return *msg->conc_info_content_.store_memory_;
}
const ::libcall_types::libcall_t&
ins_con_info_t::_Internal::call(const ins_con_info_t* msg) {
  return *msg->conc_info_content_.call_;
}
const ::syscall_types::syscall_t&
ins_con_info_t::_Internal::system_call(const ins_con_info_t* msg) {
  return *msg->conc_info_content_.system_call_;
}
void ins_con_info_t::set_allocated_read_register(::common::register_t* read_register) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  clear_conc_info_content();
  if (read_register) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      read_register = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, read_register, submessage_arena);
    }
    set_has_read_register();
    conc_info_content_.read_register_ = read_register;
  }
  // @@protoc_insertion_point(field_set_allocated:trace_format.ins_con_info_t.read_register)
}
void ins_con_info_t::clear_read_register() {
  if (has_read_register()) {
    delete conc_info_content_.read_register_;
    clear_has_conc_info_content();
  }
}
void ins_con_info_t::set_allocated_write_register(::common::register_t* write_register) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  clear_conc_info_content();
  if (write_register) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      write_register = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, write_register, submessage_arena);
    }
    set_has_write_register();
    conc_info_content_.write_register_ = write_register;
  }
  // @@protoc_insertion_point(field_set_allocated:trace_format.ins_con_info_t.write_register)
}
void ins_con_info_t::clear_write_register() {
  if (has_write_register()) {
    delete conc_info_content_.write_register_;
    clear_has_conc_info_content();
  }
}
void ins_con_info_t::set_allocated_load_memory(::common::memory_t* load_memory) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  clear_conc_info_content();
  if (load_memory) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      load_memory = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, load_memory, submessage_arena);
    }
    set_has_load_memory();
    conc_info_content_.load_memory_ = load_memory;
  }
  // @@protoc_insertion_point(field_set_allocated:trace_format.ins_con_info_t.load_memory)
}
void ins_con_info_t::clear_load_memory() {
  if (has_load_memory()) {
    delete conc_info_content_.load_memory_;
    clear_has_conc_info_content();
  }
}
void ins_con_info_t::set_allocated_store_memory(::common::memory_t* store_memory) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  clear_conc_info_content();
  if (store_memory) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      store_memory = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, store_memory, submessage_arena);
    }
    set_has_store_memory();
    conc_info_content_.store_memory_ = store_memory;
  }
  // @@protoc_insertion_point(field_set_allocated:trace_format.ins_con_info_t.store_memory)
}
void ins_con_info_t::clear_store_memory() {
  if (has_store_memory()) {
    delete conc_info_content_.store_memory_;
    clear_has_conc_info_content();
  }
}
void ins_con_info_t::set_allocated_call(::libcall_types::libcall_t* call) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  clear_conc_info_content();
  if (call) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      call = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, call, submessage_arena);
    }
    set_has_call();
    conc_info_content_.call_ = call;
  }
  // @@protoc_insertion_point(field_set_allocated:trace_format.ins_con_info_t.call)
}
void ins_con_info_t::clear_call() {
  if (has_call()) {
    delete conc_info_content_.call_;
    clear_has_conc_info_content();
  }
}
void ins_con_info_t::set_allocated_system_call(::syscall_types::syscall_t* system_call) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  clear_conc_info_content();
  if (system_call) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      system_call = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, system_call, submessage_arena);
    }
    set_has_system_call();
    conc_info_content_.system_call_ = system_call;
  }
  // @@protoc_insertion_point(field_set_allocated:trace_format.ins_con_info_t.system_call)
}
void ins_con_info_t::clear_system_call() {
  if (has_system_call()) {
    delete conc_info_content_.system_call_;
    clear_has_conc_info_content();
  }
}
ins_con_info_t::ins_con_info_t()
  : ::PROTOBUF_NAMESPACE_ID::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:trace_format.ins_con_info_t)
}
ins_con_info_t::ins_con_info_t(const ins_con_info_t& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  typeid__ = from.typeid__;
  clear_has_conc_info_content();
  switch (from.conc_info_content_case()) {
    case kReadRegister: {
      mutable_read_register()->::common::register_t::MergeFrom(from.read_register());
      break;
    }
    case kWriteRegister: {
      mutable_write_register()->::common::register_t::MergeFrom(from.write_register());
      break;
    }
    case kLoadMemory: {
      mutable_load_memory()->::common::memory_t::MergeFrom(from.load_memory());
      break;
    }
    case kStoreMemory: {
      mutable_store_memory()->::common::memory_t::MergeFrom(from.store_memory());
      break;
    }
    case kCall: {
      mutable_call()->::libcall_types::libcall_t::MergeFrom(from.call());
      break;
    }
    case kSystemCall: {
      mutable_system_call()->::syscall_types::syscall_t::MergeFrom(from.system_call());
      break;
    }
    case kNextAddress: {
      set_next_address(from.next_address());
      break;
    }
    case kReservedComment: {
      set_reserved_comment(from.reserved_comment());
      break;
    }
    case kWave: {
      set_wave(from.wave());
      break;
    }
    case CONC_INFO_CONTENT_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:trace_format.ins_con_info_t)
}

void ins_con_info_t::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_ins_con_info_t_trace_2eproto.base);
  typeid__ = 0;
  clear_has_conc_info_content();
}

ins_con_info_t::~ins_con_info_t() {
  // @@protoc_insertion_point(destructor:trace_format.ins_con_info_t)
  SharedDtor();
}

void ins_con_info_t::SharedDtor() {
  if (has_conc_info_content()) {
    clear_conc_info_content();
  }
}

void ins_con_info_t::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const ins_con_info_t& ins_con_info_t::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_ins_con_info_t_trace_2eproto.base);
  return *internal_default_instance();
}


void ins_con_info_t::clear_conc_info_content() {
// @@protoc_insertion_point(one_of_clear_start:trace_format.ins_con_info_t)
  switch (conc_info_content_case()) {
    case kReadRegister: {
      delete conc_info_content_.read_register_;
      break;
    }
    case kWriteRegister: {
      delete conc_info_content_.write_register_;
      break;
    }
    case kLoadMemory: {
      delete conc_info_content_.load_memory_;
      break;
    }
    case kStoreMemory: {
      delete conc_info_content_.store_memory_;
      break;
    }
    case kCall: {
      delete conc_info_content_.call_;
      break;
    }
    case kSystemCall: {
      delete conc_info_content_.system_call_;
      break;
    }
    case kNextAddress: {
      // No need to clear
      break;
    }
    case kReservedComment: {
      conc_info_content_.reserved_comment_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
      break;
    }
    case kWave: {
      // No need to clear
      break;
    }
    case CONC_INFO_CONTENT_NOT_SET: {
      break;
    }
  }
  _oneof_case_[0] = CONC_INFO_CONTENT_NOT_SET;
}


void ins_con_info_t::Clear() {
// @@protoc_insertion_point(message_clear_start:trace_format.ins_con_info_t)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  typeid__ = 0;
  clear_conc_info_content();
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* ins_con_info_t::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // required .trace_format.ins_con_info_t.typeid_con_info_t typeid = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::trace_format::ins_con_info_t_typeid_con_info_t_IsValid(val))) {
            set_typeid_(static_cast<::trace_format::ins_con_info_t_typeid_con_info_t>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else goto handle_unusual;
        continue;
      // optional .common.register_t read_register = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          ptr = ctx->ParseMessage(mutable_read_register(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .common.register_t write_register = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26)) {
          ptr = ctx->ParseMessage(mutable_write_register(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .common.memory_t load_memory = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 34)) {
          ptr = ctx->ParseMessage(mutable_load_memory(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .common.memory_t store_memory = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 42)) {
          ptr = ctx->ParseMessage(mutable_store_memory(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .libcall_types.libcall_t call = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 50)) {
          ptr = ctx->ParseMessage(mutable_call(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .syscall_types.syscall_t system_call = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 66)) {
          ptr = ctx->ParseMessage(mutable_system_call(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint64 next_address = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 72)) {
          set_next_address(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr));
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional string reserved_comment = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 82)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParserUTF8Verify(mutable_reserved_comment(), ptr, ctx, "trace_format.ins_con_info_t.reserved_comment");
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 wave = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 88)) {
          set_wave(::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr));
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool ins_con_info_t::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  // @@protoc_insertion_point(parse_start:trace_format.ins_con_info_t)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .trace_format.ins_con_info_t.typeid_con_info_t typeid = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (8 & 0xFF)) {
          int value = 0;
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   int, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::trace_format::ins_con_info_t_typeid_con_info_t_IsValid(value)) {
            set_typeid_(static_cast< ::trace_format::ins_con_info_t_typeid_con_info_t >(value));
          } else {
            mutable_unknown_fields()->AddVarint(
                1, static_cast<::PROTOBUF_NAMESPACE_ID::uint64>(value));
          }
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .common.register_t read_register = 2;
      case 2: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (18 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadMessage(
               input, mutable_read_register()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .common.register_t write_register = 3;
      case 3: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (26 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadMessage(
               input, mutable_write_register()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .common.memory_t load_memory = 4;
      case 4: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (34 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadMessage(
               input, mutable_load_memory()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .common.memory_t store_memory = 5;
      case 5: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (42 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadMessage(
               input, mutable_store_memory()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .libcall_types.libcall_t call = 6;
      case 6: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (50 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadMessage(
               input, mutable_call()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .syscall_types.syscall_t system_call = 8;
      case 8: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (66 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadMessage(
               input, mutable_system_call()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint64 next_address = 9;
      case 9: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (72 & 0xFF)) {
          clear_conc_info_content();
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64>(
                 input, &conc_info_content_.next_address_)));
          set_has_next_address();
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional string reserved_comment = 10;
      case 10: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (82 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadString(
                input, this->mutable_reserved_comment()));
          ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
            this->reserved_comment().data(), static_cast<int>(this->reserved_comment().length()),
            ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::PARSE,
            "trace_format.ins_con_info_t.reserved_comment");
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 wave = 11;
      case 11: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (88 & 0xFF)) {
          clear_conc_info_content();
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32>(
                 input, &conc_info_content_.wave_)));
          set_has_wave();
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:trace_format.ins_con_info_t)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:trace_format.ins_con_info_t)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void ins_con_info_t::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:trace_format.ins_con_info_t)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required .trace_format.ins_con_info_t.typeid_con_info_t typeid = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnum(
      1, this->typeid_(), output);
  }

  switch (conc_info_content_case()) {
    case kReadRegister:
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteMessageMaybeToArray(
        2, _Internal::read_register(this), output);
      break;
    case kWriteRegister:
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteMessageMaybeToArray(
        3, _Internal::write_register(this), output);
      break;
    case kLoadMemory:
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteMessageMaybeToArray(
        4, _Internal::load_memory(this), output);
      break;
    case kStoreMemory:
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteMessageMaybeToArray(
        5, _Internal::store_memory(this), output);
      break;
    case kCall:
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteMessageMaybeToArray(
        6, _Internal::call(this), output);
      break;
    case kSystemCall:
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteMessageMaybeToArray(
        8, _Internal::system_call(this), output);
      break;
    case kNextAddress:
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64(9, this->next_address(), output);
      break;
    case kReservedComment:
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
        this->reserved_comment().data(), static_cast<int>(this->reserved_comment().length()),
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
        "trace_format.ins_con_info_t.reserved_comment");
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteStringMaybeAliased(
        10, this->reserved_comment(), output);
      break;
    case kWave:
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32(11, this->wave(), output);
      break;
    default: ;
  }
  if (_internal_metadata_.have_unknown_fields()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:trace_format.ins_con_info_t)
}

::PROTOBUF_NAMESPACE_ID::uint8* ins_con_info_t::InternalSerializeWithCachedSizesToArray(
    ::PROTOBUF_NAMESPACE_ID::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:trace_format.ins_con_info_t)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required .trace_format.ins_con_info_t.typeid_con_info_t typeid = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      1, this->typeid_(), target);
  }

  switch (conc_info_content_case()) {
    case kReadRegister:
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessageToArray(
          2, _Internal::read_register(this), target);
      break;
    case kWriteRegister:
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessageToArray(
          3, _Internal::write_register(this), target);
      break;
    case kLoadMemory:
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessageToArray(
          4, _Internal::load_memory(this), target);
      break;
    case kStoreMemory:
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessageToArray(
          5, _Internal::store_memory(this), target);
      break;
    case kCall:
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessageToArray(
          6, _Internal::call(this), target);
      break;
    case kSystemCall:
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessageToArray(
          8, _Internal::system_call(this), target);
      break;
    case kNextAddress:
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(9, this->next_address(), target);
      break;
    case kReservedComment:
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
        this->reserved_comment().data(), static_cast<int>(this->reserved_comment().length()),
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
        "trace_format.ins_con_info_t.reserved_comment");
      target =
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteStringToArray(
          10, this->reserved_comment(), target);
      break;
    case kWave:
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(11, this->wave(), target);
      break;
    default: ;
  }
  if (_internal_metadata_.have_unknown_fields()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:trace_format.ins_con_info_t)
  return target;
}

size_t ins_con_info_t::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:trace_format.ins_con_info_t)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  // required .trace_format.ins_con_info_t.typeid_con_info_t typeid = 1;
  if (has_typeid_()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->typeid_());
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  switch (conc_info_content_case()) {
    // optional .common.register_t read_register = 2;
    case kReadRegister: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *conc_info_content_.read_register_);
      break;
    }
    // optional .common.register_t write_register = 3;
    case kWriteRegister: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *conc_info_content_.write_register_);
      break;
    }
    // optional .common.memory_t load_memory = 4;
    case kLoadMemory: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *conc_info_content_.load_memory_);
      break;
    }
    // optional .common.memory_t store_memory = 5;
    case kStoreMemory: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *conc_info_content_.store_memory_);
      break;
    }
    // optional .libcall_types.libcall_t call = 6;
    case kCall: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *conc_info_content_.call_);
      break;
    }
    // optional .syscall_types.syscall_t system_call = 8;
    case kSystemCall: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *conc_info_content_.system_call_);
      break;
    }
    // optional uint64 next_address = 9;
    case kNextAddress: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
          this->next_address());
      break;
    }
    // optional string reserved_comment = 10;
    case kReservedComment: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->reserved_comment());
      break;
    }
    // optional uint32 wave = 11;
    case kWave: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->wave());
      break;
    }
    case CONC_INFO_CONTENT_NOT_SET: {
      break;
    }
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ins_con_info_t::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:trace_format.ins_con_info_t)
  GOOGLE_DCHECK_NE(&from, this);
  const ins_con_info_t* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<ins_con_info_t>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:trace_format.ins_con_info_t)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:trace_format.ins_con_info_t)
    MergeFrom(*source);
  }
}

void ins_con_info_t::MergeFrom(const ins_con_info_t& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:trace_format.ins_con_info_t)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from.has_typeid_()) {
    set_typeid_(from.typeid_());
  }
  switch (from.conc_info_content_case()) {
    case kReadRegister: {
      mutable_read_register()->::common::register_t::MergeFrom(from.read_register());
      break;
    }
    case kWriteRegister: {
      mutable_write_register()->::common::register_t::MergeFrom(from.write_register());
      break;
    }
    case kLoadMemory: {
      mutable_load_memory()->::common::memory_t::MergeFrom(from.load_memory());
      break;
    }
    case kStoreMemory: {
      mutable_store_memory()->::common::memory_t::MergeFrom(from.store_memory());
      break;
    }
    case kCall: {
      mutable_call()->::libcall_types::libcall_t::MergeFrom(from.call());
      break;
    }
    case kSystemCall: {
      mutable_system_call()->::syscall_types::syscall_t::MergeFrom(from.system_call());
      break;
    }
    case kNextAddress: {
      set_next_address(from.next_address());
      break;
    }
    case kReservedComment: {
      set_reserved_comment(from.reserved_comment());
      break;
    }
    case kWave: {
      set_wave(from.wave());
      break;
    }
    case CONC_INFO_CONTENT_NOT_SET: {
      break;
    }
  }
}

void ins_con_info_t::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:trace_format.ins_con_info_t)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ins_con_info_t::CopyFrom(const ins_con_info_t& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:trace_format.ins_con_info_t)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ins_con_info_t::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;
  switch (conc_info_content_case()) {
    case kReadRegister: {
      if (has_read_register()) {
        if (!this->read_register().IsInitialized()) return false;
      }
      break;
    }
    case kWriteRegister: {
      if (has_write_register()) {
        if (!this->write_register().IsInitialized()) return false;
      }
      break;
    }
    case kLoadMemory: {
      if (has_load_memory()) {
        if (!this->load_memory().IsInitialized()) return false;
      }
      break;
    }
    case kStoreMemory: {
      if (has_store_memory()) {
        if (!this->store_memory().IsInitialized()) return false;
      }
      break;
    }
    case kCall: {
      if (has_call()) {
        if (!this->call().IsInitialized()) return false;
      }
      break;
    }
    case kSystemCall: {
      if (has_system_call()) {
        if (!this->system_call().IsInitialized()) return false;
      }
      break;
    }
    case kNextAddress: {
      break;
    }
    case kReservedComment: {
      break;
    }
    case kWave: {
      break;
    }
    case CONC_INFO_CONTENT_NOT_SET: {
      break;
    }
  }
  return true;
}

void ins_con_info_t::InternalSwap(ins_con_info_t* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(typeid__, other->typeid__);
  swap(conc_info_content_, other->conc_info_content_);
  swap(_oneof_case_[0], other->_oneof_case_[0]);
}

::PROTOBUF_NAMESPACE_ID::Metadata ins_con_info_t::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void instruction_t::InitAsDefaultInstance() {
  ::trace_format::_instruction_t_default_instance_._instance.get_mutable()->dba_instrs_ = const_cast< ::dba::dba_list*>(
      ::dba::dba_list::internal_default_instance());
}
class instruction_t::_Internal {
 public:
  using HasBits = decltype(std::declval<instruction_t>()._has_bits_);
  static void set_has_thread_id(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_address(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_opcode(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::dba::dba_list& dba_instrs(const instruction_t* msg);
  static void set_has_dba_instrs(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::dba::dba_list&
instruction_t::_Internal::dba_instrs(const instruction_t* msg) {
  return *msg->dba_instrs_;
}
void instruction_t::clear_dba_instrs() {
  if (dba_instrs_ != nullptr) dba_instrs_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
instruction_t::instruction_t()
  : ::PROTOBUF_NAMESPACE_ID::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:trace_format.instruction_t)
}
instruction_t::instruction_t(const instruction_t& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_),
      concrete_infos_(from.concrete_infos_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  opcode_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from.has_opcode()) {
    opcode_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.opcode_);
  }
  if (from.has_dba_instrs()) {
    dba_instrs_ = new ::dba::dba_list(*from.dba_instrs_);
  } else {
    dba_instrs_ = nullptr;
  }
  ::memcpy(&address_, &from.address_,
    static_cast<size_t>(reinterpret_cast<char*>(&thread_id_) -
    reinterpret_cast<char*>(&address_)) + sizeof(thread_id_));
  // @@protoc_insertion_point(copy_constructor:trace_format.instruction_t)
}

void instruction_t::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_instruction_t_trace_2eproto.base);
  opcode_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  ::memset(&dba_instrs_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&thread_id_) -
      reinterpret_cast<char*>(&dba_instrs_)) + sizeof(thread_id_));
}

instruction_t::~instruction_t() {
  // @@protoc_insertion_point(destructor:trace_format.instruction_t)
  SharedDtor();
}

void instruction_t::SharedDtor() {
  opcode_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (this != internal_default_instance()) delete dba_instrs_;
}

void instruction_t::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const instruction_t& instruction_t::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_instruction_t_trace_2eproto.base);
  return *internal_default_instance();
}


void instruction_t::Clear() {
// @@protoc_insertion_point(message_clear_start:trace_format.instruction_t)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  concrete_infos_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      opcode_.ClearNonDefaultToEmptyNoArena();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(dba_instrs_ != nullptr);
      dba_instrs_->Clear();
    }
  }
  if (cached_has_bits & 0x0000000cu) {
    ::memset(&address_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&thread_id_) -
        reinterpret_cast<char*>(&address_)) + sizeof(thread_id_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* instruction_t::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // required uint32 thread_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_thread_id(&has_bits);
          thread_id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // required uint64 address = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_address(&has_bits);
          address_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // required bytes opcode = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParser(mutable_opcode(), ptr, ctx);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // repeated .trace_format.ins_con_info_t concrete_infos = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 34)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(add_concrete_infos(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<::PROTOBUF_NAMESPACE_ID::uint8>(ptr) == 34);
        } else goto handle_unusual;
        continue;
      // optional .dba.dba_list dba_instrs = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 42)) {
          ptr = ctx->ParseMessage(mutable_dba_instrs(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool instruction_t::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  // @@protoc_insertion_point(parse_start:trace_format.instruction_t)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint32 thread_id = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (8 & 0xFF)) {
          _Internal::set_has_thread_id(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32>(
                 input, &thread_id_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // required uint64 address = 2;
      case 2: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (16 & 0xFF)) {
          _Internal::set_has_address(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64>(
                 input, &address_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // required bytes opcode = 3;
      case 3: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (26 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadBytes(
                input, this->mutable_opcode()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated .trace_format.ins_con_info_t concrete_infos = 4;
      case 4: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (34 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadMessage(
                input, add_concrete_infos()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .dba.dba_list dba_instrs = 5;
      case 5: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (42 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadMessage(
               input, mutable_dba_instrs()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:trace_format.instruction_t)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:trace_format.instruction_t)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void instruction_t::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:trace_format.instruction_t)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required uint32 thread_id = 1;
  if (cached_has_bits & 0x00000008u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32(1, this->thread_id(), output);
  }

  // required uint64 address = 2;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64(2, this->address(), output);
  }

  // required bytes opcode = 3;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBytesMaybeAliased(
      3, this->opcode(), output);
  }

  // repeated .trace_format.ins_con_info_t concrete_infos = 4;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->concrete_infos_size()); i < n; i++) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteMessageMaybeToArray(
      4,
      this->concrete_infos(static_cast<int>(i)),
      output);
  }

  // optional .dba.dba_list dba_instrs = 5;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteMessageMaybeToArray(
      5, _Internal::dba_instrs(this), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:trace_format.instruction_t)
}

::PROTOBUF_NAMESPACE_ID::uint8* instruction_t::InternalSerializeWithCachedSizesToArray(
    ::PROTOBUF_NAMESPACE_ID::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:trace_format.instruction_t)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required uint32 thread_id = 1;
  if (cached_has_bits & 0x00000008u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(1, this->thread_id(), target);
  }

  // required uint64 address = 2;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(2, this->address(), target);
  }

  // required bytes opcode = 3;
  if (cached_has_bits & 0x00000001u) {
    target =
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteBytesToArray(
        3, this->opcode(), target);
  }

  // repeated .trace_format.ins_con_info_t concrete_infos = 4;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->concrete_infos_size()); i < n; i++) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessageToArray(
        4, this->concrete_infos(static_cast<int>(i)), target);
  }

  // optional .dba.dba_list dba_instrs = 5;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessageToArray(
        5, _Internal::dba_instrs(this), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:trace_format.instruction_t)
  return target;
}

size_t instruction_t::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:trace_format.instruction_t)
  size_t total_size = 0;

  if (has_opcode()) {
    // required bytes opcode = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->opcode());
  }

  if (has_address()) {
    // required uint64 address = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
        this->address());
  }

  if (has_thread_id()) {
    // required uint32 thread_id = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
        this->thread_id());
  }

  return total_size;
}
size_t instruction_t::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:trace_format.instruction_t)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  if (((_has_bits_[0] & 0x0000000d) ^ 0x0000000d) == 0) {  // All required fields are present.
    // required bytes opcode = 3;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->opcode());

    // required uint64 address = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
        this->address());

    // required uint32 thread_id = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
        this->thread_id());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .trace_format.ins_con_info_t concrete_infos = 4;
  {
    unsigned int count = static_cast<unsigned int>(this->concrete_infos_size());
    total_size += 1UL * count;
    for (unsigned int i = 0; i < count; i++) {
      total_size +=
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          this->concrete_infos(static_cast<int>(i)));
    }
  }

  // optional .dba.dba_list dba_instrs = 5;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000002u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *dba_instrs_);
  }

  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void instruction_t::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:trace_format.instruction_t)
  GOOGLE_DCHECK_NE(&from, this);
  const instruction_t* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<instruction_t>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:trace_format.instruction_t)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:trace_format.instruction_t)
    MergeFrom(*source);
  }
}

void instruction_t::MergeFrom(const instruction_t& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:trace_format.instruction_t)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  concrete_infos_.MergeFrom(from.concrete_infos_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      _has_bits_[0] |= 0x00000001u;
      opcode_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.opcode_);
    }
    if (cached_has_bits & 0x00000002u) {
      mutable_dba_instrs()->::dba::dba_list::MergeFrom(from.dba_instrs());
    }
    if (cached_has_bits & 0x00000004u) {
      address_ = from.address_;
    }
    if (cached_has_bits & 0x00000008u) {
      thread_id_ = from.thread_id_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void instruction_t::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:trace_format.instruction_t)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void instruction_t::CopyFrom(const instruction_t& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:trace_format.instruction_t)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool instruction_t::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000000d) != 0x0000000d) return false;
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(this->concrete_infos())) return false;
  if (has_dba_instrs()) {
    if (!this->dba_instrs_->IsInitialized()) return false;
  }
  return true;
}

void instruction_t::InternalSwap(instruction_t* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  CastToBase(&concrete_infos_)->InternalSwap(CastToBase(&other->concrete_infos_));
  opcode_.Swap(&other->opcode_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  swap(dba_instrs_, other->dba_instrs_);
  swap(address_, other->address_);
  swap(thread_id_, other->thread_id_);
}

::PROTOBUF_NAMESPACE_ID::Metadata instruction_t::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void body_t::InitAsDefaultInstance() {
  ::trace_format::_body_t_default_instance_.metadata_ = const_cast< ::trace_format::metadata_t*>(
      ::trace_format::metadata_t::internal_default_instance());
  ::trace_format::_body_t_default_instance_.instruction_ = const_cast< ::trace_format::instruction_t*>(
      ::trace_format::instruction_t::internal_default_instance());
}
class body_t::_Internal {
 public:
  using HasBits = decltype(std::declval<body_t>()._has_bits_);
  static void set_has_typeid_(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::trace_format::metadata_t& metadata(const body_t* msg);
  static const ::trace_format::instruction_t& instruction(const body_t* msg);
};

const ::trace_format::metadata_t&
body_t::_Internal::metadata(const body_t* msg) {
  return *msg->body_content_.metadata_;
}
const ::trace_format::instruction_t&
body_t::_Internal::instruction(const body_t* msg) {
  return *msg->body_content_.instruction_;
}
void body_t::set_allocated_metadata(::trace_format::metadata_t* metadata) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  clear_body_content();
  if (metadata) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      metadata = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, metadata, submessage_arena);
    }
    set_has_metadata();
    body_content_.metadata_ = metadata;
  }
  // @@protoc_insertion_point(field_set_allocated:trace_format.body_t.metadata)
}
void body_t::set_allocated_instruction(::trace_format::instruction_t* instruction) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  clear_body_content();
  if (instruction) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      instruction = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, instruction, submessage_arena);
    }
    set_has_instruction();
    body_content_.instruction_ = instruction;
  }
  // @@protoc_insertion_point(field_set_allocated:trace_format.body_t.instruction)
}
body_t::body_t()
  : ::PROTOBUF_NAMESPACE_ID::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:trace_format.body_t)
}
body_t::body_t(const body_t& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  typeid__ = from.typeid__;
  clear_has_body_content();
  switch (from.body_content_case()) {
    case kMetadata: {
      mutable_metadata()->::trace_format::metadata_t::MergeFrom(from.metadata());
      break;
    }
    case kInstruction: {
      mutable_instruction()->::trace_format::instruction_t::MergeFrom(from.instruction());
      break;
    }
    case BODY_CONTENT_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:trace_format.body_t)
}

void body_t::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_body_t_trace_2eproto.base);
  typeid__ = 0;
  clear_has_body_content();
}

body_t::~body_t() {
  // @@protoc_insertion_point(destructor:trace_format.body_t)
  SharedDtor();
}

void body_t::SharedDtor() {
  if (has_body_content()) {
    clear_body_content();
  }
}

void body_t::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const body_t& body_t::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_body_t_trace_2eproto.base);
  return *internal_default_instance();
}


void body_t::clear_body_content() {
// @@protoc_insertion_point(one_of_clear_start:trace_format.body_t)
  switch (body_content_case()) {
    case kMetadata: {
      delete body_content_.metadata_;
      break;
    }
    case kInstruction: {
      delete body_content_.instruction_;
      break;
    }
    case BODY_CONTENT_NOT_SET: {
      break;
    }
  }
  _oneof_case_[0] = BODY_CONTENT_NOT_SET;
}


void body_t::Clear() {
// @@protoc_insertion_point(message_clear_start:trace_format.body_t)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  typeid__ = 0;
  clear_body_content();
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* body_t::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // required .trace_format.body_t.typeid_body_t typeid = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::trace_format::body_t_typeid_body_t_IsValid(val))) {
            set_typeid_(static_cast<::trace_format::body_t_typeid_body_t>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else goto handle_unusual;
        continue;
      // optional .trace_format.metadata_t metadata = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          ptr = ctx->ParseMessage(mutable_metadata(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .trace_format.instruction_t instruction = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26)) {
          ptr = ctx->ParseMessage(mutable_instruction(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool body_t::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  // @@protoc_insertion_point(parse_start:trace_format.body_t)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .trace_format.body_t.typeid_body_t typeid = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (8 & 0xFF)) {
          int value = 0;
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   int, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::trace_format::body_t_typeid_body_t_IsValid(value)) {
            set_typeid_(static_cast< ::trace_format::body_t_typeid_body_t >(value));
          } else {
            mutable_unknown_fields()->AddVarint(
                1, static_cast<::PROTOBUF_NAMESPACE_ID::uint64>(value));
          }
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .trace_format.metadata_t metadata = 2;
      case 2: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (18 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadMessage(
               input, mutable_metadata()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .trace_format.instruction_t instruction = 3;
      case 3: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (26 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadMessage(
               input, mutable_instruction()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:trace_format.body_t)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:trace_format.body_t)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void body_t::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:trace_format.body_t)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required .trace_format.body_t.typeid_body_t typeid = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnum(
      1, this->typeid_(), output);
  }

  switch (body_content_case()) {
    case kMetadata:
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteMessageMaybeToArray(
        2, _Internal::metadata(this), output);
      break;
    case kInstruction:
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteMessageMaybeToArray(
        3, _Internal::instruction(this), output);
      break;
    default: ;
  }
  if (_internal_metadata_.have_unknown_fields()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:trace_format.body_t)
}

::PROTOBUF_NAMESPACE_ID::uint8* body_t::InternalSerializeWithCachedSizesToArray(
    ::PROTOBUF_NAMESPACE_ID::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:trace_format.body_t)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required .trace_format.body_t.typeid_body_t typeid = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      1, this->typeid_(), target);
  }

  switch (body_content_case()) {
    case kMetadata:
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessageToArray(
          2, _Internal::metadata(this), target);
      break;
    case kInstruction:
      target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessageToArray(
          3, _Internal::instruction(this), target);
      break;
    default: ;
  }
  if (_internal_metadata_.have_unknown_fields()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:trace_format.body_t)
  return target;
}

size_t body_t::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:trace_format.body_t)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  // required .trace_format.body_t.typeid_body_t typeid = 1;
  if (has_typeid_()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->typeid_());
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  switch (body_content_case()) {
    // optional .trace_format.metadata_t metadata = 2;
    case kMetadata: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *body_content_.metadata_);
      break;
    }
    // optional .trace_format.instruction_t instruction = 3;
    case kInstruction: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *body_content_.instruction_);
      break;
    }
    case BODY_CONTENT_NOT_SET: {
      break;
    }
  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void body_t::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:trace_format.body_t)
  GOOGLE_DCHECK_NE(&from, this);
  const body_t* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<body_t>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:trace_format.body_t)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:trace_format.body_t)
    MergeFrom(*source);
  }
}

void body_t::MergeFrom(const body_t& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:trace_format.body_t)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  if (from.has_typeid_()) {
    set_typeid_(from.typeid_());
  }
  switch (from.body_content_case()) {
    case kMetadata: {
      mutable_metadata()->::trace_format::metadata_t::MergeFrom(from.metadata());
      break;
    }
    case kInstruction: {
      mutable_instruction()->::trace_format::instruction_t::MergeFrom(from.instruction());
      break;
    }
    case BODY_CONTENT_NOT_SET: {
      break;
    }
  }
}

void body_t::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:trace_format.body_t)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void body_t::CopyFrom(const body_t& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:trace_format.body_t)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool body_t::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;
  switch (body_content_case()) {
    case kMetadata: {
      if (has_metadata()) {
        if (!this->metadata().IsInitialized()) return false;
      }
      break;
    }
    case kInstruction: {
      if (has_instruction()) {
        if (!this->instruction().IsInitialized()) return false;
      }
      break;
    }
    case BODY_CONTENT_NOT_SET: {
      break;
    }
  }
  return true;
}

void body_t::InternalSwap(body_t* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(typeid__, other->typeid__);
  swap(body_content_, other->body_content_);
  swap(_oneof_case_[0], other->_oneof_case_[0]);
}

::PROTOBUF_NAMESPACE_ID::Metadata body_t::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void chunk_t::InitAsDefaultInstance() {
}
class chunk_t::_Internal {
 public:
  using HasBits = decltype(std::declval<chunk_t>()._has_bits_);
};

chunk_t::chunk_t()
  : ::PROTOBUF_NAMESPACE_ID::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:trace_format.chunk_t)
}
chunk_t::chunk_t(const chunk_t& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_),
      body_(from.body_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:trace_format.chunk_t)
}

void chunk_t::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_chunk_t_trace_2eproto.base);
}

chunk_t::~chunk_t() {
  // @@protoc_insertion_point(destructor:trace_format.chunk_t)
  SharedDtor();
}

void chunk_t::SharedDtor() {
}

void chunk_t::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const chunk_t& chunk_t::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_chunk_t_trace_2eproto.base);
  return *internal_default_instance();
}


void chunk_t::Clear() {
// @@protoc_insertion_point(message_clear_start:trace_format.chunk_t)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  body_.Clear();
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* chunk_t::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // repeated .trace_format.body_t body = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(add_body(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<::PROTOBUF_NAMESPACE_ID::uint8>(ptr) == 10);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool chunk_t::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  // @@protoc_insertion_point(parse_start:trace_format.chunk_t)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .trace_format.body_t body = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (10 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadMessage(
                input, add_body()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:trace_format.chunk_t)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:trace_format.chunk_t)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void chunk_t::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:trace_format.chunk_t)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .trace_format.body_t body = 1;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->body_size()); i < n; i++) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteMessageMaybeToArray(
      1,
      this->body(static_cast<int>(i)),
      output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:trace_format.chunk_t)
}

::PROTOBUF_NAMESPACE_ID::uint8* chunk_t::InternalSerializeWithCachedSizesToArray(
    ::PROTOBUF_NAMESPACE_ID::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:trace_format.chunk_t)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .trace_format.body_t body = 1;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->body_size()); i < n; i++) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessageToArray(
        1, this->body(static_cast<int>(i)), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:trace_format.chunk_t)
  return target;
}

size_t chunk_t::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:trace_format.chunk_t)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .trace_format.body_t body = 1;
  {
    unsigned int count = static_cast<unsigned int>(this->body_size());
    total_size += 1UL * count;
    for (unsigned int i = 0; i < count; i++) {
      total_size +=
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          this->body(static_cast<int>(i)));
    }
  }

  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void chunk_t::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:trace_format.chunk_t)
  GOOGLE_DCHECK_NE(&from, this);
  const chunk_t* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<chunk_t>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:trace_format.chunk_t)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:trace_format.chunk_t)
    MergeFrom(*source);
  }
}

void chunk_t::MergeFrom(const chunk_t& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:trace_format.chunk_t)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  body_.MergeFrom(from.body_);
}

void chunk_t::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:trace_format.chunk_t)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void chunk_t::CopyFrom(const chunk_t& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:trace_format.chunk_t)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool chunk_t::IsInitialized() const {
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(this->body())) return false;
  return true;
}

void chunk_t::InternalSwap(chunk_t* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  CastToBase(&body_)->InternalSwap(CastToBase(&other->body_));
}

::PROTOBUF_NAMESPACE_ID::Metadata chunk_t::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void trace_t::InitAsDefaultInstance() {
  ::trace_format::_trace_t_default_instance_._instance.get_mutable()->header_ = const_cast< ::trace_format::header_t*>(
      ::trace_format::header_t::internal_default_instance());
}
class trace_t::_Internal {
 public:
  using HasBits = decltype(std::declval<trace_t>()._has_bits_);
  static const ::trace_format::header_t& header(const trace_t* msg);
  static void set_has_header(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::trace_format::header_t&
trace_t::_Internal::header(const trace_t* msg) {
  return *msg->header_;
}
trace_t::trace_t()
  : ::PROTOBUF_NAMESPACE_ID::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:trace_format.trace_t)
}
trace_t::trace_t(const trace_t& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_),
      body_(from.body_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  if (from.has_header()) {
    header_ = new ::trace_format::header_t(*from.header_);
  } else {
    header_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:trace_format.trace_t)
}

void trace_t::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_trace_t_trace_2eproto.base);
  header_ = nullptr;
}

trace_t::~trace_t() {
  // @@protoc_insertion_point(destructor:trace_format.trace_t)
  SharedDtor();
}

void trace_t::SharedDtor() {
  if (this != internal_default_instance()) delete header_;
}

void trace_t::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const trace_t& trace_t::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_trace_t_trace_2eproto.base);
  return *internal_default_instance();
}


void trace_t::Clear() {
// @@protoc_insertion_point(message_clear_start:trace_format.trace_t)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  body_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(header_ != nullptr);
    header_->Clear();
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* trace_t::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // required .trace_format.header_t header = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr = ctx->ParseMessage(mutable_header(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // repeated .trace_format.body_t body = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(add_body(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<::PROTOBUF_NAMESPACE_ID::uint8>(ptr) == 18);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool trace_t::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  // @@protoc_insertion_point(parse_start:trace_format.trace_t)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .trace_format.header_t header = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (10 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadMessage(
               input, mutable_header()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated .trace_format.body_t body = 2;
      case 2: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (18 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadMessage(
                input, add_body()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:trace_format.trace_t)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:trace_format.trace_t)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void trace_t::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:trace_format.trace_t)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required .trace_format.header_t header = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, _Internal::header(this), output);
  }

  // repeated .trace_format.body_t body = 2;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->body_size()); i < n; i++) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteMessageMaybeToArray(
      2,
      this->body(static_cast<int>(i)),
      output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:trace_format.trace_t)
}

::PROTOBUF_NAMESPACE_ID::uint8* trace_t::InternalSerializeWithCachedSizesToArray(
    ::PROTOBUF_NAMESPACE_ID::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:trace_format.trace_t)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required .trace_format.header_t header = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessageToArray(
        1, _Internal::header(this), target);
  }

  // repeated .trace_format.body_t body = 2;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->body_size()); i < n; i++) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessageToArray(
        2, this->body(static_cast<int>(i)), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:trace_format.trace_t)
  return target;
}

size_t trace_t::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:trace_format.trace_t)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  // required .trace_format.header_t header = 1;
  if (has_header()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *header_);
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .trace_format.body_t body = 2;
  {
    unsigned int count = static_cast<unsigned int>(this->body_size());
    total_size += 1UL * count;
    for (unsigned int i = 0; i < count; i++) {
      total_size +=
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          this->body(static_cast<int>(i)));
    }
  }

  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void trace_t::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:trace_format.trace_t)
  GOOGLE_DCHECK_NE(&from, this);
  const trace_t* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<trace_t>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:trace_format.trace_t)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:trace_format.trace_t)
    MergeFrom(*source);
  }
}

void trace_t::MergeFrom(const trace_t& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:trace_format.trace_t)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  body_.MergeFrom(from.body_);
  if (from.has_header()) {
    mutable_header()->::trace_format::header_t::MergeFrom(from.header());
  }
}

void trace_t::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:trace_format.trace_t)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void trace_t::CopyFrom(const trace_t& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:trace_format.trace_t)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool trace_t::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(this->body())) return false;
  if (has_header()) {
    if (!this->header_->IsInitialized()) return false;
  }
  return true;
}

void trace_t::InternalSwap(trace_t* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  CastToBase(&body_)->InternalSwap(CastToBase(&other->body_));
  swap(header_, other->header_);
}

::PROTOBUF_NAMESPACE_ID::Metadata trace_t::GetMetadata() const {
  return GetMetadataStatic();
}


// @@protoc_insertion_point(namespace_scope)
}  // namespace trace_format
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::trace_format::header_t* Arena::CreateMaybeMessage< ::trace_format::header_t >(Arena* arena) {
  return Arena::CreateInternal< ::trace_format::header_t >(arena);
}
template<> PROTOBUF_NOINLINE ::trace_format::metadata_t_exception_t* Arena::CreateMaybeMessage< ::trace_format::metadata_t_exception_t >(Arena* arena) {
  return Arena::CreateInternal< ::trace_format::metadata_t_exception_t >(arena);
}
template<> PROTOBUF_NOINLINE ::trace_format::metadata_t* Arena::CreateMaybeMessage< ::trace_format::metadata_t >(Arena* arena) {
  return Arena::CreateInternal< ::trace_format::metadata_t >(arena);
}
template<> PROTOBUF_NOINLINE ::trace_format::ins_con_info_t* Arena::CreateMaybeMessage< ::trace_format::ins_con_info_t >(Arena* arena) {
  return Arena::CreateInternal< ::trace_format::ins_con_info_t >(arena);
}
template<> PROTOBUF_NOINLINE ::trace_format::instruction_t* Arena::CreateMaybeMessage< ::trace_format::instruction_t >(Arena* arena) {
  return Arena::CreateInternal< ::trace_format::instruction_t >(arena);
}
template<> PROTOBUF_NOINLINE ::trace_format::body_t* Arena::CreateMaybeMessage< ::trace_format::body_t >(Arena* arena) {
  return Arena::CreateInternal< ::trace_format::body_t >(arena);
}
template<> PROTOBUF_NOINLINE ::trace_format::chunk_t* Arena::CreateMaybeMessage< ::trace_format::chunk_t >(Arena* arena) {
  return Arena::CreateInternal< ::trace_format::chunk_t >(arena);
}
template<> PROTOBUF_NOINLINE ::trace_format::trace_t* Arena::CreateMaybeMessage< ::trace_format::trace_t >(Arena* arena) {
  return Arena::CreateInternal< ::trace_format::trace_t >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
