// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: dba.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_dba_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_dba_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3009000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3009001 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_dba_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_dba_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxillaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[10]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_dba_2eproto;
namespace dba {
class bitvector;
class bitvectorDefaultTypeInternal;
extern bitvectorDefaultTypeInternal _bitvector_default_instance_;
class codeaddress;
class codeaddressDefaultTypeInternal;
extern codeaddressDefaultTypeInternal _codeaddress_default_instance_;
class dbaLhs;
class dbaLhsDefaultTypeInternal;
extern dbaLhsDefaultTypeInternal _dbaLhs_default_instance_;
class dba_list;
class dba_listDefaultTypeInternal;
extern dba_listDefaultTypeInternal _dba_list_default_instance_;
class dbacodeaddress;
class dbacodeaddressDefaultTypeInternal;
extern dbacodeaddressDefaultTypeInternal _dbacodeaddress_default_instance_;
class dbacond;
class dbacondDefaultTypeInternal;
extern dbacondDefaultTypeInternal _dbacond_default_instance_;
class dbaexpr;
class dbaexprDefaultTypeInternal;
extern dbaexprDefaultTypeInternal _dbaexpr_default_instance_;
class dbainstr;
class dbainstrDefaultTypeInternal;
extern dbainstrDefaultTypeInternal _dbainstr_default_instance_;
class dbastopstate;
class dbastopstateDefaultTypeInternal;
extern dbastopstateDefaultTypeInternal _dbastopstate_default_instance_;
class dbatag;
class dbatagDefaultTypeInternal;
extern dbatagDefaultTypeInternal _dbatag_default_instance_;
}  // namespace dba
PROTOBUF_NAMESPACE_OPEN
template<> ::dba::bitvector* Arena::CreateMaybeMessage<::dba::bitvector>(Arena*);
template<> ::dba::codeaddress* Arena::CreateMaybeMessage<::dba::codeaddress>(Arena*);
template<> ::dba::dbaLhs* Arena::CreateMaybeMessage<::dba::dbaLhs>(Arena*);
template<> ::dba::dba_list* Arena::CreateMaybeMessage<::dba::dba_list>(Arena*);
template<> ::dba::dbacodeaddress* Arena::CreateMaybeMessage<::dba::dbacodeaddress>(Arena*);
template<> ::dba::dbacond* Arena::CreateMaybeMessage<::dba::dbacond>(Arena*);
template<> ::dba::dbaexpr* Arena::CreateMaybeMessage<::dba::dbaexpr>(Arena*);
template<> ::dba::dbainstr* Arena::CreateMaybeMessage<::dba::dbainstr>(Arena*);
template<> ::dba::dbastopstate* Arena::CreateMaybeMessage<::dba::dbastopstate>(Arena*);
template<> ::dba::dbatag* Arena::CreateMaybeMessage<::dba::dbatag>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace dba {

enum codeaddress_typeid_codeaddress : int {
  codeaddress_typeid_codeaddress_Local = 0,
  codeaddress_typeid_codeaddress_NonLocal = 1
};
bool codeaddress_typeid_codeaddress_IsValid(int value);
constexpr codeaddress_typeid_codeaddress codeaddress_typeid_codeaddress_typeid_codeaddress_MIN = codeaddress_typeid_codeaddress_Local;
constexpr codeaddress_typeid_codeaddress codeaddress_typeid_codeaddress_typeid_codeaddress_MAX = codeaddress_typeid_codeaddress_NonLocal;
constexpr int codeaddress_typeid_codeaddress_typeid_codeaddress_ARRAYSIZE = codeaddress_typeid_codeaddress_typeid_codeaddress_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* codeaddress_typeid_codeaddress_descriptor();
template<typename T>
inline const std::string& codeaddress_typeid_codeaddress_Name(T enum_t_value) {
  static_assert(::std::is_same<T, codeaddress_typeid_codeaddress>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function codeaddress_typeid_codeaddress_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    codeaddress_typeid_codeaddress_descriptor(), enum_t_value);
}
inline bool codeaddress_typeid_codeaddress_Parse(
    const std::string& name, codeaddress_typeid_codeaddress* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<codeaddress_typeid_codeaddress>(
    codeaddress_typeid_codeaddress_descriptor(), name, value);
}
enum dbatag_typeid_dbatag : int {
  dbatag_typeid_dbatag_DbaCall = 1,
  dbatag_typeid_dbatag_DbaReturn = 2
};
bool dbatag_typeid_dbatag_IsValid(int value);
constexpr dbatag_typeid_dbatag dbatag_typeid_dbatag_typeid_dbatag_MIN = dbatag_typeid_dbatag_DbaCall;
constexpr dbatag_typeid_dbatag dbatag_typeid_dbatag_typeid_dbatag_MAX = dbatag_typeid_dbatag_DbaReturn;
constexpr int dbatag_typeid_dbatag_typeid_dbatag_ARRAYSIZE = dbatag_typeid_dbatag_typeid_dbatag_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* dbatag_typeid_dbatag_descriptor();
template<typename T>
inline const std::string& dbatag_typeid_dbatag_Name(T enum_t_value) {
  static_assert(::std::is_same<T, dbatag_typeid_dbatag>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function dbatag_typeid_dbatag_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    dbatag_typeid_dbatag_descriptor(), enum_t_value);
}
inline bool dbatag_typeid_dbatag_Parse(
    const std::string& name, dbatag_typeid_dbatag* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<dbatag_typeid_dbatag>(
    dbatag_typeid_dbatag_descriptor(), name, value);
}
enum dbastopstate_typeid_dbastate : int {
  dbastopstate_typeid_dbastate_Ok = 1,
  dbastopstate_typeid_dbastate_Ko = 2,
  dbastopstate_typeid_dbastate_Undefined = 3,
  dbastopstate_typeid_dbastate_Unsupported = 4
};
bool dbastopstate_typeid_dbastate_IsValid(int value);
constexpr dbastopstate_typeid_dbastate dbastopstate_typeid_dbastate_typeid_dbastate_MIN = dbastopstate_typeid_dbastate_Ok;
constexpr dbastopstate_typeid_dbastate dbastopstate_typeid_dbastate_typeid_dbastate_MAX = dbastopstate_typeid_dbastate_Unsupported;
constexpr int dbastopstate_typeid_dbastate_typeid_dbastate_ARRAYSIZE = dbastopstate_typeid_dbastate_typeid_dbastate_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* dbastopstate_typeid_dbastate_descriptor();
template<typename T>
inline const std::string& dbastopstate_typeid_dbastate_Name(T enum_t_value) {
  static_assert(::std::is_same<T, dbastopstate_typeid_dbastate>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function dbastopstate_typeid_dbastate_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    dbastopstate_typeid_dbastate_descriptor(), enum_t_value);
}
inline bool dbastopstate_typeid_dbastate_Parse(
    const std::string& name, dbastopstate_typeid_dbastate* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<dbastopstate_typeid_dbastate>(
    dbastopstate_typeid_dbastate_descriptor(), name, value);
}
enum dbaexpr_typeid_dbaexpr : int {
  dbaexpr_typeid_dbaexpr_DbaExprVar = 1,
  dbaexpr_typeid_dbaexpr_DbaLoad = 2,
  dbaexpr_typeid_dbaexpr_DbaExprCst = 3,
  dbaexpr_typeid_dbaexpr_DbaExprUnary = 4,
  dbaexpr_typeid_dbaexpr_DbaExprBinary = 5,
  dbaexpr_typeid_dbaexpr_DbaExprRestrict = 6,
  dbaexpr_typeid_dbaexpr_DbaExprExtU = 7,
  dbaexpr_typeid_dbaexpr_DbaExprExtS = 8,
  dbaexpr_typeid_dbaexpr_DbaExprIte = 9,
  dbaexpr_typeid_dbaexpr_DbaExprAlternative = 10
};
bool dbaexpr_typeid_dbaexpr_IsValid(int value);
constexpr dbaexpr_typeid_dbaexpr dbaexpr_typeid_dbaexpr_typeid_dbaexpr_MIN = dbaexpr_typeid_dbaexpr_DbaExprVar;
constexpr dbaexpr_typeid_dbaexpr dbaexpr_typeid_dbaexpr_typeid_dbaexpr_MAX = dbaexpr_typeid_dbaexpr_DbaExprAlternative;
constexpr int dbaexpr_typeid_dbaexpr_typeid_dbaexpr_ARRAYSIZE = dbaexpr_typeid_dbaexpr_typeid_dbaexpr_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* dbaexpr_typeid_dbaexpr_descriptor();
template<typename T>
inline const std::string& dbaexpr_typeid_dbaexpr_Name(T enum_t_value) {
  static_assert(::std::is_same<T, dbaexpr_typeid_dbaexpr>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function dbaexpr_typeid_dbaexpr_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    dbaexpr_typeid_dbaexpr_descriptor(), enum_t_value);
}
inline bool dbaexpr_typeid_dbaexpr_Parse(
    const std::string& name, dbaexpr_typeid_dbaexpr* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<dbaexpr_typeid_dbaexpr>(
    dbaexpr_typeid_dbaexpr_descriptor(), name, value);
}
enum dbaexpr_dbaunary : int {
  dbaexpr_dbaunary_DbaUnaryMinus = 1,
  dbaexpr_dbaunary_DbaUnaryNot = 2
};
bool dbaexpr_dbaunary_IsValid(int value);
constexpr dbaexpr_dbaunary dbaexpr_dbaunary_dbaunary_MIN = dbaexpr_dbaunary_DbaUnaryMinus;
constexpr dbaexpr_dbaunary dbaexpr_dbaunary_dbaunary_MAX = dbaexpr_dbaunary_DbaUnaryNot;
constexpr int dbaexpr_dbaunary_dbaunary_ARRAYSIZE = dbaexpr_dbaunary_dbaunary_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* dbaexpr_dbaunary_descriptor();
template<typename T>
inline const std::string& dbaexpr_dbaunary_Name(T enum_t_value) {
  static_assert(::std::is_same<T, dbaexpr_dbaunary>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function dbaexpr_dbaunary_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    dbaexpr_dbaunary_descriptor(), enum_t_value);
}
inline bool dbaexpr_dbaunary_Parse(
    const std::string& name, dbaexpr_dbaunary* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<dbaexpr_dbaunary>(
    dbaexpr_dbaunary_descriptor(), name, value);
}
enum dbaexpr_dbabinary : int {
  dbaexpr_dbabinary_DbaPlus = 1,
  dbaexpr_dbabinary_DbaMinus = 2,
  dbaexpr_dbabinary_DbaMultU = 3,
  dbaexpr_dbabinary_DbaMultS = 4,
  dbaexpr_dbabinary_DbaDivU = 6,
  dbaexpr_dbabinary_DbaDivS = 7,
  dbaexpr_dbabinary_DbaModU = 8,
  dbaexpr_dbabinary_DbaModS = 9,
  dbaexpr_dbabinary_DbaOr = 10,
  dbaexpr_dbabinary_DbaAnd = 11,
  dbaexpr_dbabinary_DbaXor = 12,
  dbaexpr_dbabinary_DbaConcat = 13,
  dbaexpr_dbabinary_DbaLShiftU = 14,
  dbaexpr_dbabinary_DbaRShiftU = 15,
  dbaexpr_dbabinary_DbaRShiftS = 16,
  dbaexpr_dbabinary_DbaLeftRotate = 17,
  dbaexpr_dbabinary_DbaRightRotate = 18,
  dbaexpr_dbabinary_DbaEq = 19,
  dbaexpr_dbabinary_DbaDiff = 20,
  dbaexpr_dbabinary_DbaLeqU = 21,
  dbaexpr_dbabinary_DbaLtU = 22,
  dbaexpr_dbabinary_DbaGeqU = 23,
  dbaexpr_dbabinary_DbaGtU = 24,
  dbaexpr_dbabinary_DbaLeqS = 25,
  dbaexpr_dbabinary_DbaLtS = 26,
  dbaexpr_dbabinary_DbaGeqS = 27,
  dbaexpr_dbabinary_DbaGtS = 28
};
bool dbaexpr_dbabinary_IsValid(int value);
constexpr dbaexpr_dbabinary dbaexpr_dbabinary_dbabinary_MIN = dbaexpr_dbabinary_DbaPlus;
constexpr dbaexpr_dbabinary dbaexpr_dbabinary_dbabinary_MAX = dbaexpr_dbabinary_DbaGtS;
constexpr int dbaexpr_dbabinary_dbabinary_ARRAYSIZE = dbaexpr_dbabinary_dbabinary_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* dbaexpr_dbabinary_descriptor();
template<typename T>
inline const std::string& dbaexpr_dbabinary_Name(T enum_t_value) {
  static_assert(::std::is_same<T, dbaexpr_dbabinary>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function dbaexpr_dbabinary_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    dbaexpr_dbabinary_descriptor(), enum_t_value);
}
inline bool dbaexpr_dbabinary_Parse(
    const std::string& name, dbaexpr_dbabinary* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<dbaexpr_dbabinary>(
    dbaexpr_dbabinary_descriptor(), name, value);
}
enum dbacond_typeid_dbacond : int {
  dbacond_typeid_dbacond_DbaCondReif = 1,
  dbacond_typeid_dbacond_DbaCondNot = 2,
  dbacond_typeid_dbacond_DbaCondAnd = 3,
  dbacond_typeid_dbacond_DbaCondOr = 4,
  dbacond_typeid_dbacond_DbaTrue = 5,
  dbacond_typeid_dbacond_DbaFalse = 6
};
bool dbacond_typeid_dbacond_IsValid(int value);
constexpr dbacond_typeid_dbacond dbacond_typeid_dbacond_typeid_dbacond_MIN = dbacond_typeid_dbacond_DbaCondReif;
constexpr dbacond_typeid_dbacond dbacond_typeid_dbacond_typeid_dbacond_MAX = dbacond_typeid_dbacond_DbaFalse;
constexpr int dbacond_typeid_dbacond_typeid_dbacond_ARRAYSIZE = dbacond_typeid_dbacond_typeid_dbacond_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* dbacond_typeid_dbacond_descriptor();
template<typename T>
inline const std::string& dbacond_typeid_dbacond_Name(T enum_t_value) {
  static_assert(::std::is_same<T, dbacond_typeid_dbacond>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function dbacond_typeid_dbacond_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    dbacond_typeid_dbacond_descriptor(), enum_t_value);
}
inline bool dbacond_typeid_dbacond_Parse(
    const std::string& name, dbacond_typeid_dbacond* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<dbacond_typeid_dbacond>(
    dbacond_typeid_dbacond_descriptor(), name, value);
}
enum dbaLhs_typeid_dbalhs : int {
  dbaLhs_typeid_dbalhs_DbaLhsVar = 1,
  dbaLhs_typeid_dbalhs_DbaLhsVarRestrict = 2,
  dbaLhs_typeid_dbalhs_DbaStore = 3
};
bool dbaLhs_typeid_dbalhs_IsValid(int value);
constexpr dbaLhs_typeid_dbalhs dbaLhs_typeid_dbalhs_typeid_dbalhs_MIN = dbaLhs_typeid_dbalhs_DbaLhsVar;
constexpr dbaLhs_typeid_dbalhs dbaLhs_typeid_dbalhs_typeid_dbalhs_MAX = dbaLhs_typeid_dbalhs_DbaStore;
constexpr int dbaLhs_typeid_dbalhs_typeid_dbalhs_ARRAYSIZE = dbaLhs_typeid_dbalhs_typeid_dbalhs_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* dbaLhs_typeid_dbalhs_descriptor();
template<typename T>
inline const std::string& dbaLhs_typeid_dbalhs_Name(T enum_t_value) {
  static_assert(::std::is_same<T, dbaLhs_typeid_dbalhs>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function dbaLhs_typeid_dbalhs_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    dbaLhs_typeid_dbalhs_descriptor(), enum_t_value);
}
inline bool dbaLhs_typeid_dbalhs_Parse(
    const std::string& name, dbaLhs_typeid_dbalhs* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<dbaLhs_typeid_dbalhs>(
    dbaLhs_typeid_dbalhs_descriptor(), name, value);
}
enum dbainstr_typeid_instrkind : int {
  dbainstr_typeid_instrkind_DbaIkAssign = 1,
  dbainstr_typeid_instrkind_DbaIkSJump = 2,
  dbainstr_typeid_instrkind_DbaIkDJump = 3,
  dbainstr_typeid_instrkind_DbaIkIf = 4,
  dbainstr_typeid_instrkind_DbaIkStop = 5,
  dbainstr_typeid_instrkind_DbaIkAssert = 6,
  dbainstr_typeid_instrkind_DbaIkAssume = 7,
  dbainstr_typeid_instrkind_DbaIkNondetAssume = 8,
  dbainstr_typeid_instrkind_DbaIkNondet = 9,
  dbainstr_typeid_instrkind_DbaIkUndef = 10,
  dbainstr_typeid_instrkind_DbaIkMalloc = 11,
  dbainstr_typeid_instrkind_DbaIkFree = 12,
  dbainstr_typeid_instrkind_DbaIkPrint = 13
};
bool dbainstr_typeid_instrkind_IsValid(int value);
constexpr dbainstr_typeid_instrkind dbainstr_typeid_instrkind_typeid_instrkind_MIN = dbainstr_typeid_instrkind_DbaIkAssign;
constexpr dbainstr_typeid_instrkind dbainstr_typeid_instrkind_typeid_instrkind_MAX = dbainstr_typeid_instrkind_DbaIkPrint;
constexpr int dbainstr_typeid_instrkind_typeid_instrkind_ARRAYSIZE = dbainstr_typeid_instrkind_typeid_instrkind_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* dbainstr_typeid_instrkind_descriptor();
template<typename T>
inline const std::string& dbainstr_typeid_instrkind_Name(T enum_t_value) {
  static_assert(::std::is_same<T, dbainstr_typeid_instrkind>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function dbainstr_typeid_instrkind_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    dbainstr_typeid_instrkind_descriptor(), enum_t_value);
}
inline bool dbainstr_typeid_instrkind_Parse(
    const std::string& name, dbainstr_typeid_instrkind* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<dbainstr_typeid_instrkind>(
    dbainstr_typeid_instrkind_descriptor(), name, value);
}
enum endianness : int {
  Little = 1,
  Big = 2
};
bool endianness_IsValid(int value);
constexpr endianness endianness_MIN = Little;
constexpr endianness endianness_MAX = Big;
constexpr int endianness_ARRAYSIZE = endianness_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* endianness_descriptor();
template<typename T>
inline const std::string& endianness_Name(T enum_t_value) {
  static_assert(::std::is_same<T, endianness>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function endianness_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    endianness_descriptor(), enum_t_value);
}
inline bool endianness_Parse(
    const std::string& name, endianness* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<endianness>(
    endianness_descriptor(), name, value);
}
// ===================================================================

class bitvector :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:dba.bitvector) */ {
 public:
  bitvector();
  virtual ~bitvector();

  bitvector(const bitvector& from);
  bitvector(bitvector&& from) noexcept
    : bitvector() {
    *this = ::std::move(from);
  }

  inline bitvector& operator=(const bitvector& from) {
    CopyFrom(from);
    return *this;
  }
  inline bitvector& operator=(bitvector&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const bitvector& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const bitvector* internal_default_instance() {
    return reinterpret_cast<const bitvector*>(
               &_bitvector_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(bitvector& a, bitvector& b) {
    a.Swap(&b);
  }
  inline void Swap(bitvector* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline bitvector* New() const final {
    return CreateMaybeMessage<bitvector>(nullptr);
  }

  bitvector* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<bitvector>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const bitvector& from);
  void MergeFrom(const bitvector& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(bitvector* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "dba.bitvector";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_dba_2eproto);
    return ::descriptor_table_dba_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBvFieldNumber = 1,
    kSizeFieldNumber = 2,
  };
  // required uint64 bv = 1;
  bool has_bv() const;
  void clear_bv();
  ::PROTOBUF_NAMESPACE_ID::uint64 bv() const;
  void set_bv(::PROTOBUF_NAMESPACE_ID::uint64 value);

  // required uint32 size = 2;
  bool has_size() const;
  void clear_size();
  ::PROTOBUF_NAMESPACE_ID::uint32 size() const;
  void set_size(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // @@protoc_insertion_point(class_scope:dba.bitvector)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint64 bv_;
  ::PROTOBUF_NAMESPACE_ID::uint32 size_;
  friend struct ::TableStruct_dba_2eproto;
};
// -------------------------------------------------------------------

class dbacodeaddress :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:dba.dbacodeaddress) */ {
 public:
  dbacodeaddress();
  virtual ~dbacodeaddress();

  dbacodeaddress(const dbacodeaddress& from);
  dbacodeaddress(dbacodeaddress&& from) noexcept
    : dbacodeaddress() {
    *this = ::std::move(from);
  }

  inline dbacodeaddress& operator=(const dbacodeaddress& from) {
    CopyFrom(from);
    return *this;
  }
  inline dbacodeaddress& operator=(dbacodeaddress&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const dbacodeaddress& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const dbacodeaddress* internal_default_instance() {
    return reinterpret_cast<const dbacodeaddress*>(
               &_dbacodeaddress_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(dbacodeaddress& a, dbacodeaddress& b) {
    a.Swap(&b);
  }
  inline void Swap(dbacodeaddress* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline dbacodeaddress* New() const final {
    return CreateMaybeMessage<dbacodeaddress>(nullptr);
  }

  dbacodeaddress* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<dbacodeaddress>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const dbacodeaddress& from);
  void MergeFrom(const dbacodeaddress& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(dbacodeaddress* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "dba.dbacodeaddress";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_dba_2eproto);
    return ::descriptor_table_dba_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBitvectorFieldNumber = 1,
    kDbaoffsetFieldNumber = 2,
  };
  // required .dba.bitvector bitvector = 1;
  bool has_bitvector() const;
  void clear_bitvector();
  const ::dba::bitvector& bitvector() const;
  ::dba::bitvector* release_bitvector();
  ::dba::bitvector* mutable_bitvector();
  void set_allocated_bitvector(::dba::bitvector* bitvector);

  // required uint32 dbaoffset = 2;
  bool has_dbaoffset() const;
  void clear_dbaoffset();
  ::PROTOBUF_NAMESPACE_ID::uint32 dbaoffset() const;
  void set_dbaoffset(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // @@protoc_insertion_point(class_scope:dba.dbacodeaddress)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::dba::bitvector* bitvector_;
  ::PROTOBUF_NAMESPACE_ID::uint32 dbaoffset_;
  friend struct ::TableStruct_dba_2eproto;
};
// -------------------------------------------------------------------

class codeaddress :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:dba.codeaddress) */ {
 public:
  codeaddress();
  virtual ~codeaddress();

  codeaddress(const codeaddress& from);
  codeaddress(codeaddress&& from) noexcept
    : codeaddress() {
    *this = ::std::move(from);
  }

  inline codeaddress& operator=(const codeaddress& from) {
    CopyFrom(from);
    return *this;
  }
  inline codeaddress& operator=(codeaddress&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const codeaddress& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const codeaddress* internal_default_instance() {
    return reinterpret_cast<const codeaddress*>(
               &_codeaddress_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(codeaddress& a, codeaddress& b) {
    a.Swap(&b);
  }
  inline void Swap(codeaddress* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline codeaddress* New() const final {
    return CreateMaybeMessage<codeaddress>(nullptr);
  }

  codeaddress* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<codeaddress>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const codeaddress& from);
  void MergeFrom(const codeaddress& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(codeaddress* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "dba.codeaddress";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_dba_2eproto);
    return ::descriptor_table_dba_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef codeaddress_typeid_codeaddress typeid_codeaddress;
  static constexpr typeid_codeaddress Local =
    codeaddress_typeid_codeaddress_Local;
  static constexpr typeid_codeaddress NonLocal =
    codeaddress_typeid_codeaddress_NonLocal;
  static inline bool typeid_codeaddress_IsValid(int value) {
    return codeaddress_typeid_codeaddress_IsValid(value);
  }
  static constexpr typeid_codeaddress typeid_codeaddress_MIN =
    codeaddress_typeid_codeaddress_typeid_codeaddress_MIN;
  static constexpr typeid_codeaddress typeid_codeaddress_MAX =
    codeaddress_typeid_codeaddress_typeid_codeaddress_MAX;
  static constexpr int typeid_codeaddress_ARRAYSIZE =
    codeaddress_typeid_codeaddress_typeid_codeaddress_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  typeid_codeaddress_descriptor() {
    return codeaddress_typeid_codeaddress_descriptor();
  }
  template<typename T>
  static inline const std::string& typeid_codeaddress_Name(T enum_t_value) {
    static_assert(::std::is_same<T, typeid_codeaddress>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function typeid_codeaddress_Name.");
    return codeaddress_typeid_codeaddress_Name(enum_t_value);
  }
  static inline bool typeid_codeaddress_Parse(const std::string& name,
      typeid_codeaddress* value) {
    return codeaddress_typeid_codeaddress_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kAddressFieldNumber = 3,
    kTypeidFieldNumber = 1,
    kOffsetFieldNumber = 2,
  };
  // optional .dba.dbacodeaddress address = 3;
  bool has_address() const;
  void clear_address();
  const ::dba::dbacodeaddress& address() const;
  ::dba::dbacodeaddress* release_address();
  ::dba::dbacodeaddress* mutable_address();
  void set_allocated_address(::dba::dbacodeaddress* address);

  // required .dba.codeaddress.typeid_codeaddress typeid = 1;
  bool has_typeid_() const;
  void clear_typeid_();
  ::dba::codeaddress_typeid_codeaddress typeid_() const;
  void set_typeid_(::dba::codeaddress_typeid_codeaddress value);

  // optional uint32 offset = 2;
  bool has_offset() const;
  void clear_offset();
  ::PROTOBUF_NAMESPACE_ID::uint32 offset() const;
  void set_offset(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // @@protoc_insertion_point(class_scope:dba.codeaddress)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::dba::dbacodeaddress* address_;
  int typeid__;
  ::PROTOBUF_NAMESPACE_ID::uint32 offset_;
  friend struct ::TableStruct_dba_2eproto;
};
// -------------------------------------------------------------------

class dbatag :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:dba.dbatag) */ {
 public:
  dbatag();
  virtual ~dbatag();

  dbatag(const dbatag& from);
  dbatag(dbatag&& from) noexcept
    : dbatag() {
    *this = ::std::move(from);
  }

  inline dbatag& operator=(const dbatag& from) {
    CopyFrom(from);
    return *this;
  }
  inline dbatag& operator=(dbatag&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const dbatag& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const dbatag* internal_default_instance() {
    return reinterpret_cast<const dbatag*>(
               &_dbatag_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(dbatag& a, dbatag& b) {
    a.Swap(&b);
  }
  inline void Swap(dbatag* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline dbatag* New() const final {
    return CreateMaybeMessage<dbatag>(nullptr);
  }

  dbatag* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<dbatag>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const dbatag& from);
  void MergeFrom(const dbatag& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(dbatag* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "dba.dbatag";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_dba_2eproto);
    return ::descriptor_table_dba_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef dbatag_typeid_dbatag typeid_dbatag;
  static constexpr typeid_dbatag DbaCall =
    dbatag_typeid_dbatag_DbaCall;
  static constexpr typeid_dbatag DbaReturn =
    dbatag_typeid_dbatag_DbaReturn;
  static inline bool typeid_dbatag_IsValid(int value) {
    return dbatag_typeid_dbatag_IsValid(value);
  }
  static constexpr typeid_dbatag typeid_dbatag_MIN =
    dbatag_typeid_dbatag_typeid_dbatag_MIN;
  static constexpr typeid_dbatag typeid_dbatag_MAX =
    dbatag_typeid_dbatag_typeid_dbatag_MAX;
  static constexpr int typeid_dbatag_ARRAYSIZE =
    dbatag_typeid_dbatag_typeid_dbatag_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  typeid_dbatag_descriptor() {
    return dbatag_typeid_dbatag_descriptor();
  }
  template<typename T>
  static inline const std::string& typeid_dbatag_Name(T enum_t_value) {
    static_assert(::std::is_same<T, typeid_dbatag>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function typeid_dbatag_Name.");
    return dbatag_typeid_dbatag_Name(enum_t_value);
  }
  static inline bool typeid_dbatag_Parse(const std::string& name,
      typeid_dbatag* value) {
    return dbatag_typeid_dbatag_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kAddressFieldNumber = 2,
    kTypeidFieldNumber = 1,
  };
  // optional .dba.dbacodeaddress address = 2;
  bool has_address() const;
  void clear_address();
  const ::dba::dbacodeaddress& address() const;
  ::dba::dbacodeaddress* release_address();
  ::dba::dbacodeaddress* mutable_address();
  void set_allocated_address(::dba::dbacodeaddress* address);

  // required .dba.dbatag.typeid_dbatag typeid = 1;
  bool has_typeid_() const;
  void clear_typeid_();
  ::dba::dbatag_typeid_dbatag typeid_() const;
  void set_typeid_(::dba::dbatag_typeid_dbatag value);

  // @@protoc_insertion_point(class_scope:dba.dbatag)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::dba::dbacodeaddress* address_;
  int typeid__;
  friend struct ::TableStruct_dba_2eproto;
};
// -------------------------------------------------------------------

class dbastopstate :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:dba.dbastopstate) */ {
 public:
  dbastopstate();
  virtual ~dbastopstate();

  dbastopstate(const dbastopstate& from);
  dbastopstate(dbastopstate&& from) noexcept
    : dbastopstate() {
    *this = ::std::move(from);
  }

  inline dbastopstate& operator=(const dbastopstate& from) {
    CopyFrom(from);
    return *this;
  }
  inline dbastopstate& operator=(dbastopstate&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const dbastopstate& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const dbastopstate* internal_default_instance() {
    return reinterpret_cast<const dbastopstate*>(
               &_dbastopstate_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(dbastopstate& a, dbastopstate& b) {
    a.Swap(&b);
  }
  inline void Swap(dbastopstate* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline dbastopstate* New() const final {
    return CreateMaybeMessage<dbastopstate>(nullptr);
  }

  dbastopstate* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<dbastopstate>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const dbastopstate& from);
  void MergeFrom(const dbastopstate& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(dbastopstate* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "dba.dbastopstate";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_dba_2eproto);
    return ::descriptor_table_dba_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef dbastopstate_typeid_dbastate typeid_dbastate;
  static constexpr typeid_dbastate Ok =
    dbastopstate_typeid_dbastate_Ok;
  static constexpr typeid_dbastate Ko =
    dbastopstate_typeid_dbastate_Ko;
  static constexpr typeid_dbastate Undefined =
    dbastopstate_typeid_dbastate_Undefined;
  static constexpr typeid_dbastate Unsupported =
    dbastopstate_typeid_dbastate_Unsupported;
  static inline bool typeid_dbastate_IsValid(int value) {
    return dbastopstate_typeid_dbastate_IsValid(value);
  }
  static constexpr typeid_dbastate typeid_dbastate_MIN =
    dbastopstate_typeid_dbastate_typeid_dbastate_MIN;
  static constexpr typeid_dbastate typeid_dbastate_MAX =
    dbastopstate_typeid_dbastate_typeid_dbastate_MAX;
  static constexpr int typeid_dbastate_ARRAYSIZE =
    dbastopstate_typeid_dbastate_typeid_dbastate_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  typeid_dbastate_descriptor() {
    return dbastopstate_typeid_dbastate_descriptor();
  }
  template<typename T>
  static inline const std::string& typeid_dbastate_Name(T enum_t_value) {
    static_assert(::std::is_same<T, typeid_dbastate>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function typeid_dbastate_Name.");
    return dbastopstate_typeid_dbastate_Name(enum_t_value);
  }
  static inline bool typeid_dbastate_Parse(const std::string& name,
      typeid_dbastate* value) {
    return dbastopstate_typeid_dbastate_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kInfosFieldNumber = 2,
    kTypeidFieldNumber = 1,
  };
  // optional string infos = 2;
  bool has_infos() const;
  void clear_infos();
  const std::string& infos() const;
  void set_infos(const std::string& value);
  void set_infos(std::string&& value);
  void set_infos(const char* value);
  void set_infos(const char* value, size_t size);
  std::string* mutable_infos();
  std::string* release_infos();
  void set_allocated_infos(std::string* infos);

  // required .dba.dbastopstate.typeid_dbastate typeid = 1;
  bool has_typeid_() const;
  void clear_typeid_();
  ::dba::dbastopstate_typeid_dbastate typeid_() const;
  void set_typeid_(::dba::dbastopstate_typeid_dbastate value);

  // @@protoc_insertion_point(class_scope:dba.dbastopstate)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr infos_;
  int typeid__;
  friend struct ::TableStruct_dba_2eproto;
};
// -------------------------------------------------------------------

class dbaexpr :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:dba.dbaexpr) */ {
 public:
  dbaexpr();
  virtual ~dbaexpr();

  dbaexpr(const dbaexpr& from);
  dbaexpr(dbaexpr&& from) noexcept
    : dbaexpr() {
    *this = ::std::move(from);
  }

  inline dbaexpr& operator=(const dbaexpr& from) {
    CopyFrom(from);
    return *this;
  }
  inline dbaexpr& operator=(dbaexpr&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const dbaexpr& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const dbaexpr* internal_default_instance() {
    return reinterpret_cast<const dbaexpr*>(
               &_dbaexpr_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(dbaexpr& a, dbaexpr& b) {
    a.Swap(&b);
  }
  inline void Swap(dbaexpr* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline dbaexpr* New() const final {
    return CreateMaybeMessage<dbaexpr>(nullptr);
  }

  dbaexpr* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<dbaexpr>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const dbaexpr& from);
  void MergeFrom(const dbaexpr& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(dbaexpr* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "dba.dbaexpr";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_dba_2eproto);
    return ::descriptor_table_dba_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef dbaexpr_typeid_dbaexpr typeid_dbaexpr;
  static constexpr typeid_dbaexpr DbaExprVar =
    dbaexpr_typeid_dbaexpr_DbaExprVar;
  static constexpr typeid_dbaexpr DbaLoad =
    dbaexpr_typeid_dbaexpr_DbaLoad;
  static constexpr typeid_dbaexpr DbaExprCst =
    dbaexpr_typeid_dbaexpr_DbaExprCst;
  static constexpr typeid_dbaexpr DbaExprUnary =
    dbaexpr_typeid_dbaexpr_DbaExprUnary;
  static constexpr typeid_dbaexpr DbaExprBinary =
    dbaexpr_typeid_dbaexpr_DbaExprBinary;
  static constexpr typeid_dbaexpr DbaExprRestrict =
    dbaexpr_typeid_dbaexpr_DbaExprRestrict;
  static constexpr typeid_dbaexpr DbaExprExtU =
    dbaexpr_typeid_dbaexpr_DbaExprExtU;
  static constexpr typeid_dbaexpr DbaExprExtS =
    dbaexpr_typeid_dbaexpr_DbaExprExtS;
  static constexpr typeid_dbaexpr DbaExprIte =
    dbaexpr_typeid_dbaexpr_DbaExprIte;
  static constexpr typeid_dbaexpr DbaExprAlternative =
    dbaexpr_typeid_dbaexpr_DbaExprAlternative;
  static inline bool typeid_dbaexpr_IsValid(int value) {
    return dbaexpr_typeid_dbaexpr_IsValid(value);
  }
  static constexpr typeid_dbaexpr typeid_dbaexpr_MIN =
    dbaexpr_typeid_dbaexpr_typeid_dbaexpr_MIN;
  static constexpr typeid_dbaexpr typeid_dbaexpr_MAX =
    dbaexpr_typeid_dbaexpr_typeid_dbaexpr_MAX;
  static constexpr int typeid_dbaexpr_ARRAYSIZE =
    dbaexpr_typeid_dbaexpr_typeid_dbaexpr_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  typeid_dbaexpr_descriptor() {
    return dbaexpr_typeid_dbaexpr_descriptor();
  }
  template<typename T>
  static inline const std::string& typeid_dbaexpr_Name(T enum_t_value) {
    static_assert(::std::is_same<T, typeid_dbaexpr>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function typeid_dbaexpr_Name.");
    return dbaexpr_typeid_dbaexpr_Name(enum_t_value);
  }
  static inline bool typeid_dbaexpr_Parse(const std::string& name,
      typeid_dbaexpr* value) {
    return dbaexpr_typeid_dbaexpr_Parse(name, value);
  }

  typedef dbaexpr_dbaunary dbaunary;
  static constexpr dbaunary DbaUnaryMinus =
    dbaexpr_dbaunary_DbaUnaryMinus;
  static constexpr dbaunary DbaUnaryNot =
    dbaexpr_dbaunary_DbaUnaryNot;
  static inline bool dbaunary_IsValid(int value) {
    return dbaexpr_dbaunary_IsValid(value);
  }
  static constexpr dbaunary dbaunary_MIN =
    dbaexpr_dbaunary_dbaunary_MIN;
  static constexpr dbaunary dbaunary_MAX =
    dbaexpr_dbaunary_dbaunary_MAX;
  static constexpr int dbaunary_ARRAYSIZE =
    dbaexpr_dbaunary_dbaunary_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  dbaunary_descriptor() {
    return dbaexpr_dbaunary_descriptor();
  }
  template<typename T>
  static inline const std::string& dbaunary_Name(T enum_t_value) {
    static_assert(::std::is_same<T, dbaunary>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function dbaunary_Name.");
    return dbaexpr_dbaunary_Name(enum_t_value);
  }
  static inline bool dbaunary_Parse(const std::string& name,
      dbaunary* value) {
    return dbaexpr_dbaunary_Parse(name, value);
  }

  typedef dbaexpr_dbabinary dbabinary;
  static constexpr dbabinary DbaPlus =
    dbaexpr_dbabinary_DbaPlus;
  static constexpr dbabinary DbaMinus =
    dbaexpr_dbabinary_DbaMinus;
  static constexpr dbabinary DbaMultU =
    dbaexpr_dbabinary_DbaMultU;
  static constexpr dbabinary DbaMultS =
    dbaexpr_dbabinary_DbaMultS;
  static constexpr dbabinary DbaDivU =
    dbaexpr_dbabinary_DbaDivU;
  static constexpr dbabinary DbaDivS =
    dbaexpr_dbabinary_DbaDivS;
  static constexpr dbabinary DbaModU =
    dbaexpr_dbabinary_DbaModU;
  static constexpr dbabinary DbaModS =
    dbaexpr_dbabinary_DbaModS;
  static constexpr dbabinary DbaOr =
    dbaexpr_dbabinary_DbaOr;
  static constexpr dbabinary DbaAnd =
    dbaexpr_dbabinary_DbaAnd;
  static constexpr dbabinary DbaXor =
    dbaexpr_dbabinary_DbaXor;
  static constexpr dbabinary DbaConcat =
    dbaexpr_dbabinary_DbaConcat;
  static constexpr dbabinary DbaLShiftU =
    dbaexpr_dbabinary_DbaLShiftU;
  static constexpr dbabinary DbaRShiftU =
    dbaexpr_dbabinary_DbaRShiftU;
  static constexpr dbabinary DbaRShiftS =
    dbaexpr_dbabinary_DbaRShiftS;
  static constexpr dbabinary DbaLeftRotate =
    dbaexpr_dbabinary_DbaLeftRotate;
  static constexpr dbabinary DbaRightRotate =
    dbaexpr_dbabinary_DbaRightRotate;
  static constexpr dbabinary DbaEq =
    dbaexpr_dbabinary_DbaEq;
  static constexpr dbabinary DbaDiff =
    dbaexpr_dbabinary_DbaDiff;
  static constexpr dbabinary DbaLeqU =
    dbaexpr_dbabinary_DbaLeqU;
  static constexpr dbabinary DbaLtU =
    dbaexpr_dbabinary_DbaLtU;
  static constexpr dbabinary DbaGeqU =
    dbaexpr_dbabinary_DbaGeqU;
  static constexpr dbabinary DbaGtU =
    dbaexpr_dbabinary_DbaGtU;
  static constexpr dbabinary DbaLeqS =
    dbaexpr_dbabinary_DbaLeqS;
  static constexpr dbabinary DbaLtS =
    dbaexpr_dbabinary_DbaLtS;
  static constexpr dbabinary DbaGeqS =
    dbaexpr_dbabinary_DbaGeqS;
  static constexpr dbabinary DbaGtS =
    dbaexpr_dbabinary_DbaGtS;
  static inline bool dbabinary_IsValid(int value) {
    return dbaexpr_dbabinary_IsValid(value);
  }
  static constexpr dbabinary dbabinary_MIN =
    dbaexpr_dbabinary_dbabinary_MIN;
  static constexpr dbabinary dbabinary_MAX =
    dbaexpr_dbabinary_dbabinary_MAX;
  static constexpr int dbabinary_ARRAYSIZE =
    dbaexpr_dbabinary_dbabinary_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  dbabinary_descriptor() {
    return dbaexpr_dbabinary_descriptor();
  }
  template<typename T>
  static inline const std::string& dbabinary_Name(T enum_t_value) {
    static_assert(::std::is_same<T, dbabinary>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function dbabinary_Name.");
    return dbaexpr_dbabinary_Name(enum_t_value);
  }
  static inline bool dbabinary_Parse(const std::string& name,
      dbabinary* value) {
    return dbaexpr_dbabinary_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 2,
    kBitvectorFieldNumber = 5,
    kExpr1FieldNumber = 6,
    kExpr2FieldNumber = 7,
    kCondFieldNumber = 13,
    kSizeFieldNumber = 3,
    kLowFieldNumber = 11,
    kHighFieldNumber = 12,
    kTypeidFieldNumber = 1,
    kEndianFieldNumber = 4,
    kUnaryopFieldNumber = 9,
    kBinaryopFieldNumber = 10,
  };
  // optional string name = 2;
  bool has_name() const;
  void clear_name();
  const std::string& name() const;
  void set_name(const std::string& value);
  void set_name(std::string&& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  std::string* mutable_name();
  std::string* release_name();
  void set_allocated_name(std::string* name);

  // optional .dba.bitvector bitvector = 5;
  bool has_bitvector() const;
  void clear_bitvector();
  const ::dba::bitvector& bitvector() const;
  ::dba::bitvector* release_bitvector();
  ::dba::bitvector* mutable_bitvector();
  void set_allocated_bitvector(::dba::bitvector* bitvector);

  // optional .dba.dbaexpr expr1 = 6;
  bool has_expr1() const;
  void clear_expr1();
  const ::dba::dbaexpr& expr1() const;
  ::dba::dbaexpr* release_expr1();
  ::dba::dbaexpr* mutable_expr1();
  void set_allocated_expr1(::dba::dbaexpr* expr1);

  // optional .dba.dbaexpr expr2 = 7;
  bool has_expr2() const;
  void clear_expr2();
  const ::dba::dbaexpr& expr2() const;
  ::dba::dbaexpr* release_expr2();
  ::dba::dbaexpr* mutable_expr2();
  void set_allocated_expr2(::dba::dbaexpr* expr2);

  // optional .dba.dbacond cond = 13;
  bool has_cond() const;
  void clear_cond();
  const ::dba::dbacond& cond() const;
  ::dba::dbacond* release_cond();
  ::dba::dbacond* mutable_cond();
  void set_allocated_cond(::dba::dbacond* cond);

  // optional uint32 size = 3;
  bool has_size() const;
  void clear_size();
  ::PROTOBUF_NAMESPACE_ID::uint32 size() const;
  void set_size(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // optional uint32 low = 11;
  bool has_low() const;
  void clear_low();
  ::PROTOBUF_NAMESPACE_ID::uint32 low() const;
  void set_low(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // optional uint32 high = 12;
  bool has_high() const;
  void clear_high();
  ::PROTOBUF_NAMESPACE_ID::uint32 high() const;
  void set_high(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // required .dba.dbaexpr.typeid_dbaexpr typeid = 1;
  bool has_typeid_() const;
  void clear_typeid_();
  ::dba::dbaexpr_typeid_dbaexpr typeid_() const;
  void set_typeid_(::dba::dbaexpr_typeid_dbaexpr value);

  // optional .dba.endianness endian = 4;
  bool has_endian() const;
  void clear_endian();
  ::dba::endianness endian() const;
  void set_endian(::dba::endianness value);

  // optional .dba.dbaexpr.dbaunary unaryop = 9;
  bool has_unaryop() const;
  void clear_unaryop();
  ::dba::dbaexpr_dbaunary unaryop() const;
  void set_unaryop(::dba::dbaexpr_dbaunary value);

  // optional .dba.dbaexpr.dbabinary binaryop = 10;
  bool has_binaryop() const;
  void clear_binaryop();
  ::dba::dbaexpr_dbabinary binaryop() const;
  void set_binaryop(::dba::dbaexpr_dbabinary value);

  // @@protoc_insertion_point(class_scope:dba.dbaexpr)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::dba::bitvector* bitvector_;
  ::dba::dbaexpr* expr1_;
  ::dba::dbaexpr* expr2_;
  ::dba::dbacond* cond_;
  ::PROTOBUF_NAMESPACE_ID::uint32 size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 low_;
  ::PROTOBUF_NAMESPACE_ID::uint32 high_;
  int typeid__;
  int endian_;
  int unaryop_;
  int binaryop_;
  friend struct ::TableStruct_dba_2eproto;
};
// -------------------------------------------------------------------

class dbacond :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:dba.dbacond) */ {
 public:
  dbacond();
  virtual ~dbacond();

  dbacond(const dbacond& from);
  dbacond(dbacond&& from) noexcept
    : dbacond() {
    *this = ::std::move(from);
  }

  inline dbacond& operator=(const dbacond& from) {
    CopyFrom(from);
    return *this;
  }
  inline dbacond& operator=(dbacond&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const dbacond& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const dbacond* internal_default_instance() {
    return reinterpret_cast<const dbacond*>(
               &_dbacond_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(dbacond& a, dbacond& b) {
    a.Swap(&b);
  }
  inline void Swap(dbacond* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline dbacond* New() const final {
    return CreateMaybeMessage<dbacond>(nullptr);
  }

  dbacond* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<dbacond>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const dbacond& from);
  void MergeFrom(const dbacond& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(dbacond* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "dba.dbacond";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_dba_2eproto);
    return ::descriptor_table_dba_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef dbacond_typeid_dbacond typeid_dbacond;
  static constexpr typeid_dbacond DbaCondReif =
    dbacond_typeid_dbacond_DbaCondReif;
  static constexpr typeid_dbacond DbaCondNot =
    dbacond_typeid_dbacond_DbaCondNot;
  static constexpr typeid_dbacond DbaCondAnd =
    dbacond_typeid_dbacond_DbaCondAnd;
  static constexpr typeid_dbacond DbaCondOr =
    dbacond_typeid_dbacond_DbaCondOr;
  static constexpr typeid_dbacond DbaTrue =
    dbacond_typeid_dbacond_DbaTrue;
  static constexpr typeid_dbacond DbaFalse =
    dbacond_typeid_dbacond_DbaFalse;
  static inline bool typeid_dbacond_IsValid(int value) {
    return dbacond_typeid_dbacond_IsValid(value);
  }
  static constexpr typeid_dbacond typeid_dbacond_MIN =
    dbacond_typeid_dbacond_typeid_dbacond_MIN;
  static constexpr typeid_dbacond typeid_dbacond_MAX =
    dbacond_typeid_dbacond_typeid_dbacond_MAX;
  static constexpr int typeid_dbacond_ARRAYSIZE =
    dbacond_typeid_dbacond_typeid_dbacond_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  typeid_dbacond_descriptor() {
    return dbacond_typeid_dbacond_descriptor();
  }
  template<typename T>
  static inline const std::string& typeid_dbacond_Name(T enum_t_value) {
    static_assert(::std::is_same<T, typeid_dbacond>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function typeid_dbacond_Name.");
    return dbacond_typeid_dbacond_Name(enum_t_value);
  }
  static inline bool typeid_dbacond_Parse(const std::string& name,
      typeid_dbacond* value) {
    return dbacond_typeid_dbacond_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kExprFieldNumber = 2,
    kCond1FieldNumber = 3,
    kCond2FieldNumber = 4,
    kTypeidFieldNumber = 1,
  };
  // optional .dba.dbaexpr expr = 2;
  bool has_expr() const;
  void clear_expr();
  const ::dba::dbaexpr& expr() const;
  ::dba::dbaexpr* release_expr();
  ::dba::dbaexpr* mutable_expr();
  void set_allocated_expr(::dba::dbaexpr* expr);

  // optional .dba.dbacond cond1 = 3;
  bool has_cond1() const;
  void clear_cond1();
  const ::dba::dbacond& cond1() const;
  ::dba::dbacond* release_cond1();
  ::dba::dbacond* mutable_cond1();
  void set_allocated_cond1(::dba::dbacond* cond1);

  // optional .dba.dbacond cond2 = 4;
  bool has_cond2() const;
  void clear_cond2();
  const ::dba::dbacond& cond2() const;
  ::dba::dbacond* release_cond2();
  ::dba::dbacond* mutable_cond2();
  void set_allocated_cond2(::dba::dbacond* cond2);

  // required .dba.dbacond.typeid_dbacond typeid = 1;
  bool has_typeid_() const;
  void clear_typeid_();
  ::dba::dbacond_typeid_dbacond typeid_() const;
  void set_typeid_(::dba::dbacond_typeid_dbacond value);

  // @@protoc_insertion_point(class_scope:dba.dbacond)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::dba::dbaexpr* expr_;
  ::dba::dbacond* cond1_;
  ::dba::dbacond* cond2_;
  int typeid__;
  friend struct ::TableStruct_dba_2eproto;
};
// -------------------------------------------------------------------

class dbaLhs :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:dba.dbaLhs) */ {
 public:
  dbaLhs();
  virtual ~dbaLhs();

  dbaLhs(const dbaLhs& from);
  dbaLhs(dbaLhs&& from) noexcept
    : dbaLhs() {
    *this = ::std::move(from);
  }

  inline dbaLhs& operator=(const dbaLhs& from) {
    CopyFrom(from);
    return *this;
  }
  inline dbaLhs& operator=(dbaLhs&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const dbaLhs& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const dbaLhs* internal_default_instance() {
    return reinterpret_cast<const dbaLhs*>(
               &_dbaLhs_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(dbaLhs& a, dbaLhs& b) {
    a.Swap(&b);
  }
  inline void Swap(dbaLhs* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline dbaLhs* New() const final {
    return CreateMaybeMessage<dbaLhs>(nullptr);
  }

  dbaLhs* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<dbaLhs>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const dbaLhs& from);
  void MergeFrom(const dbaLhs& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(dbaLhs* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "dba.dbaLhs";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_dba_2eproto);
    return ::descriptor_table_dba_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef dbaLhs_typeid_dbalhs typeid_dbalhs;
  static constexpr typeid_dbalhs DbaLhsVar =
    dbaLhs_typeid_dbalhs_DbaLhsVar;
  static constexpr typeid_dbalhs DbaLhsVarRestrict =
    dbaLhs_typeid_dbalhs_DbaLhsVarRestrict;
  static constexpr typeid_dbalhs DbaStore =
    dbaLhs_typeid_dbalhs_DbaStore;
  static inline bool typeid_dbalhs_IsValid(int value) {
    return dbaLhs_typeid_dbalhs_IsValid(value);
  }
  static constexpr typeid_dbalhs typeid_dbalhs_MIN =
    dbaLhs_typeid_dbalhs_typeid_dbalhs_MIN;
  static constexpr typeid_dbalhs typeid_dbalhs_MAX =
    dbaLhs_typeid_dbalhs_typeid_dbalhs_MAX;
  static constexpr int typeid_dbalhs_ARRAYSIZE =
    dbaLhs_typeid_dbalhs_typeid_dbalhs_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  typeid_dbalhs_descriptor() {
    return dbaLhs_typeid_dbalhs_descriptor();
  }
  template<typename T>
  static inline const std::string& typeid_dbalhs_Name(T enum_t_value) {
    static_assert(::std::is_same<T, typeid_dbalhs>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function typeid_dbalhs_Name.");
    return dbaLhs_typeid_dbalhs_Name(enum_t_value);
  }
  static inline bool typeid_dbalhs_Parse(const std::string& name,
      typeid_dbalhs* value) {
    return dbaLhs_typeid_dbalhs_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 2,
    kExprFieldNumber = 7,
    kSizeFieldNumber = 3,
    kLowFieldNumber = 4,
    kHighFieldNumber = 5,
    kTypeidFieldNumber = 1,
    kEndianFieldNumber = 6,
  };
  // optional string name = 2;
  bool has_name() const;
  void clear_name();
  const std::string& name() const;
  void set_name(const std::string& value);
  void set_name(std::string&& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  std::string* mutable_name();
  std::string* release_name();
  void set_allocated_name(std::string* name);

  // optional .dba.dbaexpr expr = 7;
  bool has_expr() const;
  void clear_expr();
  const ::dba::dbaexpr& expr() const;
  ::dba::dbaexpr* release_expr();
  ::dba::dbaexpr* mutable_expr();
  void set_allocated_expr(::dba::dbaexpr* expr);

  // optional uint32 size = 3;
  bool has_size() const;
  void clear_size();
  ::PROTOBUF_NAMESPACE_ID::uint32 size() const;
  void set_size(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // optional uint32 low = 4;
  bool has_low() const;
  void clear_low();
  ::PROTOBUF_NAMESPACE_ID::uint32 low() const;
  void set_low(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // optional uint32 high = 5;
  bool has_high() const;
  void clear_high();
  ::PROTOBUF_NAMESPACE_ID::uint32 high() const;
  void set_high(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // required .dba.dbaLhs.typeid_dbalhs typeid = 1;
  bool has_typeid_() const;
  void clear_typeid_();
  ::dba::dbaLhs_typeid_dbalhs typeid_() const;
  void set_typeid_(::dba::dbaLhs_typeid_dbalhs value);

  // optional .dba.endianness endian = 6;
  bool has_endian() const;
  void clear_endian();
  ::dba::endianness endian() const;
  void set_endian(::dba::endianness value);

  // @@protoc_insertion_point(class_scope:dba.dbaLhs)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::dba::dbaexpr* expr_;
  ::PROTOBUF_NAMESPACE_ID::uint32 size_;
  ::PROTOBUF_NAMESPACE_ID::uint32 low_;
  ::PROTOBUF_NAMESPACE_ID::uint32 high_;
  int typeid__;
  int endian_;
  friend struct ::TableStruct_dba_2eproto;
};
// -------------------------------------------------------------------

class dbainstr :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:dba.dbainstr) */ {
 public:
  dbainstr();
  virtual ~dbainstr();

  dbainstr(const dbainstr& from);
  dbainstr(dbainstr&& from) noexcept
    : dbainstr() {
    *this = ::std::move(from);
  }

  inline dbainstr& operator=(const dbainstr& from) {
    CopyFrom(from);
    return *this;
  }
  inline dbainstr& operator=(dbainstr&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const dbainstr& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const dbainstr* internal_default_instance() {
    return reinterpret_cast<const dbainstr*>(
               &_dbainstr_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(dbainstr& a, dbainstr& b) {
    a.Swap(&b);
  }
  inline void Swap(dbainstr* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline dbainstr* New() const final {
    return CreateMaybeMessage<dbainstr>(nullptr);
  }

  dbainstr* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<dbainstr>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const dbainstr& from);
  void MergeFrom(const dbainstr& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(dbainstr* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "dba.dbainstr";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_dba_2eproto);
    return ::descriptor_table_dba_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef dbainstr_typeid_instrkind typeid_instrkind;
  static constexpr typeid_instrkind DbaIkAssign =
    dbainstr_typeid_instrkind_DbaIkAssign;
  static constexpr typeid_instrkind DbaIkSJump =
    dbainstr_typeid_instrkind_DbaIkSJump;
  static constexpr typeid_instrkind DbaIkDJump =
    dbainstr_typeid_instrkind_DbaIkDJump;
  static constexpr typeid_instrkind DbaIkIf =
    dbainstr_typeid_instrkind_DbaIkIf;
  static constexpr typeid_instrkind DbaIkStop =
    dbainstr_typeid_instrkind_DbaIkStop;
  static constexpr typeid_instrkind DbaIkAssert =
    dbainstr_typeid_instrkind_DbaIkAssert;
  static constexpr typeid_instrkind DbaIkAssume =
    dbainstr_typeid_instrkind_DbaIkAssume;
  static constexpr typeid_instrkind DbaIkNondetAssume =
    dbainstr_typeid_instrkind_DbaIkNondetAssume;
  static constexpr typeid_instrkind DbaIkNondet =
    dbainstr_typeid_instrkind_DbaIkNondet;
  static constexpr typeid_instrkind DbaIkUndef =
    dbainstr_typeid_instrkind_DbaIkUndef;
  static constexpr typeid_instrkind DbaIkMalloc =
    dbainstr_typeid_instrkind_DbaIkMalloc;
  static constexpr typeid_instrkind DbaIkFree =
    dbainstr_typeid_instrkind_DbaIkFree;
  static constexpr typeid_instrkind DbaIkPrint =
    dbainstr_typeid_instrkind_DbaIkPrint;
  static inline bool typeid_instrkind_IsValid(int value) {
    return dbainstr_typeid_instrkind_IsValid(value);
  }
  static constexpr typeid_instrkind typeid_instrkind_MIN =
    dbainstr_typeid_instrkind_typeid_instrkind_MIN;
  static constexpr typeid_instrkind typeid_instrkind_MAX =
    dbainstr_typeid_instrkind_typeid_instrkind_MAX;
  static constexpr int typeid_instrkind_ARRAYSIZE =
    dbainstr_typeid_instrkind_typeid_instrkind_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  typeid_instrkind_descriptor() {
    return dbainstr_typeid_instrkind_descriptor();
  }
  template<typename T>
  static inline const std::string& typeid_instrkind_Name(T enum_t_value) {
    static_assert(::std::is_same<T, typeid_instrkind>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function typeid_instrkind_Name.");
    return dbainstr_typeid_instrkind_Name(enum_t_value);
  }
  static inline bool typeid_instrkind_Parse(const std::string& name,
      typeid_instrkind* value) {
    return dbainstr_typeid_instrkind_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kExprsFieldNumber = 10,
    kLocationFieldNumber = 2,
    kLhsFieldNumber = 3,
    kExprFieldNumber = 4,
    kAddressFieldNumber = 6,
    kTagsFieldNumber = 7,
    kCondFieldNumber = 8,
    kStopinfosFieldNumber = 9,
    kOffsetFieldNumber = 5,
    kTypeidFieldNumber = 1,
  };
  // repeated .dba.dbaexpr exprs = 10;
  int exprs_size() const;
  void clear_exprs();
  ::dba::dbaexpr* mutable_exprs(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::dba::dbaexpr >*
      mutable_exprs();
  const ::dba::dbaexpr& exprs(int index) const;
  ::dba::dbaexpr* add_exprs();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::dba::dbaexpr >&
      exprs() const;

  // required .dba.dbacodeaddress location = 2;
  bool has_location() const;
  void clear_location();
  const ::dba::dbacodeaddress& location() const;
  ::dba::dbacodeaddress* release_location();
  ::dba::dbacodeaddress* mutable_location();
  void set_allocated_location(::dba::dbacodeaddress* location);

  // optional .dba.dbaLhs lhs = 3;
  bool has_lhs() const;
  void clear_lhs();
  const ::dba::dbaLhs& lhs() const;
  ::dba::dbaLhs* release_lhs();
  ::dba::dbaLhs* mutable_lhs();
  void set_allocated_lhs(::dba::dbaLhs* lhs);

  // optional .dba.dbaexpr expr = 4;
  bool has_expr() const;
  void clear_expr();
  const ::dba::dbaexpr& expr() const;
  ::dba::dbaexpr* release_expr();
  ::dba::dbaexpr* mutable_expr();
  void set_allocated_expr(::dba::dbaexpr* expr);

  // optional .dba.codeaddress address = 6;
  bool has_address() const;
  void clear_address();
  const ::dba::codeaddress& address() const;
  ::dba::codeaddress* release_address();
  ::dba::codeaddress* mutable_address();
  void set_allocated_address(::dba::codeaddress* address);

  // optional .dba.dbatag tags = 7;
  bool has_tags() const;
  void clear_tags();
  const ::dba::dbatag& tags() const;
  ::dba::dbatag* release_tags();
  ::dba::dbatag* mutable_tags();
  void set_allocated_tags(::dba::dbatag* tags);

  // optional .dba.dbacond cond = 8;
  bool has_cond() const;
  void clear_cond();
  const ::dba::dbacond& cond() const;
  ::dba::dbacond* release_cond();
  ::dba::dbacond* mutable_cond();
  void set_allocated_cond(::dba::dbacond* cond);

  // optional .dba.dbastopstate stopinfos = 9;
  bool has_stopinfos() const;
  void clear_stopinfos();
  const ::dba::dbastopstate& stopinfos() const;
  ::dba::dbastopstate* release_stopinfos();
  ::dba::dbastopstate* mutable_stopinfos();
  void set_allocated_stopinfos(::dba::dbastopstate* stopinfos);

  // optional uint32 offset = 5;
  bool has_offset() const;
  void clear_offset();
  ::PROTOBUF_NAMESPACE_ID::uint32 offset() const;
  void set_offset(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // required .dba.dbainstr.typeid_instrkind typeid = 1;
  bool has_typeid_() const;
  void clear_typeid_();
  ::dba::dbainstr_typeid_instrkind typeid_() const;
  void set_typeid_(::dba::dbainstr_typeid_instrkind value);

  // @@protoc_insertion_point(class_scope:dba.dbainstr)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::dba::dbaexpr > exprs_;
  ::dba::dbacodeaddress* location_;
  ::dba::dbaLhs* lhs_;
  ::dba::dbaexpr* expr_;
  ::dba::codeaddress* address_;
  ::dba::dbatag* tags_;
  ::dba::dbacond* cond_;
  ::dba::dbastopstate* stopinfos_;
  ::PROTOBUF_NAMESPACE_ID::uint32 offset_;
  int typeid__;
  friend struct ::TableStruct_dba_2eproto;
};
// -------------------------------------------------------------------

class dba_list :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:dba.dba_list) */ {
 public:
  dba_list();
  virtual ~dba_list();

  dba_list(const dba_list& from);
  dba_list(dba_list&& from) noexcept
    : dba_list() {
    *this = ::std::move(from);
  }

  inline dba_list& operator=(const dba_list& from) {
    CopyFrom(from);
    return *this;
  }
  inline dba_list& operator=(dba_list&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const dba_list& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const dba_list* internal_default_instance() {
    return reinterpret_cast<const dba_list*>(
               &_dba_list_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(dba_list& a, dba_list& b) {
    a.Swap(&b);
  }
  inline void Swap(dba_list* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline dba_list* New() const final {
    return CreateMaybeMessage<dba_list>(nullptr);
  }

  dba_list* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<dba_list>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const dba_list& from);
  void MergeFrom(const dba_list& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(dba_list* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "dba.dba_list";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_dba_2eproto);
    return ::descriptor_table_dba_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kInstrsFieldNumber = 1,
  };
  // repeated .dba.dbainstr instrs = 1;
  int instrs_size() const;
  void clear_instrs();
  ::dba::dbainstr* mutable_instrs(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::dba::dbainstr >*
      mutable_instrs();
  const ::dba::dbainstr& instrs(int index) const;
  ::dba::dbainstr* add_instrs();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::dba::dbainstr >&
      instrs() const;

  // @@protoc_insertion_point(class_scope:dba.dba_list)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::dba::dbainstr > instrs_;
  friend struct ::TableStruct_dba_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// bitvector

// required uint64 bv = 1;
inline bool bitvector::has_bv() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void bitvector::clear_bv() {
  bv_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 bitvector::bv() const {
  // @@protoc_insertion_point(field_get:dba.bitvector.bv)
  return bv_;
}
inline void bitvector::set_bv(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000001u;
  bv_ = value;
  // @@protoc_insertion_point(field_set:dba.bitvector.bv)
}

// required uint32 size = 2;
inline bool bitvector::has_size() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void bitvector::clear_size() {
  size_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 bitvector::size() const {
  // @@protoc_insertion_point(field_get:dba.bitvector.size)
  return size_;
}
inline void bitvector::set_size(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000002u;
  size_ = value;
  // @@protoc_insertion_point(field_set:dba.bitvector.size)
}

// -------------------------------------------------------------------

// dbacodeaddress

// required .dba.bitvector bitvector = 1;
inline bool dbacodeaddress::has_bitvector() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void dbacodeaddress::clear_bitvector() {
  if (bitvector_ != nullptr) bitvector_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::dba::bitvector& dbacodeaddress::bitvector() const {
  const ::dba::bitvector* p = bitvector_;
  // @@protoc_insertion_point(field_get:dba.dbacodeaddress.bitvector)
  return p != nullptr ? *p : *reinterpret_cast<const ::dba::bitvector*>(
      &::dba::_bitvector_default_instance_);
}
inline ::dba::bitvector* dbacodeaddress::release_bitvector() {
  // @@protoc_insertion_point(field_release:dba.dbacodeaddress.bitvector)
  _has_bits_[0] &= ~0x00000001u;
  ::dba::bitvector* temp = bitvector_;
  bitvector_ = nullptr;
  return temp;
}
inline ::dba::bitvector* dbacodeaddress::mutable_bitvector() {
  _has_bits_[0] |= 0x00000001u;
  if (bitvector_ == nullptr) {
    auto* p = CreateMaybeMessage<::dba::bitvector>(GetArenaNoVirtual());
    bitvector_ = p;
  }
  // @@protoc_insertion_point(field_mutable:dba.dbacodeaddress.bitvector)
  return bitvector_;
}
inline void dbacodeaddress::set_allocated_bitvector(::dba::bitvector* bitvector) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete bitvector_;
  }
  if (bitvector) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      bitvector = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, bitvector, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  bitvector_ = bitvector;
  // @@protoc_insertion_point(field_set_allocated:dba.dbacodeaddress.bitvector)
}

// required uint32 dbaoffset = 2;
inline bool dbacodeaddress::has_dbaoffset() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void dbacodeaddress::clear_dbaoffset() {
  dbaoffset_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 dbacodeaddress::dbaoffset() const {
  // @@protoc_insertion_point(field_get:dba.dbacodeaddress.dbaoffset)
  return dbaoffset_;
}
inline void dbacodeaddress::set_dbaoffset(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000002u;
  dbaoffset_ = value;
  // @@protoc_insertion_point(field_set:dba.dbacodeaddress.dbaoffset)
}

// -------------------------------------------------------------------

// codeaddress

// required .dba.codeaddress.typeid_codeaddress typeid = 1;
inline bool codeaddress::has_typeid_() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void codeaddress::clear_typeid_() {
  typeid__ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::dba::codeaddress_typeid_codeaddress codeaddress::typeid_() const {
  // @@protoc_insertion_point(field_get:dba.codeaddress.typeid)
  return static_cast< ::dba::codeaddress_typeid_codeaddress >(typeid__);
}
inline void codeaddress::set_typeid_(::dba::codeaddress_typeid_codeaddress value) {
  assert(::dba::codeaddress_typeid_codeaddress_IsValid(value));
  _has_bits_[0] |= 0x00000002u;
  typeid__ = value;
  // @@protoc_insertion_point(field_set:dba.codeaddress.typeid)
}

// optional uint32 offset = 2;
inline bool codeaddress::has_offset() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void codeaddress::clear_offset() {
  offset_ = 0u;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 codeaddress::offset() const {
  // @@protoc_insertion_point(field_get:dba.codeaddress.offset)
  return offset_;
}
inline void codeaddress::set_offset(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000004u;
  offset_ = value;
  // @@protoc_insertion_point(field_set:dba.codeaddress.offset)
}

// optional .dba.dbacodeaddress address = 3;
inline bool codeaddress::has_address() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void codeaddress::clear_address() {
  if (address_ != nullptr) address_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::dba::dbacodeaddress& codeaddress::address() const {
  const ::dba::dbacodeaddress* p = address_;
  // @@protoc_insertion_point(field_get:dba.codeaddress.address)
  return p != nullptr ? *p : *reinterpret_cast<const ::dba::dbacodeaddress*>(
      &::dba::_dbacodeaddress_default_instance_);
}
inline ::dba::dbacodeaddress* codeaddress::release_address() {
  // @@protoc_insertion_point(field_release:dba.codeaddress.address)
  _has_bits_[0] &= ~0x00000001u;
  ::dba::dbacodeaddress* temp = address_;
  address_ = nullptr;
  return temp;
}
inline ::dba::dbacodeaddress* codeaddress::mutable_address() {
  _has_bits_[0] |= 0x00000001u;
  if (address_ == nullptr) {
    auto* p = CreateMaybeMessage<::dba::dbacodeaddress>(GetArenaNoVirtual());
    address_ = p;
  }
  // @@protoc_insertion_point(field_mutable:dba.codeaddress.address)
  return address_;
}
inline void codeaddress::set_allocated_address(::dba::dbacodeaddress* address) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete address_;
  }
  if (address) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      address = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, address, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  address_ = address;
  // @@protoc_insertion_point(field_set_allocated:dba.codeaddress.address)
}

// -------------------------------------------------------------------

// dbatag

// required .dba.dbatag.typeid_dbatag typeid = 1;
inline bool dbatag::has_typeid_() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void dbatag::clear_typeid_() {
  typeid__ = 1;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::dba::dbatag_typeid_dbatag dbatag::typeid_() const {
  // @@protoc_insertion_point(field_get:dba.dbatag.typeid)
  return static_cast< ::dba::dbatag_typeid_dbatag >(typeid__);
}
inline void dbatag::set_typeid_(::dba::dbatag_typeid_dbatag value) {
  assert(::dba::dbatag_typeid_dbatag_IsValid(value));
  _has_bits_[0] |= 0x00000002u;
  typeid__ = value;
  // @@protoc_insertion_point(field_set:dba.dbatag.typeid)
}

// optional .dba.dbacodeaddress address = 2;
inline bool dbatag::has_address() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void dbatag::clear_address() {
  if (address_ != nullptr) address_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::dba::dbacodeaddress& dbatag::address() const {
  const ::dba::dbacodeaddress* p = address_;
  // @@protoc_insertion_point(field_get:dba.dbatag.address)
  return p != nullptr ? *p : *reinterpret_cast<const ::dba::dbacodeaddress*>(
      &::dba::_dbacodeaddress_default_instance_);
}
inline ::dba::dbacodeaddress* dbatag::release_address() {
  // @@protoc_insertion_point(field_release:dba.dbatag.address)
  _has_bits_[0] &= ~0x00000001u;
  ::dba::dbacodeaddress* temp = address_;
  address_ = nullptr;
  return temp;
}
inline ::dba::dbacodeaddress* dbatag::mutable_address() {
  _has_bits_[0] |= 0x00000001u;
  if (address_ == nullptr) {
    auto* p = CreateMaybeMessage<::dba::dbacodeaddress>(GetArenaNoVirtual());
    address_ = p;
  }
  // @@protoc_insertion_point(field_mutable:dba.dbatag.address)
  return address_;
}
inline void dbatag::set_allocated_address(::dba::dbacodeaddress* address) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete address_;
  }
  if (address) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      address = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, address, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  address_ = address;
  // @@protoc_insertion_point(field_set_allocated:dba.dbatag.address)
}

// -------------------------------------------------------------------

// dbastopstate

// required .dba.dbastopstate.typeid_dbastate typeid = 1;
inline bool dbastopstate::has_typeid_() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void dbastopstate::clear_typeid_() {
  typeid__ = 1;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::dba::dbastopstate_typeid_dbastate dbastopstate::typeid_() const {
  // @@protoc_insertion_point(field_get:dba.dbastopstate.typeid)
  return static_cast< ::dba::dbastopstate_typeid_dbastate >(typeid__);
}
inline void dbastopstate::set_typeid_(::dba::dbastopstate_typeid_dbastate value) {
  assert(::dba::dbastopstate_typeid_dbastate_IsValid(value));
  _has_bits_[0] |= 0x00000002u;
  typeid__ = value;
  // @@protoc_insertion_point(field_set:dba.dbastopstate.typeid)
}

// optional string infos = 2;
inline bool dbastopstate::has_infos() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void dbastopstate::clear_infos() {
  infos_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& dbastopstate::infos() const {
  // @@protoc_insertion_point(field_get:dba.dbastopstate.infos)
  return infos_.GetNoArena();
}
inline void dbastopstate::set_infos(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  infos_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:dba.dbastopstate.infos)
}
inline void dbastopstate::set_infos(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  infos_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:dba.dbastopstate.infos)
}
inline void dbastopstate::set_infos(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  infos_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:dba.dbastopstate.infos)
}
inline void dbastopstate::set_infos(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  infos_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:dba.dbastopstate.infos)
}
inline std::string* dbastopstate::mutable_infos() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:dba.dbastopstate.infos)
  return infos_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* dbastopstate::release_infos() {
  // @@protoc_insertion_point(field_release:dba.dbastopstate.infos)
  if (!has_infos()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return infos_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void dbastopstate::set_allocated_infos(std::string* infos) {
  if (infos != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  infos_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), infos);
  // @@protoc_insertion_point(field_set_allocated:dba.dbastopstate.infos)
}

// -------------------------------------------------------------------

// dbaexpr

// required .dba.dbaexpr.typeid_dbaexpr typeid = 1;
inline bool dbaexpr::has_typeid_() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void dbaexpr::clear_typeid_() {
  typeid__ = 1;
  _has_bits_[0] &= ~0x00000100u;
}
inline ::dba::dbaexpr_typeid_dbaexpr dbaexpr::typeid_() const {
  // @@protoc_insertion_point(field_get:dba.dbaexpr.typeid)
  return static_cast< ::dba::dbaexpr_typeid_dbaexpr >(typeid__);
}
inline void dbaexpr::set_typeid_(::dba::dbaexpr_typeid_dbaexpr value) {
  assert(::dba::dbaexpr_typeid_dbaexpr_IsValid(value));
  _has_bits_[0] |= 0x00000100u;
  typeid__ = value;
  // @@protoc_insertion_point(field_set:dba.dbaexpr.typeid)
}

// optional string name = 2;
inline bool dbaexpr::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void dbaexpr::clear_name() {
  name_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& dbaexpr::name() const {
  // @@protoc_insertion_point(field_get:dba.dbaexpr.name)
  return name_.GetNoArena();
}
inline void dbaexpr::set_name(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:dba.dbaexpr.name)
}
inline void dbaexpr::set_name(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  name_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:dba.dbaexpr.name)
}
inline void dbaexpr::set_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:dba.dbaexpr.name)
}
inline void dbaexpr::set_name(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:dba.dbaexpr.name)
}
inline std::string* dbaexpr::mutable_name() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:dba.dbaexpr.name)
  return name_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* dbaexpr::release_name() {
  // @@protoc_insertion_point(field_release:dba.dbaexpr.name)
  if (!has_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return name_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void dbaexpr::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  name_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:dba.dbaexpr.name)
}

// optional uint32 size = 3;
inline bool dbaexpr::has_size() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void dbaexpr::clear_size() {
  size_ = 0u;
  _has_bits_[0] &= ~0x00000020u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 dbaexpr::size() const {
  // @@protoc_insertion_point(field_get:dba.dbaexpr.size)
  return size_;
}
inline void dbaexpr::set_size(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000020u;
  size_ = value;
  // @@protoc_insertion_point(field_set:dba.dbaexpr.size)
}

// optional .dba.endianness endian = 4;
inline bool dbaexpr::has_endian() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void dbaexpr::clear_endian() {
  endian_ = 1;
  _has_bits_[0] &= ~0x00000200u;
}
inline ::dba::endianness dbaexpr::endian() const {
  // @@protoc_insertion_point(field_get:dba.dbaexpr.endian)
  return static_cast< ::dba::endianness >(endian_);
}
inline void dbaexpr::set_endian(::dba::endianness value) {
  assert(::dba::endianness_IsValid(value));
  _has_bits_[0] |= 0x00000200u;
  endian_ = value;
  // @@protoc_insertion_point(field_set:dba.dbaexpr.endian)
}

// optional .dba.bitvector bitvector = 5;
inline bool dbaexpr::has_bitvector() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void dbaexpr::clear_bitvector() {
  if (bitvector_ != nullptr) bitvector_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::dba::bitvector& dbaexpr::bitvector() const {
  const ::dba::bitvector* p = bitvector_;
  // @@protoc_insertion_point(field_get:dba.dbaexpr.bitvector)
  return p != nullptr ? *p : *reinterpret_cast<const ::dba::bitvector*>(
      &::dba::_bitvector_default_instance_);
}
inline ::dba::bitvector* dbaexpr::release_bitvector() {
  // @@protoc_insertion_point(field_release:dba.dbaexpr.bitvector)
  _has_bits_[0] &= ~0x00000002u;
  ::dba::bitvector* temp = bitvector_;
  bitvector_ = nullptr;
  return temp;
}
inline ::dba::bitvector* dbaexpr::mutable_bitvector() {
  _has_bits_[0] |= 0x00000002u;
  if (bitvector_ == nullptr) {
    auto* p = CreateMaybeMessage<::dba::bitvector>(GetArenaNoVirtual());
    bitvector_ = p;
  }
  // @@protoc_insertion_point(field_mutable:dba.dbaexpr.bitvector)
  return bitvector_;
}
inline void dbaexpr::set_allocated_bitvector(::dba::bitvector* bitvector) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete bitvector_;
  }
  if (bitvector) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      bitvector = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, bitvector, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  bitvector_ = bitvector;
  // @@protoc_insertion_point(field_set_allocated:dba.dbaexpr.bitvector)
}

// optional .dba.dbaexpr expr1 = 6;
inline bool dbaexpr::has_expr1() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void dbaexpr::clear_expr1() {
  if (expr1_ != nullptr) expr1_->Clear();
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::dba::dbaexpr& dbaexpr::expr1() const {
  const ::dba::dbaexpr* p = expr1_;
  // @@protoc_insertion_point(field_get:dba.dbaexpr.expr1)
  return p != nullptr ? *p : *reinterpret_cast<const ::dba::dbaexpr*>(
      &::dba::_dbaexpr_default_instance_);
}
inline ::dba::dbaexpr* dbaexpr::release_expr1() {
  // @@protoc_insertion_point(field_release:dba.dbaexpr.expr1)
  _has_bits_[0] &= ~0x00000004u;
  ::dba::dbaexpr* temp = expr1_;
  expr1_ = nullptr;
  return temp;
}
inline ::dba::dbaexpr* dbaexpr::mutable_expr1() {
  _has_bits_[0] |= 0x00000004u;
  if (expr1_ == nullptr) {
    auto* p = CreateMaybeMessage<::dba::dbaexpr>(GetArenaNoVirtual());
    expr1_ = p;
  }
  // @@protoc_insertion_point(field_mutable:dba.dbaexpr.expr1)
  return expr1_;
}
inline void dbaexpr::set_allocated_expr1(::dba::dbaexpr* expr1) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete expr1_;
  }
  if (expr1) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      expr1 = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, expr1, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  expr1_ = expr1;
  // @@protoc_insertion_point(field_set_allocated:dba.dbaexpr.expr1)
}

// optional .dba.dbaexpr expr2 = 7;
inline bool dbaexpr::has_expr2() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void dbaexpr::clear_expr2() {
  if (expr2_ != nullptr) expr2_->Clear();
  _has_bits_[0] &= ~0x00000008u;
}
inline const ::dba::dbaexpr& dbaexpr::expr2() const {
  const ::dba::dbaexpr* p = expr2_;
  // @@protoc_insertion_point(field_get:dba.dbaexpr.expr2)
  return p != nullptr ? *p : *reinterpret_cast<const ::dba::dbaexpr*>(
      &::dba::_dbaexpr_default_instance_);
}
inline ::dba::dbaexpr* dbaexpr::release_expr2() {
  // @@protoc_insertion_point(field_release:dba.dbaexpr.expr2)
  _has_bits_[0] &= ~0x00000008u;
  ::dba::dbaexpr* temp = expr2_;
  expr2_ = nullptr;
  return temp;
}
inline ::dba::dbaexpr* dbaexpr::mutable_expr2() {
  _has_bits_[0] |= 0x00000008u;
  if (expr2_ == nullptr) {
    auto* p = CreateMaybeMessage<::dba::dbaexpr>(GetArenaNoVirtual());
    expr2_ = p;
  }
  // @@protoc_insertion_point(field_mutable:dba.dbaexpr.expr2)
  return expr2_;
}
inline void dbaexpr::set_allocated_expr2(::dba::dbaexpr* expr2) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete expr2_;
  }
  if (expr2) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      expr2 = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, expr2, submessage_arena);
    }
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  expr2_ = expr2;
  // @@protoc_insertion_point(field_set_allocated:dba.dbaexpr.expr2)
}

// optional .dba.dbaexpr.dbaunary unaryop = 9;
inline bool dbaexpr::has_unaryop() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void dbaexpr::clear_unaryop() {
  unaryop_ = 1;
  _has_bits_[0] &= ~0x00000400u;
}
inline ::dba::dbaexpr_dbaunary dbaexpr::unaryop() const {
  // @@protoc_insertion_point(field_get:dba.dbaexpr.unaryop)
  return static_cast< ::dba::dbaexpr_dbaunary >(unaryop_);
}
inline void dbaexpr::set_unaryop(::dba::dbaexpr_dbaunary value) {
  assert(::dba::dbaexpr_dbaunary_IsValid(value));
  _has_bits_[0] |= 0x00000400u;
  unaryop_ = value;
  // @@protoc_insertion_point(field_set:dba.dbaexpr.unaryop)
}

// optional .dba.dbaexpr.dbabinary binaryop = 10;
inline bool dbaexpr::has_binaryop() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void dbaexpr::clear_binaryop() {
  binaryop_ = 1;
  _has_bits_[0] &= ~0x00000800u;
}
inline ::dba::dbaexpr_dbabinary dbaexpr::binaryop() const {
  // @@protoc_insertion_point(field_get:dba.dbaexpr.binaryop)
  return static_cast< ::dba::dbaexpr_dbabinary >(binaryop_);
}
inline void dbaexpr::set_binaryop(::dba::dbaexpr_dbabinary value) {
  assert(::dba::dbaexpr_dbabinary_IsValid(value));
  _has_bits_[0] |= 0x00000800u;
  binaryop_ = value;
  // @@protoc_insertion_point(field_set:dba.dbaexpr.binaryop)
}

// optional uint32 low = 11;
inline bool dbaexpr::has_low() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void dbaexpr::clear_low() {
  low_ = 0u;
  _has_bits_[0] &= ~0x00000040u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 dbaexpr::low() const {
  // @@protoc_insertion_point(field_get:dba.dbaexpr.low)
  return low_;
}
inline void dbaexpr::set_low(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000040u;
  low_ = value;
  // @@protoc_insertion_point(field_set:dba.dbaexpr.low)
}

// optional uint32 high = 12;
inline bool dbaexpr::has_high() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void dbaexpr::clear_high() {
  high_ = 0u;
  _has_bits_[0] &= ~0x00000080u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 dbaexpr::high() const {
  // @@protoc_insertion_point(field_get:dba.dbaexpr.high)
  return high_;
}
inline void dbaexpr::set_high(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000080u;
  high_ = value;
  // @@protoc_insertion_point(field_set:dba.dbaexpr.high)
}

// optional .dba.dbacond cond = 13;
inline bool dbaexpr::has_cond() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void dbaexpr::clear_cond() {
  if (cond_ != nullptr) cond_->Clear();
  _has_bits_[0] &= ~0x00000010u;
}
inline const ::dba::dbacond& dbaexpr::cond() const {
  const ::dba::dbacond* p = cond_;
  // @@protoc_insertion_point(field_get:dba.dbaexpr.cond)
  return p != nullptr ? *p : *reinterpret_cast<const ::dba::dbacond*>(
      &::dba::_dbacond_default_instance_);
}
inline ::dba::dbacond* dbaexpr::release_cond() {
  // @@protoc_insertion_point(field_release:dba.dbaexpr.cond)
  _has_bits_[0] &= ~0x00000010u;
  ::dba::dbacond* temp = cond_;
  cond_ = nullptr;
  return temp;
}
inline ::dba::dbacond* dbaexpr::mutable_cond() {
  _has_bits_[0] |= 0x00000010u;
  if (cond_ == nullptr) {
    auto* p = CreateMaybeMessage<::dba::dbacond>(GetArenaNoVirtual());
    cond_ = p;
  }
  // @@protoc_insertion_point(field_mutable:dba.dbaexpr.cond)
  return cond_;
}
inline void dbaexpr::set_allocated_cond(::dba::dbacond* cond) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete cond_;
  }
  if (cond) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      cond = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, cond, submessage_arena);
    }
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  cond_ = cond;
  // @@protoc_insertion_point(field_set_allocated:dba.dbaexpr.cond)
}

// -------------------------------------------------------------------

// dbacond

// required .dba.dbacond.typeid_dbacond typeid = 1;
inline bool dbacond::has_typeid_() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void dbacond::clear_typeid_() {
  typeid__ = 1;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::dba::dbacond_typeid_dbacond dbacond::typeid_() const {
  // @@protoc_insertion_point(field_get:dba.dbacond.typeid)
  return static_cast< ::dba::dbacond_typeid_dbacond >(typeid__);
}
inline void dbacond::set_typeid_(::dba::dbacond_typeid_dbacond value) {
  assert(::dba::dbacond_typeid_dbacond_IsValid(value));
  _has_bits_[0] |= 0x00000008u;
  typeid__ = value;
  // @@protoc_insertion_point(field_set:dba.dbacond.typeid)
}

// optional .dba.dbaexpr expr = 2;
inline bool dbacond::has_expr() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void dbacond::clear_expr() {
  if (expr_ != nullptr) expr_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::dba::dbaexpr& dbacond::expr() const {
  const ::dba::dbaexpr* p = expr_;
  // @@protoc_insertion_point(field_get:dba.dbacond.expr)
  return p != nullptr ? *p : *reinterpret_cast<const ::dba::dbaexpr*>(
      &::dba::_dbaexpr_default_instance_);
}
inline ::dba::dbaexpr* dbacond::release_expr() {
  // @@protoc_insertion_point(field_release:dba.dbacond.expr)
  _has_bits_[0] &= ~0x00000001u;
  ::dba::dbaexpr* temp = expr_;
  expr_ = nullptr;
  return temp;
}
inline ::dba::dbaexpr* dbacond::mutable_expr() {
  _has_bits_[0] |= 0x00000001u;
  if (expr_ == nullptr) {
    auto* p = CreateMaybeMessage<::dba::dbaexpr>(GetArenaNoVirtual());
    expr_ = p;
  }
  // @@protoc_insertion_point(field_mutable:dba.dbacond.expr)
  return expr_;
}
inline void dbacond::set_allocated_expr(::dba::dbaexpr* expr) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete expr_;
  }
  if (expr) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      expr = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, expr, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  expr_ = expr;
  // @@protoc_insertion_point(field_set_allocated:dba.dbacond.expr)
}

// optional .dba.dbacond cond1 = 3;
inline bool dbacond::has_cond1() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void dbacond::clear_cond1() {
  if (cond1_ != nullptr) cond1_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::dba::dbacond& dbacond::cond1() const {
  const ::dba::dbacond* p = cond1_;
  // @@protoc_insertion_point(field_get:dba.dbacond.cond1)
  return p != nullptr ? *p : *reinterpret_cast<const ::dba::dbacond*>(
      &::dba::_dbacond_default_instance_);
}
inline ::dba::dbacond* dbacond::release_cond1() {
  // @@protoc_insertion_point(field_release:dba.dbacond.cond1)
  _has_bits_[0] &= ~0x00000002u;
  ::dba::dbacond* temp = cond1_;
  cond1_ = nullptr;
  return temp;
}
inline ::dba::dbacond* dbacond::mutable_cond1() {
  _has_bits_[0] |= 0x00000002u;
  if (cond1_ == nullptr) {
    auto* p = CreateMaybeMessage<::dba::dbacond>(GetArenaNoVirtual());
    cond1_ = p;
  }
  // @@protoc_insertion_point(field_mutable:dba.dbacond.cond1)
  return cond1_;
}
inline void dbacond::set_allocated_cond1(::dba::dbacond* cond1) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete cond1_;
  }
  if (cond1) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      cond1 = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, cond1, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  cond1_ = cond1;
  // @@protoc_insertion_point(field_set_allocated:dba.dbacond.cond1)
}

// optional .dba.dbacond cond2 = 4;
inline bool dbacond::has_cond2() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void dbacond::clear_cond2() {
  if (cond2_ != nullptr) cond2_->Clear();
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::dba::dbacond& dbacond::cond2() const {
  const ::dba::dbacond* p = cond2_;
  // @@protoc_insertion_point(field_get:dba.dbacond.cond2)
  return p != nullptr ? *p : *reinterpret_cast<const ::dba::dbacond*>(
      &::dba::_dbacond_default_instance_);
}
inline ::dba::dbacond* dbacond::release_cond2() {
  // @@protoc_insertion_point(field_release:dba.dbacond.cond2)
  _has_bits_[0] &= ~0x00000004u;
  ::dba::dbacond* temp = cond2_;
  cond2_ = nullptr;
  return temp;
}
inline ::dba::dbacond* dbacond::mutable_cond2() {
  _has_bits_[0] |= 0x00000004u;
  if (cond2_ == nullptr) {
    auto* p = CreateMaybeMessage<::dba::dbacond>(GetArenaNoVirtual());
    cond2_ = p;
  }
  // @@protoc_insertion_point(field_mutable:dba.dbacond.cond2)
  return cond2_;
}
inline void dbacond::set_allocated_cond2(::dba::dbacond* cond2) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete cond2_;
  }
  if (cond2) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      cond2 = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, cond2, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  cond2_ = cond2;
  // @@protoc_insertion_point(field_set_allocated:dba.dbacond.cond2)
}

// -------------------------------------------------------------------

// dbaLhs

// required .dba.dbaLhs.typeid_dbalhs typeid = 1;
inline bool dbaLhs::has_typeid_() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void dbaLhs::clear_typeid_() {
  typeid__ = 1;
  _has_bits_[0] &= ~0x00000020u;
}
inline ::dba::dbaLhs_typeid_dbalhs dbaLhs::typeid_() const {
  // @@protoc_insertion_point(field_get:dba.dbaLhs.typeid)
  return static_cast< ::dba::dbaLhs_typeid_dbalhs >(typeid__);
}
inline void dbaLhs::set_typeid_(::dba::dbaLhs_typeid_dbalhs value) {
  assert(::dba::dbaLhs_typeid_dbalhs_IsValid(value));
  _has_bits_[0] |= 0x00000020u;
  typeid__ = value;
  // @@protoc_insertion_point(field_set:dba.dbaLhs.typeid)
}

// optional string name = 2;
inline bool dbaLhs::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void dbaLhs::clear_name() {
  name_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& dbaLhs::name() const {
  // @@protoc_insertion_point(field_get:dba.dbaLhs.name)
  return name_.GetNoArena();
}
inline void dbaLhs::set_name(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:dba.dbaLhs.name)
}
inline void dbaLhs::set_name(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  name_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:dba.dbaLhs.name)
}
inline void dbaLhs::set_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:dba.dbaLhs.name)
}
inline void dbaLhs::set_name(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:dba.dbaLhs.name)
}
inline std::string* dbaLhs::mutable_name() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:dba.dbaLhs.name)
  return name_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* dbaLhs::release_name() {
  // @@protoc_insertion_point(field_release:dba.dbaLhs.name)
  if (!has_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return name_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void dbaLhs::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  name_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:dba.dbaLhs.name)
}

// optional uint32 size = 3;
inline bool dbaLhs::has_size() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void dbaLhs::clear_size() {
  size_ = 0u;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 dbaLhs::size() const {
  // @@protoc_insertion_point(field_get:dba.dbaLhs.size)
  return size_;
}
inline void dbaLhs::set_size(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000004u;
  size_ = value;
  // @@protoc_insertion_point(field_set:dba.dbaLhs.size)
}

// optional uint32 low = 4;
inline bool dbaLhs::has_low() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void dbaLhs::clear_low() {
  low_ = 0u;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 dbaLhs::low() const {
  // @@protoc_insertion_point(field_get:dba.dbaLhs.low)
  return low_;
}
inline void dbaLhs::set_low(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000008u;
  low_ = value;
  // @@protoc_insertion_point(field_set:dba.dbaLhs.low)
}

// optional uint32 high = 5;
inline bool dbaLhs::has_high() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void dbaLhs::clear_high() {
  high_ = 0u;
  _has_bits_[0] &= ~0x00000010u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 dbaLhs::high() const {
  // @@protoc_insertion_point(field_get:dba.dbaLhs.high)
  return high_;
}
inline void dbaLhs::set_high(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000010u;
  high_ = value;
  // @@protoc_insertion_point(field_set:dba.dbaLhs.high)
}

// optional .dba.endianness endian = 6;
inline bool dbaLhs::has_endian() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void dbaLhs::clear_endian() {
  endian_ = 1;
  _has_bits_[0] &= ~0x00000040u;
}
inline ::dba::endianness dbaLhs::endian() const {
  // @@protoc_insertion_point(field_get:dba.dbaLhs.endian)
  return static_cast< ::dba::endianness >(endian_);
}
inline void dbaLhs::set_endian(::dba::endianness value) {
  assert(::dba::endianness_IsValid(value));
  _has_bits_[0] |= 0x00000040u;
  endian_ = value;
  // @@protoc_insertion_point(field_set:dba.dbaLhs.endian)
}

// optional .dba.dbaexpr expr = 7;
inline bool dbaLhs::has_expr() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void dbaLhs::clear_expr() {
  if (expr_ != nullptr) expr_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::dba::dbaexpr& dbaLhs::expr() const {
  const ::dba::dbaexpr* p = expr_;
  // @@protoc_insertion_point(field_get:dba.dbaLhs.expr)
  return p != nullptr ? *p : *reinterpret_cast<const ::dba::dbaexpr*>(
      &::dba::_dbaexpr_default_instance_);
}
inline ::dba::dbaexpr* dbaLhs::release_expr() {
  // @@protoc_insertion_point(field_release:dba.dbaLhs.expr)
  _has_bits_[0] &= ~0x00000002u;
  ::dba::dbaexpr* temp = expr_;
  expr_ = nullptr;
  return temp;
}
inline ::dba::dbaexpr* dbaLhs::mutable_expr() {
  _has_bits_[0] |= 0x00000002u;
  if (expr_ == nullptr) {
    auto* p = CreateMaybeMessage<::dba::dbaexpr>(GetArenaNoVirtual());
    expr_ = p;
  }
  // @@protoc_insertion_point(field_mutable:dba.dbaLhs.expr)
  return expr_;
}
inline void dbaLhs::set_allocated_expr(::dba::dbaexpr* expr) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete expr_;
  }
  if (expr) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      expr = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, expr, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  expr_ = expr;
  // @@protoc_insertion_point(field_set_allocated:dba.dbaLhs.expr)
}

// -------------------------------------------------------------------

// dbainstr

// required .dba.dbainstr.typeid_instrkind typeid = 1;
inline bool dbainstr::has_typeid_() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void dbainstr::clear_typeid_() {
  typeid__ = 1;
  _has_bits_[0] &= ~0x00000100u;
}
inline ::dba::dbainstr_typeid_instrkind dbainstr::typeid_() const {
  // @@protoc_insertion_point(field_get:dba.dbainstr.typeid)
  return static_cast< ::dba::dbainstr_typeid_instrkind >(typeid__);
}
inline void dbainstr::set_typeid_(::dba::dbainstr_typeid_instrkind value) {
  assert(::dba::dbainstr_typeid_instrkind_IsValid(value));
  _has_bits_[0] |= 0x00000100u;
  typeid__ = value;
  // @@protoc_insertion_point(field_set:dba.dbainstr.typeid)
}

// required .dba.dbacodeaddress location = 2;
inline bool dbainstr::has_location() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void dbainstr::clear_location() {
  if (location_ != nullptr) location_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::dba::dbacodeaddress& dbainstr::location() const {
  const ::dba::dbacodeaddress* p = location_;
  // @@protoc_insertion_point(field_get:dba.dbainstr.location)
  return p != nullptr ? *p : *reinterpret_cast<const ::dba::dbacodeaddress*>(
      &::dba::_dbacodeaddress_default_instance_);
}
inline ::dba::dbacodeaddress* dbainstr::release_location() {
  // @@protoc_insertion_point(field_release:dba.dbainstr.location)
  _has_bits_[0] &= ~0x00000001u;
  ::dba::dbacodeaddress* temp = location_;
  location_ = nullptr;
  return temp;
}
inline ::dba::dbacodeaddress* dbainstr::mutable_location() {
  _has_bits_[0] |= 0x00000001u;
  if (location_ == nullptr) {
    auto* p = CreateMaybeMessage<::dba::dbacodeaddress>(GetArenaNoVirtual());
    location_ = p;
  }
  // @@protoc_insertion_point(field_mutable:dba.dbainstr.location)
  return location_;
}
inline void dbainstr::set_allocated_location(::dba::dbacodeaddress* location) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete location_;
  }
  if (location) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      location = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, location, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  location_ = location;
  // @@protoc_insertion_point(field_set_allocated:dba.dbainstr.location)
}

// optional .dba.dbaLhs lhs = 3;
inline bool dbainstr::has_lhs() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void dbainstr::clear_lhs() {
  if (lhs_ != nullptr) lhs_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::dba::dbaLhs& dbainstr::lhs() const {
  const ::dba::dbaLhs* p = lhs_;
  // @@protoc_insertion_point(field_get:dba.dbainstr.lhs)
  return p != nullptr ? *p : *reinterpret_cast<const ::dba::dbaLhs*>(
      &::dba::_dbaLhs_default_instance_);
}
inline ::dba::dbaLhs* dbainstr::release_lhs() {
  // @@protoc_insertion_point(field_release:dba.dbainstr.lhs)
  _has_bits_[0] &= ~0x00000002u;
  ::dba::dbaLhs* temp = lhs_;
  lhs_ = nullptr;
  return temp;
}
inline ::dba::dbaLhs* dbainstr::mutable_lhs() {
  _has_bits_[0] |= 0x00000002u;
  if (lhs_ == nullptr) {
    auto* p = CreateMaybeMessage<::dba::dbaLhs>(GetArenaNoVirtual());
    lhs_ = p;
  }
  // @@protoc_insertion_point(field_mutable:dba.dbainstr.lhs)
  return lhs_;
}
inline void dbainstr::set_allocated_lhs(::dba::dbaLhs* lhs) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete lhs_;
  }
  if (lhs) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      lhs = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, lhs, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  lhs_ = lhs;
  // @@protoc_insertion_point(field_set_allocated:dba.dbainstr.lhs)
}

// optional .dba.dbaexpr expr = 4;
inline bool dbainstr::has_expr() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void dbainstr::clear_expr() {
  if (expr_ != nullptr) expr_->Clear();
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::dba::dbaexpr& dbainstr::expr() const {
  const ::dba::dbaexpr* p = expr_;
  // @@protoc_insertion_point(field_get:dba.dbainstr.expr)
  return p != nullptr ? *p : *reinterpret_cast<const ::dba::dbaexpr*>(
      &::dba::_dbaexpr_default_instance_);
}
inline ::dba::dbaexpr* dbainstr::release_expr() {
  // @@protoc_insertion_point(field_release:dba.dbainstr.expr)
  _has_bits_[0] &= ~0x00000004u;
  ::dba::dbaexpr* temp = expr_;
  expr_ = nullptr;
  return temp;
}
inline ::dba::dbaexpr* dbainstr::mutable_expr() {
  _has_bits_[0] |= 0x00000004u;
  if (expr_ == nullptr) {
    auto* p = CreateMaybeMessage<::dba::dbaexpr>(GetArenaNoVirtual());
    expr_ = p;
  }
  // @@protoc_insertion_point(field_mutable:dba.dbainstr.expr)
  return expr_;
}
inline void dbainstr::set_allocated_expr(::dba::dbaexpr* expr) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete expr_;
  }
  if (expr) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      expr = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, expr, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  expr_ = expr;
  // @@protoc_insertion_point(field_set_allocated:dba.dbainstr.expr)
}

// optional uint32 offset = 5;
inline bool dbainstr::has_offset() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void dbainstr::clear_offset() {
  offset_ = 0u;
  _has_bits_[0] &= ~0x00000080u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 dbainstr::offset() const {
  // @@protoc_insertion_point(field_get:dba.dbainstr.offset)
  return offset_;
}
inline void dbainstr::set_offset(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000080u;
  offset_ = value;
  // @@protoc_insertion_point(field_set:dba.dbainstr.offset)
}

// optional .dba.codeaddress address = 6;
inline bool dbainstr::has_address() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void dbainstr::clear_address() {
  if (address_ != nullptr) address_->Clear();
  _has_bits_[0] &= ~0x00000008u;
}
inline const ::dba::codeaddress& dbainstr::address() const {
  const ::dba::codeaddress* p = address_;
  // @@protoc_insertion_point(field_get:dba.dbainstr.address)
  return p != nullptr ? *p : *reinterpret_cast<const ::dba::codeaddress*>(
      &::dba::_codeaddress_default_instance_);
}
inline ::dba::codeaddress* dbainstr::release_address() {
  // @@protoc_insertion_point(field_release:dba.dbainstr.address)
  _has_bits_[0] &= ~0x00000008u;
  ::dba::codeaddress* temp = address_;
  address_ = nullptr;
  return temp;
}
inline ::dba::codeaddress* dbainstr::mutable_address() {
  _has_bits_[0] |= 0x00000008u;
  if (address_ == nullptr) {
    auto* p = CreateMaybeMessage<::dba::codeaddress>(GetArenaNoVirtual());
    address_ = p;
  }
  // @@protoc_insertion_point(field_mutable:dba.dbainstr.address)
  return address_;
}
inline void dbainstr::set_allocated_address(::dba::codeaddress* address) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete address_;
  }
  if (address) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      address = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, address, submessage_arena);
    }
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  address_ = address;
  // @@protoc_insertion_point(field_set_allocated:dba.dbainstr.address)
}

// optional .dba.dbatag tags = 7;
inline bool dbainstr::has_tags() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void dbainstr::clear_tags() {
  if (tags_ != nullptr) tags_->Clear();
  _has_bits_[0] &= ~0x00000010u;
}
inline const ::dba::dbatag& dbainstr::tags() const {
  const ::dba::dbatag* p = tags_;
  // @@protoc_insertion_point(field_get:dba.dbainstr.tags)
  return p != nullptr ? *p : *reinterpret_cast<const ::dba::dbatag*>(
      &::dba::_dbatag_default_instance_);
}
inline ::dba::dbatag* dbainstr::release_tags() {
  // @@protoc_insertion_point(field_release:dba.dbainstr.tags)
  _has_bits_[0] &= ~0x00000010u;
  ::dba::dbatag* temp = tags_;
  tags_ = nullptr;
  return temp;
}
inline ::dba::dbatag* dbainstr::mutable_tags() {
  _has_bits_[0] |= 0x00000010u;
  if (tags_ == nullptr) {
    auto* p = CreateMaybeMessage<::dba::dbatag>(GetArenaNoVirtual());
    tags_ = p;
  }
  // @@protoc_insertion_point(field_mutable:dba.dbainstr.tags)
  return tags_;
}
inline void dbainstr::set_allocated_tags(::dba::dbatag* tags) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete tags_;
  }
  if (tags) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      tags = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, tags, submessage_arena);
    }
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  tags_ = tags;
  // @@protoc_insertion_point(field_set_allocated:dba.dbainstr.tags)
}

// optional .dba.dbacond cond = 8;
inline bool dbainstr::has_cond() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void dbainstr::clear_cond() {
  if (cond_ != nullptr) cond_->Clear();
  _has_bits_[0] &= ~0x00000020u;
}
inline const ::dba::dbacond& dbainstr::cond() const {
  const ::dba::dbacond* p = cond_;
  // @@protoc_insertion_point(field_get:dba.dbainstr.cond)
  return p != nullptr ? *p : *reinterpret_cast<const ::dba::dbacond*>(
      &::dba::_dbacond_default_instance_);
}
inline ::dba::dbacond* dbainstr::release_cond() {
  // @@protoc_insertion_point(field_release:dba.dbainstr.cond)
  _has_bits_[0] &= ~0x00000020u;
  ::dba::dbacond* temp = cond_;
  cond_ = nullptr;
  return temp;
}
inline ::dba::dbacond* dbainstr::mutable_cond() {
  _has_bits_[0] |= 0x00000020u;
  if (cond_ == nullptr) {
    auto* p = CreateMaybeMessage<::dba::dbacond>(GetArenaNoVirtual());
    cond_ = p;
  }
  // @@protoc_insertion_point(field_mutable:dba.dbainstr.cond)
  return cond_;
}
inline void dbainstr::set_allocated_cond(::dba::dbacond* cond) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete cond_;
  }
  if (cond) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      cond = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, cond, submessage_arena);
    }
    _has_bits_[0] |= 0x00000020u;
  } else {
    _has_bits_[0] &= ~0x00000020u;
  }
  cond_ = cond;
  // @@protoc_insertion_point(field_set_allocated:dba.dbainstr.cond)
}

// optional .dba.dbastopstate stopinfos = 9;
inline bool dbainstr::has_stopinfos() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void dbainstr::clear_stopinfos() {
  if (stopinfos_ != nullptr) stopinfos_->Clear();
  _has_bits_[0] &= ~0x00000040u;
}
inline const ::dba::dbastopstate& dbainstr::stopinfos() const {
  const ::dba::dbastopstate* p = stopinfos_;
  // @@protoc_insertion_point(field_get:dba.dbainstr.stopinfos)
  return p != nullptr ? *p : *reinterpret_cast<const ::dba::dbastopstate*>(
      &::dba::_dbastopstate_default_instance_);
}
inline ::dba::dbastopstate* dbainstr::release_stopinfos() {
  // @@protoc_insertion_point(field_release:dba.dbainstr.stopinfos)
  _has_bits_[0] &= ~0x00000040u;
  ::dba::dbastopstate* temp = stopinfos_;
  stopinfos_ = nullptr;
  return temp;
}
inline ::dba::dbastopstate* dbainstr::mutable_stopinfos() {
  _has_bits_[0] |= 0x00000040u;
  if (stopinfos_ == nullptr) {
    auto* p = CreateMaybeMessage<::dba::dbastopstate>(GetArenaNoVirtual());
    stopinfos_ = p;
  }
  // @@protoc_insertion_point(field_mutable:dba.dbainstr.stopinfos)
  return stopinfos_;
}
inline void dbainstr::set_allocated_stopinfos(::dba::dbastopstate* stopinfos) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete stopinfos_;
  }
  if (stopinfos) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      stopinfos = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, stopinfos, submessage_arena);
    }
    _has_bits_[0] |= 0x00000040u;
  } else {
    _has_bits_[0] &= ~0x00000040u;
  }
  stopinfos_ = stopinfos;
  // @@protoc_insertion_point(field_set_allocated:dba.dbainstr.stopinfos)
}

// repeated .dba.dbaexpr exprs = 10;
inline int dbainstr::exprs_size() const {
  return exprs_.size();
}
inline void dbainstr::clear_exprs() {
  exprs_.Clear();
}
inline ::dba::dbaexpr* dbainstr::mutable_exprs(int index) {
  // @@protoc_insertion_point(field_mutable:dba.dbainstr.exprs)
  return exprs_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::dba::dbaexpr >*
dbainstr::mutable_exprs() {
  // @@protoc_insertion_point(field_mutable_list:dba.dbainstr.exprs)
  return &exprs_;
}
inline const ::dba::dbaexpr& dbainstr::exprs(int index) const {
  // @@protoc_insertion_point(field_get:dba.dbainstr.exprs)
  return exprs_.Get(index);
}
inline ::dba::dbaexpr* dbainstr::add_exprs() {
  // @@protoc_insertion_point(field_add:dba.dbainstr.exprs)
  return exprs_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::dba::dbaexpr >&
dbainstr::exprs() const {
  // @@protoc_insertion_point(field_list:dba.dbainstr.exprs)
  return exprs_;
}

// -------------------------------------------------------------------

// dba_list

// repeated .dba.dbainstr instrs = 1;
inline int dba_list::instrs_size() const {
  return instrs_.size();
}
inline void dba_list::clear_instrs() {
  instrs_.Clear();
}
inline ::dba::dbainstr* dba_list::mutable_instrs(int index) {
  // @@protoc_insertion_point(field_mutable:dba.dba_list.instrs)
  return instrs_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::dba::dbainstr >*
dba_list::mutable_instrs() {
  // @@protoc_insertion_point(field_mutable_list:dba.dba_list.instrs)
  return &instrs_;
}
inline const ::dba::dbainstr& dba_list::instrs(int index) const {
  // @@protoc_insertion_point(field_get:dba.dba_list.instrs)
  return instrs_.Get(index);
}
inline ::dba::dbainstr* dba_list::add_instrs() {
  // @@protoc_insertion_point(field_add:dba.dba_list.instrs)
  return instrs_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::dba::dbainstr >&
dba_list::instrs() const {
  // @@protoc_insertion_point(field_list:dba.dba_list.instrs)
  return instrs_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace dba

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::dba::codeaddress_typeid_codeaddress> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::dba::codeaddress_typeid_codeaddress>() {
  return ::dba::codeaddress_typeid_codeaddress_descriptor();
}
template <> struct is_proto_enum< ::dba::dbatag_typeid_dbatag> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::dba::dbatag_typeid_dbatag>() {
  return ::dba::dbatag_typeid_dbatag_descriptor();
}
template <> struct is_proto_enum< ::dba::dbastopstate_typeid_dbastate> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::dba::dbastopstate_typeid_dbastate>() {
  return ::dba::dbastopstate_typeid_dbastate_descriptor();
}
template <> struct is_proto_enum< ::dba::dbaexpr_typeid_dbaexpr> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::dba::dbaexpr_typeid_dbaexpr>() {
  return ::dba::dbaexpr_typeid_dbaexpr_descriptor();
}
template <> struct is_proto_enum< ::dba::dbaexpr_dbaunary> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::dba::dbaexpr_dbaunary>() {
  return ::dba::dbaexpr_dbaunary_descriptor();
}
template <> struct is_proto_enum< ::dba::dbaexpr_dbabinary> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::dba::dbaexpr_dbabinary>() {
  return ::dba::dbaexpr_dbabinary_descriptor();
}
template <> struct is_proto_enum< ::dba::dbacond_typeid_dbacond> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::dba::dbacond_typeid_dbacond>() {
  return ::dba::dbacond_typeid_dbacond_descriptor();
}
template <> struct is_proto_enum< ::dba::dbaLhs_typeid_dbalhs> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::dba::dbaLhs_typeid_dbalhs>() {
  return ::dba::dbaLhs_typeid_dbalhs_descriptor();
}
template <> struct is_proto_enum< ::dba::dbainstr_typeid_instrkind> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::dba::dbainstr_typeid_instrkind>() {
  return ::dba::dbainstr_typeid_instrkind_descriptor();
}
template <> struct is_proto_enum< ::dba::endianness> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::dba::endianness>() {
  return ::dba::endianness_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_dba_2eproto
