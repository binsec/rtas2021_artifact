// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: libcall.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_libcall_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_libcall_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3009000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3009001 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "common.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_libcall_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_libcall_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxillaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[65]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_libcall_2eproto;
namespace libcall_types {
class atoi_pol;
class atoi_polDefaultTypeInternal;
extern atoi_polDefaultTypeInternal _atoi_pol_default_instance_;
class atoi_t;
class atoi_tDefaultTypeInternal;
extern atoi_tDefaultTypeInternal _atoi_t_default_instance_;
class bsearch_pol;
class bsearch_polDefaultTypeInternal;
extern bsearch_polDefaultTypeInternal _bsearch_pol_default_instance_;
class bsearch_t;
class bsearch_tDefaultTypeInternal;
extern bsearch_tDefaultTypeInternal _bsearch_t_default_instance_;
class ctype_b_loc_pol;
class ctype_b_loc_polDefaultTypeInternal;
extern ctype_b_loc_polDefaultTypeInternal _ctype_b_loc_pol_default_instance_;
class ctype_b_loc_t;
class ctype_b_loc_tDefaultTypeInternal;
extern ctype_b_loc_tDefaultTypeInternal _ctype_b_loc_t_default_instance_;
class exit_pol;
class exit_polDefaultTypeInternal;
extern exit_polDefaultTypeInternal _exit_pol_default_instance_;
class exit_t;
class exit_tDefaultTypeInternal;
extern exit_tDefaultTypeInternal _exit_t_default_instance_;
class fgetc_pol;
class fgetc_polDefaultTypeInternal;
extern fgetc_polDefaultTypeInternal _fgetc_pol_default_instance_;
class fgetc_t;
class fgetc_tDefaultTypeInternal;
extern fgetc_tDefaultTypeInternal _fgetc_t_default_instance_;
class fread_pol;
class fread_polDefaultTypeInternal;
extern fread_polDefaultTypeInternal _fread_pol_default_instance_;
class fread_t;
class fread_tDefaultTypeInternal;
extern fread_tDefaultTypeInternal _fread_t_default_instance_;
class free_pol;
class free_polDefaultTypeInternal;
extern free_polDefaultTypeInternal _free_pol_default_instance_;
class free_t;
class free_tDefaultTypeInternal;
extern free_tDefaultTypeInternal _free_t_default_instance_;
class fscanf_elem_t;
class fscanf_elem_tDefaultTypeInternal;
extern fscanf_elem_tDefaultTypeInternal _fscanf_elem_t_default_instance_;
class fscanf_pol;
class fscanf_polDefaultTypeInternal;
extern fscanf_polDefaultTypeInternal _fscanf_pol_default_instance_;
class fscanf_t;
class fscanf_tDefaultTypeInternal;
extern fscanf_tDefaultTypeInternal _fscanf_t_default_instance_;
class fstat_pol;
class fstat_polDefaultTypeInternal;
extern fstat_polDefaultTypeInternal _fstat_pol_default_instance_;
class fstat_t;
class fstat_tDefaultTypeInternal;
extern fstat_tDefaultTypeInternal _fstat_t_default_instance_;
class fxstat64_pol;
class fxstat64_polDefaultTypeInternal;
extern fxstat64_polDefaultTypeInternal _fxstat64_pol_default_instance_;
class fxstat64_t;
class fxstat64_tDefaultTypeInternal;
extern fxstat64_tDefaultTypeInternal _fxstat64_t_default_instance_;
class generic_pol;
class generic_polDefaultTypeInternal;
extern generic_polDefaultTypeInternal _generic_pol_default_instance_;
class generic_t;
class generic_tDefaultTypeInternal;
extern generic_tDefaultTypeInternal _generic_t_default_instance_;
class gethostname_pol;
class gethostname_polDefaultTypeInternal;
extern gethostname_polDefaultTypeInternal _gethostname_pol_default_instance_;
class gethostname_t;
class gethostname_tDefaultTypeInternal;
extern gethostname_tDefaultTypeInternal _gethostname_t_default_instance_;
class getmainargs_pol;
class getmainargs_polDefaultTypeInternal;
extern getmainargs_polDefaultTypeInternal _getmainargs_pol_default_instance_;
class getmainargs_t;
class getmainargs_tDefaultTypeInternal;
extern getmainargs_tDefaultTypeInternal _getmainargs_t_default_instance_;
class getmodulehandle_pol;
class getmodulehandle_polDefaultTypeInternal;
extern getmodulehandle_polDefaultTypeInternal _getmodulehandle_pol_default_instance_;
class getmodulehandle_t;
class getmodulehandle_tDefaultTypeInternal;
extern getmodulehandle_tDefaultTypeInternal _getmodulehandle_t_default_instance_;
class getprocaddress_pol;
class getprocaddress_polDefaultTypeInternal;
extern getprocaddress_polDefaultTypeInternal _getprocaddress_pol_default_instance_;
class getprocaddress_t;
class getprocaddress_tDefaultTypeInternal;
extern getprocaddress_tDefaultTypeInternal _getprocaddress_t_default_instance_;
class libcall_pol;
class libcall_polDefaultTypeInternal;
extern libcall_polDefaultTypeInternal _libcall_pol_default_instance_;
class libcall_t;
class libcall_tDefaultTypeInternal;
extern libcall_tDefaultTypeInternal _libcall_t_default_instance_;
class lseek_pol;
class lseek_polDefaultTypeInternal;
extern lseek_polDefaultTypeInternal _lseek_pol_default_instance_;
class lseek_t;
class lseek_tDefaultTypeInternal;
extern lseek_tDefaultTypeInternal _lseek_t_default_instance_;
class malloc_pol;
class malloc_polDefaultTypeInternal;
extern malloc_polDefaultTypeInternal _malloc_pol_default_instance_;
class malloc_t;
class malloc_tDefaultTypeInternal;
extern malloc_tDefaultTypeInternal _malloc_t_default_instance_;
class memcmp_pol;
class memcmp_polDefaultTypeInternal;
extern memcmp_polDefaultTypeInternal _memcmp_pol_default_instance_;
class memcmp_t;
class memcmp_tDefaultTypeInternal;
extern memcmp_tDefaultTypeInternal _memcmp_t_default_instance_;
class memcpy_pol;
class memcpy_polDefaultTypeInternal;
extern memcpy_polDefaultTypeInternal _memcpy_pol_default_instance_;
class memcpy_t;
class memcpy_tDefaultTypeInternal;
extern memcpy_tDefaultTypeInternal _memcpy_t_default_instance_;
class memset_pol;
class memset_polDefaultTypeInternal;
extern memset_polDefaultTypeInternal _memset_pol_default_instance_;
class memset_t;
class memset_tDefaultTypeInternal;
extern memset_tDefaultTypeInternal _memset_t_default_instance_;
class mmap_pol;
class mmap_polDefaultTypeInternal;
extern mmap_polDefaultTypeInternal _mmap_pol_default_instance_;
class mmap_t;
class mmap_tDefaultTypeInternal;
extern mmap_tDefaultTypeInternal _mmap_t_default_instance_;
class open_pol;
class open_polDefaultTypeInternal;
extern open_polDefaultTypeInternal _open_pol_default_instance_;
class open_t;
class open_tDefaultTypeInternal;
extern open_tDefaultTypeInternal _open_t_default_instance_;
class printf_pol;
class printf_polDefaultTypeInternal;
extern printf_polDefaultTypeInternal _printf_pol_default_instance_;
class printf_t;
class printf_tDefaultTypeInternal;
extern printf_tDefaultTypeInternal _printf_t_default_instance_;
class qsort_pol;
class qsort_polDefaultTypeInternal;
extern qsort_polDefaultTypeInternal _qsort_pol_default_instance_;
class qsort_t;
class qsort_tDefaultTypeInternal;
extern qsort_tDefaultTypeInternal _qsort_t_default_instance_;
class read_pol;
class read_polDefaultTypeInternal;
extern read_polDefaultTypeInternal _read_pol_default_instance_;
class read_t;
class read_tDefaultTypeInternal;
extern read_tDefaultTypeInternal _read_t_default_instance_;
class realloc_pol;
class realloc_polDefaultTypeInternal;
extern realloc_polDefaultTypeInternal _realloc_pol_default_instance_;
class realloc_t;
class realloc_tDefaultTypeInternal;
extern realloc_tDefaultTypeInternal _realloc_t_default_instance_;
class strchr_pol;
class strchr_polDefaultTypeInternal;
extern strchr_polDefaultTypeInternal _strchr_pol_default_instance_;
class strchr_t;
class strchr_tDefaultTypeInternal;
extern strchr_tDefaultTypeInternal _strchr_t_default_instance_;
class strcmp_pol;
class strcmp_polDefaultTypeInternal;
extern strcmp_polDefaultTypeInternal _strcmp_pol_default_instance_;
class strcmp_t;
class strcmp_tDefaultTypeInternal;
extern strcmp_tDefaultTypeInternal _strcmp_t_default_instance_;
class strcpy_pol;
class strcpy_polDefaultTypeInternal;
extern strcpy_polDefaultTypeInternal _strcpy_pol_default_instance_;
class strcpy_t;
class strcpy_tDefaultTypeInternal;
extern strcpy_tDefaultTypeInternal _strcpy_t_default_instance_;
class strncmp_pol;
class strncmp_polDefaultTypeInternal;
extern strncmp_polDefaultTypeInternal _strncmp_pol_default_instance_;
class strncmp_t;
class strncmp_tDefaultTypeInternal;
extern strncmp_tDefaultTypeInternal _strncmp_t_default_instance_;
class strncpy_pol;
class strncpy_polDefaultTypeInternal;
extern strncpy_polDefaultTypeInternal _strncpy_pol_default_instance_;
class strncpy_t;
class strncpy_tDefaultTypeInternal;
extern strncpy_tDefaultTypeInternal _strncpy_t_default_instance_;
}  // namespace libcall_types
PROTOBUF_NAMESPACE_OPEN
template<> ::libcall_types::atoi_pol* Arena::CreateMaybeMessage<::libcall_types::atoi_pol>(Arena*);
template<> ::libcall_types::atoi_t* Arena::CreateMaybeMessage<::libcall_types::atoi_t>(Arena*);
template<> ::libcall_types::bsearch_pol* Arena::CreateMaybeMessage<::libcall_types::bsearch_pol>(Arena*);
template<> ::libcall_types::bsearch_t* Arena::CreateMaybeMessage<::libcall_types::bsearch_t>(Arena*);
template<> ::libcall_types::ctype_b_loc_pol* Arena::CreateMaybeMessage<::libcall_types::ctype_b_loc_pol>(Arena*);
template<> ::libcall_types::ctype_b_loc_t* Arena::CreateMaybeMessage<::libcall_types::ctype_b_loc_t>(Arena*);
template<> ::libcall_types::exit_pol* Arena::CreateMaybeMessage<::libcall_types::exit_pol>(Arena*);
template<> ::libcall_types::exit_t* Arena::CreateMaybeMessage<::libcall_types::exit_t>(Arena*);
template<> ::libcall_types::fgetc_pol* Arena::CreateMaybeMessage<::libcall_types::fgetc_pol>(Arena*);
template<> ::libcall_types::fgetc_t* Arena::CreateMaybeMessage<::libcall_types::fgetc_t>(Arena*);
template<> ::libcall_types::fread_pol* Arena::CreateMaybeMessage<::libcall_types::fread_pol>(Arena*);
template<> ::libcall_types::fread_t* Arena::CreateMaybeMessage<::libcall_types::fread_t>(Arena*);
template<> ::libcall_types::free_pol* Arena::CreateMaybeMessage<::libcall_types::free_pol>(Arena*);
template<> ::libcall_types::free_t* Arena::CreateMaybeMessage<::libcall_types::free_t>(Arena*);
template<> ::libcall_types::fscanf_elem_t* Arena::CreateMaybeMessage<::libcall_types::fscanf_elem_t>(Arena*);
template<> ::libcall_types::fscanf_pol* Arena::CreateMaybeMessage<::libcall_types::fscanf_pol>(Arena*);
template<> ::libcall_types::fscanf_t* Arena::CreateMaybeMessage<::libcall_types::fscanf_t>(Arena*);
template<> ::libcall_types::fstat_pol* Arena::CreateMaybeMessage<::libcall_types::fstat_pol>(Arena*);
template<> ::libcall_types::fstat_t* Arena::CreateMaybeMessage<::libcall_types::fstat_t>(Arena*);
template<> ::libcall_types::fxstat64_pol* Arena::CreateMaybeMessage<::libcall_types::fxstat64_pol>(Arena*);
template<> ::libcall_types::fxstat64_t* Arena::CreateMaybeMessage<::libcall_types::fxstat64_t>(Arena*);
template<> ::libcall_types::generic_pol* Arena::CreateMaybeMessage<::libcall_types::generic_pol>(Arena*);
template<> ::libcall_types::generic_t* Arena::CreateMaybeMessage<::libcall_types::generic_t>(Arena*);
template<> ::libcall_types::gethostname_pol* Arena::CreateMaybeMessage<::libcall_types::gethostname_pol>(Arena*);
template<> ::libcall_types::gethostname_t* Arena::CreateMaybeMessage<::libcall_types::gethostname_t>(Arena*);
template<> ::libcall_types::getmainargs_pol* Arena::CreateMaybeMessage<::libcall_types::getmainargs_pol>(Arena*);
template<> ::libcall_types::getmainargs_t* Arena::CreateMaybeMessage<::libcall_types::getmainargs_t>(Arena*);
template<> ::libcall_types::getmodulehandle_pol* Arena::CreateMaybeMessage<::libcall_types::getmodulehandle_pol>(Arena*);
template<> ::libcall_types::getmodulehandle_t* Arena::CreateMaybeMessage<::libcall_types::getmodulehandle_t>(Arena*);
template<> ::libcall_types::getprocaddress_pol* Arena::CreateMaybeMessage<::libcall_types::getprocaddress_pol>(Arena*);
template<> ::libcall_types::getprocaddress_t* Arena::CreateMaybeMessage<::libcall_types::getprocaddress_t>(Arena*);
template<> ::libcall_types::libcall_pol* Arena::CreateMaybeMessage<::libcall_types::libcall_pol>(Arena*);
template<> ::libcall_types::libcall_t* Arena::CreateMaybeMessage<::libcall_types::libcall_t>(Arena*);
template<> ::libcall_types::lseek_pol* Arena::CreateMaybeMessage<::libcall_types::lseek_pol>(Arena*);
template<> ::libcall_types::lseek_t* Arena::CreateMaybeMessage<::libcall_types::lseek_t>(Arena*);
template<> ::libcall_types::malloc_pol* Arena::CreateMaybeMessage<::libcall_types::malloc_pol>(Arena*);
template<> ::libcall_types::malloc_t* Arena::CreateMaybeMessage<::libcall_types::malloc_t>(Arena*);
template<> ::libcall_types::memcmp_pol* Arena::CreateMaybeMessage<::libcall_types::memcmp_pol>(Arena*);
template<> ::libcall_types::memcmp_t* Arena::CreateMaybeMessage<::libcall_types::memcmp_t>(Arena*);
template<> ::libcall_types::memcpy_pol* Arena::CreateMaybeMessage<::libcall_types::memcpy_pol>(Arena*);
template<> ::libcall_types::memcpy_t* Arena::CreateMaybeMessage<::libcall_types::memcpy_t>(Arena*);
template<> ::libcall_types::memset_pol* Arena::CreateMaybeMessage<::libcall_types::memset_pol>(Arena*);
template<> ::libcall_types::memset_t* Arena::CreateMaybeMessage<::libcall_types::memset_t>(Arena*);
template<> ::libcall_types::mmap_pol* Arena::CreateMaybeMessage<::libcall_types::mmap_pol>(Arena*);
template<> ::libcall_types::mmap_t* Arena::CreateMaybeMessage<::libcall_types::mmap_t>(Arena*);
template<> ::libcall_types::open_pol* Arena::CreateMaybeMessage<::libcall_types::open_pol>(Arena*);
template<> ::libcall_types::open_t* Arena::CreateMaybeMessage<::libcall_types::open_t>(Arena*);
template<> ::libcall_types::printf_pol* Arena::CreateMaybeMessage<::libcall_types::printf_pol>(Arena*);
template<> ::libcall_types::printf_t* Arena::CreateMaybeMessage<::libcall_types::printf_t>(Arena*);
template<> ::libcall_types::qsort_pol* Arena::CreateMaybeMessage<::libcall_types::qsort_pol>(Arena*);
template<> ::libcall_types::qsort_t* Arena::CreateMaybeMessage<::libcall_types::qsort_t>(Arena*);
template<> ::libcall_types::read_pol* Arena::CreateMaybeMessage<::libcall_types::read_pol>(Arena*);
template<> ::libcall_types::read_t* Arena::CreateMaybeMessage<::libcall_types::read_t>(Arena*);
template<> ::libcall_types::realloc_pol* Arena::CreateMaybeMessage<::libcall_types::realloc_pol>(Arena*);
template<> ::libcall_types::realloc_t* Arena::CreateMaybeMessage<::libcall_types::realloc_t>(Arena*);
template<> ::libcall_types::strchr_pol* Arena::CreateMaybeMessage<::libcall_types::strchr_pol>(Arena*);
template<> ::libcall_types::strchr_t* Arena::CreateMaybeMessage<::libcall_types::strchr_t>(Arena*);
template<> ::libcall_types::strcmp_pol* Arena::CreateMaybeMessage<::libcall_types::strcmp_pol>(Arena*);
template<> ::libcall_types::strcmp_t* Arena::CreateMaybeMessage<::libcall_types::strcmp_t>(Arena*);
template<> ::libcall_types::strcpy_pol* Arena::CreateMaybeMessage<::libcall_types::strcpy_pol>(Arena*);
template<> ::libcall_types::strcpy_t* Arena::CreateMaybeMessage<::libcall_types::strcpy_t>(Arena*);
template<> ::libcall_types::strncmp_pol* Arena::CreateMaybeMessage<::libcall_types::strncmp_pol>(Arena*);
template<> ::libcall_types::strncmp_t* Arena::CreateMaybeMessage<::libcall_types::strncmp_t>(Arena*);
template<> ::libcall_types::strncpy_pol* Arena::CreateMaybeMessage<::libcall_types::strncpy_pol>(Arena*);
template<> ::libcall_types::strncpy_t* Arena::CreateMaybeMessage<::libcall_types::strncpy_t>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace libcall_types {

enum lib_ident : int {
  INVALID = 0,
  PRINTF = 1,
  STRCPY = 2,
  ATOI = 3,
  MALLOC = 4,
  FREE = 5,
  MEMCPY = 6,
  MEMSET = 7,
  FGETC = 8,
  READ = 9,
  STRCHR = 10,
  EXIT = 11,
  STRCMP = 12,
  CTYPE_B_LOC = 13,
  FSCANF = 14,
  STRRCHR = 15,
  STRNCPY = 16,
  FSTAT = 17,
  REALLOC = 18,
  MMAP = 19,
  QSORT = 20,
  BSEARCH = 21,
  OPEN_STUB = 22,
  LSEEK = 23,
  FREAD = 24,
  STRNCMP = 25,
  MEMCMP = 26,
  FXSTAT64 = 27,
  GETMODULEHANDLE = 100,
  GETPROCADDRESS = 101,
  GETMAINARGS = 102,
  GETHOSTNAME = 103,
  GENERIC = 255
};
bool lib_ident_IsValid(int value);
constexpr lib_ident lib_ident_MIN = INVALID;
constexpr lib_ident lib_ident_MAX = GENERIC;
constexpr int lib_ident_ARRAYSIZE = lib_ident_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* lib_ident_descriptor();
template<typename T>
inline const std::string& lib_ident_Name(T enum_t_value) {
  static_assert(::std::is_same<T, lib_ident>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function lib_ident_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    lib_ident_descriptor(), enum_t_value);
}
inline bool lib_ident_Parse(
    const std::string& name, lib_ident* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<lib_ident>(
    lib_ident_descriptor(), name, value);
}
enum fscanf_enum : int {
  d = 0,
  dd = 1,
  i = 2,
  o = 3,
  u = 4,
  x = 5,
  xx = 6,
  f = 7,
  e = 8,
  g = 9,
  ee = 10,
  a = 11,
  s = 12,
  c = 13,
  sb = 14,
  p = 15,
  n = 16
};
bool fscanf_enum_IsValid(int value);
constexpr fscanf_enum fscanf_enum_MIN = d;
constexpr fscanf_enum fscanf_enum_MAX = n;
constexpr int fscanf_enum_ARRAYSIZE = fscanf_enum_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* fscanf_enum_descriptor();
template<typename T>
inline const std::string& fscanf_enum_Name(T enum_t_value) {
  static_assert(::std::is_same<T, fscanf_enum>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function fscanf_enum_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    fscanf_enum_descriptor(), enum_t_value);
}
inline bool fscanf_enum_Parse(
    const std::string& name, fscanf_enum* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<fscanf_enum>(
    fscanf_enum_descriptor(), name, value);
}
// ===================================================================

class libcall_pol :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:libcall_types.libcall_pol) */ {
 public:
  libcall_pol();
  virtual ~libcall_pol();

  libcall_pol(const libcall_pol& from);
  libcall_pol(libcall_pol&& from) noexcept
    : libcall_pol() {
    *this = ::std::move(from);
  }

  inline libcall_pol& operator=(const libcall_pol& from) {
    CopyFrom(from);
    return *this;
  }
  inline libcall_pol& operator=(libcall_pol&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const libcall_pol& default_instance();

  enum LibcallCntCase {
    kStrcpy = 5,
    kPrintf = 6,
    kAtoi = 7,
    kMalloc = 8,
    kGetmodulehandle = 9,
    kGetprocaddress = 10,
    kGetmainargs = 11,
    kGethostname = 12,
    kFree = 13,
    kMemcpy = 14,
    kMemset = 15,
    kFgetc = 16,
    kRead = 17,
    kStrchr = 18,
    kExit = 19,
    kStrcmp = 20,
    kCtypeBLoc = 22,
    kFscanf = 23,
    kStrncpy = 24,
    kFstat = 25,
    kRealloc = 26,
    kMmap = 27,
    kQsort = 28,
    kBsearch = 29,
    kOpenStub = 30,
    kLseek = 31,
    kFread = 32,
    kStrncmp = 33,
    kMemcmp = 34,
    kFxstat64 = 35,
    kGeneric = 50,
    LIBCALL_CNT_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const libcall_pol* internal_default_instance() {
    return reinterpret_cast<const libcall_pol*>(
               &_libcall_pol_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(libcall_pol& a, libcall_pol& b) {
    a.Swap(&b);
  }
  inline void Swap(libcall_pol* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline libcall_pol* New() const final {
    return CreateMaybeMessage<libcall_pol>(nullptr);
  }

  libcall_pol* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<libcall_pol>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const libcall_pol& from);
  void MergeFrom(const libcall_pol& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(libcall_pol* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "libcall_types.libcall_pol";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_libcall_2eproto);
    return ::descriptor_table_libcall_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRestrictAddressesFieldNumber = 4,
    kNameFieldNumber = 1,
    kActionFieldNumber = 3,
    kIdentFieldNumber = 2,
    kStrcpyFieldNumber = 5,
    kPrintfFieldNumber = 6,
    kAtoiFieldNumber = 7,
    kMallocFieldNumber = 8,
    kGetmodulehandleFieldNumber = 9,
    kGetprocaddressFieldNumber = 10,
    kGetmainargsFieldNumber = 11,
    kGethostnameFieldNumber = 12,
    kFreeFieldNumber = 13,
    kMemcpyFieldNumber = 14,
    kMemsetFieldNumber = 15,
    kFgetcFieldNumber = 16,
    kReadFieldNumber = 17,
    kStrchrFieldNumber = 18,
    kExitFieldNumber = 19,
    kStrcmpFieldNumber = 20,
    kCtypeBLocFieldNumber = 22,
    kFscanfFieldNumber = 23,
    kStrncpyFieldNumber = 24,
    kFstatFieldNumber = 25,
    kReallocFieldNumber = 26,
    kMmapFieldNumber = 27,
    kQsortFieldNumber = 28,
    kBsearchFieldNumber = 29,
    kOpenStubFieldNumber = 30,
    kLseekFieldNumber = 31,
    kFreadFieldNumber = 32,
    kStrncmpFieldNumber = 33,
    kMemcmpFieldNumber = 34,
    kFxstat64FieldNumber = 35,
    kGenericFieldNumber = 50,
  };
  // repeated uint64 restrict_addresses = 4;
  int restrict_addresses_size() const;
  void clear_restrict_addresses();
  ::PROTOBUF_NAMESPACE_ID::uint64 restrict_addresses(int index) const;
  void set_restrict_addresses(int index, ::PROTOBUF_NAMESPACE_ID::uint64 value);
  void add_restrict_addresses(::PROTOBUF_NAMESPACE_ID::uint64 value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint64 >&
      restrict_addresses() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint64 >*
      mutable_restrict_addresses();

  // required string name = 1;
  bool has_name() const;
  void clear_name();
  const std::string& name() const;
  void set_name(const std::string& value);
  void set_name(std::string&& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  std::string* mutable_name();
  std::string* release_name();
  void set_allocated_name(std::string* name);

  // optional .common.tracing_action action = 3 [default = SKIP];
  bool has_action() const;
  void clear_action();
  ::common::tracing_action action() const;
  void set_action(::common::tracing_action value);

  // optional .libcall_types.lib_ident ident = 2 [default = GENERIC];
  bool has_ident() const;
  void clear_ident();
  ::libcall_types::lib_ident ident() const;
  void set_ident(::libcall_types::lib_ident value);

  // optional .libcall_types.strcpy_pol strcpy = 5;
  bool has_strcpy() const;
  void clear_strcpy();
  const ::libcall_types::strcpy_pol& strcpy() const;
  ::libcall_types::strcpy_pol* release_strcpy();
  ::libcall_types::strcpy_pol* mutable_strcpy();
  void set_allocated_strcpy(::libcall_types::strcpy_pol* strcpy);

  // optional .libcall_types.printf_pol printf = 6;
  bool has_printf() const;
  void clear_printf();
  const ::libcall_types::printf_pol& printf() const;
  ::libcall_types::printf_pol* release_printf();
  ::libcall_types::printf_pol* mutable_printf();
  void set_allocated_printf(::libcall_types::printf_pol* printf);

  // optional .libcall_types.atoi_pol atoi = 7;
  bool has_atoi() const;
  void clear_atoi();
  const ::libcall_types::atoi_pol& atoi() const;
  ::libcall_types::atoi_pol* release_atoi();
  ::libcall_types::atoi_pol* mutable_atoi();
  void set_allocated_atoi(::libcall_types::atoi_pol* atoi);

  // optional .libcall_types.malloc_pol malloc = 8;
  bool has_malloc() const;
  void clear_malloc();
  const ::libcall_types::malloc_pol& malloc() const;
  ::libcall_types::malloc_pol* release_malloc();
  ::libcall_types::malloc_pol* mutable_malloc();
  void set_allocated_malloc(::libcall_types::malloc_pol* malloc);

  // optional .libcall_types.getmodulehandle_pol getmodulehandle = 9;
  bool has_getmodulehandle() const;
  void clear_getmodulehandle();
  const ::libcall_types::getmodulehandle_pol& getmodulehandle() const;
  ::libcall_types::getmodulehandle_pol* release_getmodulehandle();
  ::libcall_types::getmodulehandle_pol* mutable_getmodulehandle();
  void set_allocated_getmodulehandle(::libcall_types::getmodulehandle_pol* getmodulehandle);

  // optional .libcall_types.getprocaddress_pol getprocaddress = 10;
  bool has_getprocaddress() const;
  void clear_getprocaddress();
  const ::libcall_types::getprocaddress_pol& getprocaddress() const;
  ::libcall_types::getprocaddress_pol* release_getprocaddress();
  ::libcall_types::getprocaddress_pol* mutable_getprocaddress();
  void set_allocated_getprocaddress(::libcall_types::getprocaddress_pol* getprocaddress);

  // optional .libcall_types.getmainargs_pol getmainargs = 11;
  bool has_getmainargs() const;
  void clear_getmainargs();
  const ::libcall_types::getmainargs_pol& getmainargs() const;
  ::libcall_types::getmainargs_pol* release_getmainargs();
  ::libcall_types::getmainargs_pol* mutable_getmainargs();
  void set_allocated_getmainargs(::libcall_types::getmainargs_pol* getmainargs);

  // optional .libcall_types.gethostname_pol gethostname = 12;
  bool has_gethostname() const;
  void clear_gethostname();
  const ::libcall_types::gethostname_pol& gethostname() const;
  ::libcall_types::gethostname_pol* release_gethostname();
  ::libcall_types::gethostname_pol* mutable_gethostname();
  void set_allocated_gethostname(::libcall_types::gethostname_pol* gethostname);

  // optional .libcall_types.free_pol free = 13;
  bool has_free() const;
  void clear_free();
  const ::libcall_types::free_pol& free() const;
  ::libcall_types::free_pol* release_free();
  ::libcall_types::free_pol* mutable_free();
  void set_allocated_free(::libcall_types::free_pol* free);

  // optional .libcall_types.memcpy_pol memcpy = 14;
  bool has_memcpy() const;
  void clear_memcpy();
  const ::libcall_types::memcpy_pol& memcpy() const;
  ::libcall_types::memcpy_pol* release_memcpy();
  ::libcall_types::memcpy_pol* mutable_memcpy();
  void set_allocated_memcpy(::libcall_types::memcpy_pol* memcpy);

  // optional .libcall_types.memset_pol memset = 15;
  bool has_memset() const;
  void clear_memset();
  const ::libcall_types::memset_pol& memset() const;
  ::libcall_types::memset_pol* release_memset();
  ::libcall_types::memset_pol* mutable_memset();
  void set_allocated_memset(::libcall_types::memset_pol* memset);

  // optional .libcall_types.fgetc_pol fgetc = 16;
  bool has_fgetc() const;
  void clear_fgetc();
  const ::libcall_types::fgetc_pol& fgetc() const;
  ::libcall_types::fgetc_pol* release_fgetc();
  ::libcall_types::fgetc_pol* mutable_fgetc();
  void set_allocated_fgetc(::libcall_types::fgetc_pol* fgetc);

  // optional .libcall_types.read_pol read = 17;
  bool has_read() const;
  void clear_read();
  const ::libcall_types::read_pol& read() const;
  ::libcall_types::read_pol* release_read();
  ::libcall_types::read_pol* mutable_read();
  void set_allocated_read(::libcall_types::read_pol* read);

  // optional .libcall_types.strchr_pol strchr = 18;
  bool has_strchr() const;
  void clear_strchr();
  const ::libcall_types::strchr_pol& strchr() const;
  ::libcall_types::strchr_pol* release_strchr();
  ::libcall_types::strchr_pol* mutable_strchr();
  void set_allocated_strchr(::libcall_types::strchr_pol* strchr);

  // optional .libcall_types.exit_pol exit = 19;
  bool has_exit() const;
  void clear_exit();
  const ::libcall_types::exit_pol& exit() const;
  ::libcall_types::exit_pol* release_exit();
  ::libcall_types::exit_pol* mutable_exit();
  void set_allocated_exit(::libcall_types::exit_pol* exit);

  // optional .libcall_types.strcmp_pol strcmp = 20;
  bool has_strcmp() const;
  void clear_strcmp();
  const ::libcall_types::strcmp_pol& strcmp() const;
  ::libcall_types::strcmp_pol* release_strcmp();
  ::libcall_types::strcmp_pol* mutable_strcmp();
  void set_allocated_strcmp(::libcall_types::strcmp_pol* strcmp);

  // optional .libcall_types.ctype_b_loc_pol ctype_b_loc = 22;
  bool has_ctype_b_loc() const;
  void clear_ctype_b_loc();
  const ::libcall_types::ctype_b_loc_pol& ctype_b_loc() const;
  ::libcall_types::ctype_b_loc_pol* release_ctype_b_loc();
  ::libcall_types::ctype_b_loc_pol* mutable_ctype_b_loc();
  void set_allocated_ctype_b_loc(::libcall_types::ctype_b_loc_pol* ctype_b_loc);

  // optional .libcall_types.fscanf_pol fscanf = 23;
  bool has_fscanf() const;
  void clear_fscanf();
  const ::libcall_types::fscanf_pol& fscanf() const;
  ::libcall_types::fscanf_pol* release_fscanf();
  ::libcall_types::fscanf_pol* mutable_fscanf();
  void set_allocated_fscanf(::libcall_types::fscanf_pol* fscanf);

  // optional .libcall_types.strncpy_pol strncpy = 24;
  bool has_strncpy() const;
  void clear_strncpy();
  const ::libcall_types::strncpy_pol& strncpy() const;
  ::libcall_types::strncpy_pol* release_strncpy();
  ::libcall_types::strncpy_pol* mutable_strncpy();
  void set_allocated_strncpy(::libcall_types::strncpy_pol* strncpy);

  // optional .libcall_types.fstat_pol fstat = 25;
  bool has_fstat() const;
  void clear_fstat();
  const ::libcall_types::fstat_pol& fstat() const;
  ::libcall_types::fstat_pol* release_fstat();
  ::libcall_types::fstat_pol* mutable_fstat();
  void set_allocated_fstat(::libcall_types::fstat_pol* fstat);

  // optional .libcall_types.realloc_pol realloc = 26;
  bool has_realloc() const;
  void clear_realloc();
  const ::libcall_types::realloc_pol& realloc() const;
  ::libcall_types::realloc_pol* release_realloc();
  ::libcall_types::realloc_pol* mutable_realloc();
  void set_allocated_realloc(::libcall_types::realloc_pol* realloc);

  // optional .libcall_types.mmap_pol mmap = 27;
  bool has_mmap() const;
  void clear_mmap();
  const ::libcall_types::mmap_pol& mmap() const;
  ::libcall_types::mmap_pol* release_mmap();
  ::libcall_types::mmap_pol* mutable_mmap();
  void set_allocated_mmap(::libcall_types::mmap_pol* mmap);

  // optional .libcall_types.qsort_pol qsort = 28;
  bool has_qsort() const;
  void clear_qsort();
  const ::libcall_types::qsort_pol& qsort() const;
  ::libcall_types::qsort_pol* release_qsort();
  ::libcall_types::qsort_pol* mutable_qsort();
  void set_allocated_qsort(::libcall_types::qsort_pol* qsort);

  // optional .libcall_types.bsearch_pol bsearch = 29;
  bool has_bsearch() const;
  void clear_bsearch();
  const ::libcall_types::bsearch_pol& bsearch() const;
  ::libcall_types::bsearch_pol* release_bsearch();
  ::libcall_types::bsearch_pol* mutable_bsearch();
  void set_allocated_bsearch(::libcall_types::bsearch_pol* bsearch);

  // optional .libcall_types.open_pol open_stub = 30;
  bool has_open_stub() const;
  void clear_open_stub();
  const ::libcall_types::open_pol& open_stub() const;
  ::libcall_types::open_pol* release_open_stub();
  ::libcall_types::open_pol* mutable_open_stub();
  void set_allocated_open_stub(::libcall_types::open_pol* open_stub);

  // optional .libcall_types.lseek_pol lseek = 31;
  bool has_lseek() const;
  void clear_lseek();
  const ::libcall_types::lseek_pol& lseek() const;
  ::libcall_types::lseek_pol* release_lseek();
  ::libcall_types::lseek_pol* mutable_lseek();
  void set_allocated_lseek(::libcall_types::lseek_pol* lseek);

  // optional .libcall_types.fread_pol fread = 32;
  bool has_fread() const;
  void clear_fread();
  const ::libcall_types::fread_pol& fread() const;
  ::libcall_types::fread_pol* release_fread();
  ::libcall_types::fread_pol* mutable_fread();
  void set_allocated_fread(::libcall_types::fread_pol* fread);

  // optional .libcall_types.strncmp_pol strncmp = 33;
  bool has_strncmp() const;
  void clear_strncmp();
  const ::libcall_types::strncmp_pol& strncmp() const;
  ::libcall_types::strncmp_pol* release_strncmp();
  ::libcall_types::strncmp_pol* mutable_strncmp();
  void set_allocated_strncmp(::libcall_types::strncmp_pol* strncmp);

  // optional .libcall_types.memcmp_pol memcmp = 34;
  bool has_memcmp() const;
  void clear_memcmp();
  const ::libcall_types::memcmp_pol& memcmp() const;
  ::libcall_types::memcmp_pol* release_memcmp();
  ::libcall_types::memcmp_pol* mutable_memcmp();
  void set_allocated_memcmp(::libcall_types::memcmp_pol* memcmp);

  // optional .libcall_types.fxstat64_pol fxstat64 = 35;
  bool has_fxstat64() const;
  void clear_fxstat64();
  const ::libcall_types::fxstat64_pol& fxstat64() const;
  ::libcall_types::fxstat64_pol* release_fxstat64();
  ::libcall_types::fxstat64_pol* mutable_fxstat64();
  void set_allocated_fxstat64(::libcall_types::fxstat64_pol* fxstat64);

  // optional .libcall_types.generic_pol generic = 50;
  bool has_generic() const;
  void clear_generic();
  const ::libcall_types::generic_pol& generic() const;
  ::libcall_types::generic_pol* release_generic();
  ::libcall_types::generic_pol* mutable_generic();
  void set_allocated_generic(::libcall_types::generic_pol* generic);

  void clear_libcall_cnt();
  LibcallCntCase libcall_cnt_case() const;
  // @@protoc_insertion_point(class_scope:libcall_types.libcall_pol)
 private:
  class _Internal;
  void set_has_strcpy();
  void set_has_printf();
  void set_has_atoi();
  void set_has_malloc();
  void set_has_getmodulehandle();
  void set_has_getprocaddress();
  void set_has_getmainargs();
  void set_has_gethostname();
  void set_has_free();
  void set_has_memcpy();
  void set_has_memset();
  void set_has_fgetc();
  void set_has_read();
  void set_has_strchr();
  void set_has_exit();
  void set_has_strcmp();
  void set_has_ctype_b_loc();
  void set_has_fscanf();
  void set_has_strncpy();
  void set_has_fstat();
  void set_has_realloc();
  void set_has_mmap();
  void set_has_qsort();
  void set_has_bsearch();
  void set_has_open_stub();
  void set_has_lseek();
  void set_has_fread();
  void set_has_strncmp();
  void set_has_memcmp();
  void set_has_fxstat64();
  void set_has_generic();

  inline bool has_libcall_cnt() const;
  inline void clear_has_libcall_cnt();

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint64 > restrict_addresses_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  int action_;
  int ident_;
  union LibcallCntUnion {
    LibcallCntUnion() {}
    ::libcall_types::strcpy_pol* strcpy_;
    ::libcall_types::printf_pol* printf_;
    ::libcall_types::atoi_pol* atoi_;
    ::libcall_types::malloc_pol* malloc_;
    ::libcall_types::getmodulehandle_pol* getmodulehandle_;
    ::libcall_types::getprocaddress_pol* getprocaddress_;
    ::libcall_types::getmainargs_pol* getmainargs_;
    ::libcall_types::gethostname_pol* gethostname_;
    ::libcall_types::free_pol* free_;
    ::libcall_types::memcpy_pol* memcpy_;
    ::libcall_types::memset_pol* memset_;
    ::libcall_types::fgetc_pol* fgetc_;
    ::libcall_types::read_pol* read_;
    ::libcall_types::strchr_pol* strchr_;
    ::libcall_types::exit_pol* exit_;
    ::libcall_types::strcmp_pol* strcmp_;
    ::libcall_types::ctype_b_loc_pol* ctype_b_loc_;
    ::libcall_types::fscanf_pol* fscanf_;
    ::libcall_types::strncpy_pol* strncpy_;
    ::libcall_types::fstat_pol* fstat_;
    ::libcall_types::realloc_pol* realloc_;
    ::libcall_types::mmap_pol* mmap_;
    ::libcall_types::qsort_pol* qsort_;
    ::libcall_types::bsearch_pol* bsearch_;
    ::libcall_types::open_pol* open_stub_;
    ::libcall_types::lseek_pol* lseek_;
    ::libcall_types::fread_pol* fread_;
    ::libcall_types::strncmp_pol* strncmp_;
    ::libcall_types::memcmp_pol* memcmp_;
    ::libcall_types::fxstat64_pol* fxstat64_;
    ::libcall_types::generic_pol* generic_;
  } libcall_cnt_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];

  friend struct ::TableStruct_libcall_2eproto;
};
// -------------------------------------------------------------------

class libcall_t :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:libcall_types.libcall_t) */ {
 public:
  libcall_t();
  virtual ~libcall_t();

  libcall_t(const libcall_t& from);
  libcall_t(libcall_t&& from) noexcept
    : libcall_t() {
    *this = ::std::move(from);
  }

  inline libcall_t& operator=(const libcall_t& from) {
    CopyFrom(from);
    return *this;
  }
  inline libcall_t& operator=(libcall_t&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const libcall_t& default_instance();

  enum LibcallCntCase {
    kStrcpy = 5,
    kPrintf = 6,
    kAtoi = 7,
    kMalloc = 8,
    kGetmodulehandle = 9,
    kGetprocaddress = 10,
    kGetmainargs = 11,
    kGethostname = 12,
    kFree = 13,
    kMemcpy = 14,
    kMemset = 15,
    kFgetc = 16,
    kGeneric = 17,
    kRead = 18,
    kStrchr = 19,
    kExit = 20,
    kStrcmp = 21,
    kCtypeBLoc = 23,
    kFscanf = 24,
    kStrncpy = 25,
    kFstat = 26,
    kRealloc = 27,
    kMmap = 28,
    kQsort = 29,
    kBsearch = 30,
    kOpenStub = 31,
    kLseek = 32,
    kFread = 33,
    kStrncmp = 34,
    kMemcmp = 35,
    kFxstat64 = 36,
    LIBCALL_CNT_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const libcall_t* internal_default_instance() {
    return reinterpret_cast<const libcall_t*>(
               &_libcall_t_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(libcall_t& a, libcall_t& b) {
    a.Swap(&b);
  }
  inline void Swap(libcall_t* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline libcall_t* New() const final {
    return CreateMaybeMessage<libcall_t>(nullptr);
  }

  libcall_t* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<libcall_t>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const libcall_t& from);
  void MergeFrom(const libcall_t& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(libcall_t* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "libcall_types.libcall_t";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_libcall_2eproto);
    return ::descriptor_table_libcall_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFuncNameFieldNumber = 2,
    kFuncAddrFieldNumber = 1,
    kIsTracedFieldNumber = 3,
    kIdentFieldNumber = 4,
    kStrcpyFieldNumber = 5,
    kPrintfFieldNumber = 6,
    kAtoiFieldNumber = 7,
    kMallocFieldNumber = 8,
    kGetmodulehandleFieldNumber = 9,
    kGetprocaddressFieldNumber = 10,
    kGetmainargsFieldNumber = 11,
    kGethostnameFieldNumber = 12,
    kFreeFieldNumber = 13,
    kMemcpyFieldNumber = 14,
    kMemsetFieldNumber = 15,
    kFgetcFieldNumber = 16,
    kGenericFieldNumber = 17,
    kReadFieldNumber = 18,
    kStrchrFieldNumber = 19,
    kExitFieldNumber = 20,
    kStrcmpFieldNumber = 21,
    kCtypeBLocFieldNumber = 23,
    kFscanfFieldNumber = 24,
    kStrncpyFieldNumber = 25,
    kFstatFieldNumber = 26,
    kReallocFieldNumber = 27,
    kMmapFieldNumber = 28,
    kQsortFieldNumber = 29,
    kBsearchFieldNumber = 30,
    kOpenStubFieldNumber = 31,
    kLseekFieldNumber = 32,
    kFreadFieldNumber = 33,
    kStrncmpFieldNumber = 34,
    kMemcmpFieldNumber = 35,
    kFxstat64FieldNumber = 36,
  };
  // required string func_name = 2;
  bool has_func_name() const;
  void clear_func_name();
  const std::string& func_name() const;
  void set_func_name(const std::string& value);
  void set_func_name(std::string&& value);
  void set_func_name(const char* value);
  void set_func_name(const char* value, size_t size);
  std::string* mutable_func_name();
  std::string* release_func_name();
  void set_allocated_func_name(std::string* func_name);

  // required uint64 func_addr = 1;
  bool has_func_addr() const;
  void clear_func_addr();
  ::PROTOBUF_NAMESPACE_ID::uint64 func_addr() const;
  void set_func_addr(::PROTOBUF_NAMESPACE_ID::uint64 value);

  // required bool is_traced = 3;
  bool has_is_traced() const;
  void clear_is_traced();
  bool is_traced() const;
  void set_is_traced(bool value);

  // required .libcall_types.lib_ident ident = 4;
  bool has_ident() const;
  void clear_ident();
  ::libcall_types::lib_ident ident() const;
  void set_ident(::libcall_types::lib_ident value);

  // optional .libcall_types.strcpy_t strcpy = 5;
  bool has_strcpy() const;
  void clear_strcpy();
  const ::libcall_types::strcpy_t& strcpy() const;
  ::libcall_types::strcpy_t* release_strcpy();
  ::libcall_types::strcpy_t* mutable_strcpy();
  void set_allocated_strcpy(::libcall_types::strcpy_t* strcpy);

  // optional .libcall_types.printf_t printf = 6;
  bool has_printf() const;
  void clear_printf();
  const ::libcall_types::printf_t& printf() const;
  ::libcall_types::printf_t* release_printf();
  ::libcall_types::printf_t* mutable_printf();
  void set_allocated_printf(::libcall_types::printf_t* printf);

  // optional .libcall_types.atoi_t atoi = 7;
  bool has_atoi() const;
  void clear_atoi();
  const ::libcall_types::atoi_t& atoi() const;
  ::libcall_types::atoi_t* release_atoi();
  ::libcall_types::atoi_t* mutable_atoi();
  void set_allocated_atoi(::libcall_types::atoi_t* atoi);

  // optional .libcall_types.malloc_t malloc = 8;
  bool has_malloc() const;
  void clear_malloc();
  const ::libcall_types::malloc_t& malloc() const;
  ::libcall_types::malloc_t* release_malloc();
  ::libcall_types::malloc_t* mutable_malloc();
  void set_allocated_malloc(::libcall_types::malloc_t* malloc);

  // optional .libcall_types.getmodulehandle_t getmodulehandle = 9;
  bool has_getmodulehandle() const;
  void clear_getmodulehandle();
  const ::libcall_types::getmodulehandle_t& getmodulehandle() const;
  ::libcall_types::getmodulehandle_t* release_getmodulehandle();
  ::libcall_types::getmodulehandle_t* mutable_getmodulehandle();
  void set_allocated_getmodulehandle(::libcall_types::getmodulehandle_t* getmodulehandle);

  // optional .libcall_types.getprocaddress_t getprocaddress = 10;
  bool has_getprocaddress() const;
  void clear_getprocaddress();
  const ::libcall_types::getprocaddress_t& getprocaddress() const;
  ::libcall_types::getprocaddress_t* release_getprocaddress();
  ::libcall_types::getprocaddress_t* mutable_getprocaddress();
  void set_allocated_getprocaddress(::libcall_types::getprocaddress_t* getprocaddress);

  // optional .libcall_types.getmainargs_t getmainargs = 11;
  bool has_getmainargs() const;
  void clear_getmainargs();
  const ::libcall_types::getmainargs_t& getmainargs() const;
  ::libcall_types::getmainargs_t* release_getmainargs();
  ::libcall_types::getmainargs_t* mutable_getmainargs();
  void set_allocated_getmainargs(::libcall_types::getmainargs_t* getmainargs);

  // optional .libcall_types.gethostname_t gethostname = 12;
  bool has_gethostname() const;
  void clear_gethostname();
  const ::libcall_types::gethostname_t& gethostname() const;
  ::libcall_types::gethostname_t* release_gethostname();
  ::libcall_types::gethostname_t* mutable_gethostname();
  void set_allocated_gethostname(::libcall_types::gethostname_t* gethostname);

  // optional .libcall_types.free_t free = 13;
  bool has_free() const;
  void clear_free();
  const ::libcall_types::free_t& free() const;
  ::libcall_types::free_t* release_free();
  ::libcall_types::free_t* mutable_free();
  void set_allocated_free(::libcall_types::free_t* free);

  // optional .libcall_types.memcpy_t memcpy = 14;
  bool has_memcpy() const;
  void clear_memcpy();
  const ::libcall_types::memcpy_t& memcpy() const;
  ::libcall_types::memcpy_t* release_memcpy();
  ::libcall_types::memcpy_t* mutable_memcpy();
  void set_allocated_memcpy(::libcall_types::memcpy_t* memcpy);

  // optional .libcall_types.memset_t memset = 15;
  bool has_memset() const;
  void clear_memset();
  const ::libcall_types::memset_t& memset() const;
  ::libcall_types::memset_t* release_memset();
  ::libcall_types::memset_t* mutable_memset();
  void set_allocated_memset(::libcall_types::memset_t* memset);

  // optional .libcall_types.fgetc_t fgetc = 16;
  bool has_fgetc() const;
  void clear_fgetc();
  const ::libcall_types::fgetc_t& fgetc() const;
  ::libcall_types::fgetc_t* release_fgetc();
  ::libcall_types::fgetc_t* mutable_fgetc();
  void set_allocated_fgetc(::libcall_types::fgetc_t* fgetc);

  // optional .libcall_types.generic_t generic = 17;
  bool has_generic() const;
  void clear_generic();
  const ::libcall_types::generic_t& generic() const;
  ::libcall_types::generic_t* release_generic();
  ::libcall_types::generic_t* mutable_generic();
  void set_allocated_generic(::libcall_types::generic_t* generic);

  // optional .libcall_types.read_t read = 18;
  bool has_read() const;
  void clear_read();
  const ::libcall_types::read_t& read() const;
  ::libcall_types::read_t* release_read();
  ::libcall_types::read_t* mutable_read();
  void set_allocated_read(::libcall_types::read_t* read);

  // optional .libcall_types.strchr_t strchr = 19;
  bool has_strchr() const;
  void clear_strchr();
  const ::libcall_types::strchr_t& strchr() const;
  ::libcall_types::strchr_t* release_strchr();
  ::libcall_types::strchr_t* mutable_strchr();
  void set_allocated_strchr(::libcall_types::strchr_t* strchr);

  // optional .libcall_types.exit_t exit = 20;
  bool has_exit() const;
  void clear_exit();
  const ::libcall_types::exit_t& exit() const;
  ::libcall_types::exit_t* release_exit();
  ::libcall_types::exit_t* mutable_exit();
  void set_allocated_exit(::libcall_types::exit_t* exit);

  // optional .libcall_types.strcmp_t strcmp = 21;
  bool has_strcmp() const;
  void clear_strcmp();
  const ::libcall_types::strcmp_t& strcmp() const;
  ::libcall_types::strcmp_t* release_strcmp();
  ::libcall_types::strcmp_t* mutable_strcmp();
  void set_allocated_strcmp(::libcall_types::strcmp_t* strcmp);

  // optional .libcall_types.ctype_b_loc_t ctype_b_loc = 23;
  bool has_ctype_b_loc() const;
  void clear_ctype_b_loc();
  const ::libcall_types::ctype_b_loc_t& ctype_b_loc() const;
  ::libcall_types::ctype_b_loc_t* release_ctype_b_loc();
  ::libcall_types::ctype_b_loc_t* mutable_ctype_b_loc();
  void set_allocated_ctype_b_loc(::libcall_types::ctype_b_loc_t* ctype_b_loc);

  // optional .libcall_types.fscanf_t fscanf = 24;
  bool has_fscanf() const;
  void clear_fscanf();
  const ::libcall_types::fscanf_t& fscanf() const;
  ::libcall_types::fscanf_t* release_fscanf();
  ::libcall_types::fscanf_t* mutable_fscanf();
  void set_allocated_fscanf(::libcall_types::fscanf_t* fscanf);

  // optional .libcall_types.strncpy_t strncpy = 25;
  bool has_strncpy() const;
  void clear_strncpy();
  const ::libcall_types::strncpy_t& strncpy() const;
  ::libcall_types::strncpy_t* release_strncpy();
  ::libcall_types::strncpy_t* mutable_strncpy();
  void set_allocated_strncpy(::libcall_types::strncpy_t* strncpy);

  // optional .libcall_types.fstat_t fstat = 26;
  bool has_fstat() const;
  void clear_fstat();
  const ::libcall_types::fstat_t& fstat() const;
  ::libcall_types::fstat_t* release_fstat();
  ::libcall_types::fstat_t* mutable_fstat();
  void set_allocated_fstat(::libcall_types::fstat_t* fstat);

  // optional .libcall_types.realloc_t realloc = 27;
  bool has_realloc() const;
  void clear_realloc();
  const ::libcall_types::realloc_t& realloc() const;
  ::libcall_types::realloc_t* release_realloc();
  ::libcall_types::realloc_t* mutable_realloc();
  void set_allocated_realloc(::libcall_types::realloc_t* realloc);

  // optional .libcall_types.mmap_t mmap = 28;
  bool has_mmap() const;
  void clear_mmap();
  const ::libcall_types::mmap_t& mmap() const;
  ::libcall_types::mmap_t* release_mmap();
  ::libcall_types::mmap_t* mutable_mmap();
  void set_allocated_mmap(::libcall_types::mmap_t* mmap);

  // optional .libcall_types.qsort_t qsort = 29;
  bool has_qsort() const;
  void clear_qsort();
  const ::libcall_types::qsort_t& qsort() const;
  ::libcall_types::qsort_t* release_qsort();
  ::libcall_types::qsort_t* mutable_qsort();
  void set_allocated_qsort(::libcall_types::qsort_t* qsort);

  // optional .libcall_types.bsearch_t bsearch = 30;
  bool has_bsearch() const;
  void clear_bsearch();
  const ::libcall_types::bsearch_t& bsearch() const;
  ::libcall_types::bsearch_t* release_bsearch();
  ::libcall_types::bsearch_t* mutable_bsearch();
  void set_allocated_bsearch(::libcall_types::bsearch_t* bsearch);

  // optional .libcall_types.open_t open_stub = 31;
  bool has_open_stub() const;
  void clear_open_stub();
  const ::libcall_types::open_t& open_stub() const;
  ::libcall_types::open_t* release_open_stub();
  ::libcall_types::open_t* mutable_open_stub();
  void set_allocated_open_stub(::libcall_types::open_t* open_stub);

  // optional .libcall_types.lseek_t lseek = 32;
  bool has_lseek() const;
  void clear_lseek();
  const ::libcall_types::lseek_t& lseek() const;
  ::libcall_types::lseek_t* release_lseek();
  ::libcall_types::lseek_t* mutable_lseek();
  void set_allocated_lseek(::libcall_types::lseek_t* lseek);

  // optional .libcall_types.fread_t fread = 33;
  bool has_fread() const;
  void clear_fread();
  const ::libcall_types::fread_t& fread() const;
  ::libcall_types::fread_t* release_fread();
  ::libcall_types::fread_t* mutable_fread();
  void set_allocated_fread(::libcall_types::fread_t* fread);

  // optional .libcall_types.strncmp_t strncmp = 34;
  bool has_strncmp() const;
  void clear_strncmp();
  const ::libcall_types::strncmp_t& strncmp() const;
  ::libcall_types::strncmp_t* release_strncmp();
  ::libcall_types::strncmp_t* mutable_strncmp();
  void set_allocated_strncmp(::libcall_types::strncmp_t* strncmp);

  // optional .libcall_types.memcmp_t memcmp = 35;
  bool has_memcmp() const;
  void clear_memcmp();
  const ::libcall_types::memcmp_t& memcmp() const;
  ::libcall_types::memcmp_t* release_memcmp();
  ::libcall_types::memcmp_t* mutable_memcmp();
  void set_allocated_memcmp(::libcall_types::memcmp_t* memcmp);

  // optional .libcall_types.fxstat64_t fxstat64 = 36;
  bool has_fxstat64() const;
  void clear_fxstat64();
  const ::libcall_types::fxstat64_t& fxstat64() const;
  ::libcall_types::fxstat64_t* release_fxstat64();
  ::libcall_types::fxstat64_t* mutable_fxstat64();
  void set_allocated_fxstat64(::libcall_types::fxstat64_t* fxstat64);

  void clear_libcall_cnt();
  LibcallCntCase libcall_cnt_case() const;
  // @@protoc_insertion_point(class_scope:libcall_types.libcall_t)
 private:
  class _Internal;
  void set_has_strcpy();
  void set_has_printf();
  void set_has_atoi();
  void set_has_malloc();
  void set_has_getmodulehandle();
  void set_has_getprocaddress();
  void set_has_getmainargs();
  void set_has_gethostname();
  void set_has_free();
  void set_has_memcpy();
  void set_has_memset();
  void set_has_fgetc();
  void set_has_generic();
  void set_has_read();
  void set_has_strchr();
  void set_has_exit();
  void set_has_strcmp();
  void set_has_ctype_b_loc();
  void set_has_fscanf();
  void set_has_strncpy();
  void set_has_fstat();
  void set_has_realloc();
  void set_has_mmap();
  void set_has_qsort();
  void set_has_bsearch();
  void set_has_open_stub();
  void set_has_lseek();
  void set_has_fread();
  void set_has_strncmp();
  void set_has_memcmp();
  void set_has_fxstat64();

  inline bool has_libcall_cnt() const;
  inline void clear_has_libcall_cnt();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr func_name_;
  ::PROTOBUF_NAMESPACE_ID::uint64 func_addr_;
  bool is_traced_;
  int ident_;
  union LibcallCntUnion {
    LibcallCntUnion() {}
    ::libcall_types::strcpy_t* strcpy_;
    ::libcall_types::printf_t* printf_;
    ::libcall_types::atoi_t* atoi_;
    ::libcall_types::malloc_t* malloc_;
    ::libcall_types::getmodulehandle_t* getmodulehandle_;
    ::libcall_types::getprocaddress_t* getprocaddress_;
    ::libcall_types::getmainargs_t* getmainargs_;
    ::libcall_types::gethostname_t* gethostname_;
    ::libcall_types::free_t* free_;
    ::libcall_types::memcpy_t* memcpy_;
    ::libcall_types::memset_t* memset_;
    ::libcall_types::fgetc_t* fgetc_;
    ::libcall_types::generic_t* generic_;
    ::libcall_types::read_t* read_;
    ::libcall_types::strchr_t* strchr_;
    ::libcall_types::exit_t* exit_;
    ::libcall_types::strcmp_t* strcmp_;
    ::libcall_types::ctype_b_loc_t* ctype_b_loc_;
    ::libcall_types::fscanf_t* fscanf_;
    ::libcall_types::strncpy_t* strncpy_;
    ::libcall_types::fstat_t* fstat_;
    ::libcall_types::realloc_t* realloc_;
    ::libcall_types::mmap_t* mmap_;
    ::libcall_types::qsort_t* qsort_;
    ::libcall_types::bsearch_t* bsearch_;
    ::libcall_types::open_t* open_stub_;
    ::libcall_types::lseek_t* lseek_;
    ::libcall_types::fread_t* fread_;
    ::libcall_types::strncmp_t* strncmp_;
    ::libcall_types::memcmp_t* memcmp_;
    ::libcall_types::fxstat64_t* fxstat64_;
  } libcall_cnt_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];

  friend struct ::TableStruct_libcall_2eproto;
};
// -------------------------------------------------------------------

class generic_pol :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:libcall_types.generic_pol) */ {
 public:
  generic_pol();
  virtual ~generic_pol();

  generic_pol(const generic_pol& from);
  generic_pol(generic_pol&& from) noexcept
    : generic_pol() {
    *this = ::std::move(from);
  }

  inline generic_pol& operator=(const generic_pol& from) {
    CopyFrom(from);
    return *this;
  }
  inline generic_pol& operator=(generic_pol&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const generic_pol& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const generic_pol* internal_default_instance() {
    return reinterpret_cast<const generic_pol*>(
               &_generic_pol_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(generic_pol& a, generic_pol& b) {
    a.Swap(&b);
  }
  inline void Swap(generic_pol* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline generic_pol* New() const final {
    return CreateMaybeMessage<generic_pol>(nullptr);
  }

  generic_pol* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<generic_pol>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const generic_pol& from);
  void MergeFrom(const generic_pol& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(generic_pol* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "libcall_types.generic_pol";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_libcall_2eproto);
    return ::descriptor_table_libcall_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRetFieldNumber = 1,
  };
  // required .common.action ret = 1;
  bool has_ret() const;
  void clear_ret();
  ::common::action ret() const;
  void set_ret(::common::action value);

  // @@protoc_insertion_point(class_scope:libcall_types.generic_pol)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  int ret_;
  friend struct ::TableStruct_libcall_2eproto;
};
// -------------------------------------------------------------------

class ctype_b_loc_pol :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:libcall_types.ctype_b_loc_pol) */ {
 public:
  ctype_b_loc_pol();
  virtual ~ctype_b_loc_pol();

  ctype_b_loc_pol(const ctype_b_loc_pol& from);
  ctype_b_loc_pol(ctype_b_loc_pol&& from) noexcept
    : ctype_b_loc_pol() {
    *this = ::std::move(from);
  }

  inline ctype_b_loc_pol& operator=(const ctype_b_loc_pol& from) {
    CopyFrom(from);
    return *this;
  }
  inline ctype_b_loc_pol& operator=(ctype_b_loc_pol&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ctype_b_loc_pol& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ctype_b_loc_pol* internal_default_instance() {
    return reinterpret_cast<const ctype_b_loc_pol*>(
               &_ctype_b_loc_pol_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(ctype_b_loc_pol& a, ctype_b_loc_pol& b) {
    a.Swap(&b);
  }
  inline void Swap(ctype_b_loc_pol* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ctype_b_loc_pol* New() const final {
    return CreateMaybeMessage<ctype_b_loc_pol>(nullptr);
  }

  ctype_b_loc_pol* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ctype_b_loc_pol>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ctype_b_loc_pol& from);
  void MergeFrom(const ctype_b_loc_pol& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ctype_b_loc_pol* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "libcall_types.ctype_b_loc_pol";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_libcall_2eproto);
    return ::descriptor_table_libcall_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTableFieldNumber = 1,
    kRetFieldNumber = 2,
  };
  // required .common.memory_pol table = 1;
  bool has_table() const;
  void clear_table();
  const ::common::memory_pol& table() const;
  ::common::memory_pol* release_table();
  ::common::memory_pol* mutable_table();
  void set_allocated_table(::common::memory_pol* table);

  // required .common.action ret = 2;
  bool has_ret() const;
  void clear_ret();
  ::common::action ret() const;
  void set_ret(::common::action value);

  // @@protoc_insertion_point(class_scope:libcall_types.ctype_b_loc_pol)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::common::memory_pol* table_;
  int ret_;
  friend struct ::TableStruct_libcall_2eproto;
};
// -------------------------------------------------------------------

class exit_pol :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:libcall_types.exit_pol) */ {
 public:
  exit_pol();
  virtual ~exit_pol();

  exit_pol(const exit_pol& from);
  exit_pol(exit_pol&& from) noexcept
    : exit_pol() {
    *this = ::std::move(from);
  }

  inline exit_pol& operator=(const exit_pol& from) {
    CopyFrom(from);
    return *this;
  }
  inline exit_pol& operator=(exit_pol&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const exit_pol& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const exit_pol* internal_default_instance() {
    return reinterpret_cast<const exit_pol*>(
               &_exit_pol_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(exit_pol& a, exit_pol& b) {
    a.Swap(&b);
  }
  inline void Swap(exit_pol* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline exit_pol* New() const final {
    return CreateMaybeMessage<exit_pol>(nullptr);
  }

  exit_pol* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<exit_pol>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const exit_pol& from);
  void MergeFrom(const exit_pol& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(exit_pol* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "libcall_types.exit_pol";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_libcall_2eproto);
    return ::descriptor_table_libcall_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:libcall_types.exit_pol)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_libcall_2eproto;
};
// -------------------------------------------------------------------

class fscanf_pol :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:libcall_types.fscanf_pol) */ {
 public:
  fscanf_pol();
  virtual ~fscanf_pol();

  fscanf_pol(const fscanf_pol& from);
  fscanf_pol(fscanf_pol&& from) noexcept
    : fscanf_pol() {
    *this = ::std::move(from);
  }

  inline fscanf_pol& operator=(const fscanf_pol& from) {
    CopyFrom(from);
    return *this;
  }
  inline fscanf_pol& operator=(fscanf_pol&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const fscanf_pol& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const fscanf_pol* internal_default_instance() {
    return reinterpret_cast<const fscanf_pol*>(
               &_fscanf_pol_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(fscanf_pol& a, fscanf_pol& b) {
    a.Swap(&b);
  }
  inline void Swap(fscanf_pol* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline fscanf_pol* New() const final {
    return CreateMaybeMessage<fscanf_pol>(nullptr);
  }

  fscanf_pol* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<fscanf_pol>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const fscanf_pol& from);
  void MergeFrom(const fscanf_pol& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(fscanf_pol* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "libcall_types.fscanf_pol";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_libcall_2eproto);
    return ::descriptor_table_libcall_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStreamFieldNumber = 1,
    kElemsFieldNumber = 2,
    kRetFieldNumber = 3,
  };
  // required .common.action stream = 1;
  bool has_stream() const;
  void clear_stream();
  ::common::action stream() const;
  void set_stream(::common::action value);

  // required .common.action elems = 2;
  bool has_elems() const;
  void clear_elems();
  ::common::action elems() const;
  void set_elems(::common::action value);

  // required .common.action ret = 3;
  bool has_ret() const;
  void clear_ret();
  ::common::action ret() const;
  void set_ret(::common::action value);

  // @@protoc_insertion_point(class_scope:libcall_types.fscanf_pol)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  int stream_;
  int elems_;
  int ret_;
  friend struct ::TableStruct_libcall_2eproto;
};
// -------------------------------------------------------------------

class read_pol :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:libcall_types.read_pol) */ {
 public:
  read_pol();
  virtual ~read_pol();

  read_pol(const read_pol& from);
  read_pol(read_pol&& from) noexcept
    : read_pol() {
    *this = ::std::move(from);
  }

  inline read_pol& operator=(const read_pol& from) {
    CopyFrom(from);
    return *this;
  }
  inline read_pol& operator=(read_pol&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const read_pol& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const read_pol* internal_default_instance() {
    return reinterpret_cast<const read_pol*>(
               &_read_pol_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(read_pol& a, read_pol& b) {
    a.Swap(&b);
  }
  inline void Swap(read_pol* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline read_pol* New() const final {
    return CreateMaybeMessage<read_pol>(nullptr);
  }

  read_pol* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<read_pol>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const read_pol& from);
  void MergeFrom(const read_pol& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(read_pol* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "libcall_types.read_pol";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_libcall_2eproto);
    return ::descriptor_table_libcall_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBufFieldNumber = 2,
    kFdFieldNumber = 1,
    kCountFieldNumber = 3,
    kRetFieldNumber = 4,
  };
  // required .common.memory_pol buf = 2;
  bool has_buf() const;
  void clear_buf();
  const ::common::memory_pol& buf() const;
  ::common::memory_pol* release_buf();
  ::common::memory_pol* mutable_buf();
  void set_allocated_buf(::common::memory_pol* buf);

  // required .common.action fd = 1;
  bool has_fd() const;
  void clear_fd();
  ::common::action fd() const;
  void set_fd(::common::action value);

  // required .common.action count = 3;
  bool has_count() const;
  void clear_count();
  ::common::action count() const;
  void set_count(::common::action value);

  // required .common.action ret = 4;
  bool has_ret() const;
  void clear_ret();
  ::common::action ret() const;
  void set_ret(::common::action value);

  // @@protoc_insertion_point(class_scope:libcall_types.read_pol)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::common::memory_pol* buf_;
  int fd_;
  int count_;
  int ret_;
  friend struct ::TableStruct_libcall_2eproto;
};
// -------------------------------------------------------------------

class fread_pol :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:libcall_types.fread_pol) */ {
 public:
  fread_pol();
  virtual ~fread_pol();

  fread_pol(const fread_pol& from);
  fread_pol(fread_pol&& from) noexcept
    : fread_pol() {
    *this = ::std::move(from);
  }

  inline fread_pol& operator=(const fread_pol& from) {
    CopyFrom(from);
    return *this;
  }
  inline fread_pol& operator=(fread_pol&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const fread_pol& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const fread_pol* internal_default_instance() {
    return reinterpret_cast<const fread_pol*>(
               &_fread_pol_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(fread_pol& a, fread_pol& b) {
    a.Swap(&b);
  }
  inline void Swap(fread_pol* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline fread_pol* New() const final {
    return CreateMaybeMessage<fread_pol>(nullptr);
  }

  fread_pol* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<fread_pol>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const fread_pol& from);
  void MergeFrom(const fread_pol& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(fread_pol* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "libcall_types.fread_pol";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_libcall_2eproto);
    return ::descriptor_table_libcall_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPtrFieldNumber = 1,
    kSizeFieldNumber = 2,
    kNmembFieldNumber = 3,
    kStreamFieldNumber = 4,
    kRetFieldNumber = 5,
  };
  // required .common.memory_pol ptr = 1;
  bool has_ptr() const;
  void clear_ptr();
  const ::common::memory_pol& ptr() const;
  ::common::memory_pol* release_ptr();
  ::common::memory_pol* mutable_ptr();
  void set_allocated_ptr(::common::memory_pol* ptr);

  // required .common.action size = 2;
  bool has_size() const;
  void clear_size();
  ::common::action size() const;
  void set_size(::common::action value);

  // required .common.action nmemb = 3;
  bool has_nmemb() const;
  void clear_nmemb();
  ::common::action nmemb() const;
  void set_nmemb(::common::action value);

  // required .common.action stream = 4;
  bool has_stream() const;
  void clear_stream();
  ::common::action stream() const;
  void set_stream(::common::action value);

  // required .common.action ret = 5;
  bool has_ret() const;
  void clear_ret();
  ::common::action ret() const;
  void set_ret(::common::action value);

  // @@protoc_insertion_point(class_scope:libcall_types.fread_pol)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::common::memory_pol* ptr_;
  int size_;
  int nmemb_;
  int stream_;
  int ret_;
  friend struct ::TableStruct_libcall_2eproto;
};
// -------------------------------------------------------------------

class strcmp_pol :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:libcall_types.strcmp_pol) */ {
 public:
  strcmp_pol();
  virtual ~strcmp_pol();

  strcmp_pol(const strcmp_pol& from);
  strcmp_pol(strcmp_pol&& from) noexcept
    : strcmp_pol() {
    *this = ::std::move(from);
  }

  inline strcmp_pol& operator=(const strcmp_pol& from) {
    CopyFrom(from);
    return *this;
  }
  inline strcmp_pol& operator=(strcmp_pol&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const strcmp_pol& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const strcmp_pol* internal_default_instance() {
    return reinterpret_cast<const strcmp_pol*>(
               &_strcmp_pol_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(strcmp_pol& a, strcmp_pol& b) {
    a.Swap(&b);
  }
  inline void Swap(strcmp_pol* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline strcmp_pol* New() const final {
    return CreateMaybeMessage<strcmp_pol>(nullptr);
  }

  strcmp_pol* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<strcmp_pol>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const strcmp_pol& from);
  void MergeFrom(const strcmp_pol& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(strcmp_pol* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "libcall_types.strcmp_pol";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_libcall_2eproto);
    return ::descriptor_table_libcall_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSrcFieldNumber = 1,
    kDstFieldNumber = 2,
    kRetFieldNumber = 3,
  };
  // required .common.memory_pol src = 1;
  bool has_src() const;
  void clear_src();
  const ::common::memory_pol& src() const;
  ::common::memory_pol* release_src();
  ::common::memory_pol* mutable_src();
  void set_allocated_src(::common::memory_pol* src);

  // required .common.memory_pol dst = 2;
  bool has_dst() const;
  void clear_dst();
  const ::common::memory_pol& dst() const;
  ::common::memory_pol* release_dst();
  ::common::memory_pol* mutable_dst();
  void set_allocated_dst(::common::memory_pol* dst);

  // required .common.action ret = 3;
  bool has_ret() const;
  void clear_ret();
  ::common::action ret() const;
  void set_ret(::common::action value);

  // @@protoc_insertion_point(class_scope:libcall_types.strcmp_pol)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::common::memory_pol* src_;
  ::common::memory_pol* dst_;
  int ret_;
  friend struct ::TableStruct_libcall_2eproto;
};
// -------------------------------------------------------------------

class strncmp_pol :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:libcall_types.strncmp_pol) */ {
 public:
  strncmp_pol();
  virtual ~strncmp_pol();

  strncmp_pol(const strncmp_pol& from);
  strncmp_pol(strncmp_pol&& from) noexcept
    : strncmp_pol() {
    *this = ::std::move(from);
  }

  inline strncmp_pol& operator=(const strncmp_pol& from) {
    CopyFrom(from);
    return *this;
  }
  inline strncmp_pol& operator=(strncmp_pol&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const strncmp_pol& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const strncmp_pol* internal_default_instance() {
    return reinterpret_cast<const strncmp_pol*>(
               &_strncmp_pol_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(strncmp_pol& a, strncmp_pol& b) {
    a.Swap(&b);
  }
  inline void Swap(strncmp_pol* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline strncmp_pol* New() const final {
    return CreateMaybeMessage<strncmp_pol>(nullptr);
  }

  strncmp_pol* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<strncmp_pol>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const strncmp_pol& from);
  void MergeFrom(const strncmp_pol& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(strncmp_pol* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "libcall_types.strncmp_pol";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_libcall_2eproto);
    return ::descriptor_table_libcall_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kS1FieldNumber = 1,
    kS2FieldNumber = 2,
    kNFieldNumber = 3,
    kRetFieldNumber = 4,
  };
  // required .common.action s1 = 1;
  bool has_s1() const;
  void clear_s1();
  ::common::action s1() const;
  void set_s1(::common::action value);

  // required .common.action s2 = 2;
  bool has_s2() const;
  void clear_s2();
  ::common::action s2() const;
  void set_s2(::common::action value);

  // required .common.action n = 3;
  bool has_n() const;
  void clear_n();
  ::common::action n() const;
  void set_n(::common::action value);

  // required .common.action ret = 4;
  bool has_ret() const;
  void clear_ret();
  ::common::action ret() const;
  void set_ret(::common::action value);

  // @@protoc_insertion_point(class_scope:libcall_types.strncmp_pol)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  int s1_;
  int s2_;
  int n_;
  int ret_;
  friend struct ::TableStruct_libcall_2eproto;
};
// -------------------------------------------------------------------

class memcmp_pol :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:libcall_types.memcmp_pol) */ {
 public:
  memcmp_pol();
  virtual ~memcmp_pol();

  memcmp_pol(const memcmp_pol& from);
  memcmp_pol(memcmp_pol&& from) noexcept
    : memcmp_pol() {
    *this = ::std::move(from);
  }

  inline memcmp_pol& operator=(const memcmp_pol& from) {
    CopyFrom(from);
    return *this;
  }
  inline memcmp_pol& operator=(memcmp_pol&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const memcmp_pol& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const memcmp_pol* internal_default_instance() {
    return reinterpret_cast<const memcmp_pol*>(
               &_memcmp_pol_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(memcmp_pol& a, memcmp_pol& b) {
    a.Swap(&b);
  }
  inline void Swap(memcmp_pol* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline memcmp_pol* New() const final {
    return CreateMaybeMessage<memcmp_pol>(nullptr);
  }

  memcmp_pol* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<memcmp_pol>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const memcmp_pol& from);
  void MergeFrom(const memcmp_pol& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(memcmp_pol* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "libcall_types.memcmp_pol";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_libcall_2eproto);
    return ::descriptor_table_libcall_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kS1FieldNumber = 1,
    kS2FieldNumber = 2,
    kNFieldNumber = 3,
    kRetFieldNumber = 4,
  };
  // required .common.action s1 = 1;
  bool has_s1() const;
  void clear_s1();
  ::common::action s1() const;
  void set_s1(::common::action value);

  // required .common.action s2 = 2;
  bool has_s2() const;
  void clear_s2();
  ::common::action s2() const;
  void set_s2(::common::action value);

  // required .common.action n = 3;
  bool has_n() const;
  void clear_n();
  ::common::action n() const;
  void set_n(::common::action value);

  // required .common.action ret = 4;
  bool has_ret() const;
  void clear_ret();
  ::common::action ret() const;
  void set_ret(::common::action value);

  // @@protoc_insertion_point(class_scope:libcall_types.memcmp_pol)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  int s1_;
  int s2_;
  int n_;
  int ret_;
  friend struct ::TableStruct_libcall_2eproto;
};
// -------------------------------------------------------------------

class strchr_pol :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:libcall_types.strchr_pol) */ {
 public:
  strchr_pol();
  virtual ~strchr_pol();

  strchr_pol(const strchr_pol& from);
  strchr_pol(strchr_pol&& from) noexcept
    : strchr_pol() {
    *this = ::std::move(from);
  }

  inline strchr_pol& operator=(const strchr_pol& from) {
    CopyFrom(from);
    return *this;
  }
  inline strchr_pol& operator=(strchr_pol&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const strchr_pol& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const strchr_pol* internal_default_instance() {
    return reinterpret_cast<const strchr_pol*>(
               &_strchr_pol_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(strchr_pol& a, strchr_pol& b) {
    a.Swap(&b);
  }
  inline void Swap(strchr_pol* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline strchr_pol* New() const final {
    return CreateMaybeMessage<strchr_pol>(nullptr);
  }

  strchr_pol* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<strchr_pol>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const strchr_pol& from);
  void MergeFrom(const strchr_pol& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(strchr_pol* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "libcall_types.strchr_pol";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_libcall_2eproto);
    return ::descriptor_table_libcall_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kScFieldNumber = 1,
    kCFieldNumber = 2,
    kRetFieldNumber = 3,
  };
  // required .common.memory_pol sc = 1;
  bool has_sc() const;
  void clear_sc();
  const ::common::memory_pol& sc() const;
  ::common::memory_pol* release_sc();
  ::common::memory_pol* mutable_sc();
  void set_allocated_sc(::common::memory_pol* sc);

  // required .common.memory_pol c = 2;
  bool has_c() const;
  void clear_c();
  const ::common::memory_pol& c() const;
  ::common::memory_pol* release_c();
  ::common::memory_pol* mutable_c();
  void set_allocated_c(::common::memory_pol* c);

  // required .common.action ret = 3;
  bool has_ret() const;
  void clear_ret();
  ::common::action ret() const;
  void set_ret(::common::action value);

  // @@protoc_insertion_point(class_scope:libcall_types.strchr_pol)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::common::memory_pol* sc_;
  ::common::memory_pol* c_;
  int ret_;
  friend struct ::TableStruct_libcall_2eproto;
};
// -------------------------------------------------------------------

class strncpy_pol :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:libcall_types.strncpy_pol) */ {
 public:
  strncpy_pol();
  virtual ~strncpy_pol();

  strncpy_pol(const strncpy_pol& from);
  strncpy_pol(strncpy_pol&& from) noexcept
    : strncpy_pol() {
    *this = ::std::move(from);
  }

  inline strncpy_pol& operator=(const strncpy_pol& from) {
    CopyFrom(from);
    return *this;
  }
  inline strncpy_pol& operator=(strncpy_pol&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const strncpy_pol& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const strncpy_pol* internal_default_instance() {
    return reinterpret_cast<const strncpy_pol*>(
               &_strncpy_pol_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(strncpy_pol& a, strncpy_pol& b) {
    a.Swap(&b);
  }
  inline void Swap(strncpy_pol* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline strncpy_pol* New() const final {
    return CreateMaybeMessage<strncpy_pol>(nullptr);
  }

  strncpy_pol* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<strncpy_pol>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const strncpy_pol& from);
  void MergeFrom(const strncpy_pol& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(strncpy_pol* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "libcall_types.strncpy_pol";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_libcall_2eproto);
    return ::descriptor_table_libcall_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDstFieldNumber = 1,
    kSrcFieldNumber = 2,
    kNFieldNumber = 3,
    kRetFieldNumber = 4,
  };
  // required .common.action dst = 1;
  bool has_dst() const;
  void clear_dst();
  ::common::action dst() const;
  void set_dst(::common::action value);

  // required .common.action src = 2;
  bool has_src() const;
  void clear_src();
  ::common::action src() const;
  void set_src(::common::action value);

  // required .common.action n = 3;
  bool has_n() const;
  void clear_n();
  ::common::action n() const;
  void set_n(::common::action value);

  // required .common.action ret = 4;
  bool has_ret() const;
  void clear_ret();
  ::common::action ret() const;
  void set_ret(::common::action value);

  // @@protoc_insertion_point(class_scope:libcall_types.strncpy_pol)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  int dst_;
  int src_;
  int n_;
  int ret_;
  friend struct ::TableStruct_libcall_2eproto;
};
// -------------------------------------------------------------------

class fstat_pol :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:libcall_types.fstat_pol) */ {
 public:
  fstat_pol();
  virtual ~fstat_pol();

  fstat_pol(const fstat_pol& from);
  fstat_pol(fstat_pol&& from) noexcept
    : fstat_pol() {
    *this = ::std::move(from);
  }

  inline fstat_pol& operator=(const fstat_pol& from) {
    CopyFrom(from);
    return *this;
  }
  inline fstat_pol& operator=(fstat_pol&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const fstat_pol& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const fstat_pol* internal_default_instance() {
    return reinterpret_cast<const fstat_pol*>(
               &_fstat_pol_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(fstat_pol& a, fstat_pol& b) {
    a.Swap(&b);
  }
  inline void Swap(fstat_pol* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline fstat_pol* New() const final {
    return CreateMaybeMessage<fstat_pol>(nullptr);
  }

  fstat_pol* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<fstat_pol>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const fstat_pol& from);
  void MergeFrom(const fstat_pol& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(fstat_pol* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "libcall_types.fstat_pol";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_libcall_2eproto);
    return ::descriptor_table_libcall_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:libcall_types.fstat_pol)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_libcall_2eproto;
};
// -------------------------------------------------------------------

class fxstat64_pol :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:libcall_types.fxstat64_pol) */ {
 public:
  fxstat64_pol();
  virtual ~fxstat64_pol();

  fxstat64_pol(const fxstat64_pol& from);
  fxstat64_pol(fxstat64_pol&& from) noexcept
    : fxstat64_pol() {
    *this = ::std::move(from);
  }

  inline fxstat64_pol& operator=(const fxstat64_pol& from) {
    CopyFrom(from);
    return *this;
  }
  inline fxstat64_pol& operator=(fxstat64_pol&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const fxstat64_pol& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const fxstat64_pol* internal_default_instance() {
    return reinterpret_cast<const fxstat64_pol*>(
               &_fxstat64_pol_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(fxstat64_pol& a, fxstat64_pol& b) {
    a.Swap(&b);
  }
  inline void Swap(fxstat64_pol* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline fxstat64_pol* New() const final {
    return CreateMaybeMessage<fxstat64_pol>(nullptr);
  }

  fxstat64_pol* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<fxstat64_pol>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const fxstat64_pol& from);
  void MergeFrom(const fxstat64_pol& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(fxstat64_pol* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "libcall_types.fxstat64_pol";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_libcall_2eproto);
    return ::descriptor_table_libcall_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:libcall_types.fxstat64_pol)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_libcall_2eproto;
};
// -------------------------------------------------------------------

class realloc_pol :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:libcall_types.realloc_pol) */ {
 public:
  realloc_pol();
  virtual ~realloc_pol();

  realloc_pol(const realloc_pol& from);
  realloc_pol(realloc_pol&& from) noexcept
    : realloc_pol() {
    *this = ::std::move(from);
  }

  inline realloc_pol& operator=(const realloc_pol& from) {
    CopyFrom(from);
    return *this;
  }
  inline realloc_pol& operator=(realloc_pol&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const realloc_pol& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const realloc_pol* internal_default_instance() {
    return reinterpret_cast<const realloc_pol*>(
               &_realloc_pol_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(realloc_pol& a, realloc_pol& b) {
    a.Swap(&b);
  }
  inline void Swap(realloc_pol* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline realloc_pol* New() const final {
    return CreateMaybeMessage<realloc_pol>(nullptr);
  }

  realloc_pol* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<realloc_pol>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const realloc_pol& from);
  void MergeFrom(const realloc_pol& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(realloc_pol* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "libcall_types.realloc_pol";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_libcall_2eproto);
    return ::descriptor_table_libcall_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPtrFieldNumber = 1,
    kSizeFieldNumber = 2,
    kRetFieldNumber = 3,
  };
  // required .common.action ptr = 1;
  bool has_ptr() const;
  void clear_ptr();
  ::common::action ptr() const;
  void set_ptr(::common::action value);

  // required .common.action size = 2;
  bool has_size() const;
  void clear_size();
  ::common::action size() const;
  void set_size(::common::action value);

  // required .common.action ret = 3;
  bool has_ret() const;
  void clear_ret();
  ::common::action ret() const;
  void set_ret(::common::action value);

  // @@protoc_insertion_point(class_scope:libcall_types.realloc_pol)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  int ptr_;
  int size_;
  int ret_;
  friend struct ::TableStruct_libcall_2eproto;
};
// -------------------------------------------------------------------

class mmap_pol :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:libcall_types.mmap_pol) */ {
 public:
  mmap_pol();
  virtual ~mmap_pol();

  mmap_pol(const mmap_pol& from);
  mmap_pol(mmap_pol&& from) noexcept
    : mmap_pol() {
    *this = ::std::move(from);
  }

  inline mmap_pol& operator=(const mmap_pol& from) {
    CopyFrom(from);
    return *this;
  }
  inline mmap_pol& operator=(mmap_pol&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const mmap_pol& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const mmap_pol* internal_default_instance() {
    return reinterpret_cast<const mmap_pol*>(
               &_mmap_pol_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(mmap_pol& a, mmap_pol& b) {
    a.Swap(&b);
  }
  inline void Swap(mmap_pol* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline mmap_pol* New() const final {
    return CreateMaybeMessage<mmap_pol>(nullptr);
  }

  mmap_pol* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<mmap_pol>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const mmap_pol& from);
  void MergeFrom(const mmap_pol& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(mmap_pol* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "libcall_types.mmap_pol";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_libcall_2eproto);
    return ::descriptor_table_libcall_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRetFieldNumber = 7,
    kAddrFieldNumber = 1,
    kLengthFieldNumber = 2,
    kProtFieldNumber = 3,
    kFlagsFieldNumber = 4,
    kFdFieldNumber = 5,
    kOffsetFieldNumber = 6,
  };
  // required .common.memory_pol ret = 7;
  bool has_ret() const;
  void clear_ret();
  const ::common::memory_pol& ret() const;
  ::common::memory_pol* release_ret();
  ::common::memory_pol* mutable_ret();
  void set_allocated_ret(::common::memory_pol* ret);

  // required .common.action addr = 1;
  bool has_addr() const;
  void clear_addr();
  ::common::action addr() const;
  void set_addr(::common::action value);

  // required .common.action length = 2;
  bool has_length() const;
  void clear_length();
  ::common::action length() const;
  void set_length(::common::action value);

  // required .common.action prot = 3;
  bool has_prot() const;
  void clear_prot();
  ::common::action prot() const;
  void set_prot(::common::action value);

  // required .common.action flags = 4;
  bool has_flags() const;
  void clear_flags();
  ::common::action flags() const;
  void set_flags(::common::action value);

  // required .common.action fd = 5;
  bool has_fd() const;
  void clear_fd();
  ::common::action fd() const;
  void set_fd(::common::action value);

  // required .common.action offset = 6;
  bool has_offset() const;
  void clear_offset();
  ::common::action offset() const;
  void set_offset(::common::action value);

  // @@protoc_insertion_point(class_scope:libcall_types.mmap_pol)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::common::memory_pol* ret_;
  int addr_;
  int length_;
  int prot_;
  int flags_;
  int fd_;
  int offset_;
  friend struct ::TableStruct_libcall_2eproto;
};
// -------------------------------------------------------------------

class qsort_pol :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:libcall_types.qsort_pol) */ {
 public:
  qsort_pol();
  virtual ~qsort_pol();

  qsort_pol(const qsort_pol& from);
  qsort_pol(qsort_pol&& from) noexcept
    : qsort_pol() {
    *this = ::std::move(from);
  }

  inline qsort_pol& operator=(const qsort_pol& from) {
    CopyFrom(from);
    return *this;
  }
  inline qsort_pol& operator=(qsort_pol&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const qsort_pol& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const qsort_pol* internal_default_instance() {
    return reinterpret_cast<const qsort_pol*>(
               &_qsort_pol_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(qsort_pol& a, qsort_pol& b) {
    a.Swap(&b);
  }
  inline void Swap(qsort_pol* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline qsort_pol* New() const final {
    return CreateMaybeMessage<qsort_pol>(nullptr);
  }

  qsort_pol* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<qsort_pol>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const qsort_pol& from);
  void MergeFrom(const qsort_pol& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(qsort_pol* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "libcall_types.qsort_pol";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_libcall_2eproto);
    return ::descriptor_table_libcall_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBaseFieldNumber = 1,
    kNmembFieldNumber = 2,
    kSizeFieldNumber = 3,
    kCompareFieldNumber = 4,
  };
  // required .common.memory_pol base = 1;
  bool has_base() const;
  void clear_base();
  const ::common::memory_pol& base() const;
  ::common::memory_pol* release_base();
  ::common::memory_pol* mutable_base();
  void set_allocated_base(::common::memory_pol* base);

  // required .common.action nmemb = 2;
  bool has_nmemb() const;
  void clear_nmemb();
  ::common::action nmemb() const;
  void set_nmemb(::common::action value);

  // required .common.action size = 3;
  bool has_size() const;
  void clear_size();
  ::common::action size() const;
  void set_size(::common::action value);

  // required .common.action compare = 4;
  bool has_compare() const;
  void clear_compare();
  ::common::action compare() const;
  void set_compare(::common::action value);

  // @@protoc_insertion_point(class_scope:libcall_types.qsort_pol)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::common::memory_pol* base_;
  int nmemb_;
  int size_;
  int compare_;
  friend struct ::TableStruct_libcall_2eproto;
};
// -------------------------------------------------------------------

class bsearch_pol :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:libcall_types.bsearch_pol) */ {
 public:
  bsearch_pol();
  virtual ~bsearch_pol();

  bsearch_pol(const bsearch_pol& from);
  bsearch_pol(bsearch_pol&& from) noexcept
    : bsearch_pol() {
    *this = ::std::move(from);
  }

  inline bsearch_pol& operator=(const bsearch_pol& from) {
    CopyFrom(from);
    return *this;
  }
  inline bsearch_pol& operator=(bsearch_pol&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const bsearch_pol& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const bsearch_pol* internal_default_instance() {
    return reinterpret_cast<const bsearch_pol*>(
               &_bsearch_pol_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(bsearch_pol& a, bsearch_pol& b) {
    a.Swap(&b);
  }
  inline void Swap(bsearch_pol* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline bsearch_pol* New() const final {
    return CreateMaybeMessage<bsearch_pol>(nullptr);
  }

  bsearch_pol* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<bsearch_pol>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const bsearch_pol& from);
  void MergeFrom(const bsearch_pol& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(bsearch_pol* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "libcall_types.bsearch_pol";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_libcall_2eproto);
    return ::descriptor_table_libcall_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kKeyFieldNumber = 1,
    kBaseFieldNumber = 2,
    kRetFieldNumber = 6,
    kNmembFieldNumber = 3,
    kSizeFieldNumber = 4,
    kCompareFieldNumber = 5,
  };
  // required .common.memory_pol key = 1;
  bool has_key() const;
  void clear_key();
  const ::common::memory_pol& key() const;
  ::common::memory_pol* release_key();
  ::common::memory_pol* mutable_key();
  void set_allocated_key(::common::memory_pol* key);

  // required .common.memory_pol base = 2;
  bool has_base() const;
  void clear_base();
  const ::common::memory_pol& base() const;
  ::common::memory_pol* release_base();
  ::common::memory_pol* mutable_base();
  void set_allocated_base(::common::memory_pol* base);

  // required .common.memory_pol ret = 6;
  bool has_ret() const;
  void clear_ret();
  const ::common::memory_pol& ret() const;
  ::common::memory_pol* release_ret();
  ::common::memory_pol* mutable_ret();
  void set_allocated_ret(::common::memory_pol* ret);

  // required .common.action nmemb = 3;
  bool has_nmemb() const;
  void clear_nmemb();
  ::common::action nmemb() const;
  void set_nmemb(::common::action value);

  // required .common.action size = 4;
  bool has_size() const;
  void clear_size();
  ::common::action size() const;
  void set_size(::common::action value);

  // required .common.action compare = 5;
  bool has_compare() const;
  void clear_compare();
  ::common::action compare() const;
  void set_compare(::common::action value);

  // @@protoc_insertion_point(class_scope:libcall_types.bsearch_pol)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::common::memory_pol* key_;
  ::common::memory_pol* base_;
  ::common::memory_pol* ret_;
  int nmemb_;
  int size_;
  int compare_;
  friend struct ::TableStruct_libcall_2eproto;
};
// -------------------------------------------------------------------

class open_pol :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:libcall_types.open_pol) */ {
 public:
  open_pol();
  virtual ~open_pol();

  open_pol(const open_pol& from);
  open_pol(open_pol&& from) noexcept
    : open_pol() {
    *this = ::std::move(from);
  }

  inline open_pol& operator=(const open_pol& from) {
    CopyFrom(from);
    return *this;
  }
  inline open_pol& operator=(open_pol&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const open_pol& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const open_pol* internal_default_instance() {
    return reinterpret_cast<const open_pol*>(
               &_open_pol_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(open_pol& a, open_pol& b) {
    a.Swap(&b);
  }
  inline void Swap(open_pol* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline open_pol* New() const final {
    return CreateMaybeMessage<open_pol>(nullptr);
  }

  open_pol* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<open_pol>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const open_pol& from);
  void MergeFrom(const open_pol& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(open_pol* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "libcall_types.open_pol";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_libcall_2eproto);
    return ::descriptor_table_libcall_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPathnameFieldNumber = 1,
    kFlagsFieldNumber = 2,
    kModeFieldNumber = 3,
    kRetFieldNumber = 4,
  };
  // required .common.memory_pol pathname = 1;
  bool has_pathname() const;
  void clear_pathname();
  const ::common::memory_pol& pathname() const;
  ::common::memory_pol* release_pathname();
  ::common::memory_pol* mutable_pathname();
  void set_allocated_pathname(::common::memory_pol* pathname);

  // required .common.action flags = 2;
  bool has_flags() const;
  void clear_flags();
  ::common::action flags() const;
  void set_flags(::common::action value);

  // required .common.action mode = 3;
  bool has_mode() const;
  void clear_mode();
  ::common::action mode() const;
  void set_mode(::common::action value);

  // required .common.action ret = 4;
  bool has_ret() const;
  void clear_ret();
  ::common::action ret() const;
  void set_ret(::common::action value);

  // @@protoc_insertion_point(class_scope:libcall_types.open_pol)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::common::memory_pol* pathname_;
  int flags_;
  int mode_;
  int ret_;
  friend struct ::TableStruct_libcall_2eproto;
};
// -------------------------------------------------------------------

class strcpy_pol :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:libcall_types.strcpy_pol) */ {
 public:
  strcpy_pol();
  virtual ~strcpy_pol();

  strcpy_pol(const strcpy_pol& from);
  strcpy_pol(strcpy_pol&& from) noexcept
    : strcpy_pol() {
    *this = ::std::move(from);
  }

  inline strcpy_pol& operator=(const strcpy_pol& from) {
    CopyFrom(from);
    return *this;
  }
  inline strcpy_pol& operator=(strcpy_pol&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const strcpy_pol& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const strcpy_pol* internal_default_instance() {
    return reinterpret_cast<const strcpy_pol*>(
               &_strcpy_pol_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(strcpy_pol& a, strcpy_pol& b) {
    a.Swap(&b);
  }
  inline void Swap(strcpy_pol* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline strcpy_pol* New() const final {
    return CreateMaybeMessage<strcpy_pol>(nullptr);
  }

  strcpy_pol* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<strcpy_pol>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const strcpy_pol& from);
  void MergeFrom(const strcpy_pol& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(strcpy_pol* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "libcall_types.strcpy_pol";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_libcall_2eproto);
    return ::descriptor_table_libcall_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSrcFieldNumber = 1,
    kDstFieldNumber = 2,
    kRetFieldNumber = 3,
  };
  // required .common.memory_pol src = 1;
  bool has_src() const;
  void clear_src();
  const ::common::memory_pol& src() const;
  ::common::memory_pol* release_src();
  ::common::memory_pol* mutable_src();
  void set_allocated_src(::common::memory_pol* src);

  // required .common.memory_pol dst = 2;
  bool has_dst() const;
  void clear_dst();
  const ::common::memory_pol& dst() const;
  ::common::memory_pol* release_dst();
  ::common::memory_pol* mutable_dst();
  void set_allocated_dst(::common::memory_pol* dst);

  // required .common.action ret = 3;
  bool has_ret() const;
  void clear_ret();
  ::common::action ret() const;
  void set_ret(::common::action value);

  // @@protoc_insertion_point(class_scope:libcall_types.strcpy_pol)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::common::memory_pol* src_;
  ::common::memory_pol* dst_;
  int ret_;
  friend struct ::TableStruct_libcall_2eproto;
};
// -------------------------------------------------------------------

class printf_pol :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:libcall_types.printf_pol) */ {
 public:
  printf_pol();
  virtual ~printf_pol();

  printf_pol(const printf_pol& from);
  printf_pol(printf_pol&& from) noexcept
    : printf_pol() {
    *this = ::std::move(from);
  }

  inline printf_pol& operator=(const printf_pol& from) {
    CopyFrom(from);
    return *this;
  }
  inline printf_pol& operator=(printf_pol&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const printf_pol& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const printf_pol* internal_default_instance() {
    return reinterpret_cast<const printf_pol*>(
               &_printf_pol_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(printf_pol& a, printf_pol& b) {
    a.Swap(&b);
  }
  inline void Swap(printf_pol* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline printf_pol* New() const final {
    return CreateMaybeMessage<printf_pol>(nullptr);
  }

  printf_pol* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<printf_pol>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const printf_pol& from);
  void MergeFrom(const printf_pol& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(printf_pol* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "libcall_types.printf_pol";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_libcall_2eproto);
    return ::descriptor_table_libcall_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFormatFieldNumber = 1,
    kRetFieldNumber = 2,
  };
  // required .common.memory_pol format = 1;
  bool has_format() const;
  void clear_format();
  const ::common::memory_pol& format() const;
  ::common::memory_pol* release_format();
  ::common::memory_pol* mutable_format();
  void set_allocated_format(::common::memory_pol* format);

  // required .common.action ret = 2;
  bool has_ret() const;
  void clear_ret();
  ::common::action ret() const;
  void set_ret(::common::action value);

  // @@protoc_insertion_point(class_scope:libcall_types.printf_pol)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::common::memory_pol* format_;
  int ret_;
  friend struct ::TableStruct_libcall_2eproto;
};
// -------------------------------------------------------------------

class atoi_pol :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:libcall_types.atoi_pol) */ {
 public:
  atoi_pol();
  virtual ~atoi_pol();

  atoi_pol(const atoi_pol& from);
  atoi_pol(atoi_pol&& from) noexcept
    : atoi_pol() {
    *this = ::std::move(from);
  }

  inline atoi_pol& operator=(const atoi_pol& from) {
    CopyFrom(from);
    return *this;
  }
  inline atoi_pol& operator=(atoi_pol&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const atoi_pol& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const atoi_pol* internal_default_instance() {
    return reinterpret_cast<const atoi_pol*>(
               &_atoi_pol_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(atoi_pol& a, atoi_pol& b) {
    a.Swap(&b);
  }
  inline void Swap(atoi_pol* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline atoi_pol* New() const final {
    return CreateMaybeMessage<atoi_pol>(nullptr);
  }

  atoi_pol* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<atoi_pol>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const atoi_pol& from);
  void MergeFrom(const atoi_pol& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(atoi_pol* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "libcall_types.atoi_pol";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_libcall_2eproto);
    return ::descriptor_table_libcall_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSrcFieldNumber = 1,
    kRetFieldNumber = 3,
  };
  // required .common.memory_pol src = 1;
  bool has_src() const;
  void clear_src();
  const ::common::memory_pol& src() const;
  ::common::memory_pol* release_src();
  ::common::memory_pol* mutable_src();
  void set_allocated_src(::common::memory_pol* src);

  // required .common.action ret = 3;
  bool has_ret() const;
  void clear_ret();
  ::common::action ret() const;
  void set_ret(::common::action value);

  // @@protoc_insertion_point(class_scope:libcall_types.atoi_pol)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::common::memory_pol* src_;
  int ret_;
  friend struct ::TableStruct_libcall_2eproto;
};
// -------------------------------------------------------------------

class malloc_pol :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:libcall_types.malloc_pol) */ {
 public:
  malloc_pol();
  virtual ~malloc_pol();

  malloc_pol(const malloc_pol& from);
  malloc_pol(malloc_pol&& from) noexcept
    : malloc_pol() {
    *this = ::std::move(from);
  }

  inline malloc_pol& operator=(const malloc_pol& from) {
    CopyFrom(from);
    return *this;
  }
  inline malloc_pol& operator=(malloc_pol&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const malloc_pol& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const malloc_pol* internal_default_instance() {
    return reinterpret_cast<const malloc_pol*>(
               &_malloc_pol_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  friend void swap(malloc_pol& a, malloc_pol& b) {
    a.Swap(&b);
  }
  inline void Swap(malloc_pol* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline malloc_pol* New() const final {
    return CreateMaybeMessage<malloc_pol>(nullptr);
  }

  malloc_pol* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<malloc_pol>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const malloc_pol& from);
  void MergeFrom(const malloc_pol& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(malloc_pol* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "libcall_types.malloc_pol";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_libcall_2eproto);
    return ::descriptor_table_libcall_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSizeFieldNumber = 1,
    kRetFieldNumber = 2,
  };
  // required .common.action size = 1;
  bool has_size() const;
  void clear_size();
  ::common::action size() const;
  void set_size(::common::action value);

  // required .common.action ret = 2;
  bool has_ret() const;
  void clear_ret();
  ::common::action ret() const;
  void set_ret(::common::action value);

  // @@protoc_insertion_point(class_scope:libcall_types.malloc_pol)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  int size_;
  int ret_;
  friend struct ::TableStruct_libcall_2eproto;
};
// -------------------------------------------------------------------

class getmodulehandle_pol :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:libcall_types.getmodulehandle_pol) */ {
 public:
  getmodulehandle_pol();
  virtual ~getmodulehandle_pol();

  getmodulehandle_pol(const getmodulehandle_pol& from);
  getmodulehandle_pol(getmodulehandle_pol&& from) noexcept
    : getmodulehandle_pol() {
    *this = ::std::move(from);
  }

  inline getmodulehandle_pol& operator=(const getmodulehandle_pol& from) {
    CopyFrom(from);
    return *this;
  }
  inline getmodulehandle_pol& operator=(getmodulehandle_pol&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const getmodulehandle_pol& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const getmodulehandle_pol* internal_default_instance() {
    return reinterpret_cast<const getmodulehandle_pol*>(
               &_getmodulehandle_pol_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  friend void swap(getmodulehandle_pol& a, getmodulehandle_pol& b) {
    a.Swap(&b);
  }
  inline void Swap(getmodulehandle_pol* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline getmodulehandle_pol* New() const final {
    return CreateMaybeMessage<getmodulehandle_pol>(nullptr);
  }

  getmodulehandle_pol* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<getmodulehandle_pol>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const getmodulehandle_pol& from);
  void MergeFrom(const getmodulehandle_pol& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(getmodulehandle_pol* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "libcall_types.getmodulehandle_pol";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_libcall_2eproto);
    return ::descriptor_table_libcall_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kModuleNameFieldNumber = 1,
    kRetFieldNumber = 2,
  };
  // required .common.memory_pol module_name = 1;
  bool has_module_name() const;
  void clear_module_name();
  const ::common::memory_pol& module_name() const;
  ::common::memory_pol* release_module_name();
  ::common::memory_pol* mutable_module_name();
  void set_allocated_module_name(::common::memory_pol* module_name);

  // required .common.action ret = 2;
  bool has_ret() const;
  void clear_ret();
  ::common::action ret() const;
  void set_ret(::common::action value);

  // @@protoc_insertion_point(class_scope:libcall_types.getmodulehandle_pol)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::common::memory_pol* module_name_;
  int ret_;
  friend struct ::TableStruct_libcall_2eproto;
};
// -------------------------------------------------------------------

class getprocaddress_pol :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:libcall_types.getprocaddress_pol) */ {
 public:
  getprocaddress_pol();
  virtual ~getprocaddress_pol();

  getprocaddress_pol(const getprocaddress_pol& from);
  getprocaddress_pol(getprocaddress_pol&& from) noexcept
    : getprocaddress_pol() {
    *this = ::std::move(from);
  }

  inline getprocaddress_pol& operator=(const getprocaddress_pol& from) {
    CopyFrom(from);
    return *this;
  }
  inline getprocaddress_pol& operator=(getprocaddress_pol&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const getprocaddress_pol& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const getprocaddress_pol* internal_default_instance() {
    return reinterpret_cast<const getprocaddress_pol*>(
               &_getprocaddress_pol_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  friend void swap(getprocaddress_pol& a, getprocaddress_pol& b) {
    a.Swap(&b);
  }
  inline void Swap(getprocaddress_pol* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline getprocaddress_pol* New() const final {
    return CreateMaybeMessage<getprocaddress_pol>(nullptr);
  }

  getprocaddress_pol* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<getprocaddress_pol>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const getprocaddress_pol& from);
  void MergeFrom(const getprocaddress_pol& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(getprocaddress_pol* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "libcall_types.getprocaddress_pol";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_libcall_2eproto);
    return ::descriptor_table_libcall_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kProcNameFieldNumber = 2,
    kHmoduleFieldNumber = 1,
    kRetFieldNumber = 3,
  };
  // required .common.memory_pol proc_name = 2;
  bool has_proc_name() const;
  void clear_proc_name();
  const ::common::memory_pol& proc_name() const;
  ::common::memory_pol* release_proc_name();
  ::common::memory_pol* mutable_proc_name();
  void set_allocated_proc_name(::common::memory_pol* proc_name);

  // required .common.action hmodule = 1;
  bool has_hmodule() const;
  void clear_hmodule();
  ::common::action hmodule() const;
  void set_hmodule(::common::action value);

  // required .common.action ret = 3;
  bool has_ret() const;
  void clear_ret();
  ::common::action ret() const;
  void set_ret(::common::action value);

  // @@protoc_insertion_point(class_scope:libcall_types.getprocaddress_pol)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::common::memory_pol* proc_name_;
  int hmodule_;
  int ret_;
  friend struct ::TableStruct_libcall_2eproto;
};
// -------------------------------------------------------------------

class getmainargs_pol :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:libcall_types.getmainargs_pol) */ {
 public:
  getmainargs_pol();
  virtual ~getmainargs_pol();

  getmainargs_pol(const getmainargs_pol& from);
  getmainargs_pol(getmainargs_pol&& from) noexcept
    : getmainargs_pol() {
    *this = ::std::move(from);
  }

  inline getmainargs_pol& operator=(const getmainargs_pol& from) {
    CopyFrom(from);
    return *this;
  }
  inline getmainargs_pol& operator=(getmainargs_pol&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const getmainargs_pol& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const getmainargs_pol* internal_default_instance() {
    return reinterpret_cast<const getmainargs_pol*>(
               &_getmainargs_pol_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    26;

  friend void swap(getmainargs_pol& a, getmainargs_pol& b) {
    a.Swap(&b);
  }
  inline void Swap(getmainargs_pol* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline getmainargs_pol* New() const final {
    return CreateMaybeMessage<getmainargs_pol>(nullptr);
  }

  getmainargs_pol* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<getmainargs_pol>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const getmainargs_pol& from);
  void MergeFrom(const getmainargs_pol& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(getmainargs_pol* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "libcall_types.getmainargs_pol";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_libcall_2eproto);
    return ::descriptor_table_libcall_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kArgcFieldNumber = 1,
    kArgvFieldNumber = 2,
    kEnvFieldNumber = 3,
    kStartinfoFieldNumber = 5,
    kDowildcardFieldNumber = 4,
    kRetFieldNumber = 6,
  };
  // required .common.memory_pol argc = 1;
  bool has_argc() const;
  void clear_argc();
  const ::common::memory_pol& argc() const;
  ::common::memory_pol* release_argc();
  ::common::memory_pol* mutable_argc();
  void set_allocated_argc(::common::memory_pol* argc);

  // required .common.memory_pol argv = 2;
  bool has_argv() const;
  void clear_argv();
  const ::common::memory_pol& argv() const;
  ::common::memory_pol* release_argv();
  ::common::memory_pol* mutable_argv();
  void set_allocated_argv(::common::memory_pol* argv);

  // required .common.memory_pol env = 3;
  bool has_env() const;
  void clear_env();
  const ::common::memory_pol& env() const;
  ::common::memory_pol* release_env();
  ::common::memory_pol* mutable_env();
  void set_allocated_env(::common::memory_pol* env);

  // required .common.memory_pol startinfo = 5;
  bool has_startinfo() const;
  void clear_startinfo();
  const ::common::memory_pol& startinfo() const;
  ::common::memory_pol* release_startinfo();
  ::common::memory_pol* mutable_startinfo();
  void set_allocated_startinfo(::common::memory_pol* startinfo);

  // required .common.action dowildcard = 4;
  bool has_dowildcard() const;
  void clear_dowildcard();
  ::common::action dowildcard() const;
  void set_dowildcard(::common::action value);

  // required .common.action ret = 6;
  bool has_ret() const;
  void clear_ret();
  ::common::action ret() const;
  void set_ret(::common::action value);

  // @@protoc_insertion_point(class_scope:libcall_types.getmainargs_pol)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::common::memory_pol* argc_;
  ::common::memory_pol* argv_;
  ::common::memory_pol* env_;
  ::common::memory_pol* startinfo_;
  int dowildcard_;
  int ret_;
  friend struct ::TableStruct_libcall_2eproto;
};
// -------------------------------------------------------------------

class gethostname_pol :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:libcall_types.gethostname_pol) */ {
 public:
  gethostname_pol();
  virtual ~gethostname_pol();

  gethostname_pol(const gethostname_pol& from);
  gethostname_pol(gethostname_pol&& from) noexcept
    : gethostname_pol() {
    *this = ::std::move(from);
  }

  inline gethostname_pol& operator=(const gethostname_pol& from) {
    CopyFrom(from);
    return *this;
  }
  inline gethostname_pol& operator=(gethostname_pol&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const gethostname_pol& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const gethostname_pol* internal_default_instance() {
    return reinterpret_cast<const gethostname_pol*>(
               &_gethostname_pol_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    27;

  friend void swap(gethostname_pol& a, gethostname_pol& b) {
    a.Swap(&b);
  }
  inline void Swap(gethostname_pol* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline gethostname_pol* New() const final {
    return CreateMaybeMessage<gethostname_pol>(nullptr);
  }

  gethostname_pol* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<gethostname_pol>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const gethostname_pol& from);
  void MergeFrom(const gethostname_pol& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(gethostname_pol* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "libcall_types.gethostname_pol";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_libcall_2eproto);
    return ::descriptor_table_libcall_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kNamelenFieldNumber = 2,
    kRetFieldNumber = 3,
  };
  // required .common.memory_pol name = 1;
  bool has_name() const;
  void clear_name();
  const ::common::memory_pol& name() const;
  ::common::memory_pol* release_name();
  ::common::memory_pol* mutable_name();
  void set_allocated_name(::common::memory_pol* name);

  // required .common.action namelen = 2;
  bool has_namelen() const;
  void clear_namelen();
  ::common::action namelen() const;
  void set_namelen(::common::action value);

  // required .common.action ret = 3;
  bool has_ret() const;
  void clear_ret();
  ::common::action ret() const;
  void set_ret(::common::action value);

  // @@protoc_insertion_point(class_scope:libcall_types.gethostname_pol)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::common::memory_pol* name_;
  int namelen_;
  int ret_;
  friend struct ::TableStruct_libcall_2eproto;
};
// -------------------------------------------------------------------

class free_pol :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:libcall_types.free_pol) */ {
 public:
  free_pol();
  virtual ~free_pol();

  free_pol(const free_pol& from);
  free_pol(free_pol&& from) noexcept
    : free_pol() {
    *this = ::std::move(from);
  }

  inline free_pol& operator=(const free_pol& from) {
    CopyFrom(from);
    return *this;
  }
  inline free_pol& operator=(free_pol&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const free_pol& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const free_pol* internal_default_instance() {
    return reinterpret_cast<const free_pol*>(
               &_free_pol_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    28;

  friend void swap(free_pol& a, free_pol& b) {
    a.Swap(&b);
  }
  inline void Swap(free_pol* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline free_pol* New() const final {
    return CreateMaybeMessage<free_pol>(nullptr);
  }

  free_pol* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<free_pol>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const free_pol& from);
  void MergeFrom(const free_pol& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(free_pol* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "libcall_types.free_pol";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_libcall_2eproto);
    return ::descriptor_table_libcall_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPtrFieldNumber = 1,
  };
  // required .common.action ptr = 1;
  bool has_ptr() const;
  void clear_ptr();
  ::common::action ptr() const;
  void set_ptr(::common::action value);

  // @@protoc_insertion_point(class_scope:libcall_types.free_pol)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  int ptr_;
  friend struct ::TableStruct_libcall_2eproto;
};
// -------------------------------------------------------------------

class memcpy_pol :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:libcall_types.memcpy_pol) */ {
 public:
  memcpy_pol();
  virtual ~memcpy_pol();

  memcpy_pol(const memcpy_pol& from);
  memcpy_pol(memcpy_pol&& from) noexcept
    : memcpy_pol() {
    *this = ::std::move(from);
  }

  inline memcpy_pol& operator=(const memcpy_pol& from) {
    CopyFrom(from);
    return *this;
  }
  inline memcpy_pol& operator=(memcpy_pol&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const memcpy_pol& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const memcpy_pol* internal_default_instance() {
    return reinterpret_cast<const memcpy_pol*>(
               &_memcpy_pol_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    29;

  friend void swap(memcpy_pol& a, memcpy_pol& b) {
    a.Swap(&b);
  }
  inline void Swap(memcpy_pol* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline memcpy_pol* New() const final {
    return CreateMaybeMessage<memcpy_pol>(nullptr);
  }

  memcpy_pol* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<memcpy_pol>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const memcpy_pol& from);
  void MergeFrom(const memcpy_pol& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(memcpy_pol* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "libcall_types.memcpy_pol";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_libcall_2eproto);
    return ::descriptor_table_libcall_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDestFieldNumber = 1,
    kSrcFieldNumber = 2,
    kSizeFieldNumber = 3,
    kRetFieldNumber = 4,
  };
  // required .common.memory_pol dest = 1;
  bool has_dest() const;
  void clear_dest();
  const ::common::memory_pol& dest() const;
  ::common::memory_pol* release_dest();
  ::common::memory_pol* mutable_dest();
  void set_allocated_dest(::common::memory_pol* dest);

  // required .common.memory_pol src = 2;
  bool has_src() const;
  void clear_src();
  const ::common::memory_pol& src() const;
  ::common::memory_pol* release_src();
  ::common::memory_pol* mutable_src();
  void set_allocated_src(::common::memory_pol* src);

  // required .common.action size = 3;
  bool has_size() const;
  void clear_size();
  ::common::action size() const;
  void set_size(::common::action value);

  // required .common.action ret = 4;
  bool has_ret() const;
  void clear_ret();
  ::common::action ret() const;
  void set_ret(::common::action value);

  // @@protoc_insertion_point(class_scope:libcall_types.memcpy_pol)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::common::memory_pol* dest_;
  ::common::memory_pol* src_;
  int size_;
  int ret_;
  friend struct ::TableStruct_libcall_2eproto;
};
// -------------------------------------------------------------------

class memset_pol :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:libcall_types.memset_pol) */ {
 public:
  memset_pol();
  virtual ~memset_pol();

  memset_pol(const memset_pol& from);
  memset_pol(memset_pol&& from) noexcept
    : memset_pol() {
    *this = ::std::move(from);
  }

  inline memset_pol& operator=(const memset_pol& from) {
    CopyFrom(from);
    return *this;
  }
  inline memset_pol& operator=(memset_pol&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const memset_pol& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const memset_pol* internal_default_instance() {
    return reinterpret_cast<const memset_pol*>(
               &_memset_pol_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    30;

  friend void swap(memset_pol& a, memset_pol& b) {
    a.Swap(&b);
  }
  inline void Swap(memset_pol* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline memset_pol* New() const final {
    return CreateMaybeMessage<memset_pol>(nullptr);
  }

  memset_pol* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<memset_pol>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const memset_pol& from);
  void MergeFrom(const memset_pol& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(memset_pol* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "libcall_types.memset_pol";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_libcall_2eproto);
    return ::descriptor_table_libcall_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSFieldNumber = 1,
    kCFieldNumber = 2,
    kSizeFieldNumber = 3,
    kRetFieldNumber = 4,
  };
  // required .common.memory_pol s = 1;
  bool has_s() const;
  void clear_s();
  const ::common::memory_pol& s() const;
  ::common::memory_pol* release_s();
  ::common::memory_pol* mutable_s();
  void set_allocated_s(::common::memory_pol* s);

  // required .common.action c = 2;
  bool has_c() const;
  void clear_c();
  ::common::action c() const;
  void set_c(::common::action value);

  // required .common.action size = 3;
  bool has_size() const;
  void clear_size();
  ::common::action size() const;
  void set_size(::common::action value);

  // required .common.action ret = 4;
  bool has_ret() const;
  void clear_ret();
  ::common::action ret() const;
  void set_ret(::common::action value);

  // @@protoc_insertion_point(class_scope:libcall_types.memset_pol)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::common::memory_pol* s_;
  int c_;
  int size_;
  int ret_;
  friend struct ::TableStruct_libcall_2eproto;
};
// -------------------------------------------------------------------

class fgetc_pol :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:libcall_types.fgetc_pol) */ {
 public:
  fgetc_pol();
  virtual ~fgetc_pol();

  fgetc_pol(const fgetc_pol& from);
  fgetc_pol(fgetc_pol&& from) noexcept
    : fgetc_pol() {
    *this = ::std::move(from);
  }

  inline fgetc_pol& operator=(const fgetc_pol& from) {
    CopyFrom(from);
    return *this;
  }
  inline fgetc_pol& operator=(fgetc_pol&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const fgetc_pol& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const fgetc_pol* internal_default_instance() {
    return reinterpret_cast<const fgetc_pol*>(
               &_fgetc_pol_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    31;

  friend void swap(fgetc_pol& a, fgetc_pol& b) {
    a.Swap(&b);
  }
  inline void Swap(fgetc_pol* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline fgetc_pol* New() const final {
    return CreateMaybeMessage<fgetc_pol>(nullptr);
  }

  fgetc_pol* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<fgetc_pol>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const fgetc_pol& from);
  void MergeFrom(const fgetc_pol& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(fgetc_pol* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "libcall_types.fgetc_pol";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_libcall_2eproto);
    return ::descriptor_table_libcall_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStreamFieldNumber = 1,
    kRetFieldNumber = 2,
  };
  // required .common.action stream = 1;
  bool has_stream() const;
  void clear_stream();
  ::common::action stream() const;
  void set_stream(::common::action value);

  // required .common.action ret = 2;
  bool has_ret() const;
  void clear_ret();
  ::common::action ret() const;
  void set_ret(::common::action value);

  // @@protoc_insertion_point(class_scope:libcall_types.fgetc_pol)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  int stream_;
  int ret_;
  friend struct ::TableStruct_libcall_2eproto;
};
// -------------------------------------------------------------------

class lseek_pol :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:libcall_types.lseek_pol) */ {
 public:
  lseek_pol();
  virtual ~lseek_pol();

  lseek_pol(const lseek_pol& from);
  lseek_pol(lseek_pol&& from) noexcept
    : lseek_pol() {
    *this = ::std::move(from);
  }

  inline lseek_pol& operator=(const lseek_pol& from) {
    CopyFrom(from);
    return *this;
  }
  inline lseek_pol& operator=(lseek_pol&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const lseek_pol& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const lseek_pol* internal_default_instance() {
    return reinterpret_cast<const lseek_pol*>(
               &_lseek_pol_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    32;

  friend void swap(lseek_pol& a, lseek_pol& b) {
    a.Swap(&b);
  }
  inline void Swap(lseek_pol* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline lseek_pol* New() const final {
    return CreateMaybeMessage<lseek_pol>(nullptr);
  }

  lseek_pol* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<lseek_pol>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const lseek_pol& from);
  void MergeFrom(const lseek_pol& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(lseek_pol* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "libcall_types.lseek_pol";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_libcall_2eproto);
    return ::descriptor_table_libcall_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFdFieldNumber = 1,
    kOffsetFieldNumber = 2,
    kWhenceFieldNumber = 3,
    kRetFieldNumber = 4,
  };
  // required .common.action fd = 1;
  bool has_fd() const;
  void clear_fd();
  ::common::action fd() const;
  void set_fd(::common::action value);

  // required .common.action offset = 2;
  bool has_offset() const;
  void clear_offset();
  ::common::action offset() const;
  void set_offset(::common::action value);

  // required .common.action whence = 3;
  bool has_whence() const;
  void clear_whence();
  ::common::action whence() const;
  void set_whence(::common::action value);

  // required .common.action ret = 4;
  bool has_ret() const;
  void clear_ret();
  ::common::action ret() const;
  void set_ret(::common::action value);

  // @@protoc_insertion_point(class_scope:libcall_types.lseek_pol)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  int fd_;
  int offset_;
  int whence_;
  int ret_;
  friend struct ::TableStruct_libcall_2eproto;
};
// -------------------------------------------------------------------

class exit_t :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:libcall_types.exit_t) */ {
 public:
  exit_t();
  virtual ~exit_t();

  exit_t(const exit_t& from);
  exit_t(exit_t&& from) noexcept
    : exit_t() {
    *this = ::std::move(from);
  }

  inline exit_t& operator=(const exit_t& from) {
    CopyFrom(from);
    return *this;
  }
  inline exit_t& operator=(exit_t&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const exit_t& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const exit_t* internal_default_instance() {
    return reinterpret_cast<const exit_t*>(
               &_exit_t_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    33;

  friend void swap(exit_t& a, exit_t& b) {
    a.Swap(&b);
  }
  inline void Swap(exit_t* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline exit_t* New() const final {
    return CreateMaybeMessage<exit_t>(nullptr);
  }

  exit_t* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<exit_t>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const exit_t& from);
  void MergeFrom(const exit_t& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(exit_t* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "libcall_types.exit_t";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_libcall_2eproto);
    return ::descriptor_table_libcall_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:libcall_types.exit_t)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_libcall_2eproto;
};
// -------------------------------------------------------------------

class generic_t :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:libcall_types.generic_t) */ {
 public:
  generic_t();
  virtual ~generic_t();

  generic_t(const generic_t& from);
  generic_t(generic_t&& from) noexcept
    : generic_t() {
    *this = ::std::move(from);
  }

  inline generic_t& operator=(const generic_t& from) {
    CopyFrom(from);
    return *this;
  }
  inline generic_t& operator=(generic_t&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const generic_t& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const generic_t* internal_default_instance() {
    return reinterpret_cast<const generic_t*>(
               &_generic_t_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    34;

  friend void swap(generic_t& a, generic_t& b) {
    a.Swap(&b);
  }
  inline void Swap(generic_t* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline generic_t* New() const final {
    return CreateMaybeMessage<generic_t>(nullptr);
  }

  generic_t* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<generic_t>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const generic_t& from);
  void MergeFrom(const generic_t& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(generic_t* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "libcall_types.generic_t";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_libcall_2eproto);
    return ::descriptor_table_libcall_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRetFieldNumber = 1,
  };
  // required uint64 ret = 1;
  bool has_ret() const;
  void clear_ret();
  ::PROTOBUF_NAMESPACE_ID::uint64 ret() const;
  void set_ret(::PROTOBUF_NAMESPACE_ID::uint64 value);

  // @@protoc_insertion_point(class_scope:libcall_types.generic_t)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint64 ret_;
  friend struct ::TableStruct_libcall_2eproto;
};
// -------------------------------------------------------------------

class fscanf_elem_t :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:libcall_types.fscanf_elem_t) */ {
 public:
  fscanf_elem_t();
  virtual ~fscanf_elem_t();

  fscanf_elem_t(const fscanf_elem_t& from);
  fscanf_elem_t(fscanf_elem_t&& from) noexcept
    : fscanf_elem_t() {
    *this = ::std::move(from);
  }

  inline fscanf_elem_t& operator=(const fscanf_elem_t& from) {
    CopyFrom(from);
    return *this;
  }
  inline fscanf_elem_t& operator=(fscanf_elem_t&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const fscanf_elem_t& default_instance();

  enum FscanfCntCase {
    kValueDec = 3,
    kValueString = 4,
    FSCANF_CNT_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const fscanf_elem_t* internal_default_instance() {
    return reinterpret_cast<const fscanf_elem_t*>(
               &_fscanf_elem_t_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    35;

  friend void swap(fscanf_elem_t& a, fscanf_elem_t& b) {
    a.Swap(&b);
  }
  inline void Swap(fscanf_elem_t* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline fscanf_elem_t* New() const final {
    return CreateMaybeMessage<fscanf_elem_t>(nullptr);
  }

  fscanf_elem_t* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<fscanf_elem_t>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const fscanf_elem_t& from);
  void MergeFrom(const fscanf_elem_t& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(fscanf_elem_t* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "libcall_types.fscanf_elem_t";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_libcall_2eproto);
    return ::descriptor_table_libcall_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAddrFieldNumber = 2,
    kTypeFieldNumber = 1,
    kValueDecFieldNumber = 3,
    kValueStringFieldNumber = 4,
  };
  // required uint64 addr = 2;
  bool has_addr() const;
  void clear_addr();
  ::PROTOBUF_NAMESPACE_ID::uint64 addr() const;
  void set_addr(::PROTOBUF_NAMESPACE_ID::uint64 value);

  // required .libcall_types.fscanf_enum type = 1;
  bool has_type() const;
  void clear_type();
  ::libcall_types::fscanf_enum type() const;
  void set_type(::libcall_types::fscanf_enum value);

  // optional uint64 value_dec = 3;
  bool has_value_dec() const;
  void clear_value_dec();
  ::PROTOBUF_NAMESPACE_ID::uint64 value_dec() const;
  void set_value_dec(::PROTOBUF_NAMESPACE_ID::uint64 value);

  // optional string value_string = 4;
  bool has_value_string() const;
  void clear_value_string();
  const std::string& value_string() const;
  void set_value_string(const std::string& value);
  void set_value_string(std::string&& value);
  void set_value_string(const char* value);
  void set_value_string(const char* value, size_t size);
  std::string* mutable_value_string();
  std::string* release_value_string();
  void set_allocated_value_string(std::string* value_string);

  void clear_fscanf_cnt();
  FscanfCntCase fscanf_cnt_case() const;
  // @@protoc_insertion_point(class_scope:libcall_types.fscanf_elem_t)
 private:
  class _Internal;
  void set_has_value_dec();
  void set_has_value_string();

  inline bool has_fscanf_cnt() const;
  inline void clear_has_fscanf_cnt();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint64 addr_;
  int type_;
  union FscanfCntUnion {
    FscanfCntUnion() {}
    ::PROTOBUF_NAMESPACE_ID::uint64 value_dec_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr value_string_;
  } fscanf_cnt_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];

  friend struct ::TableStruct_libcall_2eproto;
};
// -------------------------------------------------------------------

class fscanf_t :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:libcall_types.fscanf_t) */ {
 public:
  fscanf_t();
  virtual ~fscanf_t();

  fscanf_t(const fscanf_t& from);
  fscanf_t(fscanf_t&& from) noexcept
    : fscanf_t() {
    *this = ::std::move(from);
  }

  inline fscanf_t& operator=(const fscanf_t& from) {
    CopyFrom(from);
    return *this;
  }
  inline fscanf_t& operator=(fscanf_t&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const fscanf_t& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const fscanf_t* internal_default_instance() {
    return reinterpret_cast<const fscanf_t*>(
               &_fscanf_t_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    36;

  friend void swap(fscanf_t& a, fscanf_t& b) {
    a.Swap(&b);
  }
  inline void Swap(fscanf_t* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline fscanf_t* New() const final {
    return CreateMaybeMessage<fscanf_t>(nullptr);
  }

  fscanf_t* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<fscanf_t>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const fscanf_t& from);
  void MergeFrom(const fscanf_t& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(fscanf_t* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "libcall_types.fscanf_t";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_libcall_2eproto);
    return ::descriptor_table_libcall_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kElemsFieldNumber = 2,
    kStreamFieldNumber = 1,
    kRetFieldNumber = 3,
  };
  // repeated .libcall_types.fscanf_elem_t elems = 2;
  int elems_size() const;
  void clear_elems();
  ::libcall_types::fscanf_elem_t* mutable_elems(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::libcall_types::fscanf_elem_t >*
      mutable_elems();
  const ::libcall_types::fscanf_elem_t& elems(int index) const;
  ::libcall_types::fscanf_elem_t* add_elems();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::libcall_types::fscanf_elem_t >&
      elems() const;

  // required uint64 stream = 1;
  bool has_stream() const;
  void clear_stream();
  ::PROTOBUF_NAMESPACE_ID::uint64 stream() const;
  void set_stream(::PROTOBUF_NAMESPACE_ID::uint64 value);

  // required uint64 ret = 3;
  bool has_ret() const;
  void clear_ret();
  ::PROTOBUF_NAMESPACE_ID::uint64 ret() const;
  void set_ret(::PROTOBUF_NAMESPACE_ID::uint64 value);

  // @@protoc_insertion_point(class_scope:libcall_types.fscanf_t)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::libcall_types::fscanf_elem_t > elems_;
  ::PROTOBUF_NAMESPACE_ID::uint64 stream_;
  ::PROTOBUF_NAMESPACE_ID::uint64 ret_;
  friend struct ::TableStruct_libcall_2eproto;
};
// -------------------------------------------------------------------

class ctype_b_loc_t :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:libcall_types.ctype_b_loc_t) */ {
 public:
  ctype_b_loc_t();
  virtual ~ctype_b_loc_t();

  ctype_b_loc_t(const ctype_b_loc_t& from);
  ctype_b_loc_t(ctype_b_loc_t&& from) noexcept
    : ctype_b_loc_t() {
    *this = ::std::move(from);
  }

  inline ctype_b_loc_t& operator=(const ctype_b_loc_t& from) {
    CopyFrom(from);
    return *this;
  }
  inline ctype_b_loc_t& operator=(ctype_b_loc_t&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const ctype_b_loc_t& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ctype_b_loc_t* internal_default_instance() {
    return reinterpret_cast<const ctype_b_loc_t*>(
               &_ctype_b_loc_t_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    37;

  friend void swap(ctype_b_loc_t& a, ctype_b_loc_t& b) {
    a.Swap(&b);
  }
  inline void Swap(ctype_b_loc_t* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ctype_b_loc_t* New() const final {
    return CreateMaybeMessage<ctype_b_loc_t>(nullptr);
  }

  ctype_b_loc_t* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ctype_b_loc_t>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const ctype_b_loc_t& from);
  void MergeFrom(const ctype_b_loc_t& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ctype_b_loc_t* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "libcall_types.ctype_b_loc_t";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_libcall_2eproto);
    return ::descriptor_table_libcall_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTableFieldNumber = 1,
    kRetFieldNumber = 2,
  };
  // required .common.memory_t table = 1;
  bool has_table() const;
  void clear_table();
  const ::common::memory_t& table() const;
  ::common::memory_t* release_table();
  ::common::memory_t* mutable_table();
  void set_allocated_table(::common::memory_t* table);

  // required uint64 ret = 2;
  bool has_ret() const;
  void clear_ret();
  ::PROTOBUF_NAMESPACE_ID::uint64 ret() const;
  void set_ret(::PROTOBUF_NAMESPACE_ID::uint64 value);

  // @@protoc_insertion_point(class_scope:libcall_types.ctype_b_loc_t)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::common::memory_t* table_;
  ::PROTOBUF_NAMESPACE_ID::uint64 ret_;
  friend struct ::TableStruct_libcall_2eproto;
};
// -------------------------------------------------------------------

class read_t :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:libcall_types.read_t) */ {
 public:
  read_t();
  virtual ~read_t();

  read_t(const read_t& from);
  read_t(read_t&& from) noexcept
    : read_t() {
    *this = ::std::move(from);
  }

  inline read_t& operator=(const read_t& from) {
    CopyFrom(from);
    return *this;
  }
  inline read_t& operator=(read_t&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const read_t& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const read_t* internal_default_instance() {
    return reinterpret_cast<const read_t*>(
               &_read_t_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    38;

  friend void swap(read_t& a, read_t& b) {
    a.Swap(&b);
  }
  inline void Swap(read_t* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline read_t* New() const final {
    return CreateMaybeMessage<read_t>(nullptr);
  }

  read_t* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<read_t>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const read_t& from);
  void MergeFrom(const read_t& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(read_t* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "libcall_types.read_t";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_libcall_2eproto);
    return ::descriptor_table_libcall_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBufFieldNumber = 2,
    kFdFieldNumber = 1,
    kCountFieldNumber = 3,
    kRetFieldNumber = 4,
  };
  // required .common.memory_t buf = 2;
  bool has_buf() const;
  void clear_buf();
  const ::common::memory_t& buf() const;
  ::common::memory_t* release_buf();
  ::common::memory_t* mutable_buf();
  void set_allocated_buf(::common::memory_t* buf);

  // required uint64 fd = 1;
  bool has_fd() const;
  void clear_fd();
  ::PROTOBUF_NAMESPACE_ID::uint64 fd() const;
  void set_fd(::PROTOBUF_NAMESPACE_ID::uint64 value);

  // required uint64 count = 3;
  bool has_count() const;
  void clear_count();
  ::PROTOBUF_NAMESPACE_ID::uint64 count() const;
  void set_count(::PROTOBUF_NAMESPACE_ID::uint64 value);

  // required uint64 ret = 4;
  bool has_ret() const;
  void clear_ret();
  ::PROTOBUF_NAMESPACE_ID::uint64 ret() const;
  void set_ret(::PROTOBUF_NAMESPACE_ID::uint64 value);

  // @@protoc_insertion_point(class_scope:libcall_types.read_t)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::common::memory_t* buf_;
  ::PROTOBUF_NAMESPACE_ID::uint64 fd_;
  ::PROTOBUF_NAMESPACE_ID::uint64 count_;
  ::PROTOBUF_NAMESPACE_ID::uint64 ret_;
  friend struct ::TableStruct_libcall_2eproto;
};
// -------------------------------------------------------------------

class fread_t :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:libcall_types.fread_t) */ {
 public:
  fread_t();
  virtual ~fread_t();

  fread_t(const fread_t& from);
  fread_t(fread_t&& from) noexcept
    : fread_t() {
    *this = ::std::move(from);
  }

  inline fread_t& operator=(const fread_t& from) {
    CopyFrom(from);
    return *this;
  }
  inline fread_t& operator=(fread_t&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const fread_t& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const fread_t* internal_default_instance() {
    return reinterpret_cast<const fread_t*>(
               &_fread_t_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    39;

  friend void swap(fread_t& a, fread_t& b) {
    a.Swap(&b);
  }
  inline void Swap(fread_t* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline fread_t* New() const final {
    return CreateMaybeMessage<fread_t>(nullptr);
  }

  fread_t* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<fread_t>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const fread_t& from);
  void MergeFrom(const fread_t& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(fread_t* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "libcall_types.fread_t";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_libcall_2eproto);
    return ::descriptor_table_libcall_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPtrFieldNumber = 1,
    kSizeFieldNumber = 2,
    kNmembFieldNumber = 3,
    kStreamFieldNumber = 4,
    kRetFieldNumber = 5,
  };
  // required .common.memory_t ptr = 1;
  bool has_ptr() const;
  void clear_ptr();
  const ::common::memory_t& ptr() const;
  ::common::memory_t* release_ptr();
  ::common::memory_t* mutable_ptr();
  void set_allocated_ptr(::common::memory_t* ptr);

  // required uint64 size = 2;
  bool has_size() const;
  void clear_size();
  ::PROTOBUF_NAMESPACE_ID::uint64 size() const;
  void set_size(::PROTOBUF_NAMESPACE_ID::uint64 value);

  // required uint64 nmemb = 3;
  bool has_nmemb() const;
  void clear_nmemb();
  ::PROTOBUF_NAMESPACE_ID::uint64 nmemb() const;
  void set_nmemb(::PROTOBUF_NAMESPACE_ID::uint64 value);

  // required uint64 stream = 4;
  bool has_stream() const;
  void clear_stream();
  ::PROTOBUF_NAMESPACE_ID::uint64 stream() const;
  void set_stream(::PROTOBUF_NAMESPACE_ID::uint64 value);

  // required uint64 ret = 5;
  bool has_ret() const;
  void clear_ret();
  ::PROTOBUF_NAMESPACE_ID::uint64 ret() const;
  void set_ret(::PROTOBUF_NAMESPACE_ID::uint64 value);

  // @@protoc_insertion_point(class_scope:libcall_types.fread_t)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::common::memory_t* ptr_;
  ::PROTOBUF_NAMESPACE_ID::uint64 size_;
  ::PROTOBUF_NAMESPACE_ID::uint64 nmemb_;
  ::PROTOBUF_NAMESPACE_ID::uint64 stream_;
  ::PROTOBUF_NAMESPACE_ID::uint64 ret_;
  friend struct ::TableStruct_libcall_2eproto;
};
// -------------------------------------------------------------------

class strchr_t :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:libcall_types.strchr_t) */ {
 public:
  strchr_t();
  virtual ~strchr_t();

  strchr_t(const strchr_t& from);
  strchr_t(strchr_t&& from) noexcept
    : strchr_t() {
    *this = ::std::move(from);
  }

  inline strchr_t& operator=(const strchr_t& from) {
    CopyFrom(from);
    return *this;
  }
  inline strchr_t& operator=(strchr_t&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const strchr_t& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const strchr_t* internal_default_instance() {
    return reinterpret_cast<const strchr_t*>(
               &_strchr_t_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    40;

  friend void swap(strchr_t& a, strchr_t& b) {
    a.Swap(&b);
  }
  inline void Swap(strchr_t* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline strchr_t* New() const final {
    return CreateMaybeMessage<strchr_t>(nullptr);
  }

  strchr_t* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<strchr_t>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const strchr_t& from);
  void MergeFrom(const strchr_t& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(strchr_t* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "libcall_types.strchr_t";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_libcall_2eproto);
    return ::descriptor_table_libcall_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSFieldNumber = 1,
    kCFieldNumber = 2,
    kSizeMaxFieldNumber = 3,
    kRetFieldNumber = 4,
  };
  // required uint64 s = 1;
  bool has_s() const;
  void clear_s();
  ::PROTOBUF_NAMESPACE_ID::uint64 s() const;
  void set_s(::PROTOBUF_NAMESPACE_ID::uint64 value);

  // required uint64 c = 2;
  bool has_c() const;
  void clear_c();
  ::PROTOBUF_NAMESPACE_ID::uint64 c() const;
  void set_c(::PROTOBUF_NAMESPACE_ID::uint64 value);

  // required uint64 size_max = 3;
  bool has_size_max() const;
  void clear_size_max();
  ::PROTOBUF_NAMESPACE_ID::uint64 size_max() const;
  void set_size_max(::PROTOBUF_NAMESPACE_ID::uint64 value);

  // required uint64 ret = 4;
  bool has_ret() const;
  void clear_ret();
  ::PROTOBUF_NAMESPACE_ID::uint64 ret() const;
  void set_ret(::PROTOBUF_NAMESPACE_ID::uint64 value);

  // @@protoc_insertion_point(class_scope:libcall_types.strchr_t)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint64 s_;
  ::PROTOBUF_NAMESPACE_ID::uint64 c_;
  ::PROTOBUF_NAMESPACE_ID::uint64 size_max_;
  ::PROTOBUF_NAMESPACE_ID::uint64 ret_;
  friend struct ::TableStruct_libcall_2eproto;
};
// -------------------------------------------------------------------

class strncpy_t :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:libcall_types.strncpy_t) */ {
 public:
  strncpy_t();
  virtual ~strncpy_t();

  strncpy_t(const strncpy_t& from);
  strncpy_t(strncpy_t&& from) noexcept
    : strncpy_t() {
    *this = ::std::move(from);
  }

  inline strncpy_t& operator=(const strncpy_t& from) {
    CopyFrom(from);
    return *this;
  }
  inline strncpy_t& operator=(strncpy_t&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const strncpy_t& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const strncpy_t* internal_default_instance() {
    return reinterpret_cast<const strncpy_t*>(
               &_strncpy_t_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    41;

  friend void swap(strncpy_t& a, strncpy_t& b) {
    a.Swap(&b);
  }
  inline void Swap(strncpy_t* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline strncpy_t* New() const final {
    return CreateMaybeMessage<strncpy_t>(nullptr);
  }

  strncpy_t* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<strncpy_t>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const strncpy_t& from);
  void MergeFrom(const strncpy_t& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(strncpy_t* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "libcall_types.strncpy_t";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_libcall_2eproto);
    return ::descriptor_table_libcall_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDstFieldNumber = 1,
    kSrcFieldNumber = 2,
    kNFieldNumber = 3,
    kRetFieldNumber = 4,
  };
  // required uint64 dst = 1;
  bool has_dst() const;
  void clear_dst();
  ::PROTOBUF_NAMESPACE_ID::uint64 dst() const;
  void set_dst(::PROTOBUF_NAMESPACE_ID::uint64 value);

  // required uint64 src = 2;
  bool has_src() const;
  void clear_src();
  ::PROTOBUF_NAMESPACE_ID::uint64 src() const;
  void set_src(::PROTOBUF_NAMESPACE_ID::uint64 value);

  // required uint64 n = 3;
  bool has_n() const;
  void clear_n();
  ::PROTOBUF_NAMESPACE_ID::uint64 n() const;
  void set_n(::PROTOBUF_NAMESPACE_ID::uint64 value);

  // required uint64 ret = 4;
  bool has_ret() const;
  void clear_ret();
  ::PROTOBUF_NAMESPACE_ID::uint64 ret() const;
  void set_ret(::PROTOBUF_NAMESPACE_ID::uint64 value);

  // @@protoc_insertion_point(class_scope:libcall_types.strncpy_t)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint64 dst_;
  ::PROTOBUF_NAMESPACE_ID::uint64 src_;
  ::PROTOBUF_NAMESPACE_ID::uint64 n_;
  ::PROTOBUF_NAMESPACE_ID::uint64 ret_;
  friend struct ::TableStruct_libcall_2eproto;
};
// -------------------------------------------------------------------

class fstat_t :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:libcall_types.fstat_t) */ {
 public:
  fstat_t();
  virtual ~fstat_t();

  fstat_t(const fstat_t& from);
  fstat_t(fstat_t&& from) noexcept
    : fstat_t() {
    *this = ::std::move(from);
  }

  inline fstat_t& operator=(const fstat_t& from) {
    CopyFrom(from);
    return *this;
  }
  inline fstat_t& operator=(fstat_t&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const fstat_t& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const fstat_t* internal_default_instance() {
    return reinterpret_cast<const fstat_t*>(
               &_fstat_t_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    42;

  friend void swap(fstat_t& a, fstat_t& b) {
    a.Swap(&b);
  }
  inline void Swap(fstat_t* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline fstat_t* New() const final {
    return CreateMaybeMessage<fstat_t>(nullptr);
  }

  fstat_t* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<fstat_t>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const fstat_t& from);
  void MergeFrom(const fstat_t& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(fstat_t* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "libcall_types.fstat_t";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_libcall_2eproto);
    return ::descriptor_table_libcall_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBufFieldNumber = 2,
    kFdFieldNumber = 1,
    kRetFieldNumber = 3,
  };
  // required .common.memory_t buf = 2;
  bool has_buf() const;
  void clear_buf();
  const ::common::memory_t& buf() const;
  ::common::memory_t* release_buf();
  ::common::memory_t* mutable_buf();
  void set_allocated_buf(::common::memory_t* buf);

  // required uint64 fd = 1;
  bool has_fd() const;
  void clear_fd();
  ::PROTOBUF_NAMESPACE_ID::uint64 fd() const;
  void set_fd(::PROTOBUF_NAMESPACE_ID::uint64 value);

  // required uint64 ret = 3;
  bool has_ret() const;
  void clear_ret();
  ::PROTOBUF_NAMESPACE_ID::uint64 ret() const;
  void set_ret(::PROTOBUF_NAMESPACE_ID::uint64 value);

  // @@protoc_insertion_point(class_scope:libcall_types.fstat_t)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::common::memory_t* buf_;
  ::PROTOBUF_NAMESPACE_ID::uint64 fd_;
  ::PROTOBUF_NAMESPACE_ID::uint64 ret_;
  friend struct ::TableStruct_libcall_2eproto;
};
// -------------------------------------------------------------------

class fxstat64_t :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:libcall_types.fxstat64_t) */ {
 public:
  fxstat64_t();
  virtual ~fxstat64_t();

  fxstat64_t(const fxstat64_t& from);
  fxstat64_t(fxstat64_t&& from) noexcept
    : fxstat64_t() {
    *this = ::std::move(from);
  }

  inline fxstat64_t& operator=(const fxstat64_t& from) {
    CopyFrom(from);
    return *this;
  }
  inline fxstat64_t& operator=(fxstat64_t&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const fxstat64_t& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const fxstat64_t* internal_default_instance() {
    return reinterpret_cast<const fxstat64_t*>(
               &_fxstat64_t_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    43;

  friend void swap(fxstat64_t& a, fxstat64_t& b) {
    a.Swap(&b);
  }
  inline void Swap(fxstat64_t* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline fxstat64_t* New() const final {
    return CreateMaybeMessage<fxstat64_t>(nullptr);
  }

  fxstat64_t* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<fxstat64_t>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const fxstat64_t& from);
  void MergeFrom(const fxstat64_t& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(fxstat64_t* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "libcall_types.fxstat64_t";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_libcall_2eproto);
    return ::descriptor_table_libcall_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBufFieldNumber = 3,
    kVersFieldNumber = 1,
    kFdFieldNumber = 2,
    kRetFieldNumber = 4,
  };
  // required .common.memory_t buf = 3;
  bool has_buf() const;
  void clear_buf();
  const ::common::memory_t& buf() const;
  ::common::memory_t* release_buf();
  ::common::memory_t* mutable_buf();
  void set_allocated_buf(::common::memory_t* buf);

  // required uint64 vers = 1;
  bool has_vers() const;
  void clear_vers();
  ::PROTOBUF_NAMESPACE_ID::uint64 vers() const;
  void set_vers(::PROTOBUF_NAMESPACE_ID::uint64 value);

  // required uint64 fd = 2;
  bool has_fd() const;
  void clear_fd();
  ::PROTOBUF_NAMESPACE_ID::uint64 fd() const;
  void set_fd(::PROTOBUF_NAMESPACE_ID::uint64 value);

  // required uint64 ret = 4;
  bool has_ret() const;
  void clear_ret();
  ::PROTOBUF_NAMESPACE_ID::uint64 ret() const;
  void set_ret(::PROTOBUF_NAMESPACE_ID::uint64 value);

  // @@protoc_insertion_point(class_scope:libcall_types.fxstat64_t)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::common::memory_t* buf_;
  ::PROTOBUF_NAMESPACE_ID::uint64 vers_;
  ::PROTOBUF_NAMESPACE_ID::uint64 fd_;
  ::PROTOBUF_NAMESPACE_ID::uint64 ret_;
  friend struct ::TableStruct_libcall_2eproto;
};
// -------------------------------------------------------------------

class realloc_t :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:libcall_types.realloc_t) */ {
 public:
  realloc_t();
  virtual ~realloc_t();

  realloc_t(const realloc_t& from);
  realloc_t(realloc_t&& from) noexcept
    : realloc_t() {
    *this = ::std::move(from);
  }

  inline realloc_t& operator=(const realloc_t& from) {
    CopyFrom(from);
    return *this;
  }
  inline realloc_t& operator=(realloc_t&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const realloc_t& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const realloc_t* internal_default_instance() {
    return reinterpret_cast<const realloc_t*>(
               &_realloc_t_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    44;

  friend void swap(realloc_t& a, realloc_t& b) {
    a.Swap(&b);
  }
  inline void Swap(realloc_t* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline realloc_t* New() const final {
    return CreateMaybeMessage<realloc_t>(nullptr);
  }

  realloc_t* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<realloc_t>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const realloc_t& from);
  void MergeFrom(const realloc_t& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(realloc_t* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "libcall_types.realloc_t";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_libcall_2eproto);
    return ::descriptor_table_libcall_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPtrFieldNumber = 1,
    kSizeFieldNumber = 2,
    kRetFieldNumber = 3,
  };
  // required uint64 ptr = 1;
  bool has_ptr() const;
  void clear_ptr();
  ::PROTOBUF_NAMESPACE_ID::uint64 ptr() const;
  void set_ptr(::PROTOBUF_NAMESPACE_ID::uint64 value);

  // required uint64 size = 2;
  bool has_size() const;
  void clear_size();
  ::PROTOBUF_NAMESPACE_ID::uint64 size() const;
  void set_size(::PROTOBUF_NAMESPACE_ID::uint64 value);

  // required uint64 ret = 3;
  bool has_ret() const;
  void clear_ret();
  ::PROTOBUF_NAMESPACE_ID::uint64 ret() const;
  void set_ret(::PROTOBUF_NAMESPACE_ID::uint64 value);

  // @@protoc_insertion_point(class_scope:libcall_types.realloc_t)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint64 ptr_;
  ::PROTOBUF_NAMESPACE_ID::uint64 size_;
  ::PROTOBUF_NAMESPACE_ID::uint64 ret_;
  friend struct ::TableStruct_libcall_2eproto;
};
// -------------------------------------------------------------------

class mmap_t :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:libcall_types.mmap_t) */ {
 public:
  mmap_t();
  virtual ~mmap_t();

  mmap_t(const mmap_t& from);
  mmap_t(mmap_t&& from) noexcept
    : mmap_t() {
    *this = ::std::move(from);
  }

  inline mmap_t& operator=(const mmap_t& from) {
    CopyFrom(from);
    return *this;
  }
  inline mmap_t& operator=(mmap_t&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const mmap_t& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const mmap_t* internal_default_instance() {
    return reinterpret_cast<const mmap_t*>(
               &_mmap_t_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    45;

  friend void swap(mmap_t& a, mmap_t& b) {
    a.Swap(&b);
  }
  inline void Swap(mmap_t* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline mmap_t* New() const final {
    return CreateMaybeMessage<mmap_t>(nullptr);
  }

  mmap_t* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<mmap_t>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const mmap_t& from);
  void MergeFrom(const mmap_t& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(mmap_t* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "libcall_types.mmap_t";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_libcall_2eproto);
    return ::descriptor_table_libcall_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRetFieldNumber = 7,
    kAddrFieldNumber = 1,
    kLengthFieldNumber = 2,
    kProtFieldNumber = 3,
    kFlagsFieldNumber = 4,
    kFdFieldNumber = 5,
    kOffsetFieldNumber = 6,
  };
  // required .common.memory_t ret = 7;
  bool has_ret() const;
  void clear_ret();
  const ::common::memory_t& ret() const;
  ::common::memory_t* release_ret();
  ::common::memory_t* mutable_ret();
  void set_allocated_ret(::common::memory_t* ret);

  // required uint64 addr = 1;
  bool has_addr() const;
  void clear_addr();
  ::PROTOBUF_NAMESPACE_ID::uint64 addr() const;
  void set_addr(::PROTOBUF_NAMESPACE_ID::uint64 value);

  // required uint64 length = 2;
  bool has_length() const;
  void clear_length();
  ::PROTOBUF_NAMESPACE_ID::uint64 length() const;
  void set_length(::PROTOBUF_NAMESPACE_ID::uint64 value);

  // required uint64 prot = 3;
  bool has_prot() const;
  void clear_prot();
  ::PROTOBUF_NAMESPACE_ID::uint64 prot() const;
  void set_prot(::PROTOBUF_NAMESPACE_ID::uint64 value);

  // required uint64 flags = 4;
  bool has_flags() const;
  void clear_flags();
  ::PROTOBUF_NAMESPACE_ID::uint64 flags() const;
  void set_flags(::PROTOBUF_NAMESPACE_ID::uint64 value);

  // required uint64 fd = 5;
  bool has_fd() const;
  void clear_fd();
  ::PROTOBUF_NAMESPACE_ID::uint64 fd() const;
  void set_fd(::PROTOBUF_NAMESPACE_ID::uint64 value);

  // required uint64 offset = 6;
  bool has_offset() const;
  void clear_offset();
  ::PROTOBUF_NAMESPACE_ID::uint64 offset() const;
  void set_offset(::PROTOBUF_NAMESPACE_ID::uint64 value);

  // @@protoc_insertion_point(class_scope:libcall_types.mmap_t)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::common::memory_t* ret_;
  ::PROTOBUF_NAMESPACE_ID::uint64 addr_;
  ::PROTOBUF_NAMESPACE_ID::uint64 length_;
  ::PROTOBUF_NAMESPACE_ID::uint64 prot_;
  ::PROTOBUF_NAMESPACE_ID::uint64 flags_;
  ::PROTOBUF_NAMESPACE_ID::uint64 fd_;
  ::PROTOBUF_NAMESPACE_ID::uint64 offset_;
  friend struct ::TableStruct_libcall_2eproto;
};
// -------------------------------------------------------------------

class qsort_t :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:libcall_types.qsort_t) */ {
 public:
  qsort_t();
  virtual ~qsort_t();

  qsort_t(const qsort_t& from);
  qsort_t(qsort_t&& from) noexcept
    : qsort_t() {
    *this = ::std::move(from);
  }

  inline qsort_t& operator=(const qsort_t& from) {
    CopyFrom(from);
    return *this;
  }
  inline qsort_t& operator=(qsort_t&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const qsort_t& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const qsort_t* internal_default_instance() {
    return reinterpret_cast<const qsort_t*>(
               &_qsort_t_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    46;

  friend void swap(qsort_t& a, qsort_t& b) {
    a.Swap(&b);
  }
  inline void Swap(qsort_t* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline qsort_t* New() const final {
    return CreateMaybeMessage<qsort_t>(nullptr);
  }

  qsort_t* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<qsort_t>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const qsort_t& from);
  void MergeFrom(const qsort_t& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(qsort_t* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "libcall_types.qsort_t";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_libcall_2eproto);
    return ::descriptor_table_libcall_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBaseFieldNumber = 1,
    kNmembFieldNumber = 2,
    kSizeFieldNumber = 3,
    kCompareFieldNumber = 4,
  };
  // required .common.memory_t base = 1;
  bool has_base() const;
  void clear_base();
  const ::common::memory_t& base() const;
  ::common::memory_t* release_base();
  ::common::memory_t* mutable_base();
  void set_allocated_base(::common::memory_t* base);

  // required uint64 nmemb = 2;
  bool has_nmemb() const;
  void clear_nmemb();
  ::PROTOBUF_NAMESPACE_ID::uint64 nmemb() const;
  void set_nmemb(::PROTOBUF_NAMESPACE_ID::uint64 value);

  // required uint64 size = 3;
  bool has_size() const;
  void clear_size();
  ::PROTOBUF_NAMESPACE_ID::uint64 size() const;
  void set_size(::PROTOBUF_NAMESPACE_ID::uint64 value);

  // required uint64 compare = 4;
  bool has_compare() const;
  void clear_compare();
  ::PROTOBUF_NAMESPACE_ID::uint64 compare() const;
  void set_compare(::PROTOBUF_NAMESPACE_ID::uint64 value);

  // @@protoc_insertion_point(class_scope:libcall_types.qsort_t)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::common::memory_t* base_;
  ::PROTOBUF_NAMESPACE_ID::uint64 nmemb_;
  ::PROTOBUF_NAMESPACE_ID::uint64 size_;
  ::PROTOBUF_NAMESPACE_ID::uint64 compare_;
  friend struct ::TableStruct_libcall_2eproto;
};
// -------------------------------------------------------------------

class bsearch_t :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:libcall_types.bsearch_t) */ {
 public:
  bsearch_t();
  virtual ~bsearch_t();

  bsearch_t(const bsearch_t& from);
  bsearch_t(bsearch_t&& from) noexcept
    : bsearch_t() {
    *this = ::std::move(from);
  }

  inline bsearch_t& operator=(const bsearch_t& from) {
    CopyFrom(from);
    return *this;
  }
  inline bsearch_t& operator=(bsearch_t&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const bsearch_t& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const bsearch_t* internal_default_instance() {
    return reinterpret_cast<const bsearch_t*>(
               &_bsearch_t_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    47;

  friend void swap(bsearch_t& a, bsearch_t& b) {
    a.Swap(&b);
  }
  inline void Swap(bsearch_t* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline bsearch_t* New() const final {
    return CreateMaybeMessage<bsearch_t>(nullptr);
  }

  bsearch_t* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<bsearch_t>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const bsearch_t& from);
  void MergeFrom(const bsearch_t& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(bsearch_t* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "libcall_types.bsearch_t";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_libcall_2eproto);
    return ::descriptor_table_libcall_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kKeyFieldNumber = 1,
    kBaseFieldNumber = 2,
    kRetFieldNumber = 6,
    kNmembFieldNumber = 3,
    kSizeFieldNumber = 4,
    kCompareFieldNumber = 5,
  };
  // required .common.memory_t key = 1;
  bool has_key() const;
  void clear_key();
  const ::common::memory_t& key() const;
  ::common::memory_t* release_key();
  ::common::memory_t* mutable_key();
  void set_allocated_key(::common::memory_t* key);

  // required .common.memory_t base = 2;
  bool has_base() const;
  void clear_base();
  const ::common::memory_t& base() const;
  ::common::memory_t* release_base();
  ::common::memory_t* mutable_base();
  void set_allocated_base(::common::memory_t* base);

  // required .common.memory_t ret = 6;
  bool has_ret() const;
  void clear_ret();
  const ::common::memory_t& ret() const;
  ::common::memory_t* release_ret();
  ::common::memory_t* mutable_ret();
  void set_allocated_ret(::common::memory_t* ret);

  // required uint64 nmemb = 3;
  bool has_nmemb() const;
  void clear_nmemb();
  ::PROTOBUF_NAMESPACE_ID::uint64 nmemb() const;
  void set_nmemb(::PROTOBUF_NAMESPACE_ID::uint64 value);

  // required uint64 size = 4;
  bool has_size() const;
  void clear_size();
  ::PROTOBUF_NAMESPACE_ID::uint64 size() const;
  void set_size(::PROTOBUF_NAMESPACE_ID::uint64 value);

  // required uint64 compare = 5;
  bool has_compare() const;
  void clear_compare();
  ::PROTOBUF_NAMESPACE_ID::uint64 compare() const;
  void set_compare(::PROTOBUF_NAMESPACE_ID::uint64 value);

  // @@protoc_insertion_point(class_scope:libcall_types.bsearch_t)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::common::memory_t* key_;
  ::common::memory_t* base_;
  ::common::memory_t* ret_;
  ::PROTOBUF_NAMESPACE_ID::uint64 nmemb_;
  ::PROTOBUF_NAMESPACE_ID::uint64 size_;
  ::PROTOBUF_NAMESPACE_ID::uint64 compare_;
  friend struct ::TableStruct_libcall_2eproto;
};
// -------------------------------------------------------------------

class open_t :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:libcall_types.open_t) */ {
 public:
  open_t();
  virtual ~open_t();

  open_t(const open_t& from);
  open_t(open_t&& from) noexcept
    : open_t() {
    *this = ::std::move(from);
  }

  inline open_t& operator=(const open_t& from) {
    CopyFrom(from);
    return *this;
  }
  inline open_t& operator=(open_t&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const open_t& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const open_t* internal_default_instance() {
    return reinterpret_cast<const open_t*>(
               &_open_t_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    48;

  friend void swap(open_t& a, open_t& b) {
    a.Swap(&b);
  }
  inline void Swap(open_t* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline open_t* New() const final {
    return CreateMaybeMessage<open_t>(nullptr);
  }

  open_t* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<open_t>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const open_t& from);
  void MergeFrom(const open_t& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(open_t* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "libcall_types.open_t";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_libcall_2eproto);
    return ::descriptor_table_libcall_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPathnameFieldNumber = 1,
    kFlagsFieldNumber = 3,
    kModeFieldNumber = 4,
    kRetFieldNumber = 5,
  };
  // required .common.memory_t pathname = 1;
  bool has_pathname() const;
  void clear_pathname();
  const ::common::memory_t& pathname() const;
  ::common::memory_t* release_pathname();
  ::common::memory_t* mutable_pathname();
  void set_allocated_pathname(::common::memory_t* pathname);

  // required uint64 flags = 3;
  bool has_flags() const;
  void clear_flags();
  ::PROTOBUF_NAMESPACE_ID::uint64 flags() const;
  void set_flags(::PROTOBUF_NAMESPACE_ID::uint64 value);

  // required uint64 mode = 4;
  bool has_mode() const;
  void clear_mode();
  ::PROTOBUF_NAMESPACE_ID::uint64 mode() const;
  void set_mode(::PROTOBUF_NAMESPACE_ID::uint64 value);

  // required uint64 ret = 5;
  bool has_ret() const;
  void clear_ret();
  ::PROTOBUF_NAMESPACE_ID::uint64 ret() const;
  void set_ret(::PROTOBUF_NAMESPACE_ID::uint64 value);

  // @@protoc_insertion_point(class_scope:libcall_types.open_t)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::common::memory_t* pathname_;
  ::PROTOBUF_NAMESPACE_ID::uint64 flags_;
  ::PROTOBUF_NAMESPACE_ID::uint64 mode_;
  ::PROTOBUF_NAMESPACE_ID::uint64 ret_;
  friend struct ::TableStruct_libcall_2eproto;
};
// -------------------------------------------------------------------

class strcpy_t :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:libcall_types.strcpy_t) */ {
 public:
  strcpy_t();
  virtual ~strcpy_t();

  strcpy_t(const strcpy_t& from);
  strcpy_t(strcpy_t&& from) noexcept
    : strcpy_t() {
    *this = ::std::move(from);
  }

  inline strcpy_t& operator=(const strcpy_t& from) {
    CopyFrom(from);
    return *this;
  }
  inline strcpy_t& operator=(strcpy_t&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const strcpy_t& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const strcpy_t* internal_default_instance() {
    return reinterpret_cast<const strcpy_t*>(
               &_strcpy_t_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    49;

  friend void swap(strcpy_t& a, strcpy_t& b) {
    a.Swap(&b);
  }
  inline void Swap(strcpy_t* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline strcpy_t* New() const final {
    return CreateMaybeMessage<strcpy_t>(nullptr);
  }

  strcpy_t* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<strcpy_t>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const strcpy_t& from);
  void MergeFrom(const strcpy_t& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(strcpy_t* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "libcall_types.strcpy_t";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_libcall_2eproto);
    return ::descriptor_table_libcall_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSrcFieldNumber = 1,
    kDstFieldNumber = 2,
    kRetFieldNumber = 3,
  };
  // required .common.memory_t src = 1;
  bool has_src() const;
  void clear_src();
  const ::common::memory_t& src() const;
  ::common::memory_t* release_src();
  ::common::memory_t* mutable_src();
  void set_allocated_src(::common::memory_t* src);

  // required .common.memory_t dst = 2;
  bool has_dst() const;
  void clear_dst();
  const ::common::memory_t& dst() const;
  ::common::memory_t* release_dst();
  ::common::memory_t* mutable_dst();
  void set_allocated_dst(::common::memory_t* dst);

  // required uint64 ret = 3;
  bool has_ret() const;
  void clear_ret();
  ::PROTOBUF_NAMESPACE_ID::uint64 ret() const;
  void set_ret(::PROTOBUF_NAMESPACE_ID::uint64 value);

  // @@protoc_insertion_point(class_scope:libcall_types.strcpy_t)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::common::memory_t* src_;
  ::common::memory_t* dst_;
  ::PROTOBUF_NAMESPACE_ID::uint64 ret_;
  friend struct ::TableStruct_libcall_2eproto;
};
// -------------------------------------------------------------------

class strcmp_t :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:libcall_types.strcmp_t) */ {
 public:
  strcmp_t();
  virtual ~strcmp_t();

  strcmp_t(const strcmp_t& from);
  strcmp_t(strcmp_t&& from) noexcept
    : strcmp_t() {
    *this = ::std::move(from);
  }

  inline strcmp_t& operator=(const strcmp_t& from) {
    CopyFrom(from);
    return *this;
  }
  inline strcmp_t& operator=(strcmp_t&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const strcmp_t& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const strcmp_t* internal_default_instance() {
    return reinterpret_cast<const strcmp_t*>(
               &_strcmp_t_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    50;

  friend void swap(strcmp_t& a, strcmp_t& b) {
    a.Swap(&b);
  }
  inline void Swap(strcmp_t* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline strcmp_t* New() const final {
    return CreateMaybeMessage<strcmp_t>(nullptr);
  }

  strcmp_t* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<strcmp_t>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const strcmp_t& from);
  void MergeFrom(const strcmp_t& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(strcmp_t* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "libcall_types.strcmp_t";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_libcall_2eproto);
    return ::descriptor_table_libcall_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kS1FieldNumber = 1,
    kS2FieldNumber = 2,
    kSizeMaxS1FieldNumber = 3,
    kSizeMaxS2FieldNumber = 4,
    kRetFieldNumber = 5,
  };
  // required uint64 s1 = 1;
  bool has_s1() const;
  void clear_s1();
  ::PROTOBUF_NAMESPACE_ID::uint64 s1() const;
  void set_s1(::PROTOBUF_NAMESPACE_ID::uint64 value);

  // required uint64 s2 = 2;
  bool has_s2() const;
  void clear_s2();
  ::PROTOBUF_NAMESPACE_ID::uint64 s2() const;
  void set_s2(::PROTOBUF_NAMESPACE_ID::uint64 value);

  // required uint64 size_max_s1 = 3;
  bool has_size_max_s1() const;
  void clear_size_max_s1();
  ::PROTOBUF_NAMESPACE_ID::uint64 size_max_s1() const;
  void set_size_max_s1(::PROTOBUF_NAMESPACE_ID::uint64 value);

  // required uint64 size_max_s2 = 4;
  bool has_size_max_s2() const;
  void clear_size_max_s2();
  ::PROTOBUF_NAMESPACE_ID::uint64 size_max_s2() const;
  void set_size_max_s2(::PROTOBUF_NAMESPACE_ID::uint64 value);

  // required uint64 ret = 5;
  bool has_ret() const;
  void clear_ret();
  ::PROTOBUF_NAMESPACE_ID::uint64 ret() const;
  void set_ret(::PROTOBUF_NAMESPACE_ID::uint64 value);

  // @@protoc_insertion_point(class_scope:libcall_types.strcmp_t)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint64 s1_;
  ::PROTOBUF_NAMESPACE_ID::uint64 s2_;
  ::PROTOBUF_NAMESPACE_ID::uint64 size_max_s1_;
  ::PROTOBUF_NAMESPACE_ID::uint64 size_max_s2_;
  ::PROTOBUF_NAMESPACE_ID::uint64 ret_;
  friend struct ::TableStruct_libcall_2eproto;
};
// -------------------------------------------------------------------

class strncmp_t :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:libcall_types.strncmp_t) */ {
 public:
  strncmp_t();
  virtual ~strncmp_t();

  strncmp_t(const strncmp_t& from);
  strncmp_t(strncmp_t&& from) noexcept
    : strncmp_t() {
    *this = ::std::move(from);
  }

  inline strncmp_t& operator=(const strncmp_t& from) {
    CopyFrom(from);
    return *this;
  }
  inline strncmp_t& operator=(strncmp_t&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const strncmp_t& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const strncmp_t* internal_default_instance() {
    return reinterpret_cast<const strncmp_t*>(
               &_strncmp_t_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    51;

  friend void swap(strncmp_t& a, strncmp_t& b) {
    a.Swap(&b);
  }
  inline void Swap(strncmp_t* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline strncmp_t* New() const final {
    return CreateMaybeMessage<strncmp_t>(nullptr);
  }

  strncmp_t* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<strncmp_t>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const strncmp_t& from);
  void MergeFrom(const strncmp_t& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(strncmp_t* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "libcall_types.strncmp_t";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_libcall_2eproto);
    return ::descriptor_table_libcall_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kS1FieldNumber = 1,
    kS2FieldNumber = 2,
    kNFieldNumber = 3,
    kRetFieldNumber = 4,
  };
  // required uint64 s1 = 1;
  bool has_s1() const;
  void clear_s1();
  ::PROTOBUF_NAMESPACE_ID::uint64 s1() const;
  void set_s1(::PROTOBUF_NAMESPACE_ID::uint64 value);

  // required uint64 s2 = 2;
  bool has_s2() const;
  void clear_s2();
  ::PROTOBUF_NAMESPACE_ID::uint64 s2() const;
  void set_s2(::PROTOBUF_NAMESPACE_ID::uint64 value);

  // required uint64 n = 3;
  bool has_n() const;
  void clear_n();
  ::PROTOBUF_NAMESPACE_ID::uint64 n() const;
  void set_n(::PROTOBUF_NAMESPACE_ID::uint64 value);

  // required uint64 ret = 4;
  bool has_ret() const;
  void clear_ret();
  ::PROTOBUF_NAMESPACE_ID::uint64 ret() const;
  void set_ret(::PROTOBUF_NAMESPACE_ID::uint64 value);

  // @@protoc_insertion_point(class_scope:libcall_types.strncmp_t)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint64 s1_;
  ::PROTOBUF_NAMESPACE_ID::uint64 s2_;
  ::PROTOBUF_NAMESPACE_ID::uint64 n_;
  ::PROTOBUF_NAMESPACE_ID::uint64 ret_;
  friend struct ::TableStruct_libcall_2eproto;
};
// -------------------------------------------------------------------

class memcmp_t :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:libcall_types.memcmp_t) */ {
 public:
  memcmp_t();
  virtual ~memcmp_t();

  memcmp_t(const memcmp_t& from);
  memcmp_t(memcmp_t&& from) noexcept
    : memcmp_t() {
    *this = ::std::move(from);
  }

  inline memcmp_t& operator=(const memcmp_t& from) {
    CopyFrom(from);
    return *this;
  }
  inline memcmp_t& operator=(memcmp_t&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const memcmp_t& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const memcmp_t* internal_default_instance() {
    return reinterpret_cast<const memcmp_t*>(
               &_memcmp_t_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    52;

  friend void swap(memcmp_t& a, memcmp_t& b) {
    a.Swap(&b);
  }
  inline void Swap(memcmp_t* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline memcmp_t* New() const final {
    return CreateMaybeMessage<memcmp_t>(nullptr);
  }

  memcmp_t* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<memcmp_t>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const memcmp_t& from);
  void MergeFrom(const memcmp_t& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(memcmp_t* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "libcall_types.memcmp_t";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_libcall_2eproto);
    return ::descriptor_table_libcall_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kS1FieldNumber = 1,
    kS2FieldNumber = 2,
    kNFieldNumber = 3,
    kRetFieldNumber = 4,
  };
  // required uint64 s1 = 1;
  bool has_s1() const;
  void clear_s1();
  ::PROTOBUF_NAMESPACE_ID::uint64 s1() const;
  void set_s1(::PROTOBUF_NAMESPACE_ID::uint64 value);

  // required uint64 s2 = 2;
  bool has_s2() const;
  void clear_s2();
  ::PROTOBUF_NAMESPACE_ID::uint64 s2() const;
  void set_s2(::PROTOBUF_NAMESPACE_ID::uint64 value);

  // required uint64 n = 3;
  bool has_n() const;
  void clear_n();
  ::PROTOBUF_NAMESPACE_ID::uint64 n() const;
  void set_n(::PROTOBUF_NAMESPACE_ID::uint64 value);

  // required uint64 ret = 4;
  bool has_ret() const;
  void clear_ret();
  ::PROTOBUF_NAMESPACE_ID::uint64 ret() const;
  void set_ret(::PROTOBUF_NAMESPACE_ID::uint64 value);

  // @@protoc_insertion_point(class_scope:libcall_types.memcmp_t)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint64 s1_;
  ::PROTOBUF_NAMESPACE_ID::uint64 s2_;
  ::PROTOBUF_NAMESPACE_ID::uint64 n_;
  ::PROTOBUF_NAMESPACE_ID::uint64 ret_;
  friend struct ::TableStruct_libcall_2eproto;
};
// -------------------------------------------------------------------

class printf_t :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:libcall_types.printf_t) */ {
 public:
  printf_t();
  virtual ~printf_t();

  printf_t(const printf_t& from);
  printf_t(printf_t&& from) noexcept
    : printf_t() {
    *this = ::std::move(from);
  }

  inline printf_t& operator=(const printf_t& from) {
    CopyFrom(from);
    return *this;
  }
  inline printf_t& operator=(printf_t&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const printf_t& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const printf_t* internal_default_instance() {
    return reinterpret_cast<const printf_t*>(
               &_printf_t_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    53;

  friend void swap(printf_t& a, printf_t& b) {
    a.Swap(&b);
  }
  inline void Swap(printf_t* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline printf_t* New() const final {
    return CreateMaybeMessage<printf_t>(nullptr);
  }

  printf_t* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<printf_t>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const printf_t& from);
  void MergeFrom(const printf_t& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(printf_t* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "libcall_types.printf_t";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_libcall_2eproto);
    return ::descriptor_table_libcall_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFormatFieldNumber = 1,
    kRetFieldNumber = 2,
  };
  // required .common.memory_t format = 1;
  bool has_format() const;
  void clear_format();
  const ::common::memory_t& format() const;
  ::common::memory_t* release_format();
  ::common::memory_t* mutable_format();
  void set_allocated_format(::common::memory_t* format);

  // required uint64 ret = 2;
  bool has_ret() const;
  void clear_ret();
  ::PROTOBUF_NAMESPACE_ID::uint64 ret() const;
  void set_ret(::PROTOBUF_NAMESPACE_ID::uint64 value);

  // @@protoc_insertion_point(class_scope:libcall_types.printf_t)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::common::memory_t* format_;
  ::PROTOBUF_NAMESPACE_ID::uint64 ret_;
  friend struct ::TableStruct_libcall_2eproto;
};
// -------------------------------------------------------------------

class atoi_t :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:libcall_types.atoi_t) */ {
 public:
  atoi_t();
  virtual ~atoi_t();

  atoi_t(const atoi_t& from);
  atoi_t(atoi_t&& from) noexcept
    : atoi_t() {
    *this = ::std::move(from);
  }

  inline atoi_t& operator=(const atoi_t& from) {
    CopyFrom(from);
    return *this;
  }
  inline atoi_t& operator=(atoi_t&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const atoi_t& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const atoi_t* internal_default_instance() {
    return reinterpret_cast<const atoi_t*>(
               &_atoi_t_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    54;

  friend void swap(atoi_t& a, atoi_t& b) {
    a.Swap(&b);
  }
  inline void Swap(atoi_t* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline atoi_t* New() const final {
    return CreateMaybeMessage<atoi_t>(nullptr);
  }

  atoi_t* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<atoi_t>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const atoi_t& from);
  void MergeFrom(const atoi_t& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(atoi_t* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "libcall_types.atoi_t";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_libcall_2eproto);
    return ::descriptor_table_libcall_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSrcFieldNumber = 1,
    kRetFieldNumber = 3,
  };
  // required .common.memory_t src = 1;
  bool has_src() const;
  void clear_src();
  const ::common::memory_t& src() const;
  ::common::memory_t* release_src();
  ::common::memory_t* mutable_src();
  void set_allocated_src(::common::memory_t* src);

  // required uint64 ret = 3;
  bool has_ret() const;
  void clear_ret();
  ::PROTOBUF_NAMESPACE_ID::uint64 ret() const;
  void set_ret(::PROTOBUF_NAMESPACE_ID::uint64 value);

  // @@protoc_insertion_point(class_scope:libcall_types.atoi_t)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::common::memory_t* src_;
  ::PROTOBUF_NAMESPACE_ID::uint64 ret_;
  friend struct ::TableStruct_libcall_2eproto;
};
// -------------------------------------------------------------------

class malloc_t :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:libcall_types.malloc_t) */ {
 public:
  malloc_t();
  virtual ~malloc_t();

  malloc_t(const malloc_t& from);
  malloc_t(malloc_t&& from) noexcept
    : malloc_t() {
    *this = ::std::move(from);
  }

  inline malloc_t& operator=(const malloc_t& from) {
    CopyFrom(from);
    return *this;
  }
  inline malloc_t& operator=(malloc_t&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const malloc_t& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const malloc_t* internal_default_instance() {
    return reinterpret_cast<const malloc_t*>(
               &_malloc_t_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    55;

  friend void swap(malloc_t& a, malloc_t& b) {
    a.Swap(&b);
  }
  inline void Swap(malloc_t* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline malloc_t* New() const final {
    return CreateMaybeMessage<malloc_t>(nullptr);
  }

  malloc_t* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<malloc_t>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const malloc_t& from);
  void MergeFrom(const malloc_t& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(malloc_t* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "libcall_types.malloc_t";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_libcall_2eproto);
    return ::descriptor_table_libcall_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSizeFieldNumber = 1,
    kRetFieldNumber = 2,
  };
  // required uint64 size = 1;
  bool has_size() const;
  void clear_size();
  ::PROTOBUF_NAMESPACE_ID::uint64 size() const;
  void set_size(::PROTOBUF_NAMESPACE_ID::uint64 value);

  // required uint64 ret = 2;
  bool has_ret() const;
  void clear_ret();
  ::PROTOBUF_NAMESPACE_ID::uint64 ret() const;
  void set_ret(::PROTOBUF_NAMESPACE_ID::uint64 value);

  // @@protoc_insertion_point(class_scope:libcall_types.malloc_t)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint64 size_;
  ::PROTOBUF_NAMESPACE_ID::uint64 ret_;
  friend struct ::TableStruct_libcall_2eproto;
};
// -------------------------------------------------------------------

class getmodulehandle_t :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:libcall_types.getmodulehandle_t) */ {
 public:
  getmodulehandle_t();
  virtual ~getmodulehandle_t();

  getmodulehandle_t(const getmodulehandle_t& from);
  getmodulehandle_t(getmodulehandle_t&& from) noexcept
    : getmodulehandle_t() {
    *this = ::std::move(from);
  }

  inline getmodulehandle_t& operator=(const getmodulehandle_t& from) {
    CopyFrom(from);
    return *this;
  }
  inline getmodulehandle_t& operator=(getmodulehandle_t&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const getmodulehandle_t& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const getmodulehandle_t* internal_default_instance() {
    return reinterpret_cast<const getmodulehandle_t*>(
               &_getmodulehandle_t_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    56;

  friend void swap(getmodulehandle_t& a, getmodulehandle_t& b) {
    a.Swap(&b);
  }
  inline void Swap(getmodulehandle_t* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline getmodulehandle_t* New() const final {
    return CreateMaybeMessage<getmodulehandle_t>(nullptr);
  }

  getmodulehandle_t* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<getmodulehandle_t>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const getmodulehandle_t& from);
  void MergeFrom(const getmodulehandle_t& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(getmodulehandle_t* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "libcall_types.getmodulehandle_t";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_libcall_2eproto);
    return ::descriptor_table_libcall_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kModuleNameFieldNumber = 1,
    kRetFieldNumber = 2,
  };
  // required .common.memory_t module_name = 1;
  bool has_module_name() const;
  void clear_module_name();
  const ::common::memory_t& module_name() const;
  ::common::memory_t* release_module_name();
  ::common::memory_t* mutable_module_name();
  void set_allocated_module_name(::common::memory_t* module_name);

  // required uint64 ret = 2;
  bool has_ret() const;
  void clear_ret();
  ::PROTOBUF_NAMESPACE_ID::uint64 ret() const;
  void set_ret(::PROTOBUF_NAMESPACE_ID::uint64 value);

  // @@protoc_insertion_point(class_scope:libcall_types.getmodulehandle_t)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::common::memory_t* module_name_;
  ::PROTOBUF_NAMESPACE_ID::uint64 ret_;
  friend struct ::TableStruct_libcall_2eproto;
};
// -------------------------------------------------------------------

class getprocaddress_t :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:libcall_types.getprocaddress_t) */ {
 public:
  getprocaddress_t();
  virtual ~getprocaddress_t();

  getprocaddress_t(const getprocaddress_t& from);
  getprocaddress_t(getprocaddress_t&& from) noexcept
    : getprocaddress_t() {
    *this = ::std::move(from);
  }

  inline getprocaddress_t& operator=(const getprocaddress_t& from) {
    CopyFrom(from);
    return *this;
  }
  inline getprocaddress_t& operator=(getprocaddress_t&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const getprocaddress_t& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const getprocaddress_t* internal_default_instance() {
    return reinterpret_cast<const getprocaddress_t*>(
               &_getprocaddress_t_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    57;

  friend void swap(getprocaddress_t& a, getprocaddress_t& b) {
    a.Swap(&b);
  }
  inline void Swap(getprocaddress_t* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline getprocaddress_t* New() const final {
    return CreateMaybeMessage<getprocaddress_t>(nullptr);
  }

  getprocaddress_t* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<getprocaddress_t>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const getprocaddress_t& from);
  void MergeFrom(const getprocaddress_t& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(getprocaddress_t* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "libcall_types.getprocaddress_t";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_libcall_2eproto);
    return ::descriptor_table_libcall_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kProcNameFieldNumber = 2,
    kHmoduleFieldNumber = 1,
    kRetFieldNumber = 3,
  };
  // required .common.memory_t proc_name = 2;
  bool has_proc_name() const;
  void clear_proc_name();
  const ::common::memory_t& proc_name() const;
  ::common::memory_t* release_proc_name();
  ::common::memory_t* mutable_proc_name();
  void set_allocated_proc_name(::common::memory_t* proc_name);

  // required uint64 hmodule = 1;
  bool has_hmodule() const;
  void clear_hmodule();
  ::PROTOBUF_NAMESPACE_ID::uint64 hmodule() const;
  void set_hmodule(::PROTOBUF_NAMESPACE_ID::uint64 value);

  // required uint64 ret = 3;
  bool has_ret() const;
  void clear_ret();
  ::PROTOBUF_NAMESPACE_ID::uint64 ret() const;
  void set_ret(::PROTOBUF_NAMESPACE_ID::uint64 value);

  // @@protoc_insertion_point(class_scope:libcall_types.getprocaddress_t)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::common::memory_t* proc_name_;
  ::PROTOBUF_NAMESPACE_ID::uint64 hmodule_;
  ::PROTOBUF_NAMESPACE_ID::uint64 ret_;
  friend struct ::TableStruct_libcall_2eproto;
};
// -------------------------------------------------------------------

class getmainargs_t :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:libcall_types.getmainargs_t) */ {
 public:
  getmainargs_t();
  virtual ~getmainargs_t();

  getmainargs_t(const getmainargs_t& from);
  getmainargs_t(getmainargs_t&& from) noexcept
    : getmainargs_t() {
    *this = ::std::move(from);
  }

  inline getmainargs_t& operator=(const getmainargs_t& from) {
    CopyFrom(from);
    return *this;
  }
  inline getmainargs_t& operator=(getmainargs_t&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const getmainargs_t& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const getmainargs_t* internal_default_instance() {
    return reinterpret_cast<const getmainargs_t*>(
               &_getmainargs_t_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    58;

  friend void swap(getmainargs_t& a, getmainargs_t& b) {
    a.Swap(&b);
  }
  inline void Swap(getmainargs_t* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline getmainargs_t* New() const final {
    return CreateMaybeMessage<getmainargs_t>(nullptr);
  }

  getmainargs_t* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<getmainargs_t>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const getmainargs_t& from);
  void MergeFrom(const getmainargs_t& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(getmainargs_t* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "libcall_types.getmainargs_t";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_libcall_2eproto);
    return ::descriptor_table_libcall_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kArgcFieldNumber = 1,
    kArgvFieldNumber = 2,
    kEnvFieldNumber = 3,
    kStartinfoFieldNumber = 5,
    kDowildcardFieldNumber = 4,
    kRetFieldNumber = 6,
  };
  // required .common.memory_t argc = 1;
  bool has_argc() const;
  void clear_argc();
  const ::common::memory_t& argc() const;
  ::common::memory_t* release_argc();
  ::common::memory_t* mutable_argc();
  void set_allocated_argc(::common::memory_t* argc);

  // required .common.memory_t argv = 2;
  bool has_argv() const;
  void clear_argv();
  const ::common::memory_t& argv() const;
  ::common::memory_t* release_argv();
  ::common::memory_t* mutable_argv();
  void set_allocated_argv(::common::memory_t* argv);

  // required .common.memory_t env = 3;
  bool has_env() const;
  void clear_env();
  const ::common::memory_t& env() const;
  ::common::memory_t* release_env();
  ::common::memory_t* mutable_env();
  void set_allocated_env(::common::memory_t* env);

  // required .common.memory_t startinfo = 5;
  bool has_startinfo() const;
  void clear_startinfo();
  const ::common::memory_t& startinfo() const;
  ::common::memory_t* release_startinfo();
  ::common::memory_t* mutable_startinfo();
  void set_allocated_startinfo(::common::memory_t* startinfo);

  // required uint64 dowildcard = 4;
  bool has_dowildcard() const;
  void clear_dowildcard();
  ::PROTOBUF_NAMESPACE_ID::uint64 dowildcard() const;
  void set_dowildcard(::PROTOBUF_NAMESPACE_ID::uint64 value);

  // required uint64 ret = 6;
  bool has_ret() const;
  void clear_ret();
  ::PROTOBUF_NAMESPACE_ID::uint64 ret() const;
  void set_ret(::PROTOBUF_NAMESPACE_ID::uint64 value);

  // @@protoc_insertion_point(class_scope:libcall_types.getmainargs_t)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::common::memory_t* argc_;
  ::common::memory_t* argv_;
  ::common::memory_t* env_;
  ::common::memory_t* startinfo_;
  ::PROTOBUF_NAMESPACE_ID::uint64 dowildcard_;
  ::PROTOBUF_NAMESPACE_ID::uint64 ret_;
  friend struct ::TableStruct_libcall_2eproto;
};
// -------------------------------------------------------------------

class gethostname_t :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:libcall_types.gethostname_t) */ {
 public:
  gethostname_t();
  virtual ~gethostname_t();

  gethostname_t(const gethostname_t& from);
  gethostname_t(gethostname_t&& from) noexcept
    : gethostname_t() {
    *this = ::std::move(from);
  }

  inline gethostname_t& operator=(const gethostname_t& from) {
    CopyFrom(from);
    return *this;
  }
  inline gethostname_t& operator=(gethostname_t&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const gethostname_t& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const gethostname_t* internal_default_instance() {
    return reinterpret_cast<const gethostname_t*>(
               &_gethostname_t_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    59;

  friend void swap(gethostname_t& a, gethostname_t& b) {
    a.Swap(&b);
  }
  inline void Swap(gethostname_t* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline gethostname_t* New() const final {
    return CreateMaybeMessage<gethostname_t>(nullptr);
  }

  gethostname_t* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<gethostname_t>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const gethostname_t& from);
  void MergeFrom(const gethostname_t& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(gethostname_t* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "libcall_types.gethostname_t";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_libcall_2eproto);
    return ::descriptor_table_libcall_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kNamelenFieldNumber = 2,
    kRetFieldNumber = 3,
  };
  // required .common.memory_t name = 1;
  bool has_name() const;
  void clear_name();
  const ::common::memory_t& name() const;
  ::common::memory_t* release_name();
  ::common::memory_t* mutable_name();
  void set_allocated_name(::common::memory_t* name);

  // required uint64 namelen = 2;
  bool has_namelen() const;
  void clear_namelen();
  ::PROTOBUF_NAMESPACE_ID::uint64 namelen() const;
  void set_namelen(::PROTOBUF_NAMESPACE_ID::uint64 value);

  // required uint64 ret = 3;
  bool has_ret() const;
  void clear_ret();
  ::PROTOBUF_NAMESPACE_ID::uint64 ret() const;
  void set_ret(::PROTOBUF_NAMESPACE_ID::uint64 value);

  // @@protoc_insertion_point(class_scope:libcall_types.gethostname_t)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::common::memory_t* name_;
  ::PROTOBUF_NAMESPACE_ID::uint64 namelen_;
  ::PROTOBUF_NAMESPACE_ID::uint64 ret_;
  friend struct ::TableStruct_libcall_2eproto;
};
// -------------------------------------------------------------------

class free_t :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:libcall_types.free_t) */ {
 public:
  free_t();
  virtual ~free_t();

  free_t(const free_t& from);
  free_t(free_t&& from) noexcept
    : free_t() {
    *this = ::std::move(from);
  }

  inline free_t& operator=(const free_t& from) {
    CopyFrom(from);
    return *this;
  }
  inline free_t& operator=(free_t&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const free_t& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const free_t* internal_default_instance() {
    return reinterpret_cast<const free_t*>(
               &_free_t_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    60;

  friend void swap(free_t& a, free_t& b) {
    a.Swap(&b);
  }
  inline void Swap(free_t* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline free_t* New() const final {
    return CreateMaybeMessage<free_t>(nullptr);
  }

  free_t* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<free_t>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const free_t& from);
  void MergeFrom(const free_t& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(free_t* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "libcall_types.free_t";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_libcall_2eproto);
    return ::descriptor_table_libcall_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPtrFieldNumber = 1,
  };
  // required uint64 ptr = 1;
  bool has_ptr() const;
  void clear_ptr();
  ::PROTOBUF_NAMESPACE_ID::uint64 ptr() const;
  void set_ptr(::PROTOBUF_NAMESPACE_ID::uint64 value);

  // @@protoc_insertion_point(class_scope:libcall_types.free_t)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint64 ptr_;
  friend struct ::TableStruct_libcall_2eproto;
};
// -------------------------------------------------------------------

class memcpy_t :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:libcall_types.memcpy_t) */ {
 public:
  memcpy_t();
  virtual ~memcpy_t();

  memcpy_t(const memcpy_t& from);
  memcpy_t(memcpy_t&& from) noexcept
    : memcpy_t() {
    *this = ::std::move(from);
  }

  inline memcpy_t& operator=(const memcpy_t& from) {
    CopyFrom(from);
    return *this;
  }
  inline memcpy_t& operator=(memcpy_t&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const memcpy_t& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const memcpy_t* internal_default_instance() {
    return reinterpret_cast<const memcpy_t*>(
               &_memcpy_t_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    61;

  friend void swap(memcpy_t& a, memcpy_t& b) {
    a.Swap(&b);
  }
  inline void Swap(memcpy_t* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline memcpy_t* New() const final {
    return CreateMaybeMessage<memcpy_t>(nullptr);
  }

  memcpy_t* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<memcpy_t>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const memcpy_t& from);
  void MergeFrom(const memcpy_t& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(memcpy_t* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "libcall_types.memcpy_t";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_libcall_2eproto);
    return ::descriptor_table_libcall_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDestFieldNumber = 1,
    kSrcFieldNumber = 2,
    kSizeFieldNumber = 3,
    kRetFieldNumber = 4,
  };
  // required .common.memory_t dest = 1;
  bool has_dest() const;
  void clear_dest();
  const ::common::memory_t& dest() const;
  ::common::memory_t* release_dest();
  ::common::memory_t* mutable_dest();
  void set_allocated_dest(::common::memory_t* dest);

  // required .common.memory_t src = 2;
  bool has_src() const;
  void clear_src();
  const ::common::memory_t& src() const;
  ::common::memory_t* release_src();
  ::common::memory_t* mutable_src();
  void set_allocated_src(::common::memory_t* src);

  // required uint64 size = 3;
  bool has_size() const;
  void clear_size();
  ::PROTOBUF_NAMESPACE_ID::uint64 size() const;
  void set_size(::PROTOBUF_NAMESPACE_ID::uint64 value);

  // required uint64 ret = 4;
  bool has_ret() const;
  void clear_ret();
  ::PROTOBUF_NAMESPACE_ID::uint64 ret() const;
  void set_ret(::PROTOBUF_NAMESPACE_ID::uint64 value);

  // @@protoc_insertion_point(class_scope:libcall_types.memcpy_t)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::common::memory_t* dest_;
  ::common::memory_t* src_;
  ::PROTOBUF_NAMESPACE_ID::uint64 size_;
  ::PROTOBUF_NAMESPACE_ID::uint64 ret_;
  friend struct ::TableStruct_libcall_2eproto;
};
// -------------------------------------------------------------------

class memset_t :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:libcall_types.memset_t) */ {
 public:
  memset_t();
  virtual ~memset_t();

  memset_t(const memset_t& from);
  memset_t(memset_t&& from) noexcept
    : memset_t() {
    *this = ::std::move(from);
  }

  inline memset_t& operator=(const memset_t& from) {
    CopyFrom(from);
    return *this;
  }
  inline memset_t& operator=(memset_t&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const memset_t& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const memset_t* internal_default_instance() {
    return reinterpret_cast<const memset_t*>(
               &_memset_t_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    62;

  friend void swap(memset_t& a, memset_t& b) {
    a.Swap(&b);
  }
  inline void Swap(memset_t* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline memset_t* New() const final {
    return CreateMaybeMessage<memset_t>(nullptr);
  }

  memset_t* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<memset_t>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const memset_t& from);
  void MergeFrom(const memset_t& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(memset_t* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "libcall_types.memset_t";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_libcall_2eproto);
    return ::descriptor_table_libcall_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSFieldNumber = 1,
    kCFieldNumber = 2,
    kSizeFieldNumber = 3,
    kRetFieldNumber = 4,
  };
  // required .common.memory_t s = 1;
  bool has_s() const;
  void clear_s();
  const ::common::memory_t& s() const;
  ::common::memory_t* release_s();
  ::common::memory_t* mutable_s();
  void set_allocated_s(::common::memory_t* s);

  // required uint64 c = 2;
  bool has_c() const;
  void clear_c();
  ::PROTOBUF_NAMESPACE_ID::uint64 c() const;
  void set_c(::PROTOBUF_NAMESPACE_ID::uint64 value);

  // required uint64 size = 3;
  bool has_size() const;
  void clear_size();
  ::PROTOBUF_NAMESPACE_ID::uint64 size() const;
  void set_size(::PROTOBUF_NAMESPACE_ID::uint64 value);

  // required uint64 ret = 4;
  bool has_ret() const;
  void clear_ret();
  ::PROTOBUF_NAMESPACE_ID::uint64 ret() const;
  void set_ret(::PROTOBUF_NAMESPACE_ID::uint64 value);

  // @@protoc_insertion_point(class_scope:libcall_types.memset_t)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::common::memory_t* s_;
  ::PROTOBUF_NAMESPACE_ID::uint64 c_;
  ::PROTOBUF_NAMESPACE_ID::uint64 size_;
  ::PROTOBUF_NAMESPACE_ID::uint64 ret_;
  friend struct ::TableStruct_libcall_2eproto;
};
// -------------------------------------------------------------------

class fgetc_t :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:libcall_types.fgetc_t) */ {
 public:
  fgetc_t();
  virtual ~fgetc_t();

  fgetc_t(const fgetc_t& from);
  fgetc_t(fgetc_t&& from) noexcept
    : fgetc_t() {
    *this = ::std::move(from);
  }

  inline fgetc_t& operator=(const fgetc_t& from) {
    CopyFrom(from);
    return *this;
  }
  inline fgetc_t& operator=(fgetc_t&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const fgetc_t& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const fgetc_t* internal_default_instance() {
    return reinterpret_cast<const fgetc_t*>(
               &_fgetc_t_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    63;

  friend void swap(fgetc_t& a, fgetc_t& b) {
    a.Swap(&b);
  }
  inline void Swap(fgetc_t* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline fgetc_t* New() const final {
    return CreateMaybeMessage<fgetc_t>(nullptr);
  }

  fgetc_t* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<fgetc_t>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const fgetc_t& from);
  void MergeFrom(const fgetc_t& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(fgetc_t* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "libcall_types.fgetc_t";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_libcall_2eproto);
    return ::descriptor_table_libcall_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStreamFieldNumber = 1,
    kRetFieldNumber = 2,
  };
  // required uint64 stream = 1;
  bool has_stream() const;
  void clear_stream();
  ::PROTOBUF_NAMESPACE_ID::uint64 stream() const;
  void set_stream(::PROTOBUF_NAMESPACE_ID::uint64 value);

  // required uint64 ret = 2;
  bool has_ret() const;
  void clear_ret();
  ::PROTOBUF_NAMESPACE_ID::uint64 ret() const;
  void set_ret(::PROTOBUF_NAMESPACE_ID::uint64 value);

  // @@protoc_insertion_point(class_scope:libcall_types.fgetc_t)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint64 stream_;
  ::PROTOBUF_NAMESPACE_ID::uint64 ret_;
  friend struct ::TableStruct_libcall_2eproto;
};
// -------------------------------------------------------------------

class lseek_t :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:libcall_types.lseek_t) */ {
 public:
  lseek_t();
  virtual ~lseek_t();

  lseek_t(const lseek_t& from);
  lseek_t(lseek_t&& from) noexcept
    : lseek_t() {
    *this = ::std::move(from);
  }

  inline lseek_t& operator=(const lseek_t& from) {
    CopyFrom(from);
    return *this;
  }
  inline lseek_t& operator=(lseek_t&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const lseek_t& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const lseek_t* internal_default_instance() {
    return reinterpret_cast<const lseek_t*>(
               &_lseek_t_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    64;

  friend void swap(lseek_t& a, lseek_t& b) {
    a.Swap(&b);
  }
  inline void Swap(lseek_t* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline lseek_t* New() const final {
    return CreateMaybeMessage<lseek_t>(nullptr);
  }

  lseek_t* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<lseek_t>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const lseek_t& from);
  void MergeFrom(const lseek_t& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(lseek_t* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "libcall_types.lseek_t";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_libcall_2eproto);
    return ::descriptor_table_libcall_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kFdFieldNumber = 1,
    kOffsetFieldNumber = 2,
    kWhenceFieldNumber = 3,
    kRetFieldNumber = 4,
  };
  // required uint64 fd = 1;
  bool has_fd() const;
  void clear_fd();
  ::PROTOBUF_NAMESPACE_ID::uint64 fd() const;
  void set_fd(::PROTOBUF_NAMESPACE_ID::uint64 value);

  // required uint64 offset = 2;
  bool has_offset() const;
  void clear_offset();
  ::PROTOBUF_NAMESPACE_ID::uint64 offset() const;
  void set_offset(::PROTOBUF_NAMESPACE_ID::uint64 value);

  // required uint64 whence = 3;
  bool has_whence() const;
  void clear_whence();
  ::PROTOBUF_NAMESPACE_ID::uint64 whence() const;
  void set_whence(::PROTOBUF_NAMESPACE_ID::uint64 value);

  // required uint64 ret = 4;
  bool has_ret() const;
  void clear_ret();
  ::PROTOBUF_NAMESPACE_ID::uint64 ret() const;
  void set_ret(::PROTOBUF_NAMESPACE_ID::uint64 value);

  // @@protoc_insertion_point(class_scope:libcall_types.lseek_t)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint64 fd_;
  ::PROTOBUF_NAMESPACE_ID::uint64 offset_;
  ::PROTOBUF_NAMESPACE_ID::uint64 whence_;
  ::PROTOBUF_NAMESPACE_ID::uint64 ret_;
  friend struct ::TableStruct_libcall_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// libcall_pol

// required string name = 1;
inline bool libcall_pol::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void libcall_pol::clear_name() {
  name_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& libcall_pol::name() const {
  // @@protoc_insertion_point(field_get:libcall_types.libcall_pol.name)
  return name_.GetNoArena();
}
inline void libcall_pol::set_name(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:libcall_types.libcall_pol.name)
}
inline void libcall_pol::set_name(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  name_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:libcall_types.libcall_pol.name)
}
inline void libcall_pol::set_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:libcall_types.libcall_pol.name)
}
inline void libcall_pol::set_name(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:libcall_types.libcall_pol.name)
}
inline std::string* libcall_pol::mutable_name() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:libcall_types.libcall_pol.name)
  return name_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* libcall_pol::release_name() {
  // @@protoc_insertion_point(field_release:libcall_types.libcall_pol.name)
  if (!has_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return name_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void libcall_pol::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  name_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:libcall_types.libcall_pol.name)
}

// optional .libcall_types.lib_ident ident = 2 [default = GENERIC];
inline bool libcall_pol::has_ident() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void libcall_pol::clear_ident() {
  ident_ = 255;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::libcall_types::lib_ident libcall_pol::ident() const {
  // @@protoc_insertion_point(field_get:libcall_types.libcall_pol.ident)
  return static_cast< ::libcall_types::lib_ident >(ident_);
}
inline void libcall_pol::set_ident(::libcall_types::lib_ident value) {
  assert(::libcall_types::lib_ident_IsValid(value));
  _has_bits_[0] |= 0x00000004u;
  ident_ = value;
  // @@protoc_insertion_point(field_set:libcall_types.libcall_pol.ident)
}

// optional .common.tracing_action action = 3 [default = SKIP];
inline bool libcall_pol::has_action() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void libcall_pol::clear_action() {
  action_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::common::tracing_action libcall_pol::action() const {
  // @@protoc_insertion_point(field_get:libcall_types.libcall_pol.action)
  return static_cast< ::common::tracing_action >(action_);
}
inline void libcall_pol::set_action(::common::tracing_action value) {
  assert(::common::tracing_action_IsValid(value));
  _has_bits_[0] |= 0x00000002u;
  action_ = value;
  // @@protoc_insertion_point(field_set:libcall_types.libcall_pol.action)
}

// repeated uint64 restrict_addresses = 4;
inline int libcall_pol::restrict_addresses_size() const {
  return restrict_addresses_.size();
}
inline void libcall_pol::clear_restrict_addresses() {
  restrict_addresses_.Clear();
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 libcall_pol::restrict_addresses(int index) const {
  // @@protoc_insertion_point(field_get:libcall_types.libcall_pol.restrict_addresses)
  return restrict_addresses_.Get(index);
}
inline void libcall_pol::set_restrict_addresses(int index, ::PROTOBUF_NAMESPACE_ID::uint64 value) {
  restrict_addresses_.Set(index, value);
  // @@protoc_insertion_point(field_set:libcall_types.libcall_pol.restrict_addresses)
}
inline void libcall_pol::add_restrict_addresses(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  restrict_addresses_.Add(value);
  // @@protoc_insertion_point(field_add:libcall_types.libcall_pol.restrict_addresses)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint64 >&
libcall_pol::restrict_addresses() const {
  // @@protoc_insertion_point(field_list:libcall_types.libcall_pol.restrict_addresses)
  return restrict_addresses_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint64 >*
libcall_pol::mutable_restrict_addresses() {
  // @@protoc_insertion_point(field_mutable_list:libcall_types.libcall_pol.restrict_addresses)
  return &restrict_addresses_;
}

// optional .libcall_types.strcpy_pol strcpy = 5;
inline bool libcall_pol::has_strcpy() const {
  return libcall_cnt_case() == kStrcpy;
}
inline void libcall_pol::set_has_strcpy() {
  _oneof_case_[0] = kStrcpy;
}
inline void libcall_pol::clear_strcpy() {
  if (has_strcpy()) {
    delete libcall_cnt_.strcpy_;
    clear_has_libcall_cnt();
  }
}
inline ::libcall_types::strcpy_pol* libcall_pol::release_strcpy() {
  // @@protoc_insertion_point(field_release:libcall_types.libcall_pol.strcpy)
  if (has_strcpy()) {
    clear_has_libcall_cnt();
      ::libcall_types::strcpy_pol* temp = libcall_cnt_.strcpy_;
    libcall_cnt_.strcpy_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::libcall_types::strcpy_pol& libcall_pol::strcpy() const {
  // @@protoc_insertion_point(field_get:libcall_types.libcall_pol.strcpy)
  return has_strcpy()
      ? *libcall_cnt_.strcpy_
      : *reinterpret_cast< ::libcall_types::strcpy_pol*>(&::libcall_types::_strcpy_pol_default_instance_);
}
inline ::libcall_types::strcpy_pol* libcall_pol::mutable_strcpy() {
  if (!has_strcpy()) {
    clear_libcall_cnt();
    set_has_strcpy();
    libcall_cnt_.strcpy_ = CreateMaybeMessage< ::libcall_types::strcpy_pol >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:libcall_types.libcall_pol.strcpy)
  return libcall_cnt_.strcpy_;
}

// optional .libcall_types.printf_pol printf = 6;
inline bool libcall_pol::has_printf() const {
  return libcall_cnt_case() == kPrintf;
}
inline void libcall_pol::set_has_printf() {
  _oneof_case_[0] = kPrintf;
}
inline void libcall_pol::clear_printf() {
  if (has_printf()) {
    delete libcall_cnt_.printf_;
    clear_has_libcall_cnt();
  }
}
inline ::libcall_types::printf_pol* libcall_pol::release_printf() {
  // @@protoc_insertion_point(field_release:libcall_types.libcall_pol.printf)
  if (has_printf()) {
    clear_has_libcall_cnt();
      ::libcall_types::printf_pol* temp = libcall_cnt_.printf_;
    libcall_cnt_.printf_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::libcall_types::printf_pol& libcall_pol::printf() const {
  // @@protoc_insertion_point(field_get:libcall_types.libcall_pol.printf)
  return has_printf()
      ? *libcall_cnt_.printf_
      : *reinterpret_cast< ::libcall_types::printf_pol*>(&::libcall_types::_printf_pol_default_instance_);
}
inline ::libcall_types::printf_pol* libcall_pol::mutable_printf() {
  if (!has_printf()) {
    clear_libcall_cnt();
    set_has_printf();
    libcall_cnt_.printf_ = CreateMaybeMessage< ::libcall_types::printf_pol >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:libcall_types.libcall_pol.printf)
  return libcall_cnt_.printf_;
}

// optional .libcall_types.atoi_pol atoi = 7;
inline bool libcall_pol::has_atoi() const {
  return libcall_cnt_case() == kAtoi;
}
inline void libcall_pol::set_has_atoi() {
  _oneof_case_[0] = kAtoi;
}
inline void libcall_pol::clear_atoi() {
  if (has_atoi()) {
    delete libcall_cnt_.atoi_;
    clear_has_libcall_cnt();
  }
}
inline ::libcall_types::atoi_pol* libcall_pol::release_atoi() {
  // @@protoc_insertion_point(field_release:libcall_types.libcall_pol.atoi)
  if (has_atoi()) {
    clear_has_libcall_cnt();
      ::libcall_types::atoi_pol* temp = libcall_cnt_.atoi_;
    libcall_cnt_.atoi_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::libcall_types::atoi_pol& libcall_pol::atoi() const {
  // @@protoc_insertion_point(field_get:libcall_types.libcall_pol.atoi)
  return has_atoi()
      ? *libcall_cnt_.atoi_
      : *reinterpret_cast< ::libcall_types::atoi_pol*>(&::libcall_types::_atoi_pol_default_instance_);
}
inline ::libcall_types::atoi_pol* libcall_pol::mutable_atoi() {
  if (!has_atoi()) {
    clear_libcall_cnt();
    set_has_atoi();
    libcall_cnt_.atoi_ = CreateMaybeMessage< ::libcall_types::atoi_pol >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:libcall_types.libcall_pol.atoi)
  return libcall_cnt_.atoi_;
}

// optional .libcall_types.malloc_pol malloc = 8;
inline bool libcall_pol::has_malloc() const {
  return libcall_cnt_case() == kMalloc;
}
inline void libcall_pol::set_has_malloc() {
  _oneof_case_[0] = kMalloc;
}
inline void libcall_pol::clear_malloc() {
  if (has_malloc()) {
    delete libcall_cnt_.malloc_;
    clear_has_libcall_cnt();
  }
}
inline ::libcall_types::malloc_pol* libcall_pol::release_malloc() {
  // @@protoc_insertion_point(field_release:libcall_types.libcall_pol.malloc)
  if (has_malloc()) {
    clear_has_libcall_cnt();
      ::libcall_types::malloc_pol* temp = libcall_cnt_.malloc_;
    libcall_cnt_.malloc_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::libcall_types::malloc_pol& libcall_pol::malloc() const {
  // @@protoc_insertion_point(field_get:libcall_types.libcall_pol.malloc)
  return has_malloc()
      ? *libcall_cnt_.malloc_
      : *reinterpret_cast< ::libcall_types::malloc_pol*>(&::libcall_types::_malloc_pol_default_instance_);
}
inline ::libcall_types::malloc_pol* libcall_pol::mutable_malloc() {
  if (!has_malloc()) {
    clear_libcall_cnt();
    set_has_malloc();
    libcall_cnt_.malloc_ = CreateMaybeMessage< ::libcall_types::malloc_pol >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:libcall_types.libcall_pol.malloc)
  return libcall_cnt_.malloc_;
}

// optional .libcall_types.getmodulehandle_pol getmodulehandle = 9;
inline bool libcall_pol::has_getmodulehandle() const {
  return libcall_cnt_case() == kGetmodulehandle;
}
inline void libcall_pol::set_has_getmodulehandle() {
  _oneof_case_[0] = kGetmodulehandle;
}
inline void libcall_pol::clear_getmodulehandle() {
  if (has_getmodulehandle()) {
    delete libcall_cnt_.getmodulehandle_;
    clear_has_libcall_cnt();
  }
}
inline ::libcall_types::getmodulehandle_pol* libcall_pol::release_getmodulehandle() {
  // @@protoc_insertion_point(field_release:libcall_types.libcall_pol.getmodulehandle)
  if (has_getmodulehandle()) {
    clear_has_libcall_cnt();
      ::libcall_types::getmodulehandle_pol* temp = libcall_cnt_.getmodulehandle_;
    libcall_cnt_.getmodulehandle_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::libcall_types::getmodulehandle_pol& libcall_pol::getmodulehandle() const {
  // @@protoc_insertion_point(field_get:libcall_types.libcall_pol.getmodulehandle)
  return has_getmodulehandle()
      ? *libcall_cnt_.getmodulehandle_
      : *reinterpret_cast< ::libcall_types::getmodulehandle_pol*>(&::libcall_types::_getmodulehandle_pol_default_instance_);
}
inline ::libcall_types::getmodulehandle_pol* libcall_pol::mutable_getmodulehandle() {
  if (!has_getmodulehandle()) {
    clear_libcall_cnt();
    set_has_getmodulehandle();
    libcall_cnt_.getmodulehandle_ = CreateMaybeMessage< ::libcall_types::getmodulehandle_pol >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:libcall_types.libcall_pol.getmodulehandle)
  return libcall_cnt_.getmodulehandle_;
}

// optional .libcall_types.getprocaddress_pol getprocaddress = 10;
inline bool libcall_pol::has_getprocaddress() const {
  return libcall_cnt_case() == kGetprocaddress;
}
inline void libcall_pol::set_has_getprocaddress() {
  _oneof_case_[0] = kGetprocaddress;
}
inline void libcall_pol::clear_getprocaddress() {
  if (has_getprocaddress()) {
    delete libcall_cnt_.getprocaddress_;
    clear_has_libcall_cnt();
  }
}
inline ::libcall_types::getprocaddress_pol* libcall_pol::release_getprocaddress() {
  // @@protoc_insertion_point(field_release:libcall_types.libcall_pol.getprocaddress)
  if (has_getprocaddress()) {
    clear_has_libcall_cnt();
      ::libcall_types::getprocaddress_pol* temp = libcall_cnt_.getprocaddress_;
    libcall_cnt_.getprocaddress_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::libcall_types::getprocaddress_pol& libcall_pol::getprocaddress() const {
  // @@protoc_insertion_point(field_get:libcall_types.libcall_pol.getprocaddress)
  return has_getprocaddress()
      ? *libcall_cnt_.getprocaddress_
      : *reinterpret_cast< ::libcall_types::getprocaddress_pol*>(&::libcall_types::_getprocaddress_pol_default_instance_);
}
inline ::libcall_types::getprocaddress_pol* libcall_pol::mutable_getprocaddress() {
  if (!has_getprocaddress()) {
    clear_libcall_cnt();
    set_has_getprocaddress();
    libcall_cnt_.getprocaddress_ = CreateMaybeMessage< ::libcall_types::getprocaddress_pol >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:libcall_types.libcall_pol.getprocaddress)
  return libcall_cnt_.getprocaddress_;
}

// optional .libcall_types.getmainargs_pol getmainargs = 11;
inline bool libcall_pol::has_getmainargs() const {
  return libcall_cnt_case() == kGetmainargs;
}
inline void libcall_pol::set_has_getmainargs() {
  _oneof_case_[0] = kGetmainargs;
}
inline void libcall_pol::clear_getmainargs() {
  if (has_getmainargs()) {
    delete libcall_cnt_.getmainargs_;
    clear_has_libcall_cnt();
  }
}
inline ::libcall_types::getmainargs_pol* libcall_pol::release_getmainargs() {
  // @@protoc_insertion_point(field_release:libcall_types.libcall_pol.getmainargs)
  if (has_getmainargs()) {
    clear_has_libcall_cnt();
      ::libcall_types::getmainargs_pol* temp = libcall_cnt_.getmainargs_;
    libcall_cnt_.getmainargs_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::libcall_types::getmainargs_pol& libcall_pol::getmainargs() const {
  // @@protoc_insertion_point(field_get:libcall_types.libcall_pol.getmainargs)
  return has_getmainargs()
      ? *libcall_cnt_.getmainargs_
      : *reinterpret_cast< ::libcall_types::getmainargs_pol*>(&::libcall_types::_getmainargs_pol_default_instance_);
}
inline ::libcall_types::getmainargs_pol* libcall_pol::mutable_getmainargs() {
  if (!has_getmainargs()) {
    clear_libcall_cnt();
    set_has_getmainargs();
    libcall_cnt_.getmainargs_ = CreateMaybeMessage< ::libcall_types::getmainargs_pol >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:libcall_types.libcall_pol.getmainargs)
  return libcall_cnt_.getmainargs_;
}

// optional .libcall_types.gethostname_pol gethostname = 12;
inline bool libcall_pol::has_gethostname() const {
  return libcall_cnt_case() == kGethostname;
}
inline void libcall_pol::set_has_gethostname() {
  _oneof_case_[0] = kGethostname;
}
inline void libcall_pol::clear_gethostname() {
  if (has_gethostname()) {
    delete libcall_cnt_.gethostname_;
    clear_has_libcall_cnt();
  }
}
inline ::libcall_types::gethostname_pol* libcall_pol::release_gethostname() {
  // @@protoc_insertion_point(field_release:libcall_types.libcall_pol.gethostname)
  if (has_gethostname()) {
    clear_has_libcall_cnt();
      ::libcall_types::gethostname_pol* temp = libcall_cnt_.gethostname_;
    libcall_cnt_.gethostname_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::libcall_types::gethostname_pol& libcall_pol::gethostname() const {
  // @@protoc_insertion_point(field_get:libcall_types.libcall_pol.gethostname)
  return has_gethostname()
      ? *libcall_cnt_.gethostname_
      : *reinterpret_cast< ::libcall_types::gethostname_pol*>(&::libcall_types::_gethostname_pol_default_instance_);
}
inline ::libcall_types::gethostname_pol* libcall_pol::mutable_gethostname() {
  if (!has_gethostname()) {
    clear_libcall_cnt();
    set_has_gethostname();
    libcall_cnt_.gethostname_ = CreateMaybeMessage< ::libcall_types::gethostname_pol >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:libcall_types.libcall_pol.gethostname)
  return libcall_cnt_.gethostname_;
}

// optional .libcall_types.free_pol free = 13;
inline bool libcall_pol::has_free() const {
  return libcall_cnt_case() == kFree;
}
inline void libcall_pol::set_has_free() {
  _oneof_case_[0] = kFree;
}
inline void libcall_pol::clear_free() {
  if (has_free()) {
    delete libcall_cnt_.free_;
    clear_has_libcall_cnt();
  }
}
inline ::libcall_types::free_pol* libcall_pol::release_free() {
  // @@protoc_insertion_point(field_release:libcall_types.libcall_pol.free)
  if (has_free()) {
    clear_has_libcall_cnt();
      ::libcall_types::free_pol* temp = libcall_cnt_.free_;
    libcall_cnt_.free_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::libcall_types::free_pol& libcall_pol::free() const {
  // @@protoc_insertion_point(field_get:libcall_types.libcall_pol.free)
  return has_free()
      ? *libcall_cnt_.free_
      : *reinterpret_cast< ::libcall_types::free_pol*>(&::libcall_types::_free_pol_default_instance_);
}
inline ::libcall_types::free_pol* libcall_pol::mutable_free() {
  if (!has_free()) {
    clear_libcall_cnt();
    set_has_free();
    libcall_cnt_.free_ = CreateMaybeMessage< ::libcall_types::free_pol >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:libcall_types.libcall_pol.free)
  return libcall_cnt_.free_;
}

// optional .libcall_types.memcpy_pol memcpy = 14;
inline bool libcall_pol::has_memcpy() const {
  return libcall_cnt_case() == kMemcpy;
}
inline void libcall_pol::set_has_memcpy() {
  _oneof_case_[0] = kMemcpy;
}
inline void libcall_pol::clear_memcpy() {
  if (has_memcpy()) {
    delete libcall_cnt_.memcpy_;
    clear_has_libcall_cnt();
  }
}
inline ::libcall_types::memcpy_pol* libcall_pol::release_memcpy() {
  // @@protoc_insertion_point(field_release:libcall_types.libcall_pol.memcpy)
  if (has_memcpy()) {
    clear_has_libcall_cnt();
      ::libcall_types::memcpy_pol* temp = libcall_cnt_.memcpy_;
    libcall_cnt_.memcpy_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::libcall_types::memcpy_pol& libcall_pol::memcpy() const {
  // @@protoc_insertion_point(field_get:libcall_types.libcall_pol.memcpy)
  return has_memcpy()
      ? *libcall_cnt_.memcpy_
      : *reinterpret_cast< ::libcall_types::memcpy_pol*>(&::libcall_types::_memcpy_pol_default_instance_);
}
inline ::libcall_types::memcpy_pol* libcall_pol::mutable_memcpy() {
  if (!has_memcpy()) {
    clear_libcall_cnt();
    set_has_memcpy();
    libcall_cnt_.memcpy_ = CreateMaybeMessage< ::libcall_types::memcpy_pol >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:libcall_types.libcall_pol.memcpy)
  return libcall_cnt_.memcpy_;
}

// optional .libcall_types.memset_pol memset = 15;
inline bool libcall_pol::has_memset() const {
  return libcall_cnt_case() == kMemset;
}
inline void libcall_pol::set_has_memset() {
  _oneof_case_[0] = kMemset;
}
inline void libcall_pol::clear_memset() {
  if (has_memset()) {
    delete libcall_cnt_.memset_;
    clear_has_libcall_cnt();
  }
}
inline ::libcall_types::memset_pol* libcall_pol::release_memset() {
  // @@protoc_insertion_point(field_release:libcall_types.libcall_pol.memset)
  if (has_memset()) {
    clear_has_libcall_cnt();
      ::libcall_types::memset_pol* temp = libcall_cnt_.memset_;
    libcall_cnt_.memset_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::libcall_types::memset_pol& libcall_pol::memset() const {
  // @@protoc_insertion_point(field_get:libcall_types.libcall_pol.memset)
  return has_memset()
      ? *libcall_cnt_.memset_
      : *reinterpret_cast< ::libcall_types::memset_pol*>(&::libcall_types::_memset_pol_default_instance_);
}
inline ::libcall_types::memset_pol* libcall_pol::mutable_memset() {
  if (!has_memset()) {
    clear_libcall_cnt();
    set_has_memset();
    libcall_cnt_.memset_ = CreateMaybeMessage< ::libcall_types::memset_pol >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:libcall_types.libcall_pol.memset)
  return libcall_cnt_.memset_;
}

// optional .libcall_types.fgetc_pol fgetc = 16;
inline bool libcall_pol::has_fgetc() const {
  return libcall_cnt_case() == kFgetc;
}
inline void libcall_pol::set_has_fgetc() {
  _oneof_case_[0] = kFgetc;
}
inline void libcall_pol::clear_fgetc() {
  if (has_fgetc()) {
    delete libcall_cnt_.fgetc_;
    clear_has_libcall_cnt();
  }
}
inline ::libcall_types::fgetc_pol* libcall_pol::release_fgetc() {
  // @@protoc_insertion_point(field_release:libcall_types.libcall_pol.fgetc)
  if (has_fgetc()) {
    clear_has_libcall_cnt();
      ::libcall_types::fgetc_pol* temp = libcall_cnt_.fgetc_;
    libcall_cnt_.fgetc_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::libcall_types::fgetc_pol& libcall_pol::fgetc() const {
  // @@protoc_insertion_point(field_get:libcall_types.libcall_pol.fgetc)
  return has_fgetc()
      ? *libcall_cnt_.fgetc_
      : *reinterpret_cast< ::libcall_types::fgetc_pol*>(&::libcall_types::_fgetc_pol_default_instance_);
}
inline ::libcall_types::fgetc_pol* libcall_pol::mutable_fgetc() {
  if (!has_fgetc()) {
    clear_libcall_cnt();
    set_has_fgetc();
    libcall_cnt_.fgetc_ = CreateMaybeMessage< ::libcall_types::fgetc_pol >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:libcall_types.libcall_pol.fgetc)
  return libcall_cnt_.fgetc_;
}

// optional .libcall_types.read_pol read = 17;
inline bool libcall_pol::has_read() const {
  return libcall_cnt_case() == kRead;
}
inline void libcall_pol::set_has_read() {
  _oneof_case_[0] = kRead;
}
inline void libcall_pol::clear_read() {
  if (has_read()) {
    delete libcall_cnt_.read_;
    clear_has_libcall_cnt();
  }
}
inline ::libcall_types::read_pol* libcall_pol::release_read() {
  // @@protoc_insertion_point(field_release:libcall_types.libcall_pol.read)
  if (has_read()) {
    clear_has_libcall_cnt();
      ::libcall_types::read_pol* temp = libcall_cnt_.read_;
    libcall_cnt_.read_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::libcall_types::read_pol& libcall_pol::read() const {
  // @@protoc_insertion_point(field_get:libcall_types.libcall_pol.read)
  return has_read()
      ? *libcall_cnt_.read_
      : *reinterpret_cast< ::libcall_types::read_pol*>(&::libcall_types::_read_pol_default_instance_);
}
inline ::libcall_types::read_pol* libcall_pol::mutable_read() {
  if (!has_read()) {
    clear_libcall_cnt();
    set_has_read();
    libcall_cnt_.read_ = CreateMaybeMessage< ::libcall_types::read_pol >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:libcall_types.libcall_pol.read)
  return libcall_cnt_.read_;
}

// optional .libcall_types.strchr_pol strchr = 18;
inline bool libcall_pol::has_strchr() const {
  return libcall_cnt_case() == kStrchr;
}
inline void libcall_pol::set_has_strchr() {
  _oneof_case_[0] = kStrchr;
}
inline void libcall_pol::clear_strchr() {
  if (has_strchr()) {
    delete libcall_cnt_.strchr_;
    clear_has_libcall_cnt();
  }
}
inline ::libcall_types::strchr_pol* libcall_pol::release_strchr() {
  // @@protoc_insertion_point(field_release:libcall_types.libcall_pol.strchr)
  if (has_strchr()) {
    clear_has_libcall_cnt();
      ::libcall_types::strchr_pol* temp = libcall_cnt_.strchr_;
    libcall_cnt_.strchr_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::libcall_types::strchr_pol& libcall_pol::strchr() const {
  // @@protoc_insertion_point(field_get:libcall_types.libcall_pol.strchr)
  return has_strchr()
      ? *libcall_cnt_.strchr_
      : *reinterpret_cast< ::libcall_types::strchr_pol*>(&::libcall_types::_strchr_pol_default_instance_);
}
inline ::libcall_types::strchr_pol* libcall_pol::mutable_strchr() {
  if (!has_strchr()) {
    clear_libcall_cnt();
    set_has_strchr();
    libcall_cnt_.strchr_ = CreateMaybeMessage< ::libcall_types::strchr_pol >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:libcall_types.libcall_pol.strchr)
  return libcall_cnt_.strchr_;
}

// optional .libcall_types.exit_pol exit = 19;
inline bool libcall_pol::has_exit() const {
  return libcall_cnt_case() == kExit;
}
inline void libcall_pol::set_has_exit() {
  _oneof_case_[0] = kExit;
}
inline void libcall_pol::clear_exit() {
  if (has_exit()) {
    delete libcall_cnt_.exit_;
    clear_has_libcall_cnt();
  }
}
inline ::libcall_types::exit_pol* libcall_pol::release_exit() {
  // @@protoc_insertion_point(field_release:libcall_types.libcall_pol.exit)
  if (has_exit()) {
    clear_has_libcall_cnt();
      ::libcall_types::exit_pol* temp = libcall_cnt_.exit_;
    libcall_cnt_.exit_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::libcall_types::exit_pol& libcall_pol::exit() const {
  // @@protoc_insertion_point(field_get:libcall_types.libcall_pol.exit)
  return has_exit()
      ? *libcall_cnt_.exit_
      : *reinterpret_cast< ::libcall_types::exit_pol*>(&::libcall_types::_exit_pol_default_instance_);
}
inline ::libcall_types::exit_pol* libcall_pol::mutable_exit() {
  if (!has_exit()) {
    clear_libcall_cnt();
    set_has_exit();
    libcall_cnt_.exit_ = CreateMaybeMessage< ::libcall_types::exit_pol >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:libcall_types.libcall_pol.exit)
  return libcall_cnt_.exit_;
}

// optional .libcall_types.strcmp_pol strcmp = 20;
inline bool libcall_pol::has_strcmp() const {
  return libcall_cnt_case() == kStrcmp;
}
inline void libcall_pol::set_has_strcmp() {
  _oneof_case_[0] = kStrcmp;
}
inline void libcall_pol::clear_strcmp() {
  if (has_strcmp()) {
    delete libcall_cnt_.strcmp_;
    clear_has_libcall_cnt();
  }
}
inline ::libcall_types::strcmp_pol* libcall_pol::release_strcmp() {
  // @@protoc_insertion_point(field_release:libcall_types.libcall_pol.strcmp)
  if (has_strcmp()) {
    clear_has_libcall_cnt();
      ::libcall_types::strcmp_pol* temp = libcall_cnt_.strcmp_;
    libcall_cnt_.strcmp_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::libcall_types::strcmp_pol& libcall_pol::strcmp() const {
  // @@protoc_insertion_point(field_get:libcall_types.libcall_pol.strcmp)
  return has_strcmp()
      ? *libcall_cnt_.strcmp_
      : *reinterpret_cast< ::libcall_types::strcmp_pol*>(&::libcall_types::_strcmp_pol_default_instance_);
}
inline ::libcall_types::strcmp_pol* libcall_pol::mutable_strcmp() {
  if (!has_strcmp()) {
    clear_libcall_cnt();
    set_has_strcmp();
    libcall_cnt_.strcmp_ = CreateMaybeMessage< ::libcall_types::strcmp_pol >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:libcall_types.libcall_pol.strcmp)
  return libcall_cnt_.strcmp_;
}

// optional .libcall_types.ctype_b_loc_pol ctype_b_loc = 22;
inline bool libcall_pol::has_ctype_b_loc() const {
  return libcall_cnt_case() == kCtypeBLoc;
}
inline void libcall_pol::set_has_ctype_b_loc() {
  _oneof_case_[0] = kCtypeBLoc;
}
inline void libcall_pol::clear_ctype_b_loc() {
  if (has_ctype_b_loc()) {
    delete libcall_cnt_.ctype_b_loc_;
    clear_has_libcall_cnt();
  }
}
inline ::libcall_types::ctype_b_loc_pol* libcall_pol::release_ctype_b_loc() {
  // @@protoc_insertion_point(field_release:libcall_types.libcall_pol.ctype_b_loc)
  if (has_ctype_b_loc()) {
    clear_has_libcall_cnt();
      ::libcall_types::ctype_b_loc_pol* temp = libcall_cnt_.ctype_b_loc_;
    libcall_cnt_.ctype_b_loc_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::libcall_types::ctype_b_loc_pol& libcall_pol::ctype_b_loc() const {
  // @@protoc_insertion_point(field_get:libcall_types.libcall_pol.ctype_b_loc)
  return has_ctype_b_loc()
      ? *libcall_cnt_.ctype_b_loc_
      : *reinterpret_cast< ::libcall_types::ctype_b_loc_pol*>(&::libcall_types::_ctype_b_loc_pol_default_instance_);
}
inline ::libcall_types::ctype_b_loc_pol* libcall_pol::mutable_ctype_b_loc() {
  if (!has_ctype_b_loc()) {
    clear_libcall_cnt();
    set_has_ctype_b_loc();
    libcall_cnt_.ctype_b_loc_ = CreateMaybeMessage< ::libcall_types::ctype_b_loc_pol >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:libcall_types.libcall_pol.ctype_b_loc)
  return libcall_cnt_.ctype_b_loc_;
}

// optional .libcall_types.fscanf_pol fscanf = 23;
inline bool libcall_pol::has_fscanf() const {
  return libcall_cnt_case() == kFscanf;
}
inline void libcall_pol::set_has_fscanf() {
  _oneof_case_[0] = kFscanf;
}
inline void libcall_pol::clear_fscanf() {
  if (has_fscanf()) {
    delete libcall_cnt_.fscanf_;
    clear_has_libcall_cnt();
  }
}
inline ::libcall_types::fscanf_pol* libcall_pol::release_fscanf() {
  // @@protoc_insertion_point(field_release:libcall_types.libcall_pol.fscanf)
  if (has_fscanf()) {
    clear_has_libcall_cnt();
      ::libcall_types::fscanf_pol* temp = libcall_cnt_.fscanf_;
    libcall_cnt_.fscanf_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::libcall_types::fscanf_pol& libcall_pol::fscanf() const {
  // @@protoc_insertion_point(field_get:libcall_types.libcall_pol.fscanf)
  return has_fscanf()
      ? *libcall_cnt_.fscanf_
      : *reinterpret_cast< ::libcall_types::fscanf_pol*>(&::libcall_types::_fscanf_pol_default_instance_);
}
inline ::libcall_types::fscanf_pol* libcall_pol::mutable_fscanf() {
  if (!has_fscanf()) {
    clear_libcall_cnt();
    set_has_fscanf();
    libcall_cnt_.fscanf_ = CreateMaybeMessage< ::libcall_types::fscanf_pol >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:libcall_types.libcall_pol.fscanf)
  return libcall_cnt_.fscanf_;
}

// optional .libcall_types.strncpy_pol strncpy = 24;
inline bool libcall_pol::has_strncpy() const {
  return libcall_cnt_case() == kStrncpy;
}
inline void libcall_pol::set_has_strncpy() {
  _oneof_case_[0] = kStrncpy;
}
inline void libcall_pol::clear_strncpy() {
  if (has_strncpy()) {
    delete libcall_cnt_.strncpy_;
    clear_has_libcall_cnt();
  }
}
inline ::libcall_types::strncpy_pol* libcall_pol::release_strncpy() {
  // @@protoc_insertion_point(field_release:libcall_types.libcall_pol.strncpy)
  if (has_strncpy()) {
    clear_has_libcall_cnt();
      ::libcall_types::strncpy_pol* temp = libcall_cnt_.strncpy_;
    libcall_cnt_.strncpy_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::libcall_types::strncpy_pol& libcall_pol::strncpy() const {
  // @@protoc_insertion_point(field_get:libcall_types.libcall_pol.strncpy)
  return has_strncpy()
      ? *libcall_cnt_.strncpy_
      : *reinterpret_cast< ::libcall_types::strncpy_pol*>(&::libcall_types::_strncpy_pol_default_instance_);
}
inline ::libcall_types::strncpy_pol* libcall_pol::mutable_strncpy() {
  if (!has_strncpy()) {
    clear_libcall_cnt();
    set_has_strncpy();
    libcall_cnt_.strncpy_ = CreateMaybeMessage< ::libcall_types::strncpy_pol >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:libcall_types.libcall_pol.strncpy)
  return libcall_cnt_.strncpy_;
}

// optional .libcall_types.fstat_pol fstat = 25;
inline bool libcall_pol::has_fstat() const {
  return libcall_cnt_case() == kFstat;
}
inline void libcall_pol::set_has_fstat() {
  _oneof_case_[0] = kFstat;
}
inline void libcall_pol::clear_fstat() {
  if (has_fstat()) {
    delete libcall_cnt_.fstat_;
    clear_has_libcall_cnt();
  }
}
inline ::libcall_types::fstat_pol* libcall_pol::release_fstat() {
  // @@protoc_insertion_point(field_release:libcall_types.libcall_pol.fstat)
  if (has_fstat()) {
    clear_has_libcall_cnt();
      ::libcall_types::fstat_pol* temp = libcall_cnt_.fstat_;
    libcall_cnt_.fstat_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::libcall_types::fstat_pol& libcall_pol::fstat() const {
  // @@protoc_insertion_point(field_get:libcall_types.libcall_pol.fstat)
  return has_fstat()
      ? *libcall_cnt_.fstat_
      : *reinterpret_cast< ::libcall_types::fstat_pol*>(&::libcall_types::_fstat_pol_default_instance_);
}
inline ::libcall_types::fstat_pol* libcall_pol::mutable_fstat() {
  if (!has_fstat()) {
    clear_libcall_cnt();
    set_has_fstat();
    libcall_cnt_.fstat_ = CreateMaybeMessage< ::libcall_types::fstat_pol >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:libcall_types.libcall_pol.fstat)
  return libcall_cnt_.fstat_;
}

// optional .libcall_types.realloc_pol realloc = 26;
inline bool libcall_pol::has_realloc() const {
  return libcall_cnt_case() == kRealloc;
}
inline void libcall_pol::set_has_realloc() {
  _oneof_case_[0] = kRealloc;
}
inline void libcall_pol::clear_realloc() {
  if (has_realloc()) {
    delete libcall_cnt_.realloc_;
    clear_has_libcall_cnt();
  }
}
inline ::libcall_types::realloc_pol* libcall_pol::release_realloc() {
  // @@protoc_insertion_point(field_release:libcall_types.libcall_pol.realloc)
  if (has_realloc()) {
    clear_has_libcall_cnt();
      ::libcall_types::realloc_pol* temp = libcall_cnt_.realloc_;
    libcall_cnt_.realloc_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::libcall_types::realloc_pol& libcall_pol::realloc() const {
  // @@protoc_insertion_point(field_get:libcall_types.libcall_pol.realloc)
  return has_realloc()
      ? *libcall_cnt_.realloc_
      : *reinterpret_cast< ::libcall_types::realloc_pol*>(&::libcall_types::_realloc_pol_default_instance_);
}
inline ::libcall_types::realloc_pol* libcall_pol::mutable_realloc() {
  if (!has_realloc()) {
    clear_libcall_cnt();
    set_has_realloc();
    libcall_cnt_.realloc_ = CreateMaybeMessage< ::libcall_types::realloc_pol >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:libcall_types.libcall_pol.realloc)
  return libcall_cnt_.realloc_;
}

// optional .libcall_types.mmap_pol mmap = 27;
inline bool libcall_pol::has_mmap() const {
  return libcall_cnt_case() == kMmap;
}
inline void libcall_pol::set_has_mmap() {
  _oneof_case_[0] = kMmap;
}
inline void libcall_pol::clear_mmap() {
  if (has_mmap()) {
    delete libcall_cnt_.mmap_;
    clear_has_libcall_cnt();
  }
}
inline ::libcall_types::mmap_pol* libcall_pol::release_mmap() {
  // @@protoc_insertion_point(field_release:libcall_types.libcall_pol.mmap)
  if (has_mmap()) {
    clear_has_libcall_cnt();
      ::libcall_types::mmap_pol* temp = libcall_cnt_.mmap_;
    libcall_cnt_.mmap_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::libcall_types::mmap_pol& libcall_pol::mmap() const {
  // @@protoc_insertion_point(field_get:libcall_types.libcall_pol.mmap)
  return has_mmap()
      ? *libcall_cnt_.mmap_
      : *reinterpret_cast< ::libcall_types::mmap_pol*>(&::libcall_types::_mmap_pol_default_instance_);
}
inline ::libcall_types::mmap_pol* libcall_pol::mutable_mmap() {
  if (!has_mmap()) {
    clear_libcall_cnt();
    set_has_mmap();
    libcall_cnt_.mmap_ = CreateMaybeMessage< ::libcall_types::mmap_pol >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:libcall_types.libcall_pol.mmap)
  return libcall_cnt_.mmap_;
}

// optional .libcall_types.qsort_pol qsort = 28;
inline bool libcall_pol::has_qsort() const {
  return libcall_cnt_case() == kQsort;
}
inline void libcall_pol::set_has_qsort() {
  _oneof_case_[0] = kQsort;
}
inline void libcall_pol::clear_qsort() {
  if (has_qsort()) {
    delete libcall_cnt_.qsort_;
    clear_has_libcall_cnt();
  }
}
inline ::libcall_types::qsort_pol* libcall_pol::release_qsort() {
  // @@protoc_insertion_point(field_release:libcall_types.libcall_pol.qsort)
  if (has_qsort()) {
    clear_has_libcall_cnt();
      ::libcall_types::qsort_pol* temp = libcall_cnt_.qsort_;
    libcall_cnt_.qsort_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::libcall_types::qsort_pol& libcall_pol::qsort() const {
  // @@protoc_insertion_point(field_get:libcall_types.libcall_pol.qsort)
  return has_qsort()
      ? *libcall_cnt_.qsort_
      : *reinterpret_cast< ::libcall_types::qsort_pol*>(&::libcall_types::_qsort_pol_default_instance_);
}
inline ::libcall_types::qsort_pol* libcall_pol::mutable_qsort() {
  if (!has_qsort()) {
    clear_libcall_cnt();
    set_has_qsort();
    libcall_cnt_.qsort_ = CreateMaybeMessage< ::libcall_types::qsort_pol >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:libcall_types.libcall_pol.qsort)
  return libcall_cnt_.qsort_;
}

// optional .libcall_types.bsearch_pol bsearch = 29;
inline bool libcall_pol::has_bsearch() const {
  return libcall_cnt_case() == kBsearch;
}
inline void libcall_pol::set_has_bsearch() {
  _oneof_case_[0] = kBsearch;
}
inline void libcall_pol::clear_bsearch() {
  if (has_bsearch()) {
    delete libcall_cnt_.bsearch_;
    clear_has_libcall_cnt();
  }
}
inline ::libcall_types::bsearch_pol* libcall_pol::release_bsearch() {
  // @@protoc_insertion_point(field_release:libcall_types.libcall_pol.bsearch)
  if (has_bsearch()) {
    clear_has_libcall_cnt();
      ::libcall_types::bsearch_pol* temp = libcall_cnt_.bsearch_;
    libcall_cnt_.bsearch_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::libcall_types::bsearch_pol& libcall_pol::bsearch() const {
  // @@protoc_insertion_point(field_get:libcall_types.libcall_pol.bsearch)
  return has_bsearch()
      ? *libcall_cnt_.bsearch_
      : *reinterpret_cast< ::libcall_types::bsearch_pol*>(&::libcall_types::_bsearch_pol_default_instance_);
}
inline ::libcall_types::bsearch_pol* libcall_pol::mutable_bsearch() {
  if (!has_bsearch()) {
    clear_libcall_cnt();
    set_has_bsearch();
    libcall_cnt_.bsearch_ = CreateMaybeMessage< ::libcall_types::bsearch_pol >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:libcall_types.libcall_pol.bsearch)
  return libcall_cnt_.bsearch_;
}

// optional .libcall_types.open_pol open_stub = 30;
inline bool libcall_pol::has_open_stub() const {
  return libcall_cnt_case() == kOpenStub;
}
inline void libcall_pol::set_has_open_stub() {
  _oneof_case_[0] = kOpenStub;
}
inline void libcall_pol::clear_open_stub() {
  if (has_open_stub()) {
    delete libcall_cnt_.open_stub_;
    clear_has_libcall_cnt();
  }
}
inline ::libcall_types::open_pol* libcall_pol::release_open_stub() {
  // @@protoc_insertion_point(field_release:libcall_types.libcall_pol.open_stub)
  if (has_open_stub()) {
    clear_has_libcall_cnt();
      ::libcall_types::open_pol* temp = libcall_cnt_.open_stub_;
    libcall_cnt_.open_stub_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::libcall_types::open_pol& libcall_pol::open_stub() const {
  // @@protoc_insertion_point(field_get:libcall_types.libcall_pol.open_stub)
  return has_open_stub()
      ? *libcall_cnt_.open_stub_
      : *reinterpret_cast< ::libcall_types::open_pol*>(&::libcall_types::_open_pol_default_instance_);
}
inline ::libcall_types::open_pol* libcall_pol::mutable_open_stub() {
  if (!has_open_stub()) {
    clear_libcall_cnt();
    set_has_open_stub();
    libcall_cnt_.open_stub_ = CreateMaybeMessage< ::libcall_types::open_pol >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:libcall_types.libcall_pol.open_stub)
  return libcall_cnt_.open_stub_;
}

// optional .libcall_types.lseek_pol lseek = 31;
inline bool libcall_pol::has_lseek() const {
  return libcall_cnt_case() == kLseek;
}
inline void libcall_pol::set_has_lseek() {
  _oneof_case_[0] = kLseek;
}
inline void libcall_pol::clear_lseek() {
  if (has_lseek()) {
    delete libcall_cnt_.lseek_;
    clear_has_libcall_cnt();
  }
}
inline ::libcall_types::lseek_pol* libcall_pol::release_lseek() {
  // @@protoc_insertion_point(field_release:libcall_types.libcall_pol.lseek)
  if (has_lseek()) {
    clear_has_libcall_cnt();
      ::libcall_types::lseek_pol* temp = libcall_cnt_.lseek_;
    libcall_cnt_.lseek_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::libcall_types::lseek_pol& libcall_pol::lseek() const {
  // @@protoc_insertion_point(field_get:libcall_types.libcall_pol.lseek)
  return has_lseek()
      ? *libcall_cnt_.lseek_
      : *reinterpret_cast< ::libcall_types::lseek_pol*>(&::libcall_types::_lseek_pol_default_instance_);
}
inline ::libcall_types::lseek_pol* libcall_pol::mutable_lseek() {
  if (!has_lseek()) {
    clear_libcall_cnt();
    set_has_lseek();
    libcall_cnt_.lseek_ = CreateMaybeMessage< ::libcall_types::lseek_pol >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:libcall_types.libcall_pol.lseek)
  return libcall_cnt_.lseek_;
}

// optional .libcall_types.fread_pol fread = 32;
inline bool libcall_pol::has_fread() const {
  return libcall_cnt_case() == kFread;
}
inline void libcall_pol::set_has_fread() {
  _oneof_case_[0] = kFread;
}
inline void libcall_pol::clear_fread() {
  if (has_fread()) {
    delete libcall_cnt_.fread_;
    clear_has_libcall_cnt();
  }
}
inline ::libcall_types::fread_pol* libcall_pol::release_fread() {
  // @@protoc_insertion_point(field_release:libcall_types.libcall_pol.fread)
  if (has_fread()) {
    clear_has_libcall_cnt();
      ::libcall_types::fread_pol* temp = libcall_cnt_.fread_;
    libcall_cnt_.fread_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::libcall_types::fread_pol& libcall_pol::fread() const {
  // @@protoc_insertion_point(field_get:libcall_types.libcall_pol.fread)
  return has_fread()
      ? *libcall_cnt_.fread_
      : *reinterpret_cast< ::libcall_types::fread_pol*>(&::libcall_types::_fread_pol_default_instance_);
}
inline ::libcall_types::fread_pol* libcall_pol::mutable_fread() {
  if (!has_fread()) {
    clear_libcall_cnt();
    set_has_fread();
    libcall_cnt_.fread_ = CreateMaybeMessage< ::libcall_types::fread_pol >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:libcall_types.libcall_pol.fread)
  return libcall_cnt_.fread_;
}

// optional .libcall_types.strncmp_pol strncmp = 33;
inline bool libcall_pol::has_strncmp() const {
  return libcall_cnt_case() == kStrncmp;
}
inline void libcall_pol::set_has_strncmp() {
  _oneof_case_[0] = kStrncmp;
}
inline void libcall_pol::clear_strncmp() {
  if (has_strncmp()) {
    delete libcall_cnt_.strncmp_;
    clear_has_libcall_cnt();
  }
}
inline ::libcall_types::strncmp_pol* libcall_pol::release_strncmp() {
  // @@protoc_insertion_point(field_release:libcall_types.libcall_pol.strncmp)
  if (has_strncmp()) {
    clear_has_libcall_cnt();
      ::libcall_types::strncmp_pol* temp = libcall_cnt_.strncmp_;
    libcall_cnt_.strncmp_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::libcall_types::strncmp_pol& libcall_pol::strncmp() const {
  // @@protoc_insertion_point(field_get:libcall_types.libcall_pol.strncmp)
  return has_strncmp()
      ? *libcall_cnt_.strncmp_
      : *reinterpret_cast< ::libcall_types::strncmp_pol*>(&::libcall_types::_strncmp_pol_default_instance_);
}
inline ::libcall_types::strncmp_pol* libcall_pol::mutable_strncmp() {
  if (!has_strncmp()) {
    clear_libcall_cnt();
    set_has_strncmp();
    libcall_cnt_.strncmp_ = CreateMaybeMessage< ::libcall_types::strncmp_pol >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:libcall_types.libcall_pol.strncmp)
  return libcall_cnt_.strncmp_;
}

// optional .libcall_types.memcmp_pol memcmp = 34;
inline bool libcall_pol::has_memcmp() const {
  return libcall_cnt_case() == kMemcmp;
}
inline void libcall_pol::set_has_memcmp() {
  _oneof_case_[0] = kMemcmp;
}
inline void libcall_pol::clear_memcmp() {
  if (has_memcmp()) {
    delete libcall_cnt_.memcmp_;
    clear_has_libcall_cnt();
  }
}
inline ::libcall_types::memcmp_pol* libcall_pol::release_memcmp() {
  // @@protoc_insertion_point(field_release:libcall_types.libcall_pol.memcmp)
  if (has_memcmp()) {
    clear_has_libcall_cnt();
      ::libcall_types::memcmp_pol* temp = libcall_cnt_.memcmp_;
    libcall_cnt_.memcmp_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::libcall_types::memcmp_pol& libcall_pol::memcmp() const {
  // @@protoc_insertion_point(field_get:libcall_types.libcall_pol.memcmp)
  return has_memcmp()
      ? *libcall_cnt_.memcmp_
      : *reinterpret_cast< ::libcall_types::memcmp_pol*>(&::libcall_types::_memcmp_pol_default_instance_);
}
inline ::libcall_types::memcmp_pol* libcall_pol::mutable_memcmp() {
  if (!has_memcmp()) {
    clear_libcall_cnt();
    set_has_memcmp();
    libcall_cnt_.memcmp_ = CreateMaybeMessage< ::libcall_types::memcmp_pol >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:libcall_types.libcall_pol.memcmp)
  return libcall_cnt_.memcmp_;
}

// optional .libcall_types.fxstat64_pol fxstat64 = 35;
inline bool libcall_pol::has_fxstat64() const {
  return libcall_cnt_case() == kFxstat64;
}
inline void libcall_pol::set_has_fxstat64() {
  _oneof_case_[0] = kFxstat64;
}
inline void libcall_pol::clear_fxstat64() {
  if (has_fxstat64()) {
    delete libcall_cnt_.fxstat64_;
    clear_has_libcall_cnt();
  }
}
inline ::libcall_types::fxstat64_pol* libcall_pol::release_fxstat64() {
  // @@protoc_insertion_point(field_release:libcall_types.libcall_pol.fxstat64)
  if (has_fxstat64()) {
    clear_has_libcall_cnt();
      ::libcall_types::fxstat64_pol* temp = libcall_cnt_.fxstat64_;
    libcall_cnt_.fxstat64_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::libcall_types::fxstat64_pol& libcall_pol::fxstat64() const {
  // @@protoc_insertion_point(field_get:libcall_types.libcall_pol.fxstat64)
  return has_fxstat64()
      ? *libcall_cnt_.fxstat64_
      : *reinterpret_cast< ::libcall_types::fxstat64_pol*>(&::libcall_types::_fxstat64_pol_default_instance_);
}
inline ::libcall_types::fxstat64_pol* libcall_pol::mutable_fxstat64() {
  if (!has_fxstat64()) {
    clear_libcall_cnt();
    set_has_fxstat64();
    libcall_cnt_.fxstat64_ = CreateMaybeMessage< ::libcall_types::fxstat64_pol >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:libcall_types.libcall_pol.fxstat64)
  return libcall_cnt_.fxstat64_;
}

// optional .libcall_types.generic_pol generic = 50;
inline bool libcall_pol::has_generic() const {
  return libcall_cnt_case() == kGeneric;
}
inline void libcall_pol::set_has_generic() {
  _oneof_case_[0] = kGeneric;
}
inline void libcall_pol::clear_generic() {
  if (has_generic()) {
    delete libcall_cnt_.generic_;
    clear_has_libcall_cnt();
  }
}
inline ::libcall_types::generic_pol* libcall_pol::release_generic() {
  // @@protoc_insertion_point(field_release:libcall_types.libcall_pol.generic)
  if (has_generic()) {
    clear_has_libcall_cnt();
      ::libcall_types::generic_pol* temp = libcall_cnt_.generic_;
    libcall_cnt_.generic_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::libcall_types::generic_pol& libcall_pol::generic() const {
  // @@protoc_insertion_point(field_get:libcall_types.libcall_pol.generic)
  return has_generic()
      ? *libcall_cnt_.generic_
      : *reinterpret_cast< ::libcall_types::generic_pol*>(&::libcall_types::_generic_pol_default_instance_);
}
inline ::libcall_types::generic_pol* libcall_pol::mutable_generic() {
  if (!has_generic()) {
    clear_libcall_cnt();
    set_has_generic();
    libcall_cnt_.generic_ = CreateMaybeMessage< ::libcall_types::generic_pol >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:libcall_types.libcall_pol.generic)
  return libcall_cnt_.generic_;
}

inline bool libcall_pol::has_libcall_cnt() const {
  return libcall_cnt_case() != LIBCALL_CNT_NOT_SET;
}
inline void libcall_pol::clear_has_libcall_cnt() {
  _oneof_case_[0] = LIBCALL_CNT_NOT_SET;
}
inline libcall_pol::LibcallCntCase libcall_pol::libcall_cnt_case() const {
  return libcall_pol::LibcallCntCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// libcall_t

// required uint64 func_addr = 1;
inline bool libcall_t::has_func_addr() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void libcall_t::clear_func_addr() {
  func_addr_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 libcall_t::func_addr() const {
  // @@protoc_insertion_point(field_get:libcall_types.libcall_t.func_addr)
  return func_addr_;
}
inline void libcall_t::set_func_addr(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000002u;
  func_addr_ = value;
  // @@protoc_insertion_point(field_set:libcall_types.libcall_t.func_addr)
}

// required string func_name = 2;
inline bool libcall_t::has_func_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void libcall_t::clear_func_name() {
  func_name_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& libcall_t::func_name() const {
  // @@protoc_insertion_point(field_get:libcall_types.libcall_t.func_name)
  return func_name_.GetNoArena();
}
inline void libcall_t::set_func_name(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  func_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:libcall_types.libcall_t.func_name)
}
inline void libcall_t::set_func_name(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  func_name_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:libcall_types.libcall_t.func_name)
}
inline void libcall_t::set_func_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  func_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:libcall_types.libcall_t.func_name)
}
inline void libcall_t::set_func_name(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  func_name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:libcall_types.libcall_t.func_name)
}
inline std::string* libcall_t::mutable_func_name() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:libcall_types.libcall_t.func_name)
  return func_name_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* libcall_t::release_func_name() {
  // @@protoc_insertion_point(field_release:libcall_types.libcall_t.func_name)
  if (!has_func_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return func_name_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void libcall_t::set_allocated_func_name(std::string* func_name) {
  if (func_name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  func_name_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), func_name);
  // @@protoc_insertion_point(field_set_allocated:libcall_types.libcall_t.func_name)
}

// required bool is_traced = 3;
inline bool libcall_t::has_is_traced() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void libcall_t::clear_is_traced() {
  is_traced_ = false;
  _has_bits_[0] &= ~0x00000004u;
}
inline bool libcall_t::is_traced() const {
  // @@protoc_insertion_point(field_get:libcall_types.libcall_t.is_traced)
  return is_traced_;
}
inline void libcall_t::set_is_traced(bool value) {
  _has_bits_[0] |= 0x00000004u;
  is_traced_ = value;
  // @@protoc_insertion_point(field_set:libcall_types.libcall_t.is_traced)
}

// required .libcall_types.lib_ident ident = 4;
inline bool libcall_t::has_ident() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void libcall_t::clear_ident() {
  ident_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::libcall_types::lib_ident libcall_t::ident() const {
  // @@protoc_insertion_point(field_get:libcall_types.libcall_t.ident)
  return static_cast< ::libcall_types::lib_ident >(ident_);
}
inline void libcall_t::set_ident(::libcall_types::lib_ident value) {
  assert(::libcall_types::lib_ident_IsValid(value));
  _has_bits_[0] |= 0x00000008u;
  ident_ = value;
  // @@protoc_insertion_point(field_set:libcall_types.libcall_t.ident)
}

// optional .libcall_types.strcpy_t strcpy = 5;
inline bool libcall_t::has_strcpy() const {
  return libcall_cnt_case() == kStrcpy;
}
inline void libcall_t::set_has_strcpy() {
  _oneof_case_[0] = kStrcpy;
}
inline void libcall_t::clear_strcpy() {
  if (has_strcpy()) {
    delete libcall_cnt_.strcpy_;
    clear_has_libcall_cnt();
  }
}
inline ::libcall_types::strcpy_t* libcall_t::release_strcpy() {
  // @@protoc_insertion_point(field_release:libcall_types.libcall_t.strcpy)
  if (has_strcpy()) {
    clear_has_libcall_cnt();
      ::libcall_types::strcpy_t* temp = libcall_cnt_.strcpy_;
    libcall_cnt_.strcpy_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::libcall_types::strcpy_t& libcall_t::strcpy() const {
  // @@protoc_insertion_point(field_get:libcall_types.libcall_t.strcpy)
  return has_strcpy()
      ? *libcall_cnt_.strcpy_
      : *reinterpret_cast< ::libcall_types::strcpy_t*>(&::libcall_types::_strcpy_t_default_instance_);
}
inline ::libcall_types::strcpy_t* libcall_t::mutable_strcpy() {
  if (!has_strcpy()) {
    clear_libcall_cnt();
    set_has_strcpy();
    libcall_cnt_.strcpy_ = CreateMaybeMessage< ::libcall_types::strcpy_t >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:libcall_types.libcall_t.strcpy)
  return libcall_cnt_.strcpy_;
}

// optional .libcall_types.printf_t printf = 6;
inline bool libcall_t::has_printf() const {
  return libcall_cnt_case() == kPrintf;
}
inline void libcall_t::set_has_printf() {
  _oneof_case_[0] = kPrintf;
}
inline void libcall_t::clear_printf() {
  if (has_printf()) {
    delete libcall_cnt_.printf_;
    clear_has_libcall_cnt();
  }
}
inline ::libcall_types::printf_t* libcall_t::release_printf() {
  // @@protoc_insertion_point(field_release:libcall_types.libcall_t.printf)
  if (has_printf()) {
    clear_has_libcall_cnt();
      ::libcall_types::printf_t* temp = libcall_cnt_.printf_;
    libcall_cnt_.printf_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::libcall_types::printf_t& libcall_t::printf() const {
  // @@protoc_insertion_point(field_get:libcall_types.libcall_t.printf)
  return has_printf()
      ? *libcall_cnt_.printf_
      : *reinterpret_cast< ::libcall_types::printf_t*>(&::libcall_types::_printf_t_default_instance_);
}
inline ::libcall_types::printf_t* libcall_t::mutable_printf() {
  if (!has_printf()) {
    clear_libcall_cnt();
    set_has_printf();
    libcall_cnt_.printf_ = CreateMaybeMessage< ::libcall_types::printf_t >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:libcall_types.libcall_t.printf)
  return libcall_cnt_.printf_;
}

// optional .libcall_types.atoi_t atoi = 7;
inline bool libcall_t::has_atoi() const {
  return libcall_cnt_case() == kAtoi;
}
inline void libcall_t::set_has_atoi() {
  _oneof_case_[0] = kAtoi;
}
inline void libcall_t::clear_atoi() {
  if (has_atoi()) {
    delete libcall_cnt_.atoi_;
    clear_has_libcall_cnt();
  }
}
inline ::libcall_types::atoi_t* libcall_t::release_atoi() {
  // @@protoc_insertion_point(field_release:libcall_types.libcall_t.atoi)
  if (has_atoi()) {
    clear_has_libcall_cnt();
      ::libcall_types::atoi_t* temp = libcall_cnt_.atoi_;
    libcall_cnt_.atoi_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::libcall_types::atoi_t& libcall_t::atoi() const {
  // @@protoc_insertion_point(field_get:libcall_types.libcall_t.atoi)
  return has_atoi()
      ? *libcall_cnt_.atoi_
      : *reinterpret_cast< ::libcall_types::atoi_t*>(&::libcall_types::_atoi_t_default_instance_);
}
inline ::libcall_types::atoi_t* libcall_t::mutable_atoi() {
  if (!has_atoi()) {
    clear_libcall_cnt();
    set_has_atoi();
    libcall_cnt_.atoi_ = CreateMaybeMessage< ::libcall_types::atoi_t >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:libcall_types.libcall_t.atoi)
  return libcall_cnt_.atoi_;
}

// optional .libcall_types.malloc_t malloc = 8;
inline bool libcall_t::has_malloc() const {
  return libcall_cnt_case() == kMalloc;
}
inline void libcall_t::set_has_malloc() {
  _oneof_case_[0] = kMalloc;
}
inline void libcall_t::clear_malloc() {
  if (has_malloc()) {
    delete libcall_cnt_.malloc_;
    clear_has_libcall_cnt();
  }
}
inline ::libcall_types::malloc_t* libcall_t::release_malloc() {
  // @@protoc_insertion_point(field_release:libcall_types.libcall_t.malloc)
  if (has_malloc()) {
    clear_has_libcall_cnt();
      ::libcall_types::malloc_t* temp = libcall_cnt_.malloc_;
    libcall_cnt_.malloc_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::libcall_types::malloc_t& libcall_t::malloc() const {
  // @@protoc_insertion_point(field_get:libcall_types.libcall_t.malloc)
  return has_malloc()
      ? *libcall_cnt_.malloc_
      : *reinterpret_cast< ::libcall_types::malloc_t*>(&::libcall_types::_malloc_t_default_instance_);
}
inline ::libcall_types::malloc_t* libcall_t::mutable_malloc() {
  if (!has_malloc()) {
    clear_libcall_cnt();
    set_has_malloc();
    libcall_cnt_.malloc_ = CreateMaybeMessage< ::libcall_types::malloc_t >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:libcall_types.libcall_t.malloc)
  return libcall_cnt_.malloc_;
}

// optional .libcall_types.getmodulehandle_t getmodulehandle = 9;
inline bool libcall_t::has_getmodulehandle() const {
  return libcall_cnt_case() == kGetmodulehandle;
}
inline void libcall_t::set_has_getmodulehandle() {
  _oneof_case_[0] = kGetmodulehandle;
}
inline void libcall_t::clear_getmodulehandle() {
  if (has_getmodulehandle()) {
    delete libcall_cnt_.getmodulehandle_;
    clear_has_libcall_cnt();
  }
}
inline ::libcall_types::getmodulehandle_t* libcall_t::release_getmodulehandle() {
  // @@protoc_insertion_point(field_release:libcall_types.libcall_t.getmodulehandle)
  if (has_getmodulehandle()) {
    clear_has_libcall_cnt();
      ::libcall_types::getmodulehandle_t* temp = libcall_cnt_.getmodulehandle_;
    libcall_cnt_.getmodulehandle_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::libcall_types::getmodulehandle_t& libcall_t::getmodulehandle() const {
  // @@protoc_insertion_point(field_get:libcall_types.libcall_t.getmodulehandle)
  return has_getmodulehandle()
      ? *libcall_cnt_.getmodulehandle_
      : *reinterpret_cast< ::libcall_types::getmodulehandle_t*>(&::libcall_types::_getmodulehandle_t_default_instance_);
}
inline ::libcall_types::getmodulehandle_t* libcall_t::mutable_getmodulehandle() {
  if (!has_getmodulehandle()) {
    clear_libcall_cnt();
    set_has_getmodulehandle();
    libcall_cnt_.getmodulehandle_ = CreateMaybeMessage< ::libcall_types::getmodulehandle_t >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:libcall_types.libcall_t.getmodulehandle)
  return libcall_cnt_.getmodulehandle_;
}

// optional .libcall_types.getprocaddress_t getprocaddress = 10;
inline bool libcall_t::has_getprocaddress() const {
  return libcall_cnt_case() == kGetprocaddress;
}
inline void libcall_t::set_has_getprocaddress() {
  _oneof_case_[0] = kGetprocaddress;
}
inline void libcall_t::clear_getprocaddress() {
  if (has_getprocaddress()) {
    delete libcall_cnt_.getprocaddress_;
    clear_has_libcall_cnt();
  }
}
inline ::libcall_types::getprocaddress_t* libcall_t::release_getprocaddress() {
  // @@protoc_insertion_point(field_release:libcall_types.libcall_t.getprocaddress)
  if (has_getprocaddress()) {
    clear_has_libcall_cnt();
      ::libcall_types::getprocaddress_t* temp = libcall_cnt_.getprocaddress_;
    libcall_cnt_.getprocaddress_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::libcall_types::getprocaddress_t& libcall_t::getprocaddress() const {
  // @@protoc_insertion_point(field_get:libcall_types.libcall_t.getprocaddress)
  return has_getprocaddress()
      ? *libcall_cnt_.getprocaddress_
      : *reinterpret_cast< ::libcall_types::getprocaddress_t*>(&::libcall_types::_getprocaddress_t_default_instance_);
}
inline ::libcall_types::getprocaddress_t* libcall_t::mutable_getprocaddress() {
  if (!has_getprocaddress()) {
    clear_libcall_cnt();
    set_has_getprocaddress();
    libcall_cnt_.getprocaddress_ = CreateMaybeMessage< ::libcall_types::getprocaddress_t >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:libcall_types.libcall_t.getprocaddress)
  return libcall_cnt_.getprocaddress_;
}

// optional .libcall_types.getmainargs_t getmainargs = 11;
inline bool libcall_t::has_getmainargs() const {
  return libcall_cnt_case() == kGetmainargs;
}
inline void libcall_t::set_has_getmainargs() {
  _oneof_case_[0] = kGetmainargs;
}
inline void libcall_t::clear_getmainargs() {
  if (has_getmainargs()) {
    delete libcall_cnt_.getmainargs_;
    clear_has_libcall_cnt();
  }
}
inline ::libcall_types::getmainargs_t* libcall_t::release_getmainargs() {
  // @@protoc_insertion_point(field_release:libcall_types.libcall_t.getmainargs)
  if (has_getmainargs()) {
    clear_has_libcall_cnt();
      ::libcall_types::getmainargs_t* temp = libcall_cnt_.getmainargs_;
    libcall_cnt_.getmainargs_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::libcall_types::getmainargs_t& libcall_t::getmainargs() const {
  // @@protoc_insertion_point(field_get:libcall_types.libcall_t.getmainargs)
  return has_getmainargs()
      ? *libcall_cnt_.getmainargs_
      : *reinterpret_cast< ::libcall_types::getmainargs_t*>(&::libcall_types::_getmainargs_t_default_instance_);
}
inline ::libcall_types::getmainargs_t* libcall_t::mutable_getmainargs() {
  if (!has_getmainargs()) {
    clear_libcall_cnt();
    set_has_getmainargs();
    libcall_cnt_.getmainargs_ = CreateMaybeMessage< ::libcall_types::getmainargs_t >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:libcall_types.libcall_t.getmainargs)
  return libcall_cnt_.getmainargs_;
}

// optional .libcall_types.gethostname_t gethostname = 12;
inline bool libcall_t::has_gethostname() const {
  return libcall_cnt_case() == kGethostname;
}
inline void libcall_t::set_has_gethostname() {
  _oneof_case_[0] = kGethostname;
}
inline void libcall_t::clear_gethostname() {
  if (has_gethostname()) {
    delete libcall_cnt_.gethostname_;
    clear_has_libcall_cnt();
  }
}
inline ::libcall_types::gethostname_t* libcall_t::release_gethostname() {
  // @@protoc_insertion_point(field_release:libcall_types.libcall_t.gethostname)
  if (has_gethostname()) {
    clear_has_libcall_cnt();
      ::libcall_types::gethostname_t* temp = libcall_cnt_.gethostname_;
    libcall_cnt_.gethostname_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::libcall_types::gethostname_t& libcall_t::gethostname() const {
  // @@protoc_insertion_point(field_get:libcall_types.libcall_t.gethostname)
  return has_gethostname()
      ? *libcall_cnt_.gethostname_
      : *reinterpret_cast< ::libcall_types::gethostname_t*>(&::libcall_types::_gethostname_t_default_instance_);
}
inline ::libcall_types::gethostname_t* libcall_t::mutable_gethostname() {
  if (!has_gethostname()) {
    clear_libcall_cnt();
    set_has_gethostname();
    libcall_cnt_.gethostname_ = CreateMaybeMessage< ::libcall_types::gethostname_t >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:libcall_types.libcall_t.gethostname)
  return libcall_cnt_.gethostname_;
}

// optional .libcall_types.free_t free = 13;
inline bool libcall_t::has_free() const {
  return libcall_cnt_case() == kFree;
}
inline void libcall_t::set_has_free() {
  _oneof_case_[0] = kFree;
}
inline void libcall_t::clear_free() {
  if (has_free()) {
    delete libcall_cnt_.free_;
    clear_has_libcall_cnt();
  }
}
inline ::libcall_types::free_t* libcall_t::release_free() {
  // @@protoc_insertion_point(field_release:libcall_types.libcall_t.free)
  if (has_free()) {
    clear_has_libcall_cnt();
      ::libcall_types::free_t* temp = libcall_cnt_.free_;
    libcall_cnt_.free_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::libcall_types::free_t& libcall_t::free() const {
  // @@protoc_insertion_point(field_get:libcall_types.libcall_t.free)
  return has_free()
      ? *libcall_cnt_.free_
      : *reinterpret_cast< ::libcall_types::free_t*>(&::libcall_types::_free_t_default_instance_);
}
inline ::libcall_types::free_t* libcall_t::mutable_free() {
  if (!has_free()) {
    clear_libcall_cnt();
    set_has_free();
    libcall_cnt_.free_ = CreateMaybeMessage< ::libcall_types::free_t >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:libcall_types.libcall_t.free)
  return libcall_cnt_.free_;
}

// optional .libcall_types.memcpy_t memcpy = 14;
inline bool libcall_t::has_memcpy() const {
  return libcall_cnt_case() == kMemcpy;
}
inline void libcall_t::set_has_memcpy() {
  _oneof_case_[0] = kMemcpy;
}
inline void libcall_t::clear_memcpy() {
  if (has_memcpy()) {
    delete libcall_cnt_.memcpy_;
    clear_has_libcall_cnt();
  }
}
inline ::libcall_types::memcpy_t* libcall_t::release_memcpy() {
  // @@protoc_insertion_point(field_release:libcall_types.libcall_t.memcpy)
  if (has_memcpy()) {
    clear_has_libcall_cnt();
      ::libcall_types::memcpy_t* temp = libcall_cnt_.memcpy_;
    libcall_cnt_.memcpy_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::libcall_types::memcpy_t& libcall_t::memcpy() const {
  // @@protoc_insertion_point(field_get:libcall_types.libcall_t.memcpy)
  return has_memcpy()
      ? *libcall_cnt_.memcpy_
      : *reinterpret_cast< ::libcall_types::memcpy_t*>(&::libcall_types::_memcpy_t_default_instance_);
}
inline ::libcall_types::memcpy_t* libcall_t::mutable_memcpy() {
  if (!has_memcpy()) {
    clear_libcall_cnt();
    set_has_memcpy();
    libcall_cnt_.memcpy_ = CreateMaybeMessage< ::libcall_types::memcpy_t >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:libcall_types.libcall_t.memcpy)
  return libcall_cnt_.memcpy_;
}

// optional .libcall_types.memset_t memset = 15;
inline bool libcall_t::has_memset() const {
  return libcall_cnt_case() == kMemset;
}
inline void libcall_t::set_has_memset() {
  _oneof_case_[0] = kMemset;
}
inline void libcall_t::clear_memset() {
  if (has_memset()) {
    delete libcall_cnt_.memset_;
    clear_has_libcall_cnt();
  }
}
inline ::libcall_types::memset_t* libcall_t::release_memset() {
  // @@protoc_insertion_point(field_release:libcall_types.libcall_t.memset)
  if (has_memset()) {
    clear_has_libcall_cnt();
      ::libcall_types::memset_t* temp = libcall_cnt_.memset_;
    libcall_cnt_.memset_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::libcall_types::memset_t& libcall_t::memset() const {
  // @@protoc_insertion_point(field_get:libcall_types.libcall_t.memset)
  return has_memset()
      ? *libcall_cnt_.memset_
      : *reinterpret_cast< ::libcall_types::memset_t*>(&::libcall_types::_memset_t_default_instance_);
}
inline ::libcall_types::memset_t* libcall_t::mutable_memset() {
  if (!has_memset()) {
    clear_libcall_cnt();
    set_has_memset();
    libcall_cnt_.memset_ = CreateMaybeMessage< ::libcall_types::memset_t >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:libcall_types.libcall_t.memset)
  return libcall_cnt_.memset_;
}

// optional .libcall_types.fgetc_t fgetc = 16;
inline bool libcall_t::has_fgetc() const {
  return libcall_cnt_case() == kFgetc;
}
inline void libcall_t::set_has_fgetc() {
  _oneof_case_[0] = kFgetc;
}
inline void libcall_t::clear_fgetc() {
  if (has_fgetc()) {
    delete libcall_cnt_.fgetc_;
    clear_has_libcall_cnt();
  }
}
inline ::libcall_types::fgetc_t* libcall_t::release_fgetc() {
  // @@protoc_insertion_point(field_release:libcall_types.libcall_t.fgetc)
  if (has_fgetc()) {
    clear_has_libcall_cnt();
      ::libcall_types::fgetc_t* temp = libcall_cnt_.fgetc_;
    libcall_cnt_.fgetc_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::libcall_types::fgetc_t& libcall_t::fgetc() const {
  // @@protoc_insertion_point(field_get:libcall_types.libcall_t.fgetc)
  return has_fgetc()
      ? *libcall_cnt_.fgetc_
      : *reinterpret_cast< ::libcall_types::fgetc_t*>(&::libcall_types::_fgetc_t_default_instance_);
}
inline ::libcall_types::fgetc_t* libcall_t::mutable_fgetc() {
  if (!has_fgetc()) {
    clear_libcall_cnt();
    set_has_fgetc();
    libcall_cnt_.fgetc_ = CreateMaybeMessage< ::libcall_types::fgetc_t >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:libcall_types.libcall_t.fgetc)
  return libcall_cnt_.fgetc_;
}

// optional .libcall_types.generic_t generic = 17;
inline bool libcall_t::has_generic() const {
  return libcall_cnt_case() == kGeneric;
}
inline void libcall_t::set_has_generic() {
  _oneof_case_[0] = kGeneric;
}
inline void libcall_t::clear_generic() {
  if (has_generic()) {
    delete libcall_cnt_.generic_;
    clear_has_libcall_cnt();
  }
}
inline ::libcall_types::generic_t* libcall_t::release_generic() {
  // @@protoc_insertion_point(field_release:libcall_types.libcall_t.generic)
  if (has_generic()) {
    clear_has_libcall_cnt();
      ::libcall_types::generic_t* temp = libcall_cnt_.generic_;
    libcall_cnt_.generic_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::libcall_types::generic_t& libcall_t::generic() const {
  // @@protoc_insertion_point(field_get:libcall_types.libcall_t.generic)
  return has_generic()
      ? *libcall_cnt_.generic_
      : *reinterpret_cast< ::libcall_types::generic_t*>(&::libcall_types::_generic_t_default_instance_);
}
inline ::libcall_types::generic_t* libcall_t::mutable_generic() {
  if (!has_generic()) {
    clear_libcall_cnt();
    set_has_generic();
    libcall_cnt_.generic_ = CreateMaybeMessage< ::libcall_types::generic_t >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:libcall_types.libcall_t.generic)
  return libcall_cnt_.generic_;
}

// optional .libcall_types.read_t read = 18;
inline bool libcall_t::has_read() const {
  return libcall_cnt_case() == kRead;
}
inline void libcall_t::set_has_read() {
  _oneof_case_[0] = kRead;
}
inline void libcall_t::clear_read() {
  if (has_read()) {
    delete libcall_cnt_.read_;
    clear_has_libcall_cnt();
  }
}
inline ::libcall_types::read_t* libcall_t::release_read() {
  // @@protoc_insertion_point(field_release:libcall_types.libcall_t.read)
  if (has_read()) {
    clear_has_libcall_cnt();
      ::libcall_types::read_t* temp = libcall_cnt_.read_;
    libcall_cnt_.read_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::libcall_types::read_t& libcall_t::read() const {
  // @@protoc_insertion_point(field_get:libcall_types.libcall_t.read)
  return has_read()
      ? *libcall_cnt_.read_
      : *reinterpret_cast< ::libcall_types::read_t*>(&::libcall_types::_read_t_default_instance_);
}
inline ::libcall_types::read_t* libcall_t::mutable_read() {
  if (!has_read()) {
    clear_libcall_cnt();
    set_has_read();
    libcall_cnt_.read_ = CreateMaybeMessage< ::libcall_types::read_t >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:libcall_types.libcall_t.read)
  return libcall_cnt_.read_;
}

// optional .libcall_types.strchr_t strchr = 19;
inline bool libcall_t::has_strchr() const {
  return libcall_cnt_case() == kStrchr;
}
inline void libcall_t::set_has_strchr() {
  _oneof_case_[0] = kStrchr;
}
inline void libcall_t::clear_strchr() {
  if (has_strchr()) {
    delete libcall_cnt_.strchr_;
    clear_has_libcall_cnt();
  }
}
inline ::libcall_types::strchr_t* libcall_t::release_strchr() {
  // @@protoc_insertion_point(field_release:libcall_types.libcall_t.strchr)
  if (has_strchr()) {
    clear_has_libcall_cnt();
      ::libcall_types::strchr_t* temp = libcall_cnt_.strchr_;
    libcall_cnt_.strchr_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::libcall_types::strchr_t& libcall_t::strchr() const {
  // @@protoc_insertion_point(field_get:libcall_types.libcall_t.strchr)
  return has_strchr()
      ? *libcall_cnt_.strchr_
      : *reinterpret_cast< ::libcall_types::strchr_t*>(&::libcall_types::_strchr_t_default_instance_);
}
inline ::libcall_types::strchr_t* libcall_t::mutable_strchr() {
  if (!has_strchr()) {
    clear_libcall_cnt();
    set_has_strchr();
    libcall_cnt_.strchr_ = CreateMaybeMessage< ::libcall_types::strchr_t >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:libcall_types.libcall_t.strchr)
  return libcall_cnt_.strchr_;
}

// optional .libcall_types.exit_t exit = 20;
inline bool libcall_t::has_exit() const {
  return libcall_cnt_case() == kExit;
}
inline void libcall_t::set_has_exit() {
  _oneof_case_[0] = kExit;
}
inline void libcall_t::clear_exit() {
  if (has_exit()) {
    delete libcall_cnt_.exit_;
    clear_has_libcall_cnt();
  }
}
inline ::libcall_types::exit_t* libcall_t::release_exit() {
  // @@protoc_insertion_point(field_release:libcall_types.libcall_t.exit)
  if (has_exit()) {
    clear_has_libcall_cnt();
      ::libcall_types::exit_t* temp = libcall_cnt_.exit_;
    libcall_cnt_.exit_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::libcall_types::exit_t& libcall_t::exit() const {
  // @@protoc_insertion_point(field_get:libcall_types.libcall_t.exit)
  return has_exit()
      ? *libcall_cnt_.exit_
      : *reinterpret_cast< ::libcall_types::exit_t*>(&::libcall_types::_exit_t_default_instance_);
}
inline ::libcall_types::exit_t* libcall_t::mutable_exit() {
  if (!has_exit()) {
    clear_libcall_cnt();
    set_has_exit();
    libcall_cnt_.exit_ = CreateMaybeMessage< ::libcall_types::exit_t >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:libcall_types.libcall_t.exit)
  return libcall_cnt_.exit_;
}

// optional .libcall_types.strcmp_t strcmp = 21;
inline bool libcall_t::has_strcmp() const {
  return libcall_cnt_case() == kStrcmp;
}
inline void libcall_t::set_has_strcmp() {
  _oneof_case_[0] = kStrcmp;
}
inline void libcall_t::clear_strcmp() {
  if (has_strcmp()) {
    delete libcall_cnt_.strcmp_;
    clear_has_libcall_cnt();
  }
}
inline ::libcall_types::strcmp_t* libcall_t::release_strcmp() {
  // @@protoc_insertion_point(field_release:libcall_types.libcall_t.strcmp)
  if (has_strcmp()) {
    clear_has_libcall_cnt();
      ::libcall_types::strcmp_t* temp = libcall_cnt_.strcmp_;
    libcall_cnt_.strcmp_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::libcall_types::strcmp_t& libcall_t::strcmp() const {
  // @@protoc_insertion_point(field_get:libcall_types.libcall_t.strcmp)
  return has_strcmp()
      ? *libcall_cnt_.strcmp_
      : *reinterpret_cast< ::libcall_types::strcmp_t*>(&::libcall_types::_strcmp_t_default_instance_);
}
inline ::libcall_types::strcmp_t* libcall_t::mutable_strcmp() {
  if (!has_strcmp()) {
    clear_libcall_cnt();
    set_has_strcmp();
    libcall_cnt_.strcmp_ = CreateMaybeMessage< ::libcall_types::strcmp_t >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:libcall_types.libcall_t.strcmp)
  return libcall_cnt_.strcmp_;
}

// optional .libcall_types.ctype_b_loc_t ctype_b_loc = 23;
inline bool libcall_t::has_ctype_b_loc() const {
  return libcall_cnt_case() == kCtypeBLoc;
}
inline void libcall_t::set_has_ctype_b_loc() {
  _oneof_case_[0] = kCtypeBLoc;
}
inline void libcall_t::clear_ctype_b_loc() {
  if (has_ctype_b_loc()) {
    delete libcall_cnt_.ctype_b_loc_;
    clear_has_libcall_cnt();
  }
}
inline ::libcall_types::ctype_b_loc_t* libcall_t::release_ctype_b_loc() {
  // @@protoc_insertion_point(field_release:libcall_types.libcall_t.ctype_b_loc)
  if (has_ctype_b_loc()) {
    clear_has_libcall_cnt();
      ::libcall_types::ctype_b_loc_t* temp = libcall_cnt_.ctype_b_loc_;
    libcall_cnt_.ctype_b_loc_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::libcall_types::ctype_b_loc_t& libcall_t::ctype_b_loc() const {
  // @@protoc_insertion_point(field_get:libcall_types.libcall_t.ctype_b_loc)
  return has_ctype_b_loc()
      ? *libcall_cnt_.ctype_b_loc_
      : *reinterpret_cast< ::libcall_types::ctype_b_loc_t*>(&::libcall_types::_ctype_b_loc_t_default_instance_);
}
inline ::libcall_types::ctype_b_loc_t* libcall_t::mutable_ctype_b_loc() {
  if (!has_ctype_b_loc()) {
    clear_libcall_cnt();
    set_has_ctype_b_loc();
    libcall_cnt_.ctype_b_loc_ = CreateMaybeMessage< ::libcall_types::ctype_b_loc_t >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:libcall_types.libcall_t.ctype_b_loc)
  return libcall_cnt_.ctype_b_loc_;
}

// optional .libcall_types.fscanf_t fscanf = 24;
inline bool libcall_t::has_fscanf() const {
  return libcall_cnt_case() == kFscanf;
}
inline void libcall_t::set_has_fscanf() {
  _oneof_case_[0] = kFscanf;
}
inline void libcall_t::clear_fscanf() {
  if (has_fscanf()) {
    delete libcall_cnt_.fscanf_;
    clear_has_libcall_cnt();
  }
}
inline ::libcall_types::fscanf_t* libcall_t::release_fscanf() {
  // @@protoc_insertion_point(field_release:libcall_types.libcall_t.fscanf)
  if (has_fscanf()) {
    clear_has_libcall_cnt();
      ::libcall_types::fscanf_t* temp = libcall_cnt_.fscanf_;
    libcall_cnt_.fscanf_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::libcall_types::fscanf_t& libcall_t::fscanf() const {
  // @@protoc_insertion_point(field_get:libcall_types.libcall_t.fscanf)
  return has_fscanf()
      ? *libcall_cnt_.fscanf_
      : *reinterpret_cast< ::libcall_types::fscanf_t*>(&::libcall_types::_fscanf_t_default_instance_);
}
inline ::libcall_types::fscanf_t* libcall_t::mutable_fscanf() {
  if (!has_fscanf()) {
    clear_libcall_cnt();
    set_has_fscanf();
    libcall_cnt_.fscanf_ = CreateMaybeMessage< ::libcall_types::fscanf_t >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:libcall_types.libcall_t.fscanf)
  return libcall_cnt_.fscanf_;
}

// optional .libcall_types.strncpy_t strncpy = 25;
inline bool libcall_t::has_strncpy() const {
  return libcall_cnt_case() == kStrncpy;
}
inline void libcall_t::set_has_strncpy() {
  _oneof_case_[0] = kStrncpy;
}
inline void libcall_t::clear_strncpy() {
  if (has_strncpy()) {
    delete libcall_cnt_.strncpy_;
    clear_has_libcall_cnt();
  }
}
inline ::libcall_types::strncpy_t* libcall_t::release_strncpy() {
  // @@protoc_insertion_point(field_release:libcall_types.libcall_t.strncpy)
  if (has_strncpy()) {
    clear_has_libcall_cnt();
      ::libcall_types::strncpy_t* temp = libcall_cnt_.strncpy_;
    libcall_cnt_.strncpy_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::libcall_types::strncpy_t& libcall_t::strncpy() const {
  // @@protoc_insertion_point(field_get:libcall_types.libcall_t.strncpy)
  return has_strncpy()
      ? *libcall_cnt_.strncpy_
      : *reinterpret_cast< ::libcall_types::strncpy_t*>(&::libcall_types::_strncpy_t_default_instance_);
}
inline ::libcall_types::strncpy_t* libcall_t::mutable_strncpy() {
  if (!has_strncpy()) {
    clear_libcall_cnt();
    set_has_strncpy();
    libcall_cnt_.strncpy_ = CreateMaybeMessage< ::libcall_types::strncpy_t >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:libcall_types.libcall_t.strncpy)
  return libcall_cnt_.strncpy_;
}

// optional .libcall_types.fstat_t fstat = 26;
inline bool libcall_t::has_fstat() const {
  return libcall_cnt_case() == kFstat;
}
inline void libcall_t::set_has_fstat() {
  _oneof_case_[0] = kFstat;
}
inline void libcall_t::clear_fstat() {
  if (has_fstat()) {
    delete libcall_cnt_.fstat_;
    clear_has_libcall_cnt();
  }
}
inline ::libcall_types::fstat_t* libcall_t::release_fstat() {
  // @@protoc_insertion_point(field_release:libcall_types.libcall_t.fstat)
  if (has_fstat()) {
    clear_has_libcall_cnt();
      ::libcall_types::fstat_t* temp = libcall_cnt_.fstat_;
    libcall_cnt_.fstat_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::libcall_types::fstat_t& libcall_t::fstat() const {
  // @@protoc_insertion_point(field_get:libcall_types.libcall_t.fstat)
  return has_fstat()
      ? *libcall_cnt_.fstat_
      : *reinterpret_cast< ::libcall_types::fstat_t*>(&::libcall_types::_fstat_t_default_instance_);
}
inline ::libcall_types::fstat_t* libcall_t::mutable_fstat() {
  if (!has_fstat()) {
    clear_libcall_cnt();
    set_has_fstat();
    libcall_cnt_.fstat_ = CreateMaybeMessage< ::libcall_types::fstat_t >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:libcall_types.libcall_t.fstat)
  return libcall_cnt_.fstat_;
}

// optional .libcall_types.realloc_t realloc = 27;
inline bool libcall_t::has_realloc() const {
  return libcall_cnt_case() == kRealloc;
}
inline void libcall_t::set_has_realloc() {
  _oneof_case_[0] = kRealloc;
}
inline void libcall_t::clear_realloc() {
  if (has_realloc()) {
    delete libcall_cnt_.realloc_;
    clear_has_libcall_cnt();
  }
}
inline ::libcall_types::realloc_t* libcall_t::release_realloc() {
  // @@protoc_insertion_point(field_release:libcall_types.libcall_t.realloc)
  if (has_realloc()) {
    clear_has_libcall_cnt();
      ::libcall_types::realloc_t* temp = libcall_cnt_.realloc_;
    libcall_cnt_.realloc_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::libcall_types::realloc_t& libcall_t::realloc() const {
  // @@protoc_insertion_point(field_get:libcall_types.libcall_t.realloc)
  return has_realloc()
      ? *libcall_cnt_.realloc_
      : *reinterpret_cast< ::libcall_types::realloc_t*>(&::libcall_types::_realloc_t_default_instance_);
}
inline ::libcall_types::realloc_t* libcall_t::mutable_realloc() {
  if (!has_realloc()) {
    clear_libcall_cnt();
    set_has_realloc();
    libcall_cnt_.realloc_ = CreateMaybeMessage< ::libcall_types::realloc_t >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:libcall_types.libcall_t.realloc)
  return libcall_cnt_.realloc_;
}

// optional .libcall_types.mmap_t mmap = 28;
inline bool libcall_t::has_mmap() const {
  return libcall_cnt_case() == kMmap;
}
inline void libcall_t::set_has_mmap() {
  _oneof_case_[0] = kMmap;
}
inline void libcall_t::clear_mmap() {
  if (has_mmap()) {
    delete libcall_cnt_.mmap_;
    clear_has_libcall_cnt();
  }
}
inline ::libcall_types::mmap_t* libcall_t::release_mmap() {
  // @@protoc_insertion_point(field_release:libcall_types.libcall_t.mmap)
  if (has_mmap()) {
    clear_has_libcall_cnt();
      ::libcall_types::mmap_t* temp = libcall_cnt_.mmap_;
    libcall_cnt_.mmap_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::libcall_types::mmap_t& libcall_t::mmap() const {
  // @@protoc_insertion_point(field_get:libcall_types.libcall_t.mmap)
  return has_mmap()
      ? *libcall_cnt_.mmap_
      : *reinterpret_cast< ::libcall_types::mmap_t*>(&::libcall_types::_mmap_t_default_instance_);
}
inline ::libcall_types::mmap_t* libcall_t::mutable_mmap() {
  if (!has_mmap()) {
    clear_libcall_cnt();
    set_has_mmap();
    libcall_cnt_.mmap_ = CreateMaybeMessage< ::libcall_types::mmap_t >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:libcall_types.libcall_t.mmap)
  return libcall_cnt_.mmap_;
}

// optional .libcall_types.qsort_t qsort = 29;
inline bool libcall_t::has_qsort() const {
  return libcall_cnt_case() == kQsort;
}
inline void libcall_t::set_has_qsort() {
  _oneof_case_[0] = kQsort;
}
inline void libcall_t::clear_qsort() {
  if (has_qsort()) {
    delete libcall_cnt_.qsort_;
    clear_has_libcall_cnt();
  }
}
inline ::libcall_types::qsort_t* libcall_t::release_qsort() {
  // @@protoc_insertion_point(field_release:libcall_types.libcall_t.qsort)
  if (has_qsort()) {
    clear_has_libcall_cnt();
      ::libcall_types::qsort_t* temp = libcall_cnt_.qsort_;
    libcall_cnt_.qsort_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::libcall_types::qsort_t& libcall_t::qsort() const {
  // @@protoc_insertion_point(field_get:libcall_types.libcall_t.qsort)
  return has_qsort()
      ? *libcall_cnt_.qsort_
      : *reinterpret_cast< ::libcall_types::qsort_t*>(&::libcall_types::_qsort_t_default_instance_);
}
inline ::libcall_types::qsort_t* libcall_t::mutable_qsort() {
  if (!has_qsort()) {
    clear_libcall_cnt();
    set_has_qsort();
    libcall_cnt_.qsort_ = CreateMaybeMessage< ::libcall_types::qsort_t >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:libcall_types.libcall_t.qsort)
  return libcall_cnt_.qsort_;
}

// optional .libcall_types.bsearch_t bsearch = 30;
inline bool libcall_t::has_bsearch() const {
  return libcall_cnt_case() == kBsearch;
}
inline void libcall_t::set_has_bsearch() {
  _oneof_case_[0] = kBsearch;
}
inline void libcall_t::clear_bsearch() {
  if (has_bsearch()) {
    delete libcall_cnt_.bsearch_;
    clear_has_libcall_cnt();
  }
}
inline ::libcall_types::bsearch_t* libcall_t::release_bsearch() {
  // @@protoc_insertion_point(field_release:libcall_types.libcall_t.bsearch)
  if (has_bsearch()) {
    clear_has_libcall_cnt();
      ::libcall_types::bsearch_t* temp = libcall_cnt_.bsearch_;
    libcall_cnt_.bsearch_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::libcall_types::bsearch_t& libcall_t::bsearch() const {
  // @@protoc_insertion_point(field_get:libcall_types.libcall_t.bsearch)
  return has_bsearch()
      ? *libcall_cnt_.bsearch_
      : *reinterpret_cast< ::libcall_types::bsearch_t*>(&::libcall_types::_bsearch_t_default_instance_);
}
inline ::libcall_types::bsearch_t* libcall_t::mutable_bsearch() {
  if (!has_bsearch()) {
    clear_libcall_cnt();
    set_has_bsearch();
    libcall_cnt_.bsearch_ = CreateMaybeMessage< ::libcall_types::bsearch_t >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:libcall_types.libcall_t.bsearch)
  return libcall_cnt_.bsearch_;
}

// optional .libcall_types.open_t open_stub = 31;
inline bool libcall_t::has_open_stub() const {
  return libcall_cnt_case() == kOpenStub;
}
inline void libcall_t::set_has_open_stub() {
  _oneof_case_[0] = kOpenStub;
}
inline void libcall_t::clear_open_stub() {
  if (has_open_stub()) {
    delete libcall_cnt_.open_stub_;
    clear_has_libcall_cnt();
  }
}
inline ::libcall_types::open_t* libcall_t::release_open_stub() {
  // @@protoc_insertion_point(field_release:libcall_types.libcall_t.open_stub)
  if (has_open_stub()) {
    clear_has_libcall_cnt();
      ::libcall_types::open_t* temp = libcall_cnt_.open_stub_;
    libcall_cnt_.open_stub_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::libcall_types::open_t& libcall_t::open_stub() const {
  // @@protoc_insertion_point(field_get:libcall_types.libcall_t.open_stub)
  return has_open_stub()
      ? *libcall_cnt_.open_stub_
      : *reinterpret_cast< ::libcall_types::open_t*>(&::libcall_types::_open_t_default_instance_);
}
inline ::libcall_types::open_t* libcall_t::mutable_open_stub() {
  if (!has_open_stub()) {
    clear_libcall_cnt();
    set_has_open_stub();
    libcall_cnt_.open_stub_ = CreateMaybeMessage< ::libcall_types::open_t >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:libcall_types.libcall_t.open_stub)
  return libcall_cnt_.open_stub_;
}

// optional .libcall_types.lseek_t lseek = 32;
inline bool libcall_t::has_lseek() const {
  return libcall_cnt_case() == kLseek;
}
inline void libcall_t::set_has_lseek() {
  _oneof_case_[0] = kLseek;
}
inline void libcall_t::clear_lseek() {
  if (has_lseek()) {
    delete libcall_cnt_.lseek_;
    clear_has_libcall_cnt();
  }
}
inline ::libcall_types::lseek_t* libcall_t::release_lseek() {
  // @@protoc_insertion_point(field_release:libcall_types.libcall_t.lseek)
  if (has_lseek()) {
    clear_has_libcall_cnt();
      ::libcall_types::lseek_t* temp = libcall_cnt_.lseek_;
    libcall_cnt_.lseek_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::libcall_types::lseek_t& libcall_t::lseek() const {
  // @@protoc_insertion_point(field_get:libcall_types.libcall_t.lseek)
  return has_lseek()
      ? *libcall_cnt_.lseek_
      : *reinterpret_cast< ::libcall_types::lseek_t*>(&::libcall_types::_lseek_t_default_instance_);
}
inline ::libcall_types::lseek_t* libcall_t::mutable_lseek() {
  if (!has_lseek()) {
    clear_libcall_cnt();
    set_has_lseek();
    libcall_cnt_.lseek_ = CreateMaybeMessage< ::libcall_types::lseek_t >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:libcall_types.libcall_t.lseek)
  return libcall_cnt_.lseek_;
}

// optional .libcall_types.fread_t fread = 33;
inline bool libcall_t::has_fread() const {
  return libcall_cnt_case() == kFread;
}
inline void libcall_t::set_has_fread() {
  _oneof_case_[0] = kFread;
}
inline void libcall_t::clear_fread() {
  if (has_fread()) {
    delete libcall_cnt_.fread_;
    clear_has_libcall_cnt();
  }
}
inline ::libcall_types::fread_t* libcall_t::release_fread() {
  // @@protoc_insertion_point(field_release:libcall_types.libcall_t.fread)
  if (has_fread()) {
    clear_has_libcall_cnt();
      ::libcall_types::fread_t* temp = libcall_cnt_.fread_;
    libcall_cnt_.fread_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::libcall_types::fread_t& libcall_t::fread() const {
  // @@protoc_insertion_point(field_get:libcall_types.libcall_t.fread)
  return has_fread()
      ? *libcall_cnt_.fread_
      : *reinterpret_cast< ::libcall_types::fread_t*>(&::libcall_types::_fread_t_default_instance_);
}
inline ::libcall_types::fread_t* libcall_t::mutable_fread() {
  if (!has_fread()) {
    clear_libcall_cnt();
    set_has_fread();
    libcall_cnt_.fread_ = CreateMaybeMessage< ::libcall_types::fread_t >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:libcall_types.libcall_t.fread)
  return libcall_cnt_.fread_;
}

// optional .libcall_types.strncmp_t strncmp = 34;
inline bool libcall_t::has_strncmp() const {
  return libcall_cnt_case() == kStrncmp;
}
inline void libcall_t::set_has_strncmp() {
  _oneof_case_[0] = kStrncmp;
}
inline void libcall_t::clear_strncmp() {
  if (has_strncmp()) {
    delete libcall_cnt_.strncmp_;
    clear_has_libcall_cnt();
  }
}
inline ::libcall_types::strncmp_t* libcall_t::release_strncmp() {
  // @@protoc_insertion_point(field_release:libcall_types.libcall_t.strncmp)
  if (has_strncmp()) {
    clear_has_libcall_cnt();
      ::libcall_types::strncmp_t* temp = libcall_cnt_.strncmp_;
    libcall_cnt_.strncmp_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::libcall_types::strncmp_t& libcall_t::strncmp() const {
  // @@protoc_insertion_point(field_get:libcall_types.libcall_t.strncmp)
  return has_strncmp()
      ? *libcall_cnt_.strncmp_
      : *reinterpret_cast< ::libcall_types::strncmp_t*>(&::libcall_types::_strncmp_t_default_instance_);
}
inline ::libcall_types::strncmp_t* libcall_t::mutable_strncmp() {
  if (!has_strncmp()) {
    clear_libcall_cnt();
    set_has_strncmp();
    libcall_cnt_.strncmp_ = CreateMaybeMessage< ::libcall_types::strncmp_t >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:libcall_types.libcall_t.strncmp)
  return libcall_cnt_.strncmp_;
}

// optional .libcall_types.memcmp_t memcmp = 35;
inline bool libcall_t::has_memcmp() const {
  return libcall_cnt_case() == kMemcmp;
}
inline void libcall_t::set_has_memcmp() {
  _oneof_case_[0] = kMemcmp;
}
inline void libcall_t::clear_memcmp() {
  if (has_memcmp()) {
    delete libcall_cnt_.memcmp_;
    clear_has_libcall_cnt();
  }
}
inline ::libcall_types::memcmp_t* libcall_t::release_memcmp() {
  // @@protoc_insertion_point(field_release:libcall_types.libcall_t.memcmp)
  if (has_memcmp()) {
    clear_has_libcall_cnt();
      ::libcall_types::memcmp_t* temp = libcall_cnt_.memcmp_;
    libcall_cnt_.memcmp_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::libcall_types::memcmp_t& libcall_t::memcmp() const {
  // @@protoc_insertion_point(field_get:libcall_types.libcall_t.memcmp)
  return has_memcmp()
      ? *libcall_cnt_.memcmp_
      : *reinterpret_cast< ::libcall_types::memcmp_t*>(&::libcall_types::_memcmp_t_default_instance_);
}
inline ::libcall_types::memcmp_t* libcall_t::mutable_memcmp() {
  if (!has_memcmp()) {
    clear_libcall_cnt();
    set_has_memcmp();
    libcall_cnt_.memcmp_ = CreateMaybeMessage< ::libcall_types::memcmp_t >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:libcall_types.libcall_t.memcmp)
  return libcall_cnt_.memcmp_;
}

// optional .libcall_types.fxstat64_t fxstat64 = 36;
inline bool libcall_t::has_fxstat64() const {
  return libcall_cnt_case() == kFxstat64;
}
inline void libcall_t::set_has_fxstat64() {
  _oneof_case_[0] = kFxstat64;
}
inline void libcall_t::clear_fxstat64() {
  if (has_fxstat64()) {
    delete libcall_cnt_.fxstat64_;
    clear_has_libcall_cnt();
  }
}
inline ::libcall_types::fxstat64_t* libcall_t::release_fxstat64() {
  // @@protoc_insertion_point(field_release:libcall_types.libcall_t.fxstat64)
  if (has_fxstat64()) {
    clear_has_libcall_cnt();
      ::libcall_types::fxstat64_t* temp = libcall_cnt_.fxstat64_;
    libcall_cnt_.fxstat64_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::libcall_types::fxstat64_t& libcall_t::fxstat64() const {
  // @@protoc_insertion_point(field_get:libcall_types.libcall_t.fxstat64)
  return has_fxstat64()
      ? *libcall_cnt_.fxstat64_
      : *reinterpret_cast< ::libcall_types::fxstat64_t*>(&::libcall_types::_fxstat64_t_default_instance_);
}
inline ::libcall_types::fxstat64_t* libcall_t::mutable_fxstat64() {
  if (!has_fxstat64()) {
    clear_libcall_cnt();
    set_has_fxstat64();
    libcall_cnt_.fxstat64_ = CreateMaybeMessage< ::libcall_types::fxstat64_t >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:libcall_types.libcall_t.fxstat64)
  return libcall_cnt_.fxstat64_;
}

inline bool libcall_t::has_libcall_cnt() const {
  return libcall_cnt_case() != LIBCALL_CNT_NOT_SET;
}
inline void libcall_t::clear_has_libcall_cnt() {
  _oneof_case_[0] = LIBCALL_CNT_NOT_SET;
}
inline libcall_t::LibcallCntCase libcall_t::libcall_cnt_case() const {
  return libcall_t::LibcallCntCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// generic_pol

// required .common.action ret = 1;
inline bool generic_pol::has_ret() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void generic_pol::clear_ret() {
  ret_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::common::action generic_pol::ret() const {
  // @@protoc_insertion_point(field_get:libcall_types.generic_pol.ret)
  return static_cast< ::common::action >(ret_);
}
inline void generic_pol::set_ret(::common::action value) {
  assert(::common::action_IsValid(value));
  _has_bits_[0] |= 0x00000001u;
  ret_ = value;
  // @@protoc_insertion_point(field_set:libcall_types.generic_pol.ret)
}

// -------------------------------------------------------------------

// ctype_b_loc_pol

// required .common.memory_pol table = 1;
inline bool ctype_b_loc_pol::has_table() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline const ::common::memory_pol& ctype_b_loc_pol::table() const {
  const ::common::memory_pol* p = table_;
  // @@protoc_insertion_point(field_get:libcall_types.ctype_b_loc_pol.table)
  return p != nullptr ? *p : *reinterpret_cast<const ::common::memory_pol*>(
      &::common::_memory_pol_default_instance_);
}
inline ::common::memory_pol* ctype_b_loc_pol::release_table() {
  // @@protoc_insertion_point(field_release:libcall_types.ctype_b_loc_pol.table)
  _has_bits_[0] &= ~0x00000001u;
  ::common::memory_pol* temp = table_;
  table_ = nullptr;
  return temp;
}
inline ::common::memory_pol* ctype_b_loc_pol::mutable_table() {
  _has_bits_[0] |= 0x00000001u;
  if (table_ == nullptr) {
    auto* p = CreateMaybeMessage<::common::memory_pol>(GetArenaNoVirtual());
    table_ = p;
  }
  // @@protoc_insertion_point(field_mutable:libcall_types.ctype_b_loc_pol.table)
  return table_;
}
inline void ctype_b_loc_pol::set_allocated_table(::common::memory_pol* table) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(table_);
  }
  if (table) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      table = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, table, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  table_ = table;
  // @@protoc_insertion_point(field_set_allocated:libcall_types.ctype_b_loc_pol.table)
}

// required .common.action ret = 2;
inline bool ctype_b_loc_pol::has_ret() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ctype_b_loc_pol::clear_ret() {
  ret_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::common::action ctype_b_loc_pol::ret() const {
  // @@protoc_insertion_point(field_get:libcall_types.ctype_b_loc_pol.ret)
  return static_cast< ::common::action >(ret_);
}
inline void ctype_b_loc_pol::set_ret(::common::action value) {
  assert(::common::action_IsValid(value));
  _has_bits_[0] |= 0x00000002u;
  ret_ = value;
  // @@protoc_insertion_point(field_set:libcall_types.ctype_b_loc_pol.ret)
}

// -------------------------------------------------------------------

// exit_pol

// -------------------------------------------------------------------

// fscanf_pol

// required .common.action stream = 1;
inline bool fscanf_pol::has_stream() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void fscanf_pol::clear_stream() {
  stream_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::common::action fscanf_pol::stream() const {
  // @@protoc_insertion_point(field_get:libcall_types.fscanf_pol.stream)
  return static_cast< ::common::action >(stream_);
}
inline void fscanf_pol::set_stream(::common::action value) {
  assert(::common::action_IsValid(value));
  _has_bits_[0] |= 0x00000001u;
  stream_ = value;
  // @@protoc_insertion_point(field_set:libcall_types.fscanf_pol.stream)
}

// required .common.action elems = 2;
inline bool fscanf_pol::has_elems() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void fscanf_pol::clear_elems() {
  elems_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::common::action fscanf_pol::elems() const {
  // @@protoc_insertion_point(field_get:libcall_types.fscanf_pol.elems)
  return static_cast< ::common::action >(elems_);
}
inline void fscanf_pol::set_elems(::common::action value) {
  assert(::common::action_IsValid(value));
  _has_bits_[0] |= 0x00000002u;
  elems_ = value;
  // @@protoc_insertion_point(field_set:libcall_types.fscanf_pol.elems)
}

// required .common.action ret = 3;
inline bool fscanf_pol::has_ret() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void fscanf_pol::clear_ret() {
  ret_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::common::action fscanf_pol::ret() const {
  // @@protoc_insertion_point(field_get:libcall_types.fscanf_pol.ret)
  return static_cast< ::common::action >(ret_);
}
inline void fscanf_pol::set_ret(::common::action value) {
  assert(::common::action_IsValid(value));
  _has_bits_[0] |= 0x00000004u;
  ret_ = value;
  // @@protoc_insertion_point(field_set:libcall_types.fscanf_pol.ret)
}

// -------------------------------------------------------------------

// read_pol

// required .common.action fd = 1;
inline bool read_pol::has_fd() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void read_pol::clear_fd() {
  fd_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::common::action read_pol::fd() const {
  // @@protoc_insertion_point(field_get:libcall_types.read_pol.fd)
  return static_cast< ::common::action >(fd_);
}
inline void read_pol::set_fd(::common::action value) {
  assert(::common::action_IsValid(value));
  _has_bits_[0] |= 0x00000002u;
  fd_ = value;
  // @@protoc_insertion_point(field_set:libcall_types.read_pol.fd)
}

// required .common.memory_pol buf = 2;
inline bool read_pol::has_buf() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline const ::common::memory_pol& read_pol::buf() const {
  const ::common::memory_pol* p = buf_;
  // @@protoc_insertion_point(field_get:libcall_types.read_pol.buf)
  return p != nullptr ? *p : *reinterpret_cast<const ::common::memory_pol*>(
      &::common::_memory_pol_default_instance_);
}
inline ::common::memory_pol* read_pol::release_buf() {
  // @@protoc_insertion_point(field_release:libcall_types.read_pol.buf)
  _has_bits_[0] &= ~0x00000001u;
  ::common::memory_pol* temp = buf_;
  buf_ = nullptr;
  return temp;
}
inline ::common::memory_pol* read_pol::mutable_buf() {
  _has_bits_[0] |= 0x00000001u;
  if (buf_ == nullptr) {
    auto* p = CreateMaybeMessage<::common::memory_pol>(GetArenaNoVirtual());
    buf_ = p;
  }
  // @@protoc_insertion_point(field_mutable:libcall_types.read_pol.buf)
  return buf_;
}
inline void read_pol::set_allocated_buf(::common::memory_pol* buf) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(buf_);
  }
  if (buf) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      buf = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, buf, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  buf_ = buf;
  // @@protoc_insertion_point(field_set_allocated:libcall_types.read_pol.buf)
}

// required .common.action count = 3;
inline bool read_pol::has_count() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void read_pol::clear_count() {
  count_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::common::action read_pol::count() const {
  // @@protoc_insertion_point(field_get:libcall_types.read_pol.count)
  return static_cast< ::common::action >(count_);
}
inline void read_pol::set_count(::common::action value) {
  assert(::common::action_IsValid(value));
  _has_bits_[0] |= 0x00000004u;
  count_ = value;
  // @@protoc_insertion_point(field_set:libcall_types.read_pol.count)
}

// required .common.action ret = 4;
inline bool read_pol::has_ret() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void read_pol::clear_ret() {
  ret_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::common::action read_pol::ret() const {
  // @@protoc_insertion_point(field_get:libcall_types.read_pol.ret)
  return static_cast< ::common::action >(ret_);
}
inline void read_pol::set_ret(::common::action value) {
  assert(::common::action_IsValid(value));
  _has_bits_[0] |= 0x00000008u;
  ret_ = value;
  // @@protoc_insertion_point(field_set:libcall_types.read_pol.ret)
}

// -------------------------------------------------------------------

// fread_pol

// required .common.memory_pol ptr = 1;
inline bool fread_pol::has_ptr() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline const ::common::memory_pol& fread_pol::ptr() const {
  const ::common::memory_pol* p = ptr_;
  // @@protoc_insertion_point(field_get:libcall_types.fread_pol.ptr)
  return p != nullptr ? *p : *reinterpret_cast<const ::common::memory_pol*>(
      &::common::_memory_pol_default_instance_);
}
inline ::common::memory_pol* fread_pol::release_ptr() {
  // @@protoc_insertion_point(field_release:libcall_types.fread_pol.ptr)
  _has_bits_[0] &= ~0x00000001u;
  ::common::memory_pol* temp = ptr_;
  ptr_ = nullptr;
  return temp;
}
inline ::common::memory_pol* fread_pol::mutable_ptr() {
  _has_bits_[0] |= 0x00000001u;
  if (ptr_ == nullptr) {
    auto* p = CreateMaybeMessage<::common::memory_pol>(GetArenaNoVirtual());
    ptr_ = p;
  }
  // @@protoc_insertion_point(field_mutable:libcall_types.fread_pol.ptr)
  return ptr_;
}
inline void fread_pol::set_allocated_ptr(::common::memory_pol* ptr) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(ptr_);
  }
  if (ptr) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      ptr = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, ptr, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  ptr_ = ptr;
  // @@protoc_insertion_point(field_set_allocated:libcall_types.fread_pol.ptr)
}

// required .common.action size = 2;
inline bool fread_pol::has_size() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void fread_pol::clear_size() {
  size_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::common::action fread_pol::size() const {
  // @@protoc_insertion_point(field_get:libcall_types.fread_pol.size)
  return static_cast< ::common::action >(size_);
}
inline void fread_pol::set_size(::common::action value) {
  assert(::common::action_IsValid(value));
  _has_bits_[0] |= 0x00000002u;
  size_ = value;
  // @@protoc_insertion_point(field_set:libcall_types.fread_pol.size)
}

// required .common.action nmemb = 3;
inline bool fread_pol::has_nmemb() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void fread_pol::clear_nmemb() {
  nmemb_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::common::action fread_pol::nmemb() const {
  // @@protoc_insertion_point(field_get:libcall_types.fread_pol.nmemb)
  return static_cast< ::common::action >(nmemb_);
}
inline void fread_pol::set_nmemb(::common::action value) {
  assert(::common::action_IsValid(value));
  _has_bits_[0] |= 0x00000004u;
  nmemb_ = value;
  // @@protoc_insertion_point(field_set:libcall_types.fread_pol.nmemb)
}

// required .common.action stream = 4;
inline bool fread_pol::has_stream() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void fread_pol::clear_stream() {
  stream_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::common::action fread_pol::stream() const {
  // @@protoc_insertion_point(field_get:libcall_types.fread_pol.stream)
  return static_cast< ::common::action >(stream_);
}
inline void fread_pol::set_stream(::common::action value) {
  assert(::common::action_IsValid(value));
  _has_bits_[0] |= 0x00000008u;
  stream_ = value;
  // @@protoc_insertion_point(field_set:libcall_types.fread_pol.stream)
}

// required .common.action ret = 5;
inline bool fread_pol::has_ret() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void fread_pol::clear_ret() {
  ret_ = 0;
  _has_bits_[0] &= ~0x00000010u;
}
inline ::common::action fread_pol::ret() const {
  // @@protoc_insertion_point(field_get:libcall_types.fread_pol.ret)
  return static_cast< ::common::action >(ret_);
}
inline void fread_pol::set_ret(::common::action value) {
  assert(::common::action_IsValid(value));
  _has_bits_[0] |= 0x00000010u;
  ret_ = value;
  // @@protoc_insertion_point(field_set:libcall_types.fread_pol.ret)
}

// -------------------------------------------------------------------

// strcmp_pol

// required .common.memory_pol src = 1;
inline bool strcmp_pol::has_src() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline const ::common::memory_pol& strcmp_pol::src() const {
  const ::common::memory_pol* p = src_;
  // @@protoc_insertion_point(field_get:libcall_types.strcmp_pol.src)
  return p != nullptr ? *p : *reinterpret_cast<const ::common::memory_pol*>(
      &::common::_memory_pol_default_instance_);
}
inline ::common::memory_pol* strcmp_pol::release_src() {
  // @@protoc_insertion_point(field_release:libcall_types.strcmp_pol.src)
  _has_bits_[0] &= ~0x00000001u;
  ::common::memory_pol* temp = src_;
  src_ = nullptr;
  return temp;
}
inline ::common::memory_pol* strcmp_pol::mutable_src() {
  _has_bits_[0] |= 0x00000001u;
  if (src_ == nullptr) {
    auto* p = CreateMaybeMessage<::common::memory_pol>(GetArenaNoVirtual());
    src_ = p;
  }
  // @@protoc_insertion_point(field_mutable:libcall_types.strcmp_pol.src)
  return src_;
}
inline void strcmp_pol::set_allocated_src(::common::memory_pol* src) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(src_);
  }
  if (src) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      src = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, src, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  src_ = src;
  // @@protoc_insertion_point(field_set_allocated:libcall_types.strcmp_pol.src)
}

// required .common.memory_pol dst = 2;
inline bool strcmp_pol::has_dst() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline const ::common::memory_pol& strcmp_pol::dst() const {
  const ::common::memory_pol* p = dst_;
  // @@protoc_insertion_point(field_get:libcall_types.strcmp_pol.dst)
  return p != nullptr ? *p : *reinterpret_cast<const ::common::memory_pol*>(
      &::common::_memory_pol_default_instance_);
}
inline ::common::memory_pol* strcmp_pol::release_dst() {
  // @@protoc_insertion_point(field_release:libcall_types.strcmp_pol.dst)
  _has_bits_[0] &= ~0x00000002u;
  ::common::memory_pol* temp = dst_;
  dst_ = nullptr;
  return temp;
}
inline ::common::memory_pol* strcmp_pol::mutable_dst() {
  _has_bits_[0] |= 0x00000002u;
  if (dst_ == nullptr) {
    auto* p = CreateMaybeMessage<::common::memory_pol>(GetArenaNoVirtual());
    dst_ = p;
  }
  // @@protoc_insertion_point(field_mutable:libcall_types.strcmp_pol.dst)
  return dst_;
}
inline void strcmp_pol::set_allocated_dst(::common::memory_pol* dst) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(dst_);
  }
  if (dst) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      dst = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, dst, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  dst_ = dst;
  // @@protoc_insertion_point(field_set_allocated:libcall_types.strcmp_pol.dst)
}

// required .common.action ret = 3;
inline bool strcmp_pol::has_ret() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void strcmp_pol::clear_ret() {
  ret_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::common::action strcmp_pol::ret() const {
  // @@protoc_insertion_point(field_get:libcall_types.strcmp_pol.ret)
  return static_cast< ::common::action >(ret_);
}
inline void strcmp_pol::set_ret(::common::action value) {
  assert(::common::action_IsValid(value));
  _has_bits_[0] |= 0x00000004u;
  ret_ = value;
  // @@protoc_insertion_point(field_set:libcall_types.strcmp_pol.ret)
}

// -------------------------------------------------------------------

// strncmp_pol

// required .common.action s1 = 1;
inline bool strncmp_pol::has_s1() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void strncmp_pol::clear_s1() {
  s1_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::common::action strncmp_pol::s1() const {
  // @@protoc_insertion_point(field_get:libcall_types.strncmp_pol.s1)
  return static_cast< ::common::action >(s1_);
}
inline void strncmp_pol::set_s1(::common::action value) {
  assert(::common::action_IsValid(value));
  _has_bits_[0] |= 0x00000001u;
  s1_ = value;
  // @@protoc_insertion_point(field_set:libcall_types.strncmp_pol.s1)
}

// required .common.action s2 = 2;
inline bool strncmp_pol::has_s2() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void strncmp_pol::clear_s2() {
  s2_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::common::action strncmp_pol::s2() const {
  // @@protoc_insertion_point(field_get:libcall_types.strncmp_pol.s2)
  return static_cast< ::common::action >(s2_);
}
inline void strncmp_pol::set_s2(::common::action value) {
  assert(::common::action_IsValid(value));
  _has_bits_[0] |= 0x00000002u;
  s2_ = value;
  // @@protoc_insertion_point(field_set:libcall_types.strncmp_pol.s2)
}

// required .common.action n = 3;
inline bool strncmp_pol::has_n() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void strncmp_pol::clear_n() {
  n_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::common::action strncmp_pol::n() const {
  // @@protoc_insertion_point(field_get:libcall_types.strncmp_pol.n)
  return static_cast< ::common::action >(n_);
}
inline void strncmp_pol::set_n(::common::action value) {
  assert(::common::action_IsValid(value));
  _has_bits_[0] |= 0x00000004u;
  n_ = value;
  // @@protoc_insertion_point(field_set:libcall_types.strncmp_pol.n)
}

// required .common.action ret = 4;
inline bool strncmp_pol::has_ret() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void strncmp_pol::clear_ret() {
  ret_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::common::action strncmp_pol::ret() const {
  // @@protoc_insertion_point(field_get:libcall_types.strncmp_pol.ret)
  return static_cast< ::common::action >(ret_);
}
inline void strncmp_pol::set_ret(::common::action value) {
  assert(::common::action_IsValid(value));
  _has_bits_[0] |= 0x00000008u;
  ret_ = value;
  // @@protoc_insertion_point(field_set:libcall_types.strncmp_pol.ret)
}

// -------------------------------------------------------------------

// memcmp_pol

// required .common.action s1 = 1;
inline bool memcmp_pol::has_s1() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void memcmp_pol::clear_s1() {
  s1_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::common::action memcmp_pol::s1() const {
  // @@protoc_insertion_point(field_get:libcall_types.memcmp_pol.s1)
  return static_cast< ::common::action >(s1_);
}
inline void memcmp_pol::set_s1(::common::action value) {
  assert(::common::action_IsValid(value));
  _has_bits_[0] |= 0x00000001u;
  s1_ = value;
  // @@protoc_insertion_point(field_set:libcall_types.memcmp_pol.s1)
}

// required .common.action s2 = 2;
inline bool memcmp_pol::has_s2() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void memcmp_pol::clear_s2() {
  s2_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::common::action memcmp_pol::s2() const {
  // @@protoc_insertion_point(field_get:libcall_types.memcmp_pol.s2)
  return static_cast< ::common::action >(s2_);
}
inline void memcmp_pol::set_s2(::common::action value) {
  assert(::common::action_IsValid(value));
  _has_bits_[0] |= 0x00000002u;
  s2_ = value;
  // @@protoc_insertion_point(field_set:libcall_types.memcmp_pol.s2)
}

// required .common.action n = 3;
inline bool memcmp_pol::has_n() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void memcmp_pol::clear_n() {
  n_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::common::action memcmp_pol::n() const {
  // @@protoc_insertion_point(field_get:libcall_types.memcmp_pol.n)
  return static_cast< ::common::action >(n_);
}
inline void memcmp_pol::set_n(::common::action value) {
  assert(::common::action_IsValid(value));
  _has_bits_[0] |= 0x00000004u;
  n_ = value;
  // @@protoc_insertion_point(field_set:libcall_types.memcmp_pol.n)
}

// required .common.action ret = 4;
inline bool memcmp_pol::has_ret() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void memcmp_pol::clear_ret() {
  ret_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::common::action memcmp_pol::ret() const {
  // @@protoc_insertion_point(field_get:libcall_types.memcmp_pol.ret)
  return static_cast< ::common::action >(ret_);
}
inline void memcmp_pol::set_ret(::common::action value) {
  assert(::common::action_IsValid(value));
  _has_bits_[0] |= 0x00000008u;
  ret_ = value;
  // @@protoc_insertion_point(field_set:libcall_types.memcmp_pol.ret)
}

// -------------------------------------------------------------------

// strchr_pol

// required .common.memory_pol sc = 1;
inline bool strchr_pol::has_sc() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline const ::common::memory_pol& strchr_pol::sc() const {
  const ::common::memory_pol* p = sc_;
  // @@protoc_insertion_point(field_get:libcall_types.strchr_pol.sc)
  return p != nullptr ? *p : *reinterpret_cast<const ::common::memory_pol*>(
      &::common::_memory_pol_default_instance_);
}
inline ::common::memory_pol* strchr_pol::release_sc() {
  // @@protoc_insertion_point(field_release:libcall_types.strchr_pol.sc)
  _has_bits_[0] &= ~0x00000001u;
  ::common::memory_pol* temp = sc_;
  sc_ = nullptr;
  return temp;
}
inline ::common::memory_pol* strchr_pol::mutable_sc() {
  _has_bits_[0] |= 0x00000001u;
  if (sc_ == nullptr) {
    auto* p = CreateMaybeMessage<::common::memory_pol>(GetArenaNoVirtual());
    sc_ = p;
  }
  // @@protoc_insertion_point(field_mutable:libcall_types.strchr_pol.sc)
  return sc_;
}
inline void strchr_pol::set_allocated_sc(::common::memory_pol* sc) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(sc_);
  }
  if (sc) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      sc = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, sc, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  sc_ = sc;
  // @@protoc_insertion_point(field_set_allocated:libcall_types.strchr_pol.sc)
}

// required .common.memory_pol c = 2;
inline bool strchr_pol::has_c() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline const ::common::memory_pol& strchr_pol::c() const {
  const ::common::memory_pol* p = c_;
  // @@protoc_insertion_point(field_get:libcall_types.strchr_pol.c)
  return p != nullptr ? *p : *reinterpret_cast<const ::common::memory_pol*>(
      &::common::_memory_pol_default_instance_);
}
inline ::common::memory_pol* strchr_pol::release_c() {
  // @@protoc_insertion_point(field_release:libcall_types.strchr_pol.c)
  _has_bits_[0] &= ~0x00000002u;
  ::common::memory_pol* temp = c_;
  c_ = nullptr;
  return temp;
}
inline ::common::memory_pol* strchr_pol::mutable_c() {
  _has_bits_[0] |= 0x00000002u;
  if (c_ == nullptr) {
    auto* p = CreateMaybeMessage<::common::memory_pol>(GetArenaNoVirtual());
    c_ = p;
  }
  // @@protoc_insertion_point(field_mutable:libcall_types.strchr_pol.c)
  return c_;
}
inline void strchr_pol::set_allocated_c(::common::memory_pol* c) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(c_);
  }
  if (c) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      c = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, c, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  c_ = c;
  // @@protoc_insertion_point(field_set_allocated:libcall_types.strchr_pol.c)
}

// required .common.action ret = 3;
inline bool strchr_pol::has_ret() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void strchr_pol::clear_ret() {
  ret_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::common::action strchr_pol::ret() const {
  // @@protoc_insertion_point(field_get:libcall_types.strchr_pol.ret)
  return static_cast< ::common::action >(ret_);
}
inline void strchr_pol::set_ret(::common::action value) {
  assert(::common::action_IsValid(value));
  _has_bits_[0] |= 0x00000004u;
  ret_ = value;
  // @@protoc_insertion_point(field_set:libcall_types.strchr_pol.ret)
}

// -------------------------------------------------------------------

// strncpy_pol

// required .common.action dst = 1;
inline bool strncpy_pol::has_dst() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void strncpy_pol::clear_dst() {
  dst_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::common::action strncpy_pol::dst() const {
  // @@protoc_insertion_point(field_get:libcall_types.strncpy_pol.dst)
  return static_cast< ::common::action >(dst_);
}
inline void strncpy_pol::set_dst(::common::action value) {
  assert(::common::action_IsValid(value));
  _has_bits_[0] |= 0x00000001u;
  dst_ = value;
  // @@protoc_insertion_point(field_set:libcall_types.strncpy_pol.dst)
}

// required .common.action src = 2;
inline bool strncpy_pol::has_src() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void strncpy_pol::clear_src() {
  src_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::common::action strncpy_pol::src() const {
  // @@protoc_insertion_point(field_get:libcall_types.strncpy_pol.src)
  return static_cast< ::common::action >(src_);
}
inline void strncpy_pol::set_src(::common::action value) {
  assert(::common::action_IsValid(value));
  _has_bits_[0] |= 0x00000002u;
  src_ = value;
  // @@protoc_insertion_point(field_set:libcall_types.strncpy_pol.src)
}

// required .common.action n = 3;
inline bool strncpy_pol::has_n() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void strncpy_pol::clear_n() {
  n_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::common::action strncpy_pol::n() const {
  // @@protoc_insertion_point(field_get:libcall_types.strncpy_pol.n)
  return static_cast< ::common::action >(n_);
}
inline void strncpy_pol::set_n(::common::action value) {
  assert(::common::action_IsValid(value));
  _has_bits_[0] |= 0x00000004u;
  n_ = value;
  // @@protoc_insertion_point(field_set:libcall_types.strncpy_pol.n)
}

// required .common.action ret = 4;
inline bool strncpy_pol::has_ret() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void strncpy_pol::clear_ret() {
  ret_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::common::action strncpy_pol::ret() const {
  // @@protoc_insertion_point(field_get:libcall_types.strncpy_pol.ret)
  return static_cast< ::common::action >(ret_);
}
inline void strncpy_pol::set_ret(::common::action value) {
  assert(::common::action_IsValid(value));
  _has_bits_[0] |= 0x00000008u;
  ret_ = value;
  // @@protoc_insertion_point(field_set:libcall_types.strncpy_pol.ret)
}

// -------------------------------------------------------------------

// fstat_pol

// -------------------------------------------------------------------

// fxstat64_pol

// -------------------------------------------------------------------

// realloc_pol

// required .common.action ptr = 1;
inline bool realloc_pol::has_ptr() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void realloc_pol::clear_ptr() {
  ptr_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::common::action realloc_pol::ptr() const {
  // @@protoc_insertion_point(field_get:libcall_types.realloc_pol.ptr)
  return static_cast< ::common::action >(ptr_);
}
inline void realloc_pol::set_ptr(::common::action value) {
  assert(::common::action_IsValid(value));
  _has_bits_[0] |= 0x00000001u;
  ptr_ = value;
  // @@protoc_insertion_point(field_set:libcall_types.realloc_pol.ptr)
}

// required .common.action size = 2;
inline bool realloc_pol::has_size() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void realloc_pol::clear_size() {
  size_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::common::action realloc_pol::size() const {
  // @@protoc_insertion_point(field_get:libcall_types.realloc_pol.size)
  return static_cast< ::common::action >(size_);
}
inline void realloc_pol::set_size(::common::action value) {
  assert(::common::action_IsValid(value));
  _has_bits_[0] |= 0x00000002u;
  size_ = value;
  // @@protoc_insertion_point(field_set:libcall_types.realloc_pol.size)
}

// required .common.action ret = 3;
inline bool realloc_pol::has_ret() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void realloc_pol::clear_ret() {
  ret_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::common::action realloc_pol::ret() const {
  // @@protoc_insertion_point(field_get:libcall_types.realloc_pol.ret)
  return static_cast< ::common::action >(ret_);
}
inline void realloc_pol::set_ret(::common::action value) {
  assert(::common::action_IsValid(value));
  _has_bits_[0] |= 0x00000004u;
  ret_ = value;
  // @@protoc_insertion_point(field_set:libcall_types.realloc_pol.ret)
}

// -------------------------------------------------------------------

// mmap_pol

// required .common.action addr = 1;
inline bool mmap_pol::has_addr() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void mmap_pol::clear_addr() {
  addr_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::common::action mmap_pol::addr() const {
  // @@protoc_insertion_point(field_get:libcall_types.mmap_pol.addr)
  return static_cast< ::common::action >(addr_);
}
inline void mmap_pol::set_addr(::common::action value) {
  assert(::common::action_IsValid(value));
  _has_bits_[0] |= 0x00000002u;
  addr_ = value;
  // @@protoc_insertion_point(field_set:libcall_types.mmap_pol.addr)
}

// required .common.action length = 2;
inline bool mmap_pol::has_length() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void mmap_pol::clear_length() {
  length_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::common::action mmap_pol::length() const {
  // @@protoc_insertion_point(field_get:libcall_types.mmap_pol.length)
  return static_cast< ::common::action >(length_);
}
inline void mmap_pol::set_length(::common::action value) {
  assert(::common::action_IsValid(value));
  _has_bits_[0] |= 0x00000004u;
  length_ = value;
  // @@protoc_insertion_point(field_set:libcall_types.mmap_pol.length)
}

// required .common.action prot = 3;
inline bool mmap_pol::has_prot() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void mmap_pol::clear_prot() {
  prot_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::common::action mmap_pol::prot() const {
  // @@protoc_insertion_point(field_get:libcall_types.mmap_pol.prot)
  return static_cast< ::common::action >(prot_);
}
inline void mmap_pol::set_prot(::common::action value) {
  assert(::common::action_IsValid(value));
  _has_bits_[0] |= 0x00000008u;
  prot_ = value;
  // @@protoc_insertion_point(field_set:libcall_types.mmap_pol.prot)
}

// required .common.action flags = 4;
inline bool mmap_pol::has_flags() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void mmap_pol::clear_flags() {
  flags_ = 0;
  _has_bits_[0] &= ~0x00000010u;
}
inline ::common::action mmap_pol::flags() const {
  // @@protoc_insertion_point(field_get:libcall_types.mmap_pol.flags)
  return static_cast< ::common::action >(flags_);
}
inline void mmap_pol::set_flags(::common::action value) {
  assert(::common::action_IsValid(value));
  _has_bits_[0] |= 0x00000010u;
  flags_ = value;
  // @@protoc_insertion_point(field_set:libcall_types.mmap_pol.flags)
}

// required .common.action fd = 5;
inline bool mmap_pol::has_fd() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void mmap_pol::clear_fd() {
  fd_ = 0;
  _has_bits_[0] &= ~0x00000020u;
}
inline ::common::action mmap_pol::fd() const {
  // @@protoc_insertion_point(field_get:libcall_types.mmap_pol.fd)
  return static_cast< ::common::action >(fd_);
}
inline void mmap_pol::set_fd(::common::action value) {
  assert(::common::action_IsValid(value));
  _has_bits_[0] |= 0x00000020u;
  fd_ = value;
  // @@protoc_insertion_point(field_set:libcall_types.mmap_pol.fd)
}

// required .common.action offset = 6;
inline bool mmap_pol::has_offset() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void mmap_pol::clear_offset() {
  offset_ = 0;
  _has_bits_[0] &= ~0x00000040u;
}
inline ::common::action mmap_pol::offset() const {
  // @@protoc_insertion_point(field_get:libcall_types.mmap_pol.offset)
  return static_cast< ::common::action >(offset_);
}
inline void mmap_pol::set_offset(::common::action value) {
  assert(::common::action_IsValid(value));
  _has_bits_[0] |= 0x00000040u;
  offset_ = value;
  // @@protoc_insertion_point(field_set:libcall_types.mmap_pol.offset)
}

// required .common.memory_pol ret = 7;
inline bool mmap_pol::has_ret() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline const ::common::memory_pol& mmap_pol::ret() const {
  const ::common::memory_pol* p = ret_;
  // @@protoc_insertion_point(field_get:libcall_types.mmap_pol.ret)
  return p != nullptr ? *p : *reinterpret_cast<const ::common::memory_pol*>(
      &::common::_memory_pol_default_instance_);
}
inline ::common::memory_pol* mmap_pol::release_ret() {
  // @@protoc_insertion_point(field_release:libcall_types.mmap_pol.ret)
  _has_bits_[0] &= ~0x00000001u;
  ::common::memory_pol* temp = ret_;
  ret_ = nullptr;
  return temp;
}
inline ::common::memory_pol* mmap_pol::mutable_ret() {
  _has_bits_[0] |= 0x00000001u;
  if (ret_ == nullptr) {
    auto* p = CreateMaybeMessage<::common::memory_pol>(GetArenaNoVirtual());
    ret_ = p;
  }
  // @@protoc_insertion_point(field_mutable:libcall_types.mmap_pol.ret)
  return ret_;
}
inline void mmap_pol::set_allocated_ret(::common::memory_pol* ret) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(ret_);
  }
  if (ret) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      ret = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, ret, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  ret_ = ret;
  // @@protoc_insertion_point(field_set_allocated:libcall_types.mmap_pol.ret)
}

// -------------------------------------------------------------------

// qsort_pol

// required .common.memory_pol base = 1;
inline bool qsort_pol::has_base() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline const ::common::memory_pol& qsort_pol::base() const {
  const ::common::memory_pol* p = base_;
  // @@protoc_insertion_point(field_get:libcall_types.qsort_pol.base)
  return p != nullptr ? *p : *reinterpret_cast<const ::common::memory_pol*>(
      &::common::_memory_pol_default_instance_);
}
inline ::common::memory_pol* qsort_pol::release_base() {
  // @@protoc_insertion_point(field_release:libcall_types.qsort_pol.base)
  _has_bits_[0] &= ~0x00000001u;
  ::common::memory_pol* temp = base_;
  base_ = nullptr;
  return temp;
}
inline ::common::memory_pol* qsort_pol::mutable_base() {
  _has_bits_[0] |= 0x00000001u;
  if (base_ == nullptr) {
    auto* p = CreateMaybeMessage<::common::memory_pol>(GetArenaNoVirtual());
    base_ = p;
  }
  // @@protoc_insertion_point(field_mutable:libcall_types.qsort_pol.base)
  return base_;
}
inline void qsort_pol::set_allocated_base(::common::memory_pol* base) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(base_);
  }
  if (base) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      base = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, base, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  base_ = base;
  // @@protoc_insertion_point(field_set_allocated:libcall_types.qsort_pol.base)
}

// required .common.action nmemb = 2;
inline bool qsort_pol::has_nmemb() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void qsort_pol::clear_nmemb() {
  nmemb_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::common::action qsort_pol::nmemb() const {
  // @@protoc_insertion_point(field_get:libcall_types.qsort_pol.nmemb)
  return static_cast< ::common::action >(nmemb_);
}
inline void qsort_pol::set_nmemb(::common::action value) {
  assert(::common::action_IsValid(value));
  _has_bits_[0] |= 0x00000002u;
  nmemb_ = value;
  // @@protoc_insertion_point(field_set:libcall_types.qsort_pol.nmemb)
}

// required .common.action size = 3;
inline bool qsort_pol::has_size() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void qsort_pol::clear_size() {
  size_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::common::action qsort_pol::size() const {
  // @@protoc_insertion_point(field_get:libcall_types.qsort_pol.size)
  return static_cast< ::common::action >(size_);
}
inline void qsort_pol::set_size(::common::action value) {
  assert(::common::action_IsValid(value));
  _has_bits_[0] |= 0x00000004u;
  size_ = value;
  // @@protoc_insertion_point(field_set:libcall_types.qsort_pol.size)
}

// required .common.action compare = 4;
inline bool qsort_pol::has_compare() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void qsort_pol::clear_compare() {
  compare_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::common::action qsort_pol::compare() const {
  // @@protoc_insertion_point(field_get:libcall_types.qsort_pol.compare)
  return static_cast< ::common::action >(compare_);
}
inline void qsort_pol::set_compare(::common::action value) {
  assert(::common::action_IsValid(value));
  _has_bits_[0] |= 0x00000008u;
  compare_ = value;
  // @@protoc_insertion_point(field_set:libcall_types.qsort_pol.compare)
}

// -------------------------------------------------------------------

// bsearch_pol

// required .common.memory_pol key = 1;
inline bool bsearch_pol::has_key() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline const ::common::memory_pol& bsearch_pol::key() const {
  const ::common::memory_pol* p = key_;
  // @@protoc_insertion_point(field_get:libcall_types.bsearch_pol.key)
  return p != nullptr ? *p : *reinterpret_cast<const ::common::memory_pol*>(
      &::common::_memory_pol_default_instance_);
}
inline ::common::memory_pol* bsearch_pol::release_key() {
  // @@protoc_insertion_point(field_release:libcall_types.bsearch_pol.key)
  _has_bits_[0] &= ~0x00000001u;
  ::common::memory_pol* temp = key_;
  key_ = nullptr;
  return temp;
}
inline ::common::memory_pol* bsearch_pol::mutable_key() {
  _has_bits_[0] |= 0x00000001u;
  if (key_ == nullptr) {
    auto* p = CreateMaybeMessage<::common::memory_pol>(GetArenaNoVirtual());
    key_ = p;
  }
  // @@protoc_insertion_point(field_mutable:libcall_types.bsearch_pol.key)
  return key_;
}
inline void bsearch_pol::set_allocated_key(::common::memory_pol* key) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(key_);
  }
  if (key) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      key = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, key, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  key_ = key;
  // @@protoc_insertion_point(field_set_allocated:libcall_types.bsearch_pol.key)
}

// required .common.memory_pol base = 2;
inline bool bsearch_pol::has_base() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline const ::common::memory_pol& bsearch_pol::base() const {
  const ::common::memory_pol* p = base_;
  // @@protoc_insertion_point(field_get:libcall_types.bsearch_pol.base)
  return p != nullptr ? *p : *reinterpret_cast<const ::common::memory_pol*>(
      &::common::_memory_pol_default_instance_);
}
inline ::common::memory_pol* bsearch_pol::release_base() {
  // @@protoc_insertion_point(field_release:libcall_types.bsearch_pol.base)
  _has_bits_[0] &= ~0x00000002u;
  ::common::memory_pol* temp = base_;
  base_ = nullptr;
  return temp;
}
inline ::common::memory_pol* bsearch_pol::mutable_base() {
  _has_bits_[0] |= 0x00000002u;
  if (base_ == nullptr) {
    auto* p = CreateMaybeMessage<::common::memory_pol>(GetArenaNoVirtual());
    base_ = p;
  }
  // @@protoc_insertion_point(field_mutable:libcall_types.bsearch_pol.base)
  return base_;
}
inline void bsearch_pol::set_allocated_base(::common::memory_pol* base) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(base_);
  }
  if (base) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      base = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, base, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  base_ = base;
  // @@protoc_insertion_point(field_set_allocated:libcall_types.bsearch_pol.base)
}

// required .common.action nmemb = 3;
inline bool bsearch_pol::has_nmemb() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void bsearch_pol::clear_nmemb() {
  nmemb_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::common::action bsearch_pol::nmemb() const {
  // @@protoc_insertion_point(field_get:libcall_types.bsearch_pol.nmemb)
  return static_cast< ::common::action >(nmemb_);
}
inline void bsearch_pol::set_nmemb(::common::action value) {
  assert(::common::action_IsValid(value));
  _has_bits_[0] |= 0x00000008u;
  nmemb_ = value;
  // @@protoc_insertion_point(field_set:libcall_types.bsearch_pol.nmemb)
}

// required .common.action size = 4;
inline bool bsearch_pol::has_size() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void bsearch_pol::clear_size() {
  size_ = 0;
  _has_bits_[0] &= ~0x00000010u;
}
inline ::common::action bsearch_pol::size() const {
  // @@protoc_insertion_point(field_get:libcall_types.bsearch_pol.size)
  return static_cast< ::common::action >(size_);
}
inline void bsearch_pol::set_size(::common::action value) {
  assert(::common::action_IsValid(value));
  _has_bits_[0] |= 0x00000010u;
  size_ = value;
  // @@protoc_insertion_point(field_set:libcall_types.bsearch_pol.size)
}

// required .common.action compare = 5;
inline bool bsearch_pol::has_compare() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void bsearch_pol::clear_compare() {
  compare_ = 0;
  _has_bits_[0] &= ~0x00000020u;
}
inline ::common::action bsearch_pol::compare() const {
  // @@protoc_insertion_point(field_get:libcall_types.bsearch_pol.compare)
  return static_cast< ::common::action >(compare_);
}
inline void bsearch_pol::set_compare(::common::action value) {
  assert(::common::action_IsValid(value));
  _has_bits_[0] |= 0x00000020u;
  compare_ = value;
  // @@protoc_insertion_point(field_set:libcall_types.bsearch_pol.compare)
}

// required .common.memory_pol ret = 6;
inline bool bsearch_pol::has_ret() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline const ::common::memory_pol& bsearch_pol::ret() const {
  const ::common::memory_pol* p = ret_;
  // @@protoc_insertion_point(field_get:libcall_types.bsearch_pol.ret)
  return p != nullptr ? *p : *reinterpret_cast<const ::common::memory_pol*>(
      &::common::_memory_pol_default_instance_);
}
inline ::common::memory_pol* bsearch_pol::release_ret() {
  // @@protoc_insertion_point(field_release:libcall_types.bsearch_pol.ret)
  _has_bits_[0] &= ~0x00000004u;
  ::common::memory_pol* temp = ret_;
  ret_ = nullptr;
  return temp;
}
inline ::common::memory_pol* bsearch_pol::mutable_ret() {
  _has_bits_[0] |= 0x00000004u;
  if (ret_ == nullptr) {
    auto* p = CreateMaybeMessage<::common::memory_pol>(GetArenaNoVirtual());
    ret_ = p;
  }
  // @@protoc_insertion_point(field_mutable:libcall_types.bsearch_pol.ret)
  return ret_;
}
inline void bsearch_pol::set_allocated_ret(::common::memory_pol* ret) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(ret_);
  }
  if (ret) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      ret = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, ret, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  ret_ = ret;
  // @@protoc_insertion_point(field_set_allocated:libcall_types.bsearch_pol.ret)
}

// -------------------------------------------------------------------

// open_pol

// required .common.memory_pol pathname = 1;
inline bool open_pol::has_pathname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline const ::common::memory_pol& open_pol::pathname() const {
  const ::common::memory_pol* p = pathname_;
  // @@protoc_insertion_point(field_get:libcall_types.open_pol.pathname)
  return p != nullptr ? *p : *reinterpret_cast<const ::common::memory_pol*>(
      &::common::_memory_pol_default_instance_);
}
inline ::common::memory_pol* open_pol::release_pathname() {
  // @@protoc_insertion_point(field_release:libcall_types.open_pol.pathname)
  _has_bits_[0] &= ~0x00000001u;
  ::common::memory_pol* temp = pathname_;
  pathname_ = nullptr;
  return temp;
}
inline ::common::memory_pol* open_pol::mutable_pathname() {
  _has_bits_[0] |= 0x00000001u;
  if (pathname_ == nullptr) {
    auto* p = CreateMaybeMessage<::common::memory_pol>(GetArenaNoVirtual());
    pathname_ = p;
  }
  // @@protoc_insertion_point(field_mutable:libcall_types.open_pol.pathname)
  return pathname_;
}
inline void open_pol::set_allocated_pathname(::common::memory_pol* pathname) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(pathname_);
  }
  if (pathname) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      pathname = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, pathname, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  pathname_ = pathname;
  // @@protoc_insertion_point(field_set_allocated:libcall_types.open_pol.pathname)
}

// required .common.action flags = 2;
inline bool open_pol::has_flags() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void open_pol::clear_flags() {
  flags_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::common::action open_pol::flags() const {
  // @@protoc_insertion_point(field_get:libcall_types.open_pol.flags)
  return static_cast< ::common::action >(flags_);
}
inline void open_pol::set_flags(::common::action value) {
  assert(::common::action_IsValid(value));
  _has_bits_[0] |= 0x00000002u;
  flags_ = value;
  // @@protoc_insertion_point(field_set:libcall_types.open_pol.flags)
}

// required .common.action mode = 3;
inline bool open_pol::has_mode() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void open_pol::clear_mode() {
  mode_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::common::action open_pol::mode() const {
  // @@protoc_insertion_point(field_get:libcall_types.open_pol.mode)
  return static_cast< ::common::action >(mode_);
}
inline void open_pol::set_mode(::common::action value) {
  assert(::common::action_IsValid(value));
  _has_bits_[0] |= 0x00000004u;
  mode_ = value;
  // @@protoc_insertion_point(field_set:libcall_types.open_pol.mode)
}

// required .common.action ret = 4;
inline bool open_pol::has_ret() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void open_pol::clear_ret() {
  ret_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::common::action open_pol::ret() const {
  // @@protoc_insertion_point(field_get:libcall_types.open_pol.ret)
  return static_cast< ::common::action >(ret_);
}
inline void open_pol::set_ret(::common::action value) {
  assert(::common::action_IsValid(value));
  _has_bits_[0] |= 0x00000008u;
  ret_ = value;
  // @@protoc_insertion_point(field_set:libcall_types.open_pol.ret)
}

// -------------------------------------------------------------------

// strcpy_pol

// required .common.memory_pol src = 1;
inline bool strcpy_pol::has_src() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline const ::common::memory_pol& strcpy_pol::src() const {
  const ::common::memory_pol* p = src_;
  // @@protoc_insertion_point(field_get:libcall_types.strcpy_pol.src)
  return p != nullptr ? *p : *reinterpret_cast<const ::common::memory_pol*>(
      &::common::_memory_pol_default_instance_);
}
inline ::common::memory_pol* strcpy_pol::release_src() {
  // @@protoc_insertion_point(field_release:libcall_types.strcpy_pol.src)
  _has_bits_[0] &= ~0x00000001u;
  ::common::memory_pol* temp = src_;
  src_ = nullptr;
  return temp;
}
inline ::common::memory_pol* strcpy_pol::mutable_src() {
  _has_bits_[0] |= 0x00000001u;
  if (src_ == nullptr) {
    auto* p = CreateMaybeMessage<::common::memory_pol>(GetArenaNoVirtual());
    src_ = p;
  }
  // @@protoc_insertion_point(field_mutable:libcall_types.strcpy_pol.src)
  return src_;
}
inline void strcpy_pol::set_allocated_src(::common::memory_pol* src) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(src_);
  }
  if (src) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      src = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, src, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  src_ = src;
  // @@protoc_insertion_point(field_set_allocated:libcall_types.strcpy_pol.src)
}

// required .common.memory_pol dst = 2;
inline bool strcpy_pol::has_dst() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline const ::common::memory_pol& strcpy_pol::dst() const {
  const ::common::memory_pol* p = dst_;
  // @@protoc_insertion_point(field_get:libcall_types.strcpy_pol.dst)
  return p != nullptr ? *p : *reinterpret_cast<const ::common::memory_pol*>(
      &::common::_memory_pol_default_instance_);
}
inline ::common::memory_pol* strcpy_pol::release_dst() {
  // @@protoc_insertion_point(field_release:libcall_types.strcpy_pol.dst)
  _has_bits_[0] &= ~0x00000002u;
  ::common::memory_pol* temp = dst_;
  dst_ = nullptr;
  return temp;
}
inline ::common::memory_pol* strcpy_pol::mutable_dst() {
  _has_bits_[0] |= 0x00000002u;
  if (dst_ == nullptr) {
    auto* p = CreateMaybeMessage<::common::memory_pol>(GetArenaNoVirtual());
    dst_ = p;
  }
  // @@protoc_insertion_point(field_mutable:libcall_types.strcpy_pol.dst)
  return dst_;
}
inline void strcpy_pol::set_allocated_dst(::common::memory_pol* dst) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(dst_);
  }
  if (dst) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      dst = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, dst, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  dst_ = dst;
  // @@protoc_insertion_point(field_set_allocated:libcall_types.strcpy_pol.dst)
}

// required .common.action ret = 3;
inline bool strcpy_pol::has_ret() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void strcpy_pol::clear_ret() {
  ret_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::common::action strcpy_pol::ret() const {
  // @@protoc_insertion_point(field_get:libcall_types.strcpy_pol.ret)
  return static_cast< ::common::action >(ret_);
}
inline void strcpy_pol::set_ret(::common::action value) {
  assert(::common::action_IsValid(value));
  _has_bits_[0] |= 0x00000004u;
  ret_ = value;
  // @@protoc_insertion_point(field_set:libcall_types.strcpy_pol.ret)
}

// -------------------------------------------------------------------

// printf_pol

// required .common.memory_pol format = 1;
inline bool printf_pol::has_format() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline const ::common::memory_pol& printf_pol::format() const {
  const ::common::memory_pol* p = format_;
  // @@protoc_insertion_point(field_get:libcall_types.printf_pol.format)
  return p != nullptr ? *p : *reinterpret_cast<const ::common::memory_pol*>(
      &::common::_memory_pol_default_instance_);
}
inline ::common::memory_pol* printf_pol::release_format() {
  // @@protoc_insertion_point(field_release:libcall_types.printf_pol.format)
  _has_bits_[0] &= ~0x00000001u;
  ::common::memory_pol* temp = format_;
  format_ = nullptr;
  return temp;
}
inline ::common::memory_pol* printf_pol::mutable_format() {
  _has_bits_[0] |= 0x00000001u;
  if (format_ == nullptr) {
    auto* p = CreateMaybeMessage<::common::memory_pol>(GetArenaNoVirtual());
    format_ = p;
  }
  // @@protoc_insertion_point(field_mutable:libcall_types.printf_pol.format)
  return format_;
}
inline void printf_pol::set_allocated_format(::common::memory_pol* format) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(format_);
  }
  if (format) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      format = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, format, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  format_ = format;
  // @@protoc_insertion_point(field_set_allocated:libcall_types.printf_pol.format)
}

// required .common.action ret = 2;
inline bool printf_pol::has_ret() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void printf_pol::clear_ret() {
  ret_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::common::action printf_pol::ret() const {
  // @@protoc_insertion_point(field_get:libcall_types.printf_pol.ret)
  return static_cast< ::common::action >(ret_);
}
inline void printf_pol::set_ret(::common::action value) {
  assert(::common::action_IsValid(value));
  _has_bits_[0] |= 0x00000002u;
  ret_ = value;
  // @@protoc_insertion_point(field_set:libcall_types.printf_pol.ret)
}

// -------------------------------------------------------------------

// atoi_pol

// required .common.memory_pol src = 1;
inline bool atoi_pol::has_src() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline const ::common::memory_pol& atoi_pol::src() const {
  const ::common::memory_pol* p = src_;
  // @@protoc_insertion_point(field_get:libcall_types.atoi_pol.src)
  return p != nullptr ? *p : *reinterpret_cast<const ::common::memory_pol*>(
      &::common::_memory_pol_default_instance_);
}
inline ::common::memory_pol* atoi_pol::release_src() {
  // @@protoc_insertion_point(field_release:libcall_types.atoi_pol.src)
  _has_bits_[0] &= ~0x00000001u;
  ::common::memory_pol* temp = src_;
  src_ = nullptr;
  return temp;
}
inline ::common::memory_pol* atoi_pol::mutable_src() {
  _has_bits_[0] |= 0x00000001u;
  if (src_ == nullptr) {
    auto* p = CreateMaybeMessage<::common::memory_pol>(GetArenaNoVirtual());
    src_ = p;
  }
  // @@protoc_insertion_point(field_mutable:libcall_types.atoi_pol.src)
  return src_;
}
inline void atoi_pol::set_allocated_src(::common::memory_pol* src) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(src_);
  }
  if (src) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      src = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, src, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  src_ = src;
  // @@protoc_insertion_point(field_set_allocated:libcall_types.atoi_pol.src)
}

// required .common.action ret = 3;
inline bool atoi_pol::has_ret() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void atoi_pol::clear_ret() {
  ret_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::common::action atoi_pol::ret() const {
  // @@protoc_insertion_point(field_get:libcall_types.atoi_pol.ret)
  return static_cast< ::common::action >(ret_);
}
inline void atoi_pol::set_ret(::common::action value) {
  assert(::common::action_IsValid(value));
  _has_bits_[0] |= 0x00000002u;
  ret_ = value;
  // @@protoc_insertion_point(field_set:libcall_types.atoi_pol.ret)
}

// -------------------------------------------------------------------

// malloc_pol

// required .common.action size = 1;
inline bool malloc_pol::has_size() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void malloc_pol::clear_size() {
  size_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::common::action malloc_pol::size() const {
  // @@protoc_insertion_point(field_get:libcall_types.malloc_pol.size)
  return static_cast< ::common::action >(size_);
}
inline void malloc_pol::set_size(::common::action value) {
  assert(::common::action_IsValid(value));
  _has_bits_[0] |= 0x00000001u;
  size_ = value;
  // @@protoc_insertion_point(field_set:libcall_types.malloc_pol.size)
}

// required .common.action ret = 2;
inline bool malloc_pol::has_ret() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void malloc_pol::clear_ret() {
  ret_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::common::action malloc_pol::ret() const {
  // @@protoc_insertion_point(field_get:libcall_types.malloc_pol.ret)
  return static_cast< ::common::action >(ret_);
}
inline void malloc_pol::set_ret(::common::action value) {
  assert(::common::action_IsValid(value));
  _has_bits_[0] |= 0x00000002u;
  ret_ = value;
  // @@protoc_insertion_point(field_set:libcall_types.malloc_pol.ret)
}

// -------------------------------------------------------------------

// getmodulehandle_pol

// required .common.memory_pol module_name = 1;
inline bool getmodulehandle_pol::has_module_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline const ::common::memory_pol& getmodulehandle_pol::module_name() const {
  const ::common::memory_pol* p = module_name_;
  // @@protoc_insertion_point(field_get:libcall_types.getmodulehandle_pol.module_name)
  return p != nullptr ? *p : *reinterpret_cast<const ::common::memory_pol*>(
      &::common::_memory_pol_default_instance_);
}
inline ::common::memory_pol* getmodulehandle_pol::release_module_name() {
  // @@protoc_insertion_point(field_release:libcall_types.getmodulehandle_pol.module_name)
  _has_bits_[0] &= ~0x00000001u;
  ::common::memory_pol* temp = module_name_;
  module_name_ = nullptr;
  return temp;
}
inline ::common::memory_pol* getmodulehandle_pol::mutable_module_name() {
  _has_bits_[0] |= 0x00000001u;
  if (module_name_ == nullptr) {
    auto* p = CreateMaybeMessage<::common::memory_pol>(GetArenaNoVirtual());
    module_name_ = p;
  }
  // @@protoc_insertion_point(field_mutable:libcall_types.getmodulehandle_pol.module_name)
  return module_name_;
}
inline void getmodulehandle_pol::set_allocated_module_name(::common::memory_pol* module_name) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(module_name_);
  }
  if (module_name) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      module_name = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, module_name, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  module_name_ = module_name;
  // @@protoc_insertion_point(field_set_allocated:libcall_types.getmodulehandle_pol.module_name)
}

// required .common.action ret = 2;
inline bool getmodulehandle_pol::has_ret() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void getmodulehandle_pol::clear_ret() {
  ret_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::common::action getmodulehandle_pol::ret() const {
  // @@protoc_insertion_point(field_get:libcall_types.getmodulehandle_pol.ret)
  return static_cast< ::common::action >(ret_);
}
inline void getmodulehandle_pol::set_ret(::common::action value) {
  assert(::common::action_IsValid(value));
  _has_bits_[0] |= 0x00000002u;
  ret_ = value;
  // @@protoc_insertion_point(field_set:libcall_types.getmodulehandle_pol.ret)
}

// -------------------------------------------------------------------

// getprocaddress_pol

// required .common.action hmodule = 1;
inline bool getprocaddress_pol::has_hmodule() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void getprocaddress_pol::clear_hmodule() {
  hmodule_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::common::action getprocaddress_pol::hmodule() const {
  // @@protoc_insertion_point(field_get:libcall_types.getprocaddress_pol.hmodule)
  return static_cast< ::common::action >(hmodule_);
}
inline void getprocaddress_pol::set_hmodule(::common::action value) {
  assert(::common::action_IsValid(value));
  _has_bits_[0] |= 0x00000002u;
  hmodule_ = value;
  // @@protoc_insertion_point(field_set:libcall_types.getprocaddress_pol.hmodule)
}

// required .common.memory_pol proc_name = 2;
inline bool getprocaddress_pol::has_proc_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline const ::common::memory_pol& getprocaddress_pol::proc_name() const {
  const ::common::memory_pol* p = proc_name_;
  // @@protoc_insertion_point(field_get:libcall_types.getprocaddress_pol.proc_name)
  return p != nullptr ? *p : *reinterpret_cast<const ::common::memory_pol*>(
      &::common::_memory_pol_default_instance_);
}
inline ::common::memory_pol* getprocaddress_pol::release_proc_name() {
  // @@protoc_insertion_point(field_release:libcall_types.getprocaddress_pol.proc_name)
  _has_bits_[0] &= ~0x00000001u;
  ::common::memory_pol* temp = proc_name_;
  proc_name_ = nullptr;
  return temp;
}
inline ::common::memory_pol* getprocaddress_pol::mutable_proc_name() {
  _has_bits_[0] |= 0x00000001u;
  if (proc_name_ == nullptr) {
    auto* p = CreateMaybeMessage<::common::memory_pol>(GetArenaNoVirtual());
    proc_name_ = p;
  }
  // @@protoc_insertion_point(field_mutable:libcall_types.getprocaddress_pol.proc_name)
  return proc_name_;
}
inline void getprocaddress_pol::set_allocated_proc_name(::common::memory_pol* proc_name) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(proc_name_);
  }
  if (proc_name) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      proc_name = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, proc_name, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  proc_name_ = proc_name;
  // @@protoc_insertion_point(field_set_allocated:libcall_types.getprocaddress_pol.proc_name)
}

// required .common.action ret = 3;
inline bool getprocaddress_pol::has_ret() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void getprocaddress_pol::clear_ret() {
  ret_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::common::action getprocaddress_pol::ret() const {
  // @@protoc_insertion_point(field_get:libcall_types.getprocaddress_pol.ret)
  return static_cast< ::common::action >(ret_);
}
inline void getprocaddress_pol::set_ret(::common::action value) {
  assert(::common::action_IsValid(value));
  _has_bits_[0] |= 0x00000004u;
  ret_ = value;
  // @@protoc_insertion_point(field_set:libcall_types.getprocaddress_pol.ret)
}

// -------------------------------------------------------------------

// getmainargs_pol

// required .common.memory_pol argc = 1;
inline bool getmainargs_pol::has_argc() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline const ::common::memory_pol& getmainargs_pol::argc() const {
  const ::common::memory_pol* p = argc_;
  // @@protoc_insertion_point(field_get:libcall_types.getmainargs_pol.argc)
  return p != nullptr ? *p : *reinterpret_cast<const ::common::memory_pol*>(
      &::common::_memory_pol_default_instance_);
}
inline ::common::memory_pol* getmainargs_pol::release_argc() {
  // @@protoc_insertion_point(field_release:libcall_types.getmainargs_pol.argc)
  _has_bits_[0] &= ~0x00000001u;
  ::common::memory_pol* temp = argc_;
  argc_ = nullptr;
  return temp;
}
inline ::common::memory_pol* getmainargs_pol::mutable_argc() {
  _has_bits_[0] |= 0x00000001u;
  if (argc_ == nullptr) {
    auto* p = CreateMaybeMessage<::common::memory_pol>(GetArenaNoVirtual());
    argc_ = p;
  }
  // @@protoc_insertion_point(field_mutable:libcall_types.getmainargs_pol.argc)
  return argc_;
}
inline void getmainargs_pol::set_allocated_argc(::common::memory_pol* argc) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(argc_);
  }
  if (argc) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      argc = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, argc, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  argc_ = argc;
  // @@protoc_insertion_point(field_set_allocated:libcall_types.getmainargs_pol.argc)
}

// required .common.memory_pol argv = 2;
inline bool getmainargs_pol::has_argv() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline const ::common::memory_pol& getmainargs_pol::argv() const {
  const ::common::memory_pol* p = argv_;
  // @@protoc_insertion_point(field_get:libcall_types.getmainargs_pol.argv)
  return p != nullptr ? *p : *reinterpret_cast<const ::common::memory_pol*>(
      &::common::_memory_pol_default_instance_);
}
inline ::common::memory_pol* getmainargs_pol::release_argv() {
  // @@protoc_insertion_point(field_release:libcall_types.getmainargs_pol.argv)
  _has_bits_[0] &= ~0x00000002u;
  ::common::memory_pol* temp = argv_;
  argv_ = nullptr;
  return temp;
}
inline ::common::memory_pol* getmainargs_pol::mutable_argv() {
  _has_bits_[0] |= 0x00000002u;
  if (argv_ == nullptr) {
    auto* p = CreateMaybeMessage<::common::memory_pol>(GetArenaNoVirtual());
    argv_ = p;
  }
  // @@protoc_insertion_point(field_mutable:libcall_types.getmainargs_pol.argv)
  return argv_;
}
inline void getmainargs_pol::set_allocated_argv(::common::memory_pol* argv) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(argv_);
  }
  if (argv) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      argv = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, argv, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  argv_ = argv;
  // @@protoc_insertion_point(field_set_allocated:libcall_types.getmainargs_pol.argv)
}

// required .common.memory_pol env = 3;
inline bool getmainargs_pol::has_env() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline const ::common::memory_pol& getmainargs_pol::env() const {
  const ::common::memory_pol* p = env_;
  // @@protoc_insertion_point(field_get:libcall_types.getmainargs_pol.env)
  return p != nullptr ? *p : *reinterpret_cast<const ::common::memory_pol*>(
      &::common::_memory_pol_default_instance_);
}
inline ::common::memory_pol* getmainargs_pol::release_env() {
  // @@protoc_insertion_point(field_release:libcall_types.getmainargs_pol.env)
  _has_bits_[0] &= ~0x00000004u;
  ::common::memory_pol* temp = env_;
  env_ = nullptr;
  return temp;
}
inline ::common::memory_pol* getmainargs_pol::mutable_env() {
  _has_bits_[0] |= 0x00000004u;
  if (env_ == nullptr) {
    auto* p = CreateMaybeMessage<::common::memory_pol>(GetArenaNoVirtual());
    env_ = p;
  }
  // @@protoc_insertion_point(field_mutable:libcall_types.getmainargs_pol.env)
  return env_;
}
inline void getmainargs_pol::set_allocated_env(::common::memory_pol* env) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(env_);
  }
  if (env) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      env = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, env, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  env_ = env;
  // @@protoc_insertion_point(field_set_allocated:libcall_types.getmainargs_pol.env)
}

// required .common.action dowildcard = 4;
inline bool getmainargs_pol::has_dowildcard() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void getmainargs_pol::clear_dowildcard() {
  dowildcard_ = 0;
  _has_bits_[0] &= ~0x00000010u;
}
inline ::common::action getmainargs_pol::dowildcard() const {
  // @@protoc_insertion_point(field_get:libcall_types.getmainargs_pol.dowildcard)
  return static_cast< ::common::action >(dowildcard_);
}
inline void getmainargs_pol::set_dowildcard(::common::action value) {
  assert(::common::action_IsValid(value));
  _has_bits_[0] |= 0x00000010u;
  dowildcard_ = value;
  // @@protoc_insertion_point(field_set:libcall_types.getmainargs_pol.dowildcard)
}

// required .common.memory_pol startinfo = 5;
inline bool getmainargs_pol::has_startinfo() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline const ::common::memory_pol& getmainargs_pol::startinfo() const {
  const ::common::memory_pol* p = startinfo_;
  // @@protoc_insertion_point(field_get:libcall_types.getmainargs_pol.startinfo)
  return p != nullptr ? *p : *reinterpret_cast<const ::common::memory_pol*>(
      &::common::_memory_pol_default_instance_);
}
inline ::common::memory_pol* getmainargs_pol::release_startinfo() {
  // @@protoc_insertion_point(field_release:libcall_types.getmainargs_pol.startinfo)
  _has_bits_[0] &= ~0x00000008u;
  ::common::memory_pol* temp = startinfo_;
  startinfo_ = nullptr;
  return temp;
}
inline ::common::memory_pol* getmainargs_pol::mutable_startinfo() {
  _has_bits_[0] |= 0x00000008u;
  if (startinfo_ == nullptr) {
    auto* p = CreateMaybeMessage<::common::memory_pol>(GetArenaNoVirtual());
    startinfo_ = p;
  }
  // @@protoc_insertion_point(field_mutable:libcall_types.getmainargs_pol.startinfo)
  return startinfo_;
}
inline void getmainargs_pol::set_allocated_startinfo(::common::memory_pol* startinfo) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(startinfo_);
  }
  if (startinfo) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      startinfo = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, startinfo, submessage_arena);
    }
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  startinfo_ = startinfo;
  // @@protoc_insertion_point(field_set_allocated:libcall_types.getmainargs_pol.startinfo)
}

// required .common.action ret = 6;
inline bool getmainargs_pol::has_ret() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void getmainargs_pol::clear_ret() {
  ret_ = 0;
  _has_bits_[0] &= ~0x00000020u;
}
inline ::common::action getmainargs_pol::ret() const {
  // @@protoc_insertion_point(field_get:libcall_types.getmainargs_pol.ret)
  return static_cast< ::common::action >(ret_);
}
inline void getmainargs_pol::set_ret(::common::action value) {
  assert(::common::action_IsValid(value));
  _has_bits_[0] |= 0x00000020u;
  ret_ = value;
  // @@protoc_insertion_point(field_set:libcall_types.getmainargs_pol.ret)
}

// -------------------------------------------------------------------

// gethostname_pol

// required .common.memory_pol name = 1;
inline bool gethostname_pol::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline const ::common::memory_pol& gethostname_pol::name() const {
  const ::common::memory_pol* p = name_;
  // @@protoc_insertion_point(field_get:libcall_types.gethostname_pol.name)
  return p != nullptr ? *p : *reinterpret_cast<const ::common::memory_pol*>(
      &::common::_memory_pol_default_instance_);
}
inline ::common::memory_pol* gethostname_pol::release_name() {
  // @@protoc_insertion_point(field_release:libcall_types.gethostname_pol.name)
  _has_bits_[0] &= ~0x00000001u;
  ::common::memory_pol* temp = name_;
  name_ = nullptr;
  return temp;
}
inline ::common::memory_pol* gethostname_pol::mutable_name() {
  _has_bits_[0] |= 0x00000001u;
  if (name_ == nullptr) {
    auto* p = CreateMaybeMessage<::common::memory_pol>(GetArenaNoVirtual());
    name_ = p;
  }
  // @@protoc_insertion_point(field_mutable:libcall_types.gethostname_pol.name)
  return name_;
}
inline void gethostname_pol::set_allocated_name(::common::memory_pol* name) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(name_);
  }
  if (name) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      name = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, name, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  name_ = name;
  // @@protoc_insertion_point(field_set_allocated:libcall_types.gethostname_pol.name)
}

// required .common.action namelen = 2;
inline bool gethostname_pol::has_namelen() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void gethostname_pol::clear_namelen() {
  namelen_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::common::action gethostname_pol::namelen() const {
  // @@protoc_insertion_point(field_get:libcall_types.gethostname_pol.namelen)
  return static_cast< ::common::action >(namelen_);
}
inline void gethostname_pol::set_namelen(::common::action value) {
  assert(::common::action_IsValid(value));
  _has_bits_[0] |= 0x00000002u;
  namelen_ = value;
  // @@protoc_insertion_point(field_set:libcall_types.gethostname_pol.namelen)
}

// required .common.action ret = 3;
inline bool gethostname_pol::has_ret() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void gethostname_pol::clear_ret() {
  ret_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::common::action gethostname_pol::ret() const {
  // @@protoc_insertion_point(field_get:libcall_types.gethostname_pol.ret)
  return static_cast< ::common::action >(ret_);
}
inline void gethostname_pol::set_ret(::common::action value) {
  assert(::common::action_IsValid(value));
  _has_bits_[0] |= 0x00000004u;
  ret_ = value;
  // @@protoc_insertion_point(field_set:libcall_types.gethostname_pol.ret)
}

// -------------------------------------------------------------------

// free_pol

// required .common.action ptr = 1;
inline bool free_pol::has_ptr() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void free_pol::clear_ptr() {
  ptr_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::common::action free_pol::ptr() const {
  // @@protoc_insertion_point(field_get:libcall_types.free_pol.ptr)
  return static_cast< ::common::action >(ptr_);
}
inline void free_pol::set_ptr(::common::action value) {
  assert(::common::action_IsValid(value));
  _has_bits_[0] |= 0x00000001u;
  ptr_ = value;
  // @@protoc_insertion_point(field_set:libcall_types.free_pol.ptr)
}

// -------------------------------------------------------------------

// memcpy_pol

// required .common.memory_pol dest = 1;
inline bool memcpy_pol::has_dest() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline const ::common::memory_pol& memcpy_pol::dest() const {
  const ::common::memory_pol* p = dest_;
  // @@protoc_insertion_point(field_get:libcall_types.memcpy_pol.dest)
  return p != nullptr ? *p : *reinterpret_cast<const ::common::memory_pol*>(
      &::common::_memory_pol_default_instance_);
}
inline ::common::memory_pol* memcpy_pol::release_dest() {
  // @@protoc_insertion_point(field_release:libcall_types.memcpy_pol.dest)
  _has_bits_[0] &= ~0x00000001u;
  ::common::memory_pol* temp = dest_;
  dest_ = nullptr;
  return temp;
}
inline ::common::memory_pol* memcpy_pol::mutable_dest() {
  _has_bits_[0] |= 0x00000001u;
  if (dest_ == nullptr) {
    auto* p = CreateMaybeMessage<::common::memory_pol>(GetArenaNoVirtual());
    dest_ = p;
  }
  // @@protoc_insertion_point(field_mutable:libcall_types.memcpy_pol.dest)
  return dest_;
}
inline void memcpy_pol::set_allocated_dest(::common::memory_pol* dest) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(dest_);
  }
  if (dest) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      dest = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, dest, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  dest_ = dest;
  // @@protoc_insertion_point(field_set_allocated:libcall_types.memcpy_pol.dest)
}

// required .common.memory_pol src = 2;
inline bool memcpy_pol::has_src() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline const ::common::memory_pol& memcpy_pol::src() const {
  const ::common::memory_pol* p = src_;
  // @@protoc_insertion_point(field_get:libcall_types.memcpy_pol.src)
  return p != nullptr ? *p : *reinterpret_cast<const ::common::memory_pol*>(
      &::common::_memory_pol_default_instance_);
}
inline ::common::memory_pol* memcpy_pol::release_src() {
  // @@protoc_insertion_point(field_release:libcall_types.memcpy_pol.src)
  _has_bits_[0] &= ~0x00000002u;
  ::common::memory_pol* temp = src_;
  src_ = nullptr;
  return temp;
}
inline ::common::memory_pol* memcpy_pol::mutable_src() {
  _has_bits_[0] |= 0x00000002u;
  if (src_ == nullptr) {
    auto* p = CreateMaybeMessage<::common::memory_pol>(GetArenaNoVirtual());
    src_ = p;
  }
  // @@protoc_insertion_point(field_mutable:libcall_types.memcpy_pol.src)
  return src_;
}
inline void memcpy_pol::set_allocated_src(::common::memory_pol* src) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(src_);
  }
  if (src) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      src = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, src, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  src_ = src;
  // @@protoc_insertion_point(field_set_allocated:libcall_types.memcpy_pol.src)
}

// required .common.action size = 3;
inline bool memcpy_pol::has_size() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void memcpy_pol::clear_size() {
  size_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::common::action memcpy_pol::size() const {
  // @@protoc_insertion_point(field_get:libcall_types.memcpy_pol.size)
  return static_cast< ::common::action >(size_);
}
inline void memcpy_pol::set_size(::common::action value) {
  assert(::common::action_IsValid(value));
  _has_bits_[0] |= 0x00000004u;
  size_ = value;
  // @@protoc_insertion_point(field_set:libcall_types.memcpy_pol.size)
}

// required .common.action ret = 4;
inline bool memcpy_pol::has_ret() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void memcpy_pol::clear_ret() {
  ret_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::common::action memcpy_pol::ret() const {
  // @@protoc_insertion_point(field_get:libcall_types.memcpy_pol.ret)
  return static_cast< ::common::action >(ret_);
}
inline void memcpy_pol::set_ret(::common::action value) {
  assert(::common::action_IsValid(value));
  _has_bits_[0] |= 0x00000008u;
  ret_ = value;
  // @@protoc_insertion_point(field_set:libcall_types.memcpy_pol.ret)
}

// -------------------------------------------------------------------

// memset_pol

// required .common.memory_pol s = 1;
inline bool memset_pol::has_s() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline const ::common::memory_pol& memset_pol::s() const {
  const ::common::memory_pol* p = s_;
  // @@protoc_insertion_point(field_get:libcall_types.memset_pol.s)
  return p != nullptr ? *p : *reinterpret_cast<const ::common::memory_pol*>(
      &::common::_memory_pol_default_instance_);
}
inline ::common::memory_pol* memset_pol::release_s() {
  // @@protoc_insertion_point(field_release:libcall_types.memset_pol.s)
  _has_bits_[0] &= ~0x00000001u;
  ::common::memory_pol* temp = s_;
  s_ = nullptr;
  return temp;
}
inline ::common::memory_pol* memset_pol::mutable_s() {
  _has_bits_[0] |= 0x00000001u;
  if (s_ == nullptr) {
    auto* p = CreateMaybeMessage<::common::memory_pol>(GetArenaNoVirtual());
    s_ = p;
  }
  // @@protoc_insertion_point(field_mutable:libcall_types.memset_pol.s)
  return s_;
}
inline void memset_pol::set_allocated_s(::common::memory_pol* s) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(s_);
  }
  if (s) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      s = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, s, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  s_ = s;
  // @@protoc_insertion_point(field_set_allocated:libcall_types.memset_pol.s)
}

// required .common.action c = 2;
inline bool memset_pol::has_c() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void memset_pol::clear_c() {
  c_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::common::action memset_pol::c() const {
  // @@protoc_insertion_point(field_get:libcall_types.memset_pol.c)
  return static_cast< ::common::action >(c_);
}
inline void memset_pol::set_c(::common::action value) {
  assert(::common::action_IsValid(value));
  _has_bits_[0] |= 0x00000002u;
  c_ = value;
  // @@protoc_insertion_point(field_set:libcall_types.memset_pol.c)
}

// required .common.action size = 3;
inline bool memset_pol::has_size() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void memset_pol::clear_size() {
  size_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::common::action memset_pol::size() const {
  // @@protoc_insertion_point(field_get:libcall_types.memset_pol.size)
  return static_cast< ::common::action >(size_);
}
inline void memset_pol::set_size(::common::action value) {
  assert(::common::action_IsValid(value));
  _has_bits_[0] |= 0x00000004u;
  size_ = value;
  // @@protoc_insertion_point(field_set:libcall_types.memset_pol.size)
}

// required .common.action ret = 4;
inline bool memset_pol::has_ret() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void memset_pol::clear_ret() {
  ret_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::common::action memset_pol::ret() const {
  // @@protoc_insertion_point(field_get:libcall_types.memset_pol.ret)
  return static_cast< ::common::action >(ret_);
}
inline void memset_pol::set_ret(::common::action value) {
  assert(::common::action_IsValid(value));
  _has_bits_[0] |= 0x00000008u;
  ret_ = value;
  // @@protoc_insertion_point(field_set:libcall_types.memset_pol.ret)
}

// -------------------------------------------------------------------

// fgetc_pol

// required .common.action stream = 1;
inline bool fgetc_pol::has_stream() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void fgetc_pol::clear_stream() {
  stream_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::common::action fgetc_pol::stream() const {
  // @@protoc_insertion_point(field_get:libcall_types.fgetc_pol.stream)
  return static_cast< ::common::action >(stream_);
}
inline void fgetc_pol::set_stream(::common::action value) {
  assert(::common::action_IsValid(value));
  _has_bits_[0] |= 0x00000001u;
  stream_ = value;
  // @@protoc_insertion_point(field_set:libcall_types.fgetc_pol.stream)
}

// required .common.action ret = 2;
inline bool fgetc_pol::has_ret() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void fgetc_pol::clear_ret() {
  ret_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::common::action fgetc_pol::ret() const {
  // @@protoc_insertion_point(field_get:libcall_types.fgetc_pol.ret)
  return static_cast< ::common::action >(ret_);
}
inline void fgetc_pol::set_ret(::common::action value) {
  assert(::common::action_IsValid(value));
  _has_bits_[0] |= 0x00000002u;
  ret_ = value;
  // @@protoc_insertion_point(field_set:libcall_types.fgetc_pol.ret)
}

// -------------------------------------------------------------------

// lseek_pol

// required .common.action fd = 1;
inline bool lseek_pol::has_fd() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void lseek_pol::clear_fd() {
  fd_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::common::action lseek_pol::fd() const {
  // @@protoc_insertion_point(field_get:libcall_types.lseek_pol.fd)
  return static_cast< ::common::action >(fd_);
}
inline void lseek_pol::set_fd(::common::action value) {
  assert(::common::action_IsValid(value));
  _has_bits_[0] |= 0x00000001u;
  fd_ = value;
  // @@protoc_insertion_point(field_set:libcall_types.lseek_pol.fd)
}

// required .common.action offset = 2;
inline bool lseek_pol::has_offset() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void lseek_pol::clear_offset() {
  offset_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::common::action lseek_pol::offset() const {
  // @@protoc_insertion_point(field_get:libcall_types.lseek_pol.offset)
  return static_cast< ::common::action >(offset_);
}
inline void lseek_pol::set_offset(::common::action value) {
  assert(::common::action_IsValid(value));
  _has_bits_[0] |= 0x00000002u;
  offset_ = value;
  // @@protoc_insertion_point(field_set:libcall_types.lseek_pol.offset)
}

// required .common.action whence = 3;
inline bool lseek_pol::has_whence() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void lseek_pol::clear_whence() {
  whence_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::common::action lseek_pol::whence() const {
  // @@protoc_insertion_point(field_get:libcall_types.lseek_pol.whence)
  return static_cast< ::common::action >(whence_);
}
inline void lseek_pol::set_whence(::common::action value) {
  assert(::common::action_IsValid(value));
  _has_bits_[0] |= 0x00000004u;
  whence_ = value;
  // @@protoc_insertion_point(field_set:libcall_types.lseek_pol.whence)
}

// required .common.action ret = 4;
inline bool lseek_pol::has_ret() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void lseek_pol::clear_ret() {
  ret_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::common::action lseek_pol::ret() const {
  // @@protoc_insertion_point(field_get:libcall_types.lseek_pol.ret)
  return static_cast< ::common::action >(ret_);
}
inline void lseek_pol::set_ret(::common::action value) {
  assert(::common::action_IsValid(value));
  _has_bits_[0] |= 0x00000008u;
  ret_ = value;
  // @@protoc_insertion_point(field_set:libcall_types.lseek_pol.ret)
}

// -------------------------------------------------------------------

// exit_t

// -------------------------------------------------------------------

// generic_t

// required uint64 ret = 1;
inline bool generic_t::has_ret() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void generic_t::clear_ret() {
  ret_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 generic_t::ret() const {
  // @@protoc_insertion_point(field_get:libcall_types.generic_t.ret)
  return ret_;
}
inline void generic_t::set_ret(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000001u;
  ret_ = value;
  // @@protoc_insertion_point(field_set:libcall_types.generic_t.ret)
}

// -------------------------------------------------------------------

// fscanf_elem_t

// required .libcall_types.fscanf_enum type = 1;
inline bool fscanf_elem_t::has_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void fscanf_elem_t::clear_type() {
  type_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::libcall_types::fscanf_enum fscanf_elem_t::type() const {
  // @@protoc_insertion_point(field_get:libcall_types.fscanf_elem_t.type)
  return static_cast< ::libcall_types::fscanf_enum >(type_);
}
inline void fscanf_elem_t::set_type(::libcall_types::fscanf_enum value) {
  assert(::libcall_types::fscanf_enum_IsValid(value));
  _has_bits_[0] |= 0x00000002u;
  type_ = value;
  // @@protoc_insertion_point(field_set:libcall_types.fscanf_elem_t.type)
}

// required uint64 addr = 2;
inline bool fscanf_elem_t::has_addr() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void fscanf_elem_t::clear_addr() {
  addr_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 fscanf_elem_t::addr() const {
  // @@protoc_insertion_point(field_get:libcall_types.fscanf_elem_t.addr)
  return addr_;
}
inline void fscanf_elem_t::set_addr(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000001u;
  addr_ = value;
  // @@protoc_insertion_point(field_set:libcall_types.fscanf_elem_t.addr)
}

// optional uint64 value_dec = 3;
inline bool fscanf_elem_t::has_value_dec() const {
  return fscanf_cnt_case() == kValueDec;
}
inline void fscanf_elem_t::set_has_value_dec() {
  _oneof_case_[0] = kValueDec;
}
inline void fscanf_elem_t::clear_value_dec() {
  if (has_value_dec()) {
    fscanf_cnt_.value_dec_ = PROTOBUF_ULONGLONG(0);
    clear_has_fscanf_cnt();
  }
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 fscanf_elem_t::value_dec() const {
  // @@protoc_insertion_point(field_get:libcall_types.fscanf_elem_t.value_dec)
  if (has_value_dec()) {
    return fscanf_cnt_.value_dec_;
  }
  return PROTOBUF_ULONGLONG(0);
}
inline void fscanf_elem_t::set_value_dec(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  if (!has_value_dec()) {
    clear_fscanf_cnt();
    set_has_value_dec();
  }
  fscanf_cnt_.value_dec_ = value;
  // @@protoc_insertion_point(field_set:libcall_types.fscanf_elem_t.value_dec)
}

// optional string value_string = 4;
inline bool fscanf_elem_t::has_value_string() const {
  return fscanf_cnt_case() == kValueString;
}
inline void fscanf_elem_t::set_has_value_string() {
  _oneof_case_[0] = kValueString;
}
inline void fscanf_elem_t::clear_value_string() {
  if (has_value_string()) {
    fscanf_cnt_.value_string_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
    clear_has_fscanf_cnt();
  }
}
inline const std::string& fscanf_elem_t::value_string() const {
  // @@protoc_insertion_point(field_get:libcall_types.fscanf_elem_t.value_string)
  if (has_value_string()) {
    return fscanf_cnt_.value_string_.GetNoArena();
  }
  return *&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited();
}
inline void fscanf_elem_t::set_value_string(const std::string& value) {
  // @@protoc_insertion_point(field_set:libcall_types.fscanf_elem_t.value_string)
  if (!has_value_string()) {
    clear_fscanf_cnt();
    set_has_value_string();
    fscanf_cnt_.value_string_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  fscanf_cnt_.value_string_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:libcall_types.fscanf_elem_t.value_string)
}
inline void fscanf_elem_t::set_value_string(std::string&& value) {
  // @@protoc_insertion_point(field_set:libcall_types.fscanf_elem_t.value_string)
  if (!has_value_string()) {
    clear_fscanf_cnt();
    set_has_value_string();
    fscanf_cnt_.value_string_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  fscanf_cnt_.value_string_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:libcall_types.fscanf_elem_t.value_string)
}
inline void fscanf_elem_t::set_value_string(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  if (!has_value_string()) {
    clear_fscanf_cnt();
    set_has_value_string();
    fscanf_cnt_.value_string_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  fscanf_cnt_.value_string_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(value));
  // @@protoc_insertion_point(field_set_char:libcall_types.fscanf_elem_t.value_string)
}
inline void fscanf_elem_t::set_value_string(const char* value, size_t size) {
  if (!has_value_string()) {
    clear_fscanf_cnt();
    set_has_value_string();
    fscanf_cnt_.value_string_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  fscanf_cnt_.value_string_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:libcall_types.fscanf_elem_t.value_string)
}
inline std::string* fscanf_elem_t::mutable_value_string() {
  if (!has_value_string()) {
    clear_fscanf_cnt();
    set_has_value_string();
    fscanf_cnt_.value_string_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_mutable:libcall_types.fscanf_elem_t.value_string)
  return fscanf_cnt_.value_string_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* fscanf_elem_t::release_value_string() {
  // @@protoc_insertion_point(field_release:libcall_types.fscanf_elem_t.value_string)
  if (has_value_string()) {
    clear_has_fscanf_cnt();
    return fscanf_cnt_.value_string_.ReleaseNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  } else {
    return nullptr;
  }
}
inline void fscanf_elem_t::set_allocated_value_string(std::string* value_string) {
  if (has_fscanf_cnt()) {
    clear_fscanf_cnt();
  }
  if (value_string != nullptr) {
    set_has_value_string();
    fscanf_cnt_.value_string_.UnsafeSetDefault(value_string);
  }
  // @@protoc_insertion_point(field_set_allocated:libcall_types.fscanf_elem_t.value_string)
}

inline bool fscanf_elem_t::has_fscanf_cnt() const {
  return fscanf_cnt_case() != FSCANF_CNT_NOT_SET;
}
inline void fscanf_elem_t::clear_has_fscanf_cnt() {
  _oneof_case_[0] = FSCANF_CNT_NOT_SET;
}
inline fscanf_elem_t::FscanfCntCase fscanf_elem_t::fscanf_cnt_case() const {
  return fscanf_elem_t::FscanfCntCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// fscanf_t

// required uint64 stream = 1;
inline bool fscanf_t::has_stream() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void fscanf_t::clear_stream() {
  stream_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 fscanf_t::stream() const {
  // @@protoc_insertion_point(field_get:libcall_types.fscanf_t.stream)
  return stream_;
}
inline void fscanf_t::set_stream(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000001u;
  stream_ = value;
  // @@protoc_insertion_point(field_set:libcall_types.fscanf_t.stream)
}

// repeated .libcall_types.fscanf_elem_t elems = 2;
inline int fscanf_t::elems_size() const {
  return elems_.size();
}
inline void fscanf_t::clear_elems() {
  elems_.Clear();
}
inline ::libcall_types::fscanf_elem_t* fscanf_t::mutable_elems(int index) {
  // @@protoc_insertion_point(field_mutable:libcall_types.fscanf_t.elems)
  return elems_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::libcall_types::fscanf_elem_t >*
fscanf_t::mutable_elems() {
  // @@protoc_insertion_point(field_mutable_list:libcall_types.fscanf_t.elems)
  return &elems_;
}
inline const ::libcall_types::fscanf_elem_t& fscanf_t::elems(int index) const {
  // @@protoc_insertion_point(field_get:libcall_types.fscanf_t.elems)
  return elems_.Get(index);
}
inline ::libcall_types::fscanf_elem_t* fscanf_t::add_elems() {
  // @@protoc_insertion_point(field_add:libcall_types.fscanf_t.elems)
  return elems_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::libcall_types::fscanf_elem_t >&
fscanf_t::elems() const {
  // @@protoc_insertion_point(field_list:libcall_types.fscanf_t.elems)
  return elems_;
}

// required uint64 ret = 3;
inline bool fscanf_t::has_ret() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void fscanf_t::clear_ret() {
  ret_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 fscanf_t::ret() const {
  // @@protoc_insertion_point(field_get:libcall_types.fscanf_t.ret)
  return ret_;
}
inline void fscanf_t::set_ret(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000002u;
  ret_ = value;
  // @@protoc_insertion_point(field_set:libcall_types.fscanf_t.ret)
}

// -------------------------------------------------------------------

// ctype_b_loc_t

// required .common.memory_t table = 1;
inline bool ctype_b_loc_t::has_table() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline const ::common::memory_t& ctype_b_loc_t::table() const {
  const ::common::memory_t* p = table_;
  // @@protoc_insertion_point(field_get:libcall_types.ctype_b_loc_t.table)
  return p != nullptr ? *p : *reinterpret_cast<const ::common::memory_t*>(
      &::common::_memory_t_default_instance_);
}
inline ::common::memory_t* ctype_b_loc_t::release_table() {
  // @@protoc_insertion_point(field_release:libcall_types.ctype_b_loc_t.table)
  _has_bits_[0] &= ~0x00000001u;
  ::common::memory_t* temp = table_;
  table_ = nullptr;
  return temp;
}
inline ::common::memory_t* ctype_b_loc_t::mutable_table() {
  _has_bits_[0] |= 0x00000001u;
  if (table_ == nullptr) {
    auto* p = CreateMaybeMessage<::common::memory_t>(GetArenaNoVirtual());
    table_ = p;
  }
  // @@protoc_insertion_point(field_mutable:libcall_types.ctype_b_loc_t.table)
  return table_;
}
inline void ctype_b_loc_t::set_allocated_table(::common::memory_t* table) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(table_);
  }
  if (table) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      table = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, table, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  table_ = table;
  // @@protoc_insertion_point(field_set_allocated:libcall_types.ctype_b_loc_t.table)
}

// required uint64 ret = 2;
inline bool ctype_b_loc_t::has_ret() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ctype_b_loc_t::clear_ret() {
  ret_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 ctype_b_loc_t::ret() const {
  // @@protoc_insertion_point(field_get:libcall_types.ctype_b_loc_t.ret)
  return ret_;
}
inline void ctype_b_loc_t::set_ret(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000002u;
  ret_ = value;
  // @@protoc_insertion_point(field_set:libcall_types.ctype_b_loc_t.ret)
}

// -------------------------------------------------------------------

// read_t

// required uint64 fd = 1;
inline bool read_t::has_fd() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void read_t::clear_fd() {
  fd_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 read_t::fd() const {
  // @@protoc_insertion_point(field_get:libcall_types.read_t.fd)
  return fd_;
}
inline void read_t::set_fd(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000002u;
  fd_ = value;
  // @@protoc_insertion_point(field_set:libcall_types.read_t.fd)
}

// required .common.memory_t buf = 2;
inline bool read_t::has_buf() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline const ::common::memory_t& read_t::buf() const {
  const ::common::memory_t* p = buf_;
  // @@protoc_insertion_point(field_get:libcall_types.read_t.buf)
  return p != nullptr ? *p : *reinterpret_cast<const ::common::memory_t*>(
      &::common::_memory_t_default_instance_);
}
inline ::common::memory_t* read_t::release_buf() {
  // @@protoc_insertion_point(field_release:libcall_types.read_t.buf)
  _has_bits_[0] &= ~0x00000001u;
  ::common::memory_t* temp = buf_;
  buf_ = nullptr;
  return temp;
}
inline ::common::memory_t* read_t::mutable_buf() {
  _has_bits_[0] |= 0x00000001u;
  if (buf_ == nullptr) {
    auto* p = CreateMaybeMessage<::common::memory_t>(GetArenaNoVirtual());
    buf_ = p;
  }
  // @@protoc_insertion_point(field_mutable:libcall_types.read_t.buf)
  return buf_;
}
inline void read_t::set_allocated_buf(::common::memory_t* buf) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(buf_);
  }
  if (buf) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      buf = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, buf, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  buf_ = buf;
  // @@protoc_insertion_point(field_set_allocated:libcall_types.read_t.buf)
}

// required uint64 count = 3;
inline bool read_t::has_count() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void read_t::clear_count() {
  count_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 read_t::count() const {
  // @@protoc_insertion_point(field_get:libcall_types.read_t.count)
  return count_;
}
inline void read_t::set_count(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000004u;
  count_ = value;
  // @@protoc_insertion_point(field_set:libcall_types.read_t.count)
}

// required uint64 ret = 4;
inline bool read_t::has_ret() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void read_t::clear_ret() {
  ret_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000008u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 read_t::ret() const {
  // @@protoc_insertion_point(field_get:libcall_types.read_t.ret)
  return ret_;
}
inline void read_t::set_ret(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000008u;
  ret_ = value;
  // @@protoc_insertion_point(field_set:libcall_types.read_t.ret)
}

// -------------------------------------------------------------------

// fread_t

// required .common.memory_t ptr = 1;
inline bool fread_t::has_ptr() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline const ::common::memory_t& fread_t::ptr() const {
  const ::common::memory_t* p = ptr_;
  // @@protoc_insertion_point(field_get:libcall_types.fread_t.ptr)
  return p != nullptr ? *p : *reinterpret_cast<const ::common::memory_t*>(
      &::common::_memory_t_default_instance_);
}
inline ::common::memory_t* fread_t::release_ptr() {
  // @@protoc_insertion_point(field_release:libcall_types.fread_t.ptr)
  _has_bits_[0] &= ~0x00000001u;
  ::common::memory_t* temp = ptr_;
  ptr_ = nullptr;
  return temp;
}
inline ::common::memory_t* fread_t::mutable_ptr() {
  _has_bits_[0] |= 0x00000001u;
  if (ptr_ == nullptr) {
    auto* p = CreateMaybeMessage<::common::memory_t>(GetArenaNoVirtual());
    ptr_ = p;
  }
  // @@protoc_insertion_point(field_mutable:libcall_types.fread_t.ptr)
  return ptr_;
}
inline void fread_t::set_allocated_ptr(::common::memory_t* ptr) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(ptr_);
  }
  if (ptr) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      ptr = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, ptr, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  ptr_ = ptr;
  // @@protoc_insertion_point(field_set_allocated:libcall_types.fread_t.ptr)
}

// required uint64 size = 2;
inline bool fread_t::has_size() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void fread_t::clear_size() {
  size_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 fread_t::size() const {
  // @@protoc_insertion_point(field_get:libcall_types.fread_t.size)
  return size_;
}
inline void fread_t::set_size(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000002u;
  size_ = value;
  // @@protoc_insertion_point(field_set:libcall_types.fread_t.size)
}

// required uint64 nmemb = 3;
inline bool fread_t::has_nmemb() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void fread_t::clear_nmemb() {
  nmemb_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 fread_t::nmemb() const {
  // @@protoc_insertion_point(field_get:libcall_types.fread_t.nmemb)
  return nmemb_;
}
inline void fread_t::set_nmemb(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000004u;
  nmemb_ = value;
  // @@protoc_insertion_point(field_set:libcall_types.fread_t.nmemb)
}

// required uint64 stream = 4;
inline bool fread_t::has_stream() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void fread_t::clear_stream() {
  stream_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000008u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 fread_t::stream() const {
  // @@protoc_insertion_point(field_get:libcall_types.fread_t.stream)
  return stream_;
}
inline void fread_t::set_stream(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000008u;
  stream_ = value;
  // @@protoc_insertion_point(field_set:libcall_types.fread_t.stream)
}

// required uint64 ret = 5;
inline bool fread_t::has_ret() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void fread_t::clear_ret() {
  ret_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000010u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 fread_t::ret() const {
  // @@protoc_insertion_point(field_get:libcall_types.fread_t.ret)
  return ret_;
}
inline void fread_t::set_ret(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000010u;
  ret_ = value;
  // @@protoc_insertion_point(field_set:libcall_types.fread_t.ret)
}

// -------------------------------------------------------------------

// strchr_t

// required uint64 s = 1;
inline bool strchr_t::has_s() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void strchr_t::clear_s() {
  s_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 strchr_t::s() const {
  // @@protoc_insertion_point(field_get:libcall_types.strchr_t.s)
  return s_;
}
inline void strchr_t::set_s(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000001u;
  s_ = value;
  // @@protoc_insertion_point(field_set:libcall_types.strchr_t.s)
}

// required uint64 c = 2;
inline bool strchr_t::has_c() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void strchr_t::clear_c() {
  c_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 strchr_t::c() const {
  // @@protoc_insertion_point(field_get:libcall_types.strchr_t.c)
  return c_;
}
inline void strchr_t::set_c(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000002u;
  c_ = value;
  // @@protoc_insertion_point(field_set:libcall_types.strchr_t.c)
}

// required uint64 size_max = 3;
inline bool strchr_t::has_size_max() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void strchr_t::clear_size_max() {
  size_max_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 strchr_t::size_max() const {
  // @@protoc_insertion_point(field_get:libcall_types.strchr_t.size_max)
  return size_max_;
}
inline void strchr_t::set_size_max(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000004u;
  size_max_ = value;
  // @@protoc_insertion_point(field_set:libcall_types.strchr_t.size_max)
}

// required uint64 ret = 4;
inline bool strchr_t::has_ret() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void strchr_t::clear_ret() {
  ret_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000008u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 strchr_t::ret() const {
  // @@protoc_insertion_point(field_get:libcall_types.strchr_t.ret)
  return ret_;
}
inline void strchr_t::set_ret(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000008u;
  ret_ = value;
  // @@protoc_insertion_point(field_set:libcall_types.strchr_t.ret)
}

// -------------------------------------------------------------------

// strncpy_t

// required uint64 dst = 1;
inline bool strncpy_t::has_dst() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void strncpy_t::clear_dst() {
  dst_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 strncpy_t::dst() const {
  // @@protoc_insertion_point(field_get:libcall_types.strncpy_t.dst)
  return dst_;
}
inline void strncpy_t::set_dst(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000001u;
  dst_ = value;
  // @@protoc_insertion_point(field_set:libcall_types.strncpy_t.dst)
}

// required uint64 src = 2;
inline bool strncpy_t::has_src() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void strncpy_t::clear_src() {
  src_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 strncpy_t::src() const {
  // @@protoc_insertion_point(field_get:libcall_types.strncpy_t.src)
  return src_;
}
inline void strncpy_t::set_src(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000002u;
  src_ = value;
  // @@protoc_insertion_point(field_set:libcall_types.strncpy_t.src)
}

// required uint64 n = 3;
inline bool strncpy_t::has_n() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void strncpy_t::clear_n() {
  n_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 strncpy_t::n() const {
  // @@protoc_insertion_point(field_get:libcall_types.strncpy_t.n)
  return n_;
}
inline void strncpy_t::set_n(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000004u;
  n_ = value;
  // @@protoc_insertion_point(field_set:libcall_types.strncpy_t.n)
}

// required uint64 ret = 4;
inline bool strncpy_t::has_ret() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void strncpy_t::clear_ret() {
  ret_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000008u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 strncpy_t::ret() const {
  // @@protoc_insertion_point(field_get:libcall_types.strncpy_t.ret)
  return ret_;
}
inline void strncpy_t::set_ret(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000008u;
  ret_ = value;
  // @@protoc_insertion_point(field_set:libcall_types.strncpy_t.ret)
}

// -------------------------------------------------------------------

// fstat_t

// required uint64 fd = 1;
inline bool fstat_t::has_fd() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void fstat_t::clear_fd() {
  fd_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 fstat_t::fd() const {
  // @@protoc_insertion_point(field_get:libcall_types.fstat_t.fd)
  return fd_;
}
inline void fstat_t::set_fd(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000002u;
  fd_ = value;
  // @@protoc_insertion_point(field_set:libcall_types.fstat_t.fd)
}

// required .common.memory_t buf = 2;
inline bool fstat_t::has_buf() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline const ::common::memory_t& fstat_t::buf() const {
  const ::common::memory_t* p = buf_;
  // @@protoc_insertion_point(field_get:libcall_types.fstat_t.buf)
  return p != nullptr ? *p : *reinterpret_cast<const ::common::memory_t*>(
      &::common::_memory_t_default_instance_);
}
inline ::common::memory_t* fstat_t::release_buf() {
  // @@protoc_insertion_point(field_release:libcall_types.fstat_t.buf)
  _has_bits_[0] &= ~0x00000001u;
  ::common::memory_t* temp = buf_;
  buf_ = nullptr;
  return temp;
}
inline ::common::memory_t* fstat_t::mutable_buf() {
  _has_bits_[0] |= 0x00000001u;
  if (buf_ == nullptr) {
    auto* p = CreateMaybeMessage<::common::memory_t>(GetArenaNoVirtual());
    buf_ = p;
  }
  // @@protoc_insertion_point(field_mutable:libcall_types.fstat_t.buf)
  return buf_;
}
inline void fstat_t::set_allocated_buf(::common::memory_t* buf) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(buf_);
  }
  if (buf) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      buf = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, buf, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  buf_ = buf;
  // @@protoc_insertion_point(field_set_allocated:libcall_types.fstat_t.buf)
}

// required uint64 ret = 3;
inline bool fstat_t::has_ret() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void fstat_t::clear_ret() {
  ret_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 fstat_t::ret() const {
  // @@protoc_insertion_point(field_get:libcall_types.fstat_t.ret)
  return ret_;
}
inline void fstat_t::set_ret(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000004u;
  ret_ = value;
  // @@protoc_insertion_point(field_set:libcall_types.fstat_t.ret)
}

// -------------------------------------------------------------------

// fxstat64_t

// required uint64 vers = 1;
inline bool fxstat64_t::has_vers() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void fxstat64_t::clear_vers() {
  vers_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 fxstat64_t::vers() const {
  // @@protoc_insertion_point(field_get:libcall_types.fxstat64_t.vers)
  return vers_;
}
inline void fxstat64_t::set_vers(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000002u;
  vers_ = value;
  // @@protoc_insertion_point(field_set:libcall_types.fxstat64_t.vers)
}

// required uint64 fd = 2;
inline bool fxstat64_t::has_fd() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void fxstat64_t::clear_fd() {
  fd_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 fxstat64_t::fd() const {
  // @@protoc_insertion_point(field_get:libcall_types.fxstat64_t.fd)
  return fd_;
}
inline void fxstat64_t::set_fd(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000004u;
  fd_ = value;
  // @@protoc_insertion_point(field_set:libcall_types.fxstat64_t.fd)
}

// required .common.memory_t buf = 3;
inline bool fxstat64_t::has_buf() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline const ::common::memory_t& fxstat64_t::buf() const {
  const ::common::memory_t* p = buf_;
  // @@protoc_insertion_point(field_get:libcall_types.fxstat64_t.buf)
  return p != nullptr ? *p : *reinterpret_cast<const ::common::memory_t*>(
      &::common::_memory_t_default_instance_);
}
inline ::common::memory_t* fxstat64_t::release_buf() {
  // @@protoc_insertion_point(field_release:libcall_types.fxstat64_t.buf)
  _has_bits_[0] &= ~0x00000001u;
  ::common::memory_t* temp = buf_;
  buf_ = nullptr;
  return temp;
}
inline ::common::memory_t* fxstat64_t::mutable_buf() {
  _has_bits_[0] |= 0x00000001u;
  if (buf_ == nullptr) {
    auto* p = CreateMaybeMessage<::common::memory_t>(GetArenaNoVirtual());
    buf_ = p;
  }
  // @@protoc_insertion_point(field_mutable:libcall_types.fxstat64_t.buf)
  return buf_;
}
inline void fxstat64_t::set_allocated_buf(::common::memory_t* buf) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(buf_);
  }
  if (buf) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      buf = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, buf, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  buf_ = buf;
  // @@protoc_insertion_point(field_set_allocated:libcall_types.fxstat64_t.buf)
}

// required uint64 ret = 4;
inline bool fxstat64_t::has_ret() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void fxstat64_t::clear_ret() {
  ret_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000008u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 fxstat64_t::ret() const {
  // @@protoc_insertion_point(field_get:libcall_types.fxstat64_t.ret)
  return ret_;
}
inline void fxstat64_t::set_ret(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000008u;
  ret_ = value;
  // @@protoc_insertion_point(field_set:libcall_types.fxstat64_t.ret)
}

// -------------------------------------------------------------------

// realloc_t

// required uint64 ptr = 1;
inline bool realloc_t::has_ptr() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void realloc_t::clear_ptr() {
  ptr_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 realloc_t::ptr() const {
  // @@protoc_insertion_point(field_get:libcall_types.realloc_t.ptr)
  return ptr_;
}
inline void realloc_t::set_ptr(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000001u;
  ptr_ = value;
  // @@protoc_insertion_point(field_set:libcall_types.realloc_t.ptr)
}

// required uint64 size = 2;
inline bool realloc_t::has_size() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void realloc_t::clear_size() {
  size_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 realloc_t::size() const {
  // @@protoc_insertion_point(field_get:libcall_types.realloc_t.size)
  return size_;
}
inline void realloc_t::set_size(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000002u;
  size_ = value;
  // @@protoc_insertion_point(field_set:libcall_types.realloc_t.size)
}

// required uint64 ret = 3;
inline bool realloc_t::has_ret() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void realloc_t::clear_ret() {
  ret_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 realloc_t::ret() const {
  // @@protoc_insertion_point(field_get:libcall_types.realloc_t.ret)
  return ret_;
}
inline void realloc_t::set_ret(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000004u;
  ret_ = value;
  // @@protoc_insertion_point(field_set:libcall_types.realloc_t.ret)
}

// -------------------------------------------------------------------

// mmap_t

// required uint64 addr = 1;
inline bool mmap_t::has_addr() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void mmap_t::clear_addr() {
  addr_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 mmap_t::addr() const {
  // @@protoc_insertion_point(field_get:libcall_types.mmap_t.addr)
  return addr_;
}
inline void mmap_t::set_addr(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000002u;
  addr_ = value;
  // @@protoc_insertion_point(field_set:libcall_types.mmap_t.addr)
}

// required uint64 length = 2;
inline bool mmap_t::has_length() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void mmap_t::clear_length() {
  length_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 mmap_t::length() const {
  // @@protoc_insertion_point(field_get:libcall_types.mmap_t.length)
  return length_;
}
inline void mmap_t::set_length(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000004u;
  length_ = value;
  // @@protoc_insertion_point(field_set:libcall_types.mmap_t.length)
}

// required uint64 prot = 3;
inline bool mmap_t::has_prot() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void mmap_t::clear_prot() {
  prot_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000008u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 mmap_t::prot() const {
  // @@protoc_insertion_point(field_get:libcall_types.mmap_t.prot)
  return prot_;
}
inline void mmap_t::set_prot(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000008u;
  prot_ = value;
  // @@protoc_insertion_point(field_set:libcall_types.mmap_t.prot)
}

// required uint64 flags = 4;
inline bool mmap_t::has_flags() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void mmap_t::clear_flags() {
  flags_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000010u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 mmap_t::flags() const {
  // @@protoc_insertion_point(field_get:libcall_types.mmap_t.flags)
  return flags_;
}
inline void mmap_t::set_flags(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000010u;
  flags_ = value;
  // @@protoc_insertion_point(field_set:libcall_types.mmap_t.flags)
}

// required uint64 fd = 5;
inline bool mmap_t::has_fd() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void mmap_t::clear_fd() {
  fd_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000020u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 mmap_t::fd() const {
  // @@protoc_insertion_point(field_get:libcall_types.mmap_t.fd)
  return fd_;
}
inline void mmap_t::set_fd(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000020u;
  fd_ = value;
  // @@protoc_insertion_point(field_set:libcall_types.mmap_t.fd)
}

// required uint64 offset = 6;
inline bool mmap_t::has_offset() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void mmap_t::clear_offset() {
  offset_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000040u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 mmap_t::offset() const {
  // @@protoc_insertion_point(field_get:libcall_types.mmap_t.offset)
  return offset_;
}
inline void mmap_t::set_offset(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000040u;
  offset_ = value;
  // @@protoc_insertion_point(field_set:libcall_types.mmap_t.offset)
}

// required .common.memory_t ret = 7;
inline bool mmap_t::has_ret() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline const ::common::memory_t& mmap_t::ret() const {
  const ::common::memory_t* p = ret_;
  // @@protoc_insertion_point(field_get:libcall_types.mmap_t.ret)
  return p != nullptr ? *p : *reinterpret_cast<const ::common::memory_t*>(
      &::common::_memory_t_default_instance_);
}
inline ::common::memory_t* mmap_t::release_ret() {
  // @@protoc_insertion_point(field_release:libcall_types.mmap_t.ret)
  _has_bits_[0] &= ~0x00000001u;
  ::common::memory_t* temp = ret_;
  ret_ = nullptr;
  return temp;
}
inline ::common::memory_t* mmap_t::mutable_ret() {
  _has_bits_[0] |= 0x00000001u;
  if (ret_ == nullptr) {
    auto* p = CreateMaybeMessage<::common::memory_t>(GetArenaNoVirtual());
    ret_ = p;
  }
  // @@protoc_insertion_point(field_mutable:libcall_types.mmap_t.ret)
  return ret_;
}
inline void mmap_t::set_allocated_ret(::common::memory_t* ret) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(ret_);
  }
  if (ret) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      ret = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, ret, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  ret_ = ret;
  // @@protoc_insertion_point(field_set_allocated:libcall_types.mmap_t.ret)
}

// -------------------------------------------------------------------

// qsort_t

// required .common.memory_t base = 1;
inline bool qsort_t::has_base() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline const ::common::memory_t& qsort_t::base() const {
  const ::common::memory_t* p = base_;
  // @@protoc_insertion_point(field_get:libcall_types.qsort_t.base)
  return p != nullptr ? *p : *reinterpret_cast<const ::common::memory_t*>(
      &::common::_memory_t_default_instance_);
}
inline ::common::memory_t* qsort_t::release_base() {
  // @@protoc_insertion_point(field_release:libcall_types.qsort_t.base)
  _has_bits_[0] &= ~0x00000001u;
  ::common::memory_t* temp = base_;
  base_ = nullptr;
  return temp;
}
inline ::common::memory_t* qsort_t::mutable_base() {
  _has_bits_[0] |= 0x00000001u;
  if (base_ == nullptr) {
    auto* p = CreateMaybeMessage<::common::memory_t>(GetArenaNoVirtual());
    base_ = p;
  }
  // @@protoc_insertion_point(field_mutable:libcall_types.qsort_t.base)
  return base_;
}
inline void qsort_t::set_allocated_base(::common::memory_t* base) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(base_);
  }
  if (base) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      base = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, base, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  base_ = base;
  // @@protoc_insertion_point(field_set_allocated:libcall_types.qsort_t.base)
}

// required uint64 nmemb = 2;
inline bool qsort_t::has_nmemb() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void qsort_t::clear_nmemb() {
  nmemb_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 qsort_t::nmemb() const {
  // @@protoc_insertion_point(field_get:libcall_types.qsort_t.nmemb)
  return nmemb_;
}
inline void qsort_t::set_nmemb(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000002u;
  nmemb_ = value;
  // @@protoc_insertion_point(field_set:libcall_types.qsort_t.nmemb)
}

// required uint64 size = 3;
inline bool qsort_t::has_size() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void qsort_t::clear_size() {
  size_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 qsort_t::size() const {
  // @@protoc_insertion_point(field_get:libcall_types.qsort_t.size)
  return size_;
}
inline void qsort_t::set_size(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000004u;
  size_ = value;
  // @@protoc_insertion_point(field_set:libcall_types.qsort_t.size)
}

// required uint64 compare = 4;
inline bool qsort_t::has_compare() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void qsort_t::clear_compare() {
  compare_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000008u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 qsort_t::compare() const {
  // @@protoc_insertion_point(field_get:libcall_types.qsort_t.compare)
  return compare_;
}
inline void qsort_t::set_compare(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000008u;
  compare_ = value;
  // @@protoc_insertion_point(field_set:libcall_types.qsort_t.compare)
}

// -------------------------------------------------------------------

// bsearch_t

// required .common.memory_t key = 1;
inline bool bsearch_t::has_key() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline const ::common::memory_t& bsearch_t::key() const {
  const ::common::memory_t* p = key_;
  // @@protoc_insertion_point(field_get:libcall_types.bsearch_t.key)
  return p != nullptr ? *p : *reinterpret_cast<const ::common::memory_t*>(
      &::common::_memory_t_default_instance_);
}
inline ::common::memory_t* bsearch_t::release_key() {
  // @@protoc_insertion_point(field_release:libcall_types.bsearch_t.key)
  _has_bits_[0] &= ~0x00000001u;
  ::common::memory_t* temp = key_;
  key_ = nullptr;
  return temp;
}
inline ::common::memory_t* bsearch_t::mutable_key() {
  _has_bits_[0] |= 0x00000001u;
  if (key_ == nullptr) {
    auto* p = CreateMaybeMessage<::common::memory_t>(GetArenaNoVirtual());
    key_ = p;
  }
  // @@protoc_insertion_point(field_mutable:libcall_types.bsearch_t.key)
  return key_;
}
inline void bsearch_t::set_allocated_key(::common::memory_t* key) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(key_);
  }
  if (key) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      key = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, key, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  key_ = key;
  // @@protoc_insertion_point(field_set_allocated:libcall_types.bsearch_t.key)
}

// required .common.memory_t base = 2;
inline bool bsearch_t::has_base() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline const ::common::memory_t& bsearch_t::base() const {
  const ::common::memory_t* p = base_;
  // @@protoc_insertion_point(field_get:libcall_types.bsearch_t.base)
  return p != nullptr ? *p : *reinterpret_cast<const ::common::memory_t*>(
      &::common::_memory_t_default_instance_);
}
inline ::common::memory_t* bsearch_t::release_base() {
  // @@protoc_insertion_point(field_release:libcall_types.bsearch_t.base)
  _has_bits_[0] &= ~0x00000002u;
  ::common::memory_t* temp = base_;
  base_ = nullptr;
  return temp;
}
inline ::common::memory_t* bsearch_t::mutable_base() {
  _has_bits_[0] |= 0x00000002u;
  if (base_ == nullptr) {
    auto* p = CreateMaybeMessage<::common::memory_t>(GetArenaNoVirtual());
    base_ = p;
  }
  // @@protoc_insertion_point(field_mutable:libcall_types.bsearch_t.base)
  return base_;
}
inline void bsearch_t::set_allocated_base(::common::memory_t* base) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(base_);
  }
  if (base) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      base = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, base, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  base_ = base;
  // @@protoc_insertion_point(field_set_allocated:libcall_types.bsearch_t.base)
}

// required uint64 nmemb = 3;
inline bool bsearch_t::has_nmemb() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void bsearch_t::clear_nmemb() {
  nmemb_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000008u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 bsearch_t::nmemb() const {
  // @@protoc_insertion_point(field_get:libcall_types.bsearch_t.nmemb)
  return nmemb_;
}
inline void bsearch_t::set_nmemb(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000008u;
  nmemb_ = value;
  // @@protoc_insertion_point(field_set:libcall_types.bsearch_t.nmemb)
}

// required uint64 size = 4;
inline bool bsearch_t::has_size() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void bsearch_t::clear_size() {
  size_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000010u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 bsearch_t::size() const {
  // @@protoc_insertion_point(field_get:libcall_types.bsearch_t.size)
  return size_;
}
inline void bsearch_t::set_size(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000010u;
  size_ = value;
  // @@protoc_insertion_point(field_set:libcall_types.bsearch_t.size)
}

// required uint64 compare = 5;
inline bool bsearch_t::has_compare() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void bsearch_t::clear_compare() {
  compare_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000020u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 bsearch_t::compare() const {
  // @@protoc_insertion_point(field_get:libcall_types.bsearch_t.compare)
  return compare_;
}
inline void bsearch_t::set_compare(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000020u;
  compare_ = value;
  // @@protoc_insertion_point(field_set:libcall_types.bsearch_t.compare)
}

// required .common.memory_t ret = 6;
inline bool bsearch_t::has_ret() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline const ::common::memory_t& bsearch_t::ret() const {
  const ::common::memory_t* p = ret_;
  // @@protoc_insertion_point(field_get:libcall_types.bsearch_t.ret)
  return p != nullptr ? *p : *reinterpret_cast<const ::common::memory_t*>(
      &::common::_memory_t_default_instance_);
}
inline ::common::memory_t* bsearch_t::release_ret() {
  // @@protoc_insertion_point(field_release:libcall_types.bsearch_t.ret)
  _has_bits_[0] &= ~0x00000004u;
  ::common::memory_t* temp = ret_;
  ret_ = nullptr;
  return temp;
}
inline ::common::memory_t* bsearch_t::mutable_ret() {
  _has_bits_[0] |= 0x00000004u;
  if (ret_ == nullptr) {
    auto* p = CreateMaybeMessage<::common::memory_t>(GetArenaNoVirtual());
    ret_ = p;
  }
  // @@protoc_insertion_point(field_mutable:libcall_types.bsearch_t.ret)
  return ret_;
}
inline void bsearch_t::set_allocated_ret(::common::memory_t* ret) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(ret_);
  }
  if (ret) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      ret = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, ret, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  ret_ = ret;
  // @@protoc_insertion_point(field_set_allocated:libcall_types.bsearch_t.ret)
}

// -------------------------------------------------------------------

// open_t

// required .common.memory_t pathname = 1;
inline bool open_t::has_pathname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline const ::common::memory_t& open_t::pathname() const {
  const ::common::memory_t* p = pathname_;
  // @@protoc_insertion_point(field_get:libcall_types.open_t.pathname)
  return p != nullptr ? *p : *reinterpret_cast<const ::common::memory_t*>(
      &::common::_memory_t_default_instance_);
}
inline ::common::memory_t* open_t::release_pathname() {
  // @@protoc_insertion_point(field_release:libcall_types.open_t.pathname)
  _has_bits_[0] &= ~0x00000001u;
  ::common::memory_t* temp = pathname_;
  pathname_ = nullptr;
  return temp;
}
inline ::common::memory_t* open_t::mutable_pathname() {
  _has_bits_[0] |= 0x00000001u;
  if (pathname_ == nullptr) {
    auto* p = CreateMaybeMessage<::common::memory_t>(GetArenaNoVirtual());
    pathname_ = p;
  }
  // @@protoc_insertion_point(field_mutable:libcall_types.open_t.pathname)
  return pathname_;
}
inline void open_t::set_allocated_pathname(::common::memory_t* pathname) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(pathname_);
  }
  if (pathname) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      pathname = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, pathname, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  pathname_ = pathname;
  // @@protoc_insertion_point(field_set_allocated:libcall_types.open_t.pathname)
}

// required uint64 flags = 3;
inline bool open_t::has_flags() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void open_t::clear_flags() {
  flags_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 open_t::flags() const {
  // @@protoc_insertion_point(field_get:libcall_types.open_t.flags)
  return flags_;
}
inline void open_t::set_flags(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000002u;
  flags_ = value;
  // @@protoc_insertion_point(field_set:libcall_types.open_t.flags)
}

// required uint64 mode = 4;
inline bool open_t::has_mode() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void open_t::clear_mode() {
  mode_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 open_t::mode() const {
  // @@protoc_insertion_point(field_get:libcall_types.open_t.mode)
  return mode_;
}
inline void open_t::set_mode(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000004u;
  mode_ = value;
  // @@protoc_insertion_point(field_set:libcall_types.open_t.mode)
}

// required uint64 ret = 5;
inline bool open_t::has_ret() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void open_t::clear_ret() {
  ret_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000008u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 open_t::ret() const {
  // @@protoc_insertion_point(field_get:libcall_types.open_t.ret)
  return ret_;
}
inline void open_t::set_ret(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000008u;
  ret_ = value;
  // @@protoc_insertion_point(field_set:libcall_types.open_t.ret)
}

// -------------------------------------------------------------------

// strcpy_t

// required .common.memory_t src = 1;
inline bool strcpy_t::has_src() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline const ::common::memory_t& strcpy_t::src() const {
  const ::common::memory_t* p = src_;
  // @@protoc_insertion_point(field_get:libcall_types.strcpy_t.src)
  return p != nullptr ? *p : *reinterpret_cast<const ::common::memory_t*>(
      &::common::_memory_t_default_instance_);
}
inline ::common::memory_t* strcpy_t::release_src() {
  // @@protoc_insertion_point(field_release:libcall_types.strcpy_t.src)
  _has_bits_[0] &= ~0x00000001u;
  ::common::memory_t* temp = src_;
  src_ = nullptr;
  return temp;
}
inline ::common::memory_t* strcpy_t::mutable_src() {
  _has_bits_[0] |= 0x00000001u;
  if (src_ == nullptr) {
    auto* p = CreateMaybeMessage<::common::memory_t>(GetArenaNoVirtual());
    src_ = p;
  }
  // @@protoc_insertion_point(field_mutable:libcall_types.strcpy_t.src)
  return src_;
}
inline void strcpy_t::set_allocated_src(::common::memory_t* src) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(src_);
  }
  if (src) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      src = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, src, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  src_ = src;
  // @@protoc_insertion_point(field_set_allocated:libcall_types.strcpy_t.src)
}

// required .common.memory_t dst = 2;
inline bool strcpy_t::has_dst() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline const ::common::memory_t& strcpy_t::dst() const {
  const ::common::memory_t* p = dst_;
  // @@protoc_insertion_point(field_get:libcall_types.strcpy_t.dst)
  return p != nullptr ? *p : *reinterpret_cast<const ::common::memory_t*>(
      &::common::_memory_t_default_instance_);
}
inline ::common::memory_t* strcpy_t::release_dst() {
  // @@protoc_insertion_point(field_release:libcall_types.strcpy_t.dst)
  _has_bits_[0] &= ~0x00000002u;
  ::common::memory_t* temp = dst_;
  dst_ = nullptr;
  return temp;
}
inline ::common::memory_t* strcpy_t::mutable_dst() {
  _has_bits_[0] |= 0x00000002u;
  if (dst_ == nullptr) {
    auto* p = CreateMaybeMessage<::common::memory_t>(GetArenaNoVirtual());
    dst_ = p;
  }
  // @@protoc_insertion_point(field_mutable:libcall_types.strcpy_t.dst)
  return dst_;
}
inline void strcpy_t::set_allocated_dst(::common::memory_t* dst) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(dst_);
  }
  if (dst) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      dst = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, dst, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  dst_ = dst;
  // @@protoc_insertion_point(field_set_allocated:libcall_types.strcpy_t.dst)
}

// required uint64 ret = 3;
inline bool strcpy_t::has_ret() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void strcpy_t::clear_ret() {
  ret_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 strcpy_t::ret() const {
  // @@protoc_insertion_point(field_get:libcall_types.strcpy_t.ret)
  return ret_;
}
inline void strcpy_t::set_ret(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000004u;
  ret_ = value;
  // @@protoc_insertion_point(field_set:libcall_types.strcpy_t.ret)
}

// -------------------------------------------------------------------

// strcmp_t

// required uint64 s1 = 1;
inline bool strcmp_t::has_s1() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void strcmp_t::clear_s1() {
  s1_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 strcmp_t::s1() const {
  // @@protoc_insertion_point(field_get:libcall_types.strcmp_t.s1)
  return s1_;
}
inline void strcmp_t::set_s1(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000001u;
  s1_ = value;
  // @@protoc_insertion_point(field_set:libcall_types.strcmp_t.s1)
}

// required uint64 s2 = 2;
inline bool strcmp_t::has_s2() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void strcmp_t::clear_s2() {
  s2_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 strcmp_t::s2() const {
  // @@protoc_insertion_point(field_get:libcall_types.strcmp_t.s2)
  return s2_;
}
inline void strcmp_t::set_s2(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000002u;
  s2_ = value;
  // @@protoc_insertion_point(field_set:libcall_types.strcmp_t.s2)
}

// required uint64 size_max_s1 = 3;
inline bool strcmp_t::has_size_max_s1() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void strcmp_t::clear_size_max_s1() {
  size_max_s1_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 strcmp_t::size_max_s1() const {
  // @@protoc_insertion_point(field_get:libcall_types.strcmp_t.size_max_s1)
  return size_max_s1_;
}
inline void strcmp_t::set_size_max_s1(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000004u;
  size_max_s1_ = value;
  // @@protoc_insertion_point(field_set:libcall_types.strcmp_t.size_max_s1)
}

// required uint64 size_max_s2 = 4;
inline bool strcmp_t::has_size_max_s2() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void strcmp_t::clear_size_max_s2() {
  size_max_s2_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000008u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 strcmp_t::size_max_s2() const {
  // @@protoc_insertion_point(field_get:libcall_types.strcmp_t.size_max_s2)
  return size_max_s2_;
}
inline void strcmp_t::set_size_max_s2(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000008u;
  size_max_s2_ = value;
  // @@protoc_insertion_point(field_set:libcall_types.strcmp_t.size_max_s2)
}

// required uint64 ret = 5;
inline bool strcmp_t::has_ret() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void strcmp_t::clear_ret() {
  ret_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000010u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 strcmp_t::ret() const {
  // @@protoc_insertion_point(field_get:libcall_types.strcmp_t.ret)
  return ret_;
}
inline void strcmp_t::set_ret(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000010u;
  ret_ = value;
  // @@protoc_insertion_point(field_set:libcall_types.strcmp_t.ret)
}

// -------------------------------------------------------------------

// strncmp_t

// required uint64 s1 = 1;
inline bool strncmp_t::has_s1() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void strncmp_t::clear_s1() {
  s1_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 strncmp_t::s1() const {
  // @@protoc_insertion_point(field_get:libcall_types.strncmp_t.s1)
  return s1_;
}
inline void strncmp_t::set_s1(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000001u;
  s1_ = value;
  // @@protoc_insertion_point(field_set:libcall_types.strncmp_t.s1)
}

// required uint64 s2 = 2;
inline bool strncmp_t::has_s2() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void strncmp_t::clear_s2() {
  s2_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 strncmp_t::s2() const {
  // @@protoc_insertion_point(field_get:libcall_types.strncmp_t.s2)
  return s2_;
}
inline void strncmp_t::set_s2(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000002u;
  s2_ = value;
  // @@protoc_insertion_point(field_set:libcall_types.strncmp_t.s2)
}

// required uint64 n = 3;
inline bool strncmp_t::has_n() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void strncmp_t::clear_n() {
  n_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 strncmp_t::n() const {
  // @@protoc_insertion_point(field_get:libcall_types.strncmp_t.n)
  return n_;
}
inline void strncmp_t::set_n(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000004u;
  n_ = value;
  // @@protoc_insertion_point(field_set:libcall_types.strncmp_t.n)
}

// required uint64 ret = 4;
inline bool strncmp_t::has_ret() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void strncmp_t::clear_ret() {
  ret_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000008u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 strncmp_t::ret() const {
  // @@protoc_insertion_point(field_get:libcall_types.strncmp_t.ret)
  return ret_;
}
inline void strncmp_t::set_ret(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000008u;
  ret_ = value;
  // @@protoc_insertion_point(field_set:libcall_types.strncmp_t.ret)
}

// -------------------------------------------------------------------

// memcmp_t

// required uint64 s1 = 1;
inline bool memcmp_t::has_s1() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void memcmp_t::clear_s1() {
  s1_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 memcmp_t::s1() const {
  // @@protoc_insertion_point(field_get:libcall_types.memcmp_t.s1)
  return s1_;
}
inline void memcmp_t::set_s1(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000001u;
  s1_ = value;
  // @@protoc_insertion_point(field_set:libcall_types.memcmp_t.s1)
}

// required uint64 s2 = 2;
inline bool memcmp_t::has_s2() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void memcmp_t::clear_s2() {
  s2_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 memcmp_t::s2() const {
  // @@protoc_insertion_point(field_get:libcall_types.memcmp_t.s2)
  return s2_;
}
inline void memcmp_t::set_s2(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000002u;
  s2_ = value;
  // @@protoc_insertion_point(field_set:libcall_types.memcmp_t.s2)
}

// required uint64 n = 3;
inline bool memcmp_t::has_n() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void memcmp_t::clear_n() {
  n_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 memcmp_t::n() const {
  // @@protoc_insertion_point(field_get:libcall_types.memcmp_t.n)
  return n_;
}
inline void memcmp_t::set_n(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000004u;
  n_ = value;
  // @@protoc_insertion_point(field_set:libcall_types.memcmp_t.n)
}

// required uint64 ret = 4;
inline bool memcmp_t::has_ret() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void memcmp_t::clear_ret() {
  ret_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000008u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 memcmp_t::ret() const {
  // @@protoc_insertion_point(field_get:libcall_types.memcmp_t.ret)
  return ret_;
}
inline void memcmp_t::set_ret(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000008u;
  ret_ = value;
  // @@protoc_insertion_point(field_set:libcall_types.memcmp_t.ret)
}

// -------------------------------------------------------------------

// printf_t

// required .common.memory_t format = 1;
inline bool printf_t::has_format() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline const ::common::memory_t& printf_t::format() const {
  const ::common::memory_t* p = format_;
  // @@protoc_insertion_point(field_get:libcall_types.printf_t.format)
  return p != nullptr ? *p : *reinterpret_cast<const ::common::memory_t*>(
      &::common::_memory_t_default_instance_);
}
inline ::common::memory_t* printf_t::release_format() {
  // @@protoc_insertion_point(field_release:libcall_types.printf_t.format)
  _has_bits_[0] &= ~0x00000001u;
  ::common::memory_t* temp = format_;
  format_ = nullptr;
  return temp;
}
inline ::common::memory_t* printf_t::mutable_format() {
  _has_bits_[0] |= 0x00000001u;
  if (format_ == nullptr) {
    auto* p = CreateMaybeMessage<::common::memory_t>(GetArenaNoVirtual());
    format_ = p;
  }
  // @@protoc_insertion_point(field_mutable:libcall_types.printf_t.format)
  return format_;
}
inline void printf_t::set_allocated_format(::common::memory_t* format) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(format_);
  }
  if (format) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      format = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, format, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  format_ = format;
  // @@protoc_insertion_point(field_set_allocated:libcall_types.printf_t.format)
}

// required uint64 ret = 2;
inline bool printf_t::has_ret() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void printf_t::clear_ret() {
  ret_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 printf_t::ret() const {
  // @@protoc_insertion_point(field_get:libcall_types.printf_t.ret)
  return ret_;
}
inline void printf_t::set_ret(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000002u;
  ret_ = value;
  // @@protoc_insertion_point(field_set:libcall_types.printf_t.ret)
}

// -------------------------------------------------------------------

// atoi_t

// required .common.memory_t src = 1;
inline bool atoi_t::has_src() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline const ::common::memory_t& atoi_t::src() const {
  const ::common::memory_t* p = src_;
  // @@protoc_insertion_point(field_get:libcall_types.atoi_t.src)
  return p != nullptr ? *p : *reinterpret_cast<const ::common::memory_t*>(
      &::common::_memory_t_default_instance_);
}
inline ::common::memory_t* atoi_t::release_src() {
  // @@protoc_insertion_point(field_release:libcall_types.atoi_t.src)
  _has_bits_[0] &= ~0x00000001u;
  ::common::memory_t* temp = src_;
  src_ = nullptr;
  return temp;
}
inline ::common::memory_t* atoi_t::mutable_src() {
  _has_bits_[0] |= 0x00000001u;
  if (src_ == nullptr) {
    auto* p = CreateMaybeMessage<::common::memory_t>(GetArenaNoVirtual());
    src_ = p;
  }
  // @@protoc_insertion_point(field_mutable:libcall_types.atoi_t.src)
  return src_;
}
inline void atoi_t::set_allocated_src(::common::memory_t* src) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(src_);
  }
  if (src) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      src = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, src, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  src_ = src;
  // @@protoc_insertion_point(field_set_allocated:libcall_types.atoi_t.src)
}

// required uint64 ret = 3;
inline bool atoi_t::has_ret() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void atoi_t::clear_ret() {
  ret_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 atoi_t::ret() const {
  // @@protoc_insertion_point(field_get:libcall_types.atoi_t.ret)
  return ret_;
}
inline void atoi_t::set_ret(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000002u;
  ret_ = value;
  // @@protoc_insertion_point(field_set:libcall_types.atoi_t.ret)
}

// -------------------------------------------------------------------

// malloc_t

// required uint64 size = 1;
inline bool malloc_t::has_size() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void malloc_t::clear_size() {
  size_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 malloc_t::size() const {
  // @@protoc_insertion_point(field_get:libcall_types.malloc_t.size)
  return size_;
}
inline void malloc_t::set_size(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000001u;
  size_ = value;
  // @@protoc_insertion_point(field_set:libcall_types.malloc_t.size)
}

// required uint64 ret = 2;
inline bool malloc_t::has_ret() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void malloc_t::clear_ret() {
  ret_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 malloc_t::ret() const {
  // @@protoc_insertion_point(field_get:libcall_types.malloc_t.ret)
  return ret_;
}
inline void malloc_t::set_ret(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000002u;
  ret_ = value;
  // @@protoc_insertion_point(field_set:libcall_types.malloc_t.ret)
}

// -------------------------------------------------------------------

// getmodulehandle_t

// required .common.memory_t module_name = 1;
inline bool getmodulehandle_t::has_module_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline const ::common::memory_t& getmodulehandle_t::module_name() const {
  const ::common::memory_t* p = module_name_;
  // @@protoc_insertion_point(field_get:libcall_types.getmodulehandle_t.module_name)
  return p != nullptr ? *p : *reinterpret_cast<const ::common::memory_t*>(
      &::common::_memory_t_default_instance_);
}
inline ::common::memory_t* getmodulehandle_t::release_module_name() {
  // @@protoc_insertion_point(field_release:libcall_types.getmodulehandle_t.module_name)
  _has_bits_[0] &= ~0x00000001u;
  ::common::memory_t* temp = module_name_;
  module_name_ = nullptr;
  return temp;
}
inline ::common::memory_t* getmodulehandle_t::mutable_module_name() {
  _has_bits_[0] |= 0x00000001u;
  if (module_name_ == nullptr) {
    auto* p = CreateMaybeMessage<::common::memory_t>(GetArenaNoVirtual());
    module_name_ = p;
  }
  // @@protoc_insertion_point(field_mutable:libcall_types.getmodulehandle_t.module_name)
  return module_name_;
}
inline void getmodulehandle_t::set_allocated_module_name(::common::memory_t* module_name) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(module_name_);
  }
  if (module_name) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      module_name = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, module_name, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  module_name_ = module_name;
  // @@protoc_insertion_point(field_set_allocated:libcall_types.getmodulehandle_t.module_name)
}

// required uint64 ret = 2;
inline bool getmodulehandle_t::has_ret() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void getmodulehandle_t::clear_ret() {
  ret_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 getmodulehandle_t::ret() const {
  // @@protoc_insertion_point(field_get:libcall_types.getmodulehandle_t.ret)
  return ret_;
}
inline void getmodulehandle_t::set_ret(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000002u;
  ret_ = value;
  // @@protoc_insertion_point(field_set:libcall_types.getmodulehandle_t.ret)
}

// -------------------------------------------------------------------

// getprocaddress_t

// required uint64 hmodule = 1;
inline bool getprocaddress_t::has_hmodule() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void getprocaddress_t::clear_hmodule() {
  hmodule_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 getprocaddress_t::hmodule() const {
  // @@protoc_insertion_point(field_get:libcall_types.getprocaddress_t.hmodule)
  return hmodule_;
}
inline void getprocaddress_t::set_hmodule(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000002u;
  hmodule_ = value;
  // @@protoc_insertion_point(field_set:libcall_types.getprocaddress_t.hmodule)
}

// required .common.memory_t proc_name = 2;
inline bool getprocaddress_t::has_proc_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline const ::common::memory_t& getprocaddress_t::proc_name() const {
  const ::common::memory_t* p = proc_name_;
  // @@protoc_insertion_point(field_get:libcall_types.getprocaddress_t.proc_name)
  return p != nullptr ? *p : *reinterpret_cast<const ::common::memory_t*>(
      &::common::_memory_t_default_instance_);
}
inline ::common::memory_t* getprocaddress_t::release_proc_name() {
  // @@protoc_insertion_point(field_release:libcall_types.getprocaddress_t.proc_name)
  _has_bits_[0] &= ~0x00000001u;
  ::common::memory_t* temp = proc_name_;
  proc_name_ = nullptr;
  return temp;
}
inline ::common::memory_t* getprocaddress_t::mutable_proc_name() {
  _has_bits_[0] |= 0x00000001u;
  if (proc_name_ == nullptr) {
    auto* p = CreateMaybeMessage<::common::memory_t>(GetArenaNoVirtual());
    proc_name_ = p;
  }
  // @@protoc_insertion_point(field_mutable:libcall_types.getprocaddress_t.proc_name)
  return proc_name_;
}
inline void getprocaddress_t::set_allocated_proc_name(::common::memory_t* proc_name) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(proc_name_);
  }
  if (proc_name) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      proc_name = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, proc_name, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  proc_name_ = proc_name;
  // @@protoc_insertion_point(field_set_allocated:libcall_types.getprocaddress_t.proc_name)
}

// required uint64 ret = 3;
inline bool getprocaddress_t::has_ret() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void getprocaddress_t::clear_ret() {
  ret_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 getprocaddress_t::ret() const {
  // @@protoc_insertion_point(field_get:libcall_types.getprocaddress_t.ret)
  return ret_;
}
inline void getprocaddress_t::set_ret(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000004u;
  ret_ = value;
  // @@protoc_insertion_point(field_set:libcall_types.getprocaddress_t.ret)
}

// -------------------------------------------------------------------

// getmainargs_t

// required .common.memory_t argc = 1;
inline bool getmainargs_t::has_argc() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline const ::common::memory_t& getmainargs_t::argc() const {
  const ::common::memory_t* p = argc_;
  // @@protoc_insertion_point(field_get:libcall_types.getmainargs_t.argc)
  return p != nullptr ? *p : *reinterpret_cast<const ::common::memory_t*>(
      &::common::_memory_t_default_instance_);
}
inline ::common::memory_t* getmainargs_t::release_argc() {
  // @@protoc_insertion_point(field_release:libcall_types.getmainargs_t.argc)
  _has_bits_[0] &= ~0x00000001u;
  ::common::memory_t* temp = argc_;
  argc_ = nullptr;
  return temp;
}
inline ::common::memory_t* getmainargs_t::mutable_argc() {
  _has_bits_[0] |= 0x00000001u;
  if (argc_ == nullptr) {
    auto* p = CreateMaybeMessage<::common::memory_t>(GetArenaNoVirtual());
    argc_ = p;
  }
  // @@protoc_insertion_point(field_mutable:libcall_types.getmainargs_t.argc)
  return argc_;
}
inline void getmainargs_t::set_allocated_argc(::common::memory_t* argc) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(argc_);
  }
  if (argc) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      argc = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, argc, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  argc_ = argc;
  // @@protoc_insertion_point(field_set_allocated:libcall_types.getmainargs_t.argc)
}

// required .common.memory_t argv = 2;
inline bool getmainargs_t::has_argv() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline const ::common::memory_t& getmainargs_t::argv() const {
  const ::common::memory_t* p = argv_;
  // @@protoc_insertion_point(field_get:libcall_types.getmainargs_t.argv)
  return p != nullptr ? *p : *reinterpret_cast<const ::common::memory_t*>(
      &::common::_memory_t_default_instance_);
}
inline ::common::memory_t* getmainargs_t::release_argv() {
  // @@protoc_insertion_point(field_release:libcall_types.getmainargs_t.argv)
  _has_bits_[0] &= ~0x00000002u;
  ::common::memory_t* temp = argv_;
  argv_ = nullptr;
  return temp;
}
inline ::common::memory_t* getmainargs_t::mutable_argv() {
  _has_bits_[0] |= 0x00000002u;
  if (argv_ == nullptr) {
    auto* p = CreateMaybeMessage<::common::memory_t>(GetArenaNoVirtual());
    argv_ = p;
  }
  // @@protoc_insertion_point(field_mutable:libcall_types.getmainargs_t.argv)
  return argv_;
}
inline void getmainargs_t::set_allocated_argv(::common::memory_t* argv) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(argv_);
  }
  if (argv) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      argv = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, argv, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  argv_ = argv;
  // @@protoc_insertion_point(field_set_allocated:libcall_types.getmainargs_t.argv)
}

// required .common.memory_t env = 3;
inline bool getmainargs_t::has_env() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline const ::common::memory_t& getmainargs_t::env() const {
  const ::common::memory_t* p = env_;
  // @@protoc_insertion_point(field_get:libcall_types.getmainargs_t.env)
  return p != nullptr ? *p : *reinterpret_cast<const ::common::memory_t*>(
      &::common::_memory_t_default_instance_);
}
inline ::common::memory_t* getmainargs_t::release_env() {
  // @@protoc_insertion_point(field_release:libcall_types.getmainargs_t.env)
  _has_bits_[0] &= ~0x00000004u;
  ::common::memory_t* temp = env_;
  env_ = nullptr;
  return temp;
}
inline ::common::memory_t* getmainargs_t::mutable_env() {
  _has_bits_[0] |= 0x00000004u;
  if (env_ == nullptr) {
    auto* p = CreateMaybeMessage<::common::memory_t>(GetArenaNoVirtual());
    env_ = p;
  }
  // @@protoc_insertion_point(field_mutable:libcall_types.getmainargs_t.env)
  return env_;
}
inline void getmainargs_t::set_allocated_env(::common::memory_t* env) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(env_);
  }
  if (env) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      env = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, env, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  env_ = env;
  // @@protoc_insertion_point(field_set_allocated:libcall_types.getmainargs_t.env)
}

// required uint64 dowildcard = 4;
inline bool getmainargs_t::has_dowildcard() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void getmainargs_t::clear_dowildcard() {
  dowildcard_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000010u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 getmainargs_t::dowildcard() const {
  // @@protoc_insertion_point(field_get:libcall_types.getmainargs_t.dowildcard)
  return dowildcard_;
}
inline void getmainargs_t::set_dowildcard(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000010u;
  dowildcard_ = value;
  // @@protoc_insertion_point(field_set:libcall_types.getmainargs_t.dowildcard)
}

// required .common.memory_t startinfo = 5;
inline bool getmainargs_t::has_startinfo() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline const ::common::memory_t& getmainargs_t::startinfo() const {
  const ::common::memory_t* p = startinfo_;
  // @@protoc_insertion_point(field_get:libcall_types.getmainargs_t.startinfo)
  return p != nullptr ? *p : *reinterpret_cast<const ::common::memory_t*>(
      &::common::_memory_t_default_instance_);
}
inline ::common::memory_t* getmainargs_t::release_startinfo() {
  // @@protoc_insertion_point(field_release:libcall_types.getmainargs_t.startinfo)
  _has_bits_[0] &= ~0x00000008u;
  ::common::memory_t* temp = startinfo_;
  startinfo_ = nullptr;
  return temp;
}
inline ::common::memory_t* getmainargs_t::mutable_startinfo() {
  _has_bits_[0] |= 0x00000008u;
  if (startinfo_ == nullptr) {
    auto* p = CreateMaybeMessage<::common::memory_t>(GetArenaNoVirtual());
    startinfo_ = p;
  }
  // @@protoc_insertion_point(field_mutable:libcall_types.getmainargs_t.startinfo)
  return startinfo_;
}
inline void getmainargs_t::set_allocated_startinfo(::common::memory_t* startinfo) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(startinfo_);
  }
  if (startinfo) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      startinfo = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, startinfo, submessage_arena);
    }
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  startinfo_ = startinfo;
  // @@protoc_insertion_point(field_set_allocated:libcall_types.getmainargs_t.startinfo)
}

// required uint64 ret = 6;
inline bool getmainargs_t::has_ret() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void getmainargs_t::clear_ret() {
  ret_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000020u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 getmainargs_t::ret() const {
  // @@protoc_insertion_point(field_get:libcall_types.getmainargs_t.ret)
  return ret_;
}
inline void getmainargs_t::set_ret(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000020u;
  ret_ = value;
  // @@protoc_insertion_point(field_set:libcall_types.getmainargs_t.ret)
}

// -------------------------------------------------------------------

// gethostname_t

// required .common.memory_t name = 1;
inline bool gethostname_t::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline const ::common::memory_t& gethostname_t::name() const {
  const ::common::memory_t* p = name_;
  // @@protoc_insertion_point(field_get:libcall_types.gethostname_t.name)
  return p != nullptr ? *p : *reinterpret_cast<const ::common::memory_t*>(
      &::common::_memory_t_default_instance_);
}
inline ::common::memory_t* gethostname_t::release_name() {
  // @@protoc_insertion_point(field_release:libcall_types.gethostname_t.name)
  _has_bits_[0] &= ~0x00000001u;
  ::common::memory_t* temp = name_;
  name_ = nullptr;
  return temp;
}
inline ::common::memory_t* gethostname_t::mutable_name() {
  _has_bits_[0] |= 0x00000001u;
  if (name_ == nullptr) {
    auto* p = CreateMaybeMessage<::common::memory_t>(GetArenaNoVirtual());
    name_ = p;
  }
  // @@protoc_insertion_point(field_mutable:libcall_types.gethostname_t.name)
  return name_;
}
inline void gethostname_t::set_allocated_name(::common::memory_t* name) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(name_);
  }
  if (name) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      name = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, name, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  name_ = name;
  // @@protoc_insertion_point(field_set_allocated:libcall_types.gethostname_t.name)
}

// required uint64 namelen = 2;
inline bool gethostname_t::has_namelen() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void gethostname_t::clear_namelen() {
  namelen_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 gethostname_t::namelen() const {
  // @@protoc_insertion_point(field_get:libcall_types.gethostname_t.namelen)
  return namelen_;
}
inline void gethostname_t::set_namelen(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000002u;
  namelen_ = value;
  // @@protoc_insertion_point(field_set:libcall_types.gethostname_t.namelen)
}

// required uint64 ret = 3;
inline bool gethostname_t::has_ret() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void gethostname_t::clear_ret() {
  ret_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 gethostname_t::ret() const {
  // @@protoc_insertion_point(field_get:libcall_types.gethostname_t.ret)
  return ret_;
}
inline void gethostname_t::set_ret(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000004u;
  ret_ = value;
  // @@protoc_insertion_point(field_set:libcall_types.gethostname_t.ret)
}

// -------------------------------------------------------------------

// free_t

// required uint64 ptr = 1;
inline bool free_t::has_ptr() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void free_t::clear_ptr() {
  ptr_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 free_t::ptr() const {
  // @@protoc_insertion_point(field_get:libcall_types.free_t.ptr)
  return ptr_;
}
inline void free_t::set_ptr(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000001u;
  ptr_ = value;
  // @@protoc_insertion_point(field_set:libcall_types.free_t.ptr)
}

// -------------------------------------------------------------------

// memcpy_t

// required .common.memory_t dest = 1;
inline bool memcpy_t::has_dest() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline const ::common::memory_t& memcpy_t::dest() const {
  const ::common::memory_t* p = dest_;
  // @@protoc_insertion_point(field_get:libcall_types.memcpy_t.dest)
  return p != nullptr ? *p : *reinterpret_cast<const ::common::memory_t*>(
      &::common::_memory_t_default_instance_);
}
inline ::common::memory_t* memcpy_t::release_dest() {
  // @@protoc_insertion_point(field_release:libcall_types.memcpy_t.dest)
  _has_bits_[0] &= ~0x00000001u;
  ::common::memory_t* temp = dest_;
  dest_ = nullptr;
  return temp;
}
inline ::common::memory_t* memcpy_t::mutable_dest() {
  _has_bits_[0] |= 0x00000001u;
  if (dest_ == nullptr) {
    auto* p = CreateMaybeMessage<::common::memory_t>(GetArenaNoVirtual());
    dest_ = p;
  }
  // @@protoc_insertion_point(field_mutable:libcall_types.memcpy_t.dest)
  return dest_;
}
inline void memcpy_t::set_allocated_dest(::common::memory_t* dest) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(dest_);
  }
  if (dest) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      dest = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, dest, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  dest_ = dest;
  // @@protoc_insertion_point(field_set_allocated:libcall_types.memcpy_t.dest)
}

// required .common.memory_t src = 2;
inline bool memcpy_t::has_src() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline const ::common::memory_t& memcpy_t::src() const {
  const ::common::memory_t* p = src_;
  // @@protoc_insertion_point(field_get:libcall_types.memcpy_t.src)
  return p != nullptr ? *p : *reinterpret_cast<const ::common::memory_t*>(
      &::common::_memory_t_default_instance_);
}
inline ::common::memory_t* memcpy_t::release_src() {
  // @@protoc_insertion_point(field_release:libcall_types.memcpy_t.src)
  _has_bits_[0] &= ~0x00000002u;
  ::common::memory_t* temp = src_;
  src_ = nullptr;
  return temp;
}
inline ::common::memory_t* memcpy_t::mutable_src() {
  _has_bits_[0] |= 0x00000002u;
  if (src_ == nullptr) {
    auto* p = CreateMaybeMessage<::common::memory_t>(GetArenaNoVirtual());
    src_ = p;
  }
  // @@protoc_insertion_point(field_mutable:libcall_types.memcpy_t.src)
  return src_;
}
inline void memcpy_t::set_allocated_src(::common::memory_t* src) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(src_);
  }
  if (src) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      src = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, src, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  src_ = src;
  // @@protoc_insertion_point(field_set_allocated:libcall_types.memcpy_t.src)
}

// required uint64 size = 3;
inline bool memcpy_t::has_size() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void memcpy_t::clear_size() {
  size_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 memcpy_t::size() const {
  // @@protoc_insertion_point(field_get:libcall_types.memcpy_t.size)
  return size_;
}
inline void memcpy_t::set_size(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000004u;
  size_ = value;
  // @@protoc_insertion_point(field_set:libcall_types.memcpy_t.size)
}

// required uint64 ret = 4;
inline bool memcpy_t::has_ret() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void memcpy_t::clear_ret() {
  ret_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000008u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 memcpy_t::ret() const {
  // @@protoc_insertion_point(field_get:libcall_types.memcpy_t.ret)
  return ret_;
}
inline void memcpy_t::set_ret(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000008u;
  ret_ = value;
  // @@protoc_insertion_point(field_set:libcall_types.memcpy_t.ret)
}

// -------------------------------------------------------------------

// memset_t

// required .common.memory_t s = 1;
inline bool memset_t::has_s() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline const ::common::memory_t& memset_t::s() const {
  const ::common::memory_t* p = s_;
  // @@protoc_insertion_point(field_get:libcall_types.memset_t.s)
  return p != nullptr ? *p : *reinterpret_cast<const ::common::memory_t*>(
      &::common::_memory_t_default_instance_);
}
inline ::common::memory_t* memset_t::release_s() {
  // @@protoc_insertion_point(field_release:libcall_types.memset_t.s)
  _has_bits_[0] &= ~0x00000001u;
  ::common::memory_t* temp = s_;
  s_ = nullptr;
  return temp;
}
inline ::common::memory_t* memset_t::mutable_s() {
  _has_bits_[0] |= 0x00000001u;
  if (s_ == nullptr) {
    auto* p = CreateMaybeMessage<::common::memory_t>(GetArenaNoVirtual());
    s_ = p;
  }
  // @@protoc_insertion_point(field_mutable:libcall_types.memset_t.s)
  return s_;
}
inline void memset_t::set_allocated_s(::common::memory_t* s) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(s_);
  }
  if (s) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      s = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, s, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  s_ = s;
  // @@protoc_insertion_point(field_set_allocated:libcall_types.memset_t.s)
}

// required uint64 c = 2;
inline bool memset_t::has_c() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void memset_t::clear_c() {
  c_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 memset_t::c() const {
  // @@protoc_insertion_point(field_get:libcall_types.memset_t.c)
  return c_;
}
inline void memset_t::set_c(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000002u;
  c_ = value;
  // @@protoc_insertion_point(field_set:libcall_types.memset_t.c)
}

// required uint64 size = 3;
inline bool memset_t::has_size() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void memset_t::clear_size() {
  size_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 memset_t::size() const {
  // @@protoc_insertion_point(field_get:libcall_types.memset_t.size)
  return size_;
}
inline void memset_t::set_size(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000004u;
  size_ = value;
  // @@protoc_insertion_point(field_set:libcall_types.memset_t.size)
}

// required uint64 ret = 4;
inline bool memset_t::has_ret() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void memset_t::clear_ret() {
  ret_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000008u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 memset_t::ret() const {
  // @@protoc_insertion_point(field_get:libcall_types.memset_t.ret)
  return ret_;
}
inline void memset_t::set_ret(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000008u;
  ret_ = value;
  // @@protoc_insertion_point(field_set:libcall_types.memset_t.ret)
}

// -------------------------------------------------------------------

// fgetc_t

// required uint64 stream = 1;
inline bool fgetc_t::has_stream() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void fgetc_t::clear_stream() {
  stream_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 fgetc_t::stream() const {
  // @@protoc_insertion_point(field_get:libcall_types.fgetc_t.stream)
  return stream_;
}
inline void fgetc_t::set_stream(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000001u;
  stream_ = value;
  // @@protoc_insertion_point(field_set:libcall_types.fgetc_t.stream)
}

// required uint64 ret = 2;
inline bool fgetc_t::has_ret() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void fgetc_t::clear_ret() {
  ret_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 fgetc_t::ret() const {
  // @@protoc_insertion_point(field_get:libcall_types.fgetc_t.ret)
  return ret_;
}
inline void fgetc_t::set_ret(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000002u;
  ret_ = value;
  // @@protoc_insertion_point(field_set:libcall_types.fgetc_t.ret)
}

// -------------------------------------------------------------------

// lseek_t

// required uint64 fd = 1;
inline bool lseek_t::has_fd() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void lseek_t::clear_fd() {
  fd_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 lseek_t::fd() const {
  // @@protoc_insertion_point(field_get:libcall_types.lseek_t.fd)
  return fd_;
}
inline void lseek_t::set_fd(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000001u;
  fd_ = value;
  // @@protoc_insertion_point(field_set:libcall_types.lseek_t.fd)
}

// required uint64 offset = 2;
inline bool lseek_t::has_offset() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void lseek_t::clear_offset() {
  offset_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 lseek_t::offset() const {
  // @@protoc_insertion_point(field_get:libcall_types.lseek_t.offset)
  return offset_;
}
inline void lseek_t::set_offset(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000002u;
  offset_ = value;
  // @@protoc_insertion_point(field_set:libcall_types.lseek_t.offset)
}

// required uint64 whence = 3;
inline bool lseek_t::has_whence() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void lseek_t::clear_whence() {
  whence_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 lseek_t::whence() const {
  // @@protoc_insertion_point(field_get:libcall_types.lseek_t.whence)
  return whence_;
}
inline void lseek_t::set_whence(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000004u;
  whence_ = value;
  // @@protoc_insertion_point(field_set:libcall_types.lseek_t.whence)
}

// required uint64 ret = 4;
inline bool lseek_t::has_ret() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void lseek_t::clear_ret() {
  ret_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000008u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 lseek_t::ret() const {
  // @@protoc_insertion_point(field_get:libcall_types.lseek_t.ret)
  return ret_;
}
inline void lseek_t::set_ret(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000008u;
  ret_ = value;
  // @@protoc_insertion_point(field_set:libcall_types.lseek_t.ret)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace libcall_types

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::libcall_types::lib_ident> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::libcall_types::lib_ident>() {
  return ::libcall_types::lib_ident_descriptor();
}
template <> struct is_proto_enum< ::libcall_types::fscanf_enum> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::libcall_types::fscanf_enum>() {
  return ::libcall_types::fscanf_enum_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_libcall_2eproto
