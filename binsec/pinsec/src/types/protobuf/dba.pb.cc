// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: dba.proto

#include "dba.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
extern PROTOBUF_INTERNAL_EXPORT_dba_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_bitvector_dba_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_dba_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_codeaddress_dba_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_dba_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_dbaLhs_dba_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_dba_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_dbacodeaddress_dba_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_dba_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_dbacond_dba_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_dba_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<6> scc_info_dbainstr_dba_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_dba_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_dbastopstate_dba_2eproto;
extern PROTOBUF_INTERNAL_EXPORT_dba_2eproto ::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_dbatag_dba_2eproto;
namespace dba {
class bitvectorDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<bitvector> _instance;
} _bitvector_default_instance_;
class dbacodeaddressDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<dbacodeaddress> _instance;
} _dbacodeaddress_default_instance_;
class codeaddressDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<codeaddress> _instance;
} _codeaddress_default_instance_;
class dbatagDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<dbatag> _instance;
} _dbatag_default_instance_;
class dbastopstateDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<dbastopstate> _instance;
} _dbastopstate_default_instance_;
class dbaexprDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<dbaexpr> _instance;
} _dbaexpr_default_instance_;
class dbacondDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<dbacond> _instance;
} _dbacond_default_instance_;
class dbaLhsDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<dbaLhs> _instance;
} _dbaLhs_default_instance_;
class dbainstrDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<dbainstr> _instance;
} _dbainstr_default_instance_;
class dba_listDefaultTypeInternal {
 public:
  ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<dba_list> _instance;
} _dba_list_default_instance_;
}  // namespace dba
static void InitDefaultsscc_info_bitvector_dba_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::dba::_bitvector_default_instance_;
    new (ptr) ::dba::bitvector();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::dba::bitvector::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_bitvector_dba_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsscc_info_bitvector_dba_2eproto}, {}};

static void InitDefaultsscc_info_codeaddress_dba_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::dba::_codeaddress_default_instance_;
    new (ptr) ::dba::codeaddress();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::dba::codeaddress::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_codeaddress_dba_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 1, InitDefaultsscc_info_codeaddress_dba_2eproto}, {
      &scc_info_dbacodeaddress_dba_2eproto.base,}};

static void InitDefaultsscc_info_dbaLhs_dba_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::dba::_dbaLhs_default_instance_;
    new (ptr) ::dba::dbaLhs();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::dba::dbaLhs::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_dbaLhs_dba_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 1, InitDefaultsscc_info_dbaLhs_dba_2eproto}, {
      &scc_info_dbacond_dba_2eproto.base,}};

static void InitDefaultsscc_info_dba_list_dba_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::dba::_dba_list_default_instance_;
    new (ptr) ::dba::dba_list();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::dba::dba_list::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_dba_list_dba_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 1, InitDefaultsscc_info_dba_list_dba_2eproto}, {
      &scc_info_dbainstr_dba_2eproto.base,}};

static void InitDefaultsscc_info_dbacodeaddress_dba_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::dba::_dbacodeaddress_default_instance_;
    new (ptr) ::dba::dbacodeaddress();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::dba::dbacodeaddress::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_dbacodeaddress_dba_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 1, InitDefaultsscc_info_dbacodeaddress_dba_2eproto}, {
      &scc_info_bitvector_dba_2eproto.base,}};

static void InitDefaultsscc_info_dbacond_dba_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::dba::_dbaexpr_default_instance_;
    new (ptr) ::dba::dbaexpr();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  {
    void* ptr = &::dba::_dbacond_default_instance_;
    new (ptr) ::dba::dbacond();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::dba::dbaexpr::InitAsDefaultInstance();
  ::dba::dbacond::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_dbacond_dba_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 1, InitDefaultsscc_info_dbacond_dba_2eproto}, {
      &scc_info_bitvector_dba_2eproto.base,}};

static void InitDefaultsscc_info_dbainstr_dba_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::dba::_dbainstr_default_instance_;
    new (ptr) ::dba::dbainstr();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::dba::dbainstr::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<6> scc_info_dbainstr_dba_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 6, InitDefaultsscc_info_dbainstr_dba_2eproto}, {
      &scc_info_dbacodeaddress_dba_2eproto.base,
      &scc_info_dbaLhs_dba_2eproto.base,
      &scc_info_dbacond_dba_2eproto.base,
      &scc_info_codeaddress_dba_2eproto.base,
      &scc_info_dbatag_dba_2eproto.base,
      &scc_info_dbastopstate_dba_2eproto.base,}};

static void InitDefaultsscc_info_dbastopstate_dba_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::dba::_dbastopstate_default_instance_;
    new (ptr) ::dba::dbastopstate();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::dba::dbastopstate::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<0> scc_info_dbastopstate_dba_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 0, InitDefaultsscc_info_dbastopstate_dba_2eproto}, {}};

static void InitDefaultsscc_info_dbatag_dba_2eproto() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  {
    void* ptr = &::dba::_dbatag_default_instance_;
    new (ptr) ::dba::dbatag();
    ::PROTOBUF_NAMESPACE_ID::internal::OnShutdownDestroyMessage(ptr);
  }
  ::dba::dbatag::InitAsDefaultInstance();
}

::PROTOBUF_NAMESPACE_ID::internal::SCCInfo<1> scc_info_dbatag_dba_2eproto =
    {{ATOMIC_VAR_INIT(::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase::kUninitialized), 1, InitDefaultsscc_info_dbatag_dba_2eproto}, {
      &scc_info_dbacodeaddress_dba_2eproto.base,}};

static ::PROTOBUF_NAMESPACE_ID::Metadata file_level_metadata_dba_2eproto[10];
static const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* file_level_enum_descriptors_dba_2eproto[10];
static constexpr ::PROTOBUF_NAMESPACE_ID::ServiceDescriptor const** file_level_service_descriptors_dba_2eproto = nullptr;

const ::PROTOBUF_NAMESPACE_ID::uint32 TableStruct_dba_2eproto::offsets[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  PROTOBUF_FIELD_OFFSET(::dba::bitvector, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::dba::bitvector, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::dba::bitvector, bv_),
  PROTOBUF_FIELD_OFFSET(::dba::bitvector, size_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::dba::dbacodeaddress, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::dba::dbacodeaddress, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::dba::dbacodeaddress, bitvector_),
  PROTOBUF_FIELD_OFFSET(::dba::dbacodeaddress, dbaoffset_),
  0,
  1,
  PROTOBUF_FIELD_OFFSET(::dba::codeaddress, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::dba::codeaddress, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::dba::codeaddress, typeid__),
  PROTOBUF_FIELD_OFFSET(::dba::codeaddress, offset_),
  PROTOBUF_FIELD_OFFSET(::dba::codeaddress, address_),
  1,
  2,
  0,
  PROTOBUF_FIELD_OFFSET(::dba::dbatag, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::dba::dbatag, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::dba::dbatag, typeid__),
  PROTOBUF_FIELD_OFFSET(::dba::dbatag, address_),
  1,
  0,
  PROTOBUF_FIELD_OFFSET(::dba::dbastopstate, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::dba::dbastopstate, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::dba::dbastopstate, typeid__),
  PROTOBUF_FIELD_OFFSET(::dba::dbastopstate, infos_),
  1,
  0,
  PROTOBUF_FIELD_OFFSET(::dba::dbaexpr, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::dba::dbaexpr, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::dba::dbaexpr, typeid__),
  PROTOBUF_FIELD_OFFSET(::dba::dbaexpr, name_),
  PROTOBUF_FIELD_OFFSET(::dba::dbaexpr, size_),
  PROTOBUF_FIELD_OFFSET(::dba::dbaexpr, endian_),
  PROTOBUF_FIELD_OFFSET(::dba::dbaexpr, bitvector_),
  PROTOBUF_FIELD_OFFSET(::dba::dbaexpr, expr1_),
  PROTOBUF_FIELD_OFFSET(::dba::dbaexpr, expr2_),
  PROTOBUF_FIELD_OFFSET(::dba::dbaexpr, unaryop_),
  PROTOBUF_FIELD_OFFSET(::dba::dbaexpr, binaryop_),
  PROTOBUF_FIELD_OFFSET(::dba::dbaexpr, low_),
  PROTOBUF_FIELD_OFFSET(::dba::dbaexpr, high_),
  PROTOBUF_FIELD_OFFSET(::dba::dbaexpr, cond_),
  8,
  0,
  5,
  9,
  1,
  2,
  3,
  10,
  11,
  6,
  7,
  4,
  PROTOBUF_FIELD_OFFSET(::dba::dbacond, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::dba::dbacond, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::dba::dbacond, typeid__),
  PROTOBUF_FIELD_OFFSET(::dba::dbacond, expr_),
  PROTOBUF_FIELD_OFFSET(::dba::dbacond, cond1_),
  PROTOBUF_FIELD_OFFSET(::dba::dbacond, cond2_),
  3,
  0,
  1,
  2,
  PROTOBUF_FIELD_OFFSET(::dba::dbaLhs, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::dba::dbaLhs, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::dba::dbaLhs, typeid__),
  PROTOBUF_FIELD_OFFSET(::dba::dbaLhs, name_),
  PROTOBUF_FIELD_OFFSET(::dba::dbaLhs, size_),
  PROTOBUF_FIELD_OFFSET(::dba::dbaLhs, low_),
  PROTOBUF_FIELD_OFFSET(::dba::dbaLhs, high_),
  PROTOBUF_FIELD_OFFSET(::dba::dbaLhs, endian_),
  PROTOBUF_FIELD_OFFSET(::dba::dbaLhs, expr_),
  5,
  0,
  2,
  3,
  4,
  6,
  1,
  PROTOBUF_FIELD_OFFSET(::dba::dbainstr, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::dba::dbainstr, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::dba::dbainstr, typeid__),
  PROTOBUF_FIELD_OFFSET(::dba::dbainstr, location_),
  PROTOBUF_FIELD_OFFSET(::dba::dbainstr, lhs_),
  PROTOBUF_FIELD_OFFSET(::dba::dbainstr, expr_),
  PROTOBUF_FIELD_OFFSET(::dba::dbainstr, offset_),
  PROTOBUF_FIELD_OFFSET(::dba::dbainstr, address_),
  PROTOBUF_FIELD_OFFSET(::dba::dbainstr, tags_),
  PROTOBUF_FIELD_OFFSET(::dba::dbainstr, cond_),
  PROTOBUF_FIELD_OFFSET(::dba::dbainstr, stopinfos_),
  PROTOBUF_FIELD_OFFSET(::dba::dbainstr, exprs_),
  8,
  0,
  1,
  2,
  7,
  3,
  4,
  5,
  6,
  ~0u,
  PROTOBUF_FIELD_OFFSET(::dba::dba_list, _has_bits_),
  PROTOBUF_FIELD_OFFSET(::dba::dba_list, _internal_metadata_),
  ~0u,  // no _extensions_
  ~0u,  // no _oneof_case_
  ~0u,  // no _weak_field_map_
  PROTOBUF_FIELD_OFFSET(::dba::dba_list, instrs_),
  ~0u,
};
static const ::PROTOBUF_NAMESPACE_ID::internal::MigrationSchema schemas[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) = {
  { 0, 7, sizeof(::dba::bitvector)},
  { 9, 16, sizeof(::dba::dbacodeaddress)},
  { 18, 26, sizeof(::dba::codeaddress)},
  { 29, 36, sizeof(::dba::dbatag)},
  { 38, 45, sizeof(::dba::dbastopstate)},
  { 47, 64, sizeof(::dba::dbaexpr)},
  { 76, 85, sizeof(::dba::dbacond)},
  { 89, 101, sizeof(::dba::dbaLhs)},
  { 108, 123, sizeof(::dba::dbainstr)},
  { 133, 139, sizeof(::dba::dba_list)},
};

static ::PROTOBUF_NAMESPACE_ID::Message const * const file_default_instances[] = {
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::dba::_bitvector_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::dba::_dbacodeaddress_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::dba::_codeaddress_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::dba::_dbatag_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::dba::_dbastopstate_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::dba::_dbaexpr_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::dba::_dbacond_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::dba::_dbaLhs_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::dba::_dbainstr_default_instance_),
  reinterpret_cast<const ::PROTOBUF_NAMESPACE_ID::Message*>(&::dba::_dba_list_default_instance_),
};

const char descriptor_table_protodef_dba_2eproto[] PROTOBUF_SECTION_VARIABLE(protodesc_cold) =
  "\n\tdba.proto\022\003dba\"%\n\tbitvector\022\n\n\002bv\030\001 \002("
  "\004\022\014\n\004size\030\002 \002(\r\"F\n\016dbacodeaddress\022!\n\tbit"
  "vector\030\001 \002(\0132\016.dba.bitvector\022\021\n\tdbaoffse"
  "t\030\002 \002(\r\"\247\001\n\013codeaddress\0223\n\006typeid\030\001 \002(\0162"
  "#.dba.codeaddress.typeid_codeaddress\022\016\n\006"
  "offset\030\002 \001(\r\022$\n\007address\030\003 \001(\0132\023.dba.dbac"
  "odeaddress\"-\n\022typeid_codeaddress\022\t\n\005Loca"
  "l\020\000\022\014\n\010NonLocal\020\001\"\206\001\n\006dbatag\022)\n\006typeid\030\001"
  " \002(\0162\031.dba.dbatag.typeid_dbatag\022$\n\007addre"
  "ss\030\002 \001(\0132\023.dba.dbacodeaddress\"+\n\rtypeid_"
  "dbatag\022\013\n\007DbaCall\020\001\022\r\n\tDbaReturn\020\002\"\223\001\n\014d"
  "bastopstate\0221\n\006typeid\030\001 \002(\0162!.dba.dbasto"
  "pstate.typeid_dbastate\022\r\n\005infos\030\002 \001(\t\"A\n"
  "\017typeid_dbastate\022\006\n\002Ok\020\001\022\006\n\002Ko\020\002\022\r\n\tUnde"
  "fined\020\003\022\017\n\013Unsupported\020\004\"\313\007\n\007dbaexpr\022+\n\006"
  "typeid\030\001 \002(\0162\033.dba.dbaexpr.typeid_dbaexp"
  "r\022\014\n\004name\030\002 \001(\t\022\014\n\004size\030\003 \001(\r\022\037\n\006endian\030"
  "\004 \001(\0162\017.dba.endianness\022!\n\tbitvector\030\005 \001("
  "\0132\016.dba.bitvector\022\033\n\005expr1\030\006 \001(\0132\014.dba.d"
  "baexpr\022\033\n\005expr2\030\007 \001(\0132\014.dba.dbaexpr\022&\n\007u"
  "naryop\030\t \001(\0162\025.dba.dbaexpr.dbaunary\022(\n\010b"
  "inaryop\030\n \001(\0162\026.dba.dbaexpr.dbabinary\022\013\n"
  "\003low\030\013 \001(\r\022\014\n\004high\030\014 \001(\r\022\032\n\004cond\030\r \001(\0132\014"
  ".dba.dbacond\"\301\001\n\016typeid_dbaexpr\022\016\n\nDbaEx"
  "prVar\020\001\022\013\n\007DbaLoad\020\002\022\016\n\nDbaExprCst\020\003\022\020\n\014"
  "DbaExprUnary\020\004\022\021\n\rDbaExprBinary\020\005\022\023\n\017Dba"
  "ExprRestrict\020\006\022\017\n\013DbaExprExtU\020\007\022\017\n\013DbaEx"
  "prExtS\020\010\022\016\n\nDbaExprIte\020\t\022\026\n\022DbaExprAlter"
  "native\020\n\".\n\010dbaunary\022\021\n\rDbaUnaryMinus\020\001\022"
  "\017\n\013DbaUnaryNot\020\002\"\373\002\n\tdbabinary\022\013\n\007DbaPlu"
  "s\020\001\022\014\n\010DbaMinus\020\002\022\014\n\010DbaMultU\020\003\022\014\n\010DbaMu"
  "ltS\020\004\022\013\n\007DbaDivU\020\006\022\013\n\007DbaDivS\020\007\022\013\n\007DbaMo"
  "dU\020\010\022\013\n\007DbaModS\020\t\022\t\n\005DbaOr\020\n\022\n\n\006DbaAnd\020\013"
  "\022\n\n\006DbaXor\020\014\022\r\n\tDbaConcat\020\r\022\016\n\nDbaLShift"
  "U\020\016\022\016\n\nDbaRShiftU\020\017\022\016\n\nDbaRShiftS\020\020\022\021\n\rD"
  "baLeftRotate\020\021\022\022\n\016DbaRightRotate\020\022\022\t\n\005Db"
  "aEq\020\023\022\013\n\007DbaDiff\020\024\022\013\n\007DbaLeqU\020\025\022\n\n\006DbaLt"
  "U\020\026\022\013\n\007DbaGeqU\020\027\022\n\n\006DbaGtU\020\030\022\013\n\007DbaLeqS\020"
  "\031\022\n\n\006DbaLtS\020\032\022\013\n\007DbaGeqS\020\033\022\n\n\006DbaGtS\020\034\"\371"
  "\001\n\007dbacond\022+\n\006typeid\030\001 \002(\0162\033.dba.dbacond"
  ".typeid_dbacond\022\032\n\004expr\030\002 \001(\0132\014.dba.dbae"
  "xpr\022\033\n\005cond1\030\003 \001(\0132\014.dba.dbacond\022\033\n\005cond"
  "2\030\004 \001(\0132\014.dba.dbacond\"k\n\016typeid_dbacond\022"
  "\017\n\013DbaCondReif\020\001\022\016\n\nDbaCondNot\020\002\022\016\n\nDbaC"
  "ondAnd\020\003\022\r\n\tDbaCondOr\020\004\022\013\n\007DbaTrue\020\005\022\014\n\010"
  "DbaFalse\020\006\"\354\001\n\006dbaLhs\022)\n\006typeid\030\001 \002(\0162\031."
  "dba.dbaLhs.typeid_dbalhs\022\014\n\004name\030\002 \001(\t\022\014"
  "\n\004size\030\003 \001(\r\022\013\n\003low\030\004 \001(\r\022\014\n\004high\030\005 \001(\r\022"
  "\037\n\006endian\030\006 \001(\0162\017.dba.endianness\022\032\n\004expr"
  "\030\007 \001(\0132\014.dba.dbaexpr\"C\n\rtypeid_dbalhs\022\r\n"
  "\tDbaLhsVar\020\001\022\025\n\021DbaLhsVarRestrict\020\002\022\014\n\010D"
  "baStore\020\003\"\260\004\n\010dbainstr\022.\n\006typeid\030\001 \002(\0162\036"
  ".dba.dbainstr.typeid_instrkind\022%\n\010locati"
  "on\030\002 \002(\0132\023.dba.dbacodeaddress\022\030\n\003lhs\030\003 \001"
  "(\0132\013.dba.dbaLhs\022\032\n\004expr\030\004 \001(\0132\014.dba.dbae"
  "xpr\022\016\n\006offset\030\005 \001(\r\022!\n\007address\030\006 \001(\0132\020.d"
  "ba.codeaddress\022\031\n\004tags\030\007 \001(\0132\013.dba.dbata"
  "g\022\032\n\004cond\030\010 \001(\0132\014.dba.dbacond\022$\n\tstopinf"
  "os\030\t \001(\0132\021.dba.dbastopstate\022\033\n\005exprs\030\n \003"
  "(\0132\014.dba.dbaexpr\"\351\001\n\020typeid_instrkind\022\017\n"
  "\013DbaIkAssign\020\001\022\016\n\nDbaIkSJump\020\002\022\016\n\nDbaIkD"
  "Jump\020\003\022\013\n\007DbaIkIf\020\004\022\r\n\tDbaIkStop\020\005\022\017\n\013Db"
  "aIkAssert\020\006\022\017\n\013DbaIkAssume\020\007\022\025\n\021DbaIkNon"
  "detAssume\020\010\022\017\n\013DbaIkNondet\020\t\022\016\n\nDbaIkUnd"
  "ef\020\n\022\017\n\013DbaIkMalloc\020\013\022\r\n\tDbaIkFree\020\014\022\016\n\n"
  "DbaIkPrint\020\r\")\n\010dba_list\022\035\n\006instrs\030\001 \003(\013"
  "2\r.dba.dbainstr*!\n\nendianness\022\n\n\006Little\020"
  "\001\022\007\n\003Big\020\002"
  ;
static const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable*const descriptor_table_dba_2eproto_deps[1] = {
};
static ::PROTOBUF_NAMESPACE_ID::internal::SCCInfoBase*const descriptor_table_dba_2eproto_sccs[9] = {
  &scc_info_bitvector_dba_2eproto.base,
  &scc_info_codeaddress_dba_2eproto.base,
  &scc_info_dbaLhs_dba_2eproto.base,
  &scc_info_dba_list_dba_2eproto.base,
  &scc_info_dbacodeaddress_dba_2eproto.base,
  &scc_info_dbacond_dba_2eproto.base,
  &scc_info_dbainstr_dba_2eproto.base,
  &scc_info_dbastopstate_dba_2eproto.base,
  &scc_info_dbatag_dba_2eproto.base,
};
static ::PROTOBUF_NAMESPACE_ID::internal::once_flag descriptor_table_dba_2eproto_once;
static bool descriptor_table_dba_2eproto_initialized = false;
const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_dba_2eproto = {
  &descriptor_table_dba_2eproto_initialized, descriptor_table_protodef_dba_2eproto, "dba.proto", 2690,
  &descriptor_table_dba_2eproto_once, descriptor_table_dba_2eproto_sccs, descriptor_table_dba_2eproto_deps, 9, 0,
  schemas, file_default_instances, TableStruct_dba_2eproto::offsets,
  file_level_metadata_dba_2eproto, 10, file_level_enum_descriptors_dba_2eproto, file_level_service_descriptors_dba_2eproto,
};

// Force running AddDescriptors() at dynamic initialization time.
static bool dynamic_init_dummy_dba_2eproto = (  ::PROTOBUF_NAMESPACE_ID::internal::AddDescriptors(&descriptor_table_dba_2eproto), true);
namespace dba {
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* codeaddress_typeid_codeaddress_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_dba_2eproto);
  return file_level_enum_descriptors_dba_2eproto[0];
}
bool codeaddress_typeid_codeaddress_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
constexpr codeaddress_typeid_codeaddress codeaddress::Local;
constexpr codeaddress_typeid_codeaddress codeaddress::NonLocal;
constexpr codeaddress_typeid_codeaddress codeaddress::typeid_codeaddress_MIN;
constexpr codeaddress_typeid_codeaddress codeaddress::typeid_codeaddress_MAX;
constexpr int codeaddress::typeid_codeaddress_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* dbatag_typeid_dbatag_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_dba_2eproto);
  return file_level_enum_descriptors_dba_2eproto[1];
}
bool dbatag_typeid_dbatag_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
constexpr dbatag_typeid_dbatag dbatag::DbaCall;
constexpr dbatag_typeid_dbatag dbatag::DbaReturn;
constexpr dbatag_typeid_dbatag dbatag::typeid_dbatag_MIN;
constexpr dbatag_typeid_dbatag dbatag::typeid_dbatag_MAX;
constexpr int dbatag::typeid_dbatag_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* dbastopstate_typeid_dbastate_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_dba_2eproto);
  return file_level_enum_descriptors_dba_2eproto[2];
}
bool dbastopstate_typeid_dbastate_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
    case 3:
    case 4:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
constexpr dbastopstate_typeid_dbastate dbastopstate::Ok;
constexpr dbastopstate_typeid_dbastate dbastopstate::Ko;
constexpr dbastopstate_typeid_dbastate dbastopstate::Undefined;
constexpr dbastopstate_typeid_dbastate dbastopstate::Unsupported;
constexpr dbastopstate_typeid_dbastate dbastopstate::typeid_dbastate_MIN;
constexpr dbastopstate_typeid_dbastate dbastopstate::typeid_dbastate_MAX;
constexpr int dbastopstate::typeid_dbastate_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* dbaexpr_typeid_dbaexpr_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_dba_2eproto);
  return file_level_enum_descriptors_dba_2eproto[3];
}
bool dbaexpr_typeid_dbaexpr_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
constexpr dbaexpr_typeid_dbaexpr dbaexpr::DbaExprVar;
constexpr dbaexpr_typeid_dbaexpr dbaexpr::DbaLoad;
constexpr dbaexpr_typeid_dbaexpr dbaexpr::DbaExprCst;
constexpr dbaexpr_typeid_dbaexpr dbaexpr::DbaExprUnary;
constexpr dbaexpr_typeid_dbaexpr dbaexpr::DbaExprBinary;
constexpr dbaexpr_typeid_dbaexpr dbaexpr::DbaExprRestrict;
constexpr dbaexpr_typeid_dbaexpr dbaexpr::DbaExprExtU;
constexpr dbaexpr_typeid_dbaexpr dbaexpr::DbaExprExtS;
constexpr dbaexpr_typeid_dbaexpr dbaexpr::DbaExprIte;
constexpr dbaexpr_typeid_dbaexpr dbaexpr::DbaExprAlternative;
constexpr dbaexpr_typeid_dbaexpr dbaexpr::typeid_dbaexpr_MIN;
constexpr dbaexpr_typeid_dbaexpr dbaexpr::typeid_dbaexpr_MAX;
constexpr int dbaexpr::typeid_dbaexpr_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* dbaexpr_dbaunary_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_dba_2eproto);
  return file_level_enum_descriptors_dba_2eproto[4];
}
bool dbaexpr_dbaunary_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
constexpr dbaexpr_dbaunary dbaexpr::DbaUnaryMinus;
constexpr dbaexpr_dbaunary dbaexpr::DbaUnaryNot;
constexpr dbaexpr_dbaunary dbaexpr::dbaunary_MIN;
constexpr dbaexpr_dbaunary dbaexpr::dbaunary_MAX;
constexpr int dbaexpr::dbaunary_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* dbaexpr_dbabinary_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_dba_2eproto);
  return file_level_enum_descriptors_dba_2eproto[5];
}
bool dbaexpr_dbabinary_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
    case 3:
    case 4:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
    case 12:
    case 13:
    case 14:
    case 15:
    case 16:
    case 17:
    case 18:
    case 19:
    case 20:
    case 21:
    case 22:
    case 23:
    case 24:
    case 25:
    case 26:
    case 27:
    case 28:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
constexpr dbaexpr_dbabinary dbaexpr::DbaPlus;
constexpr dbaexpr_dbabinary dbaexpr::DbaMinus;
constexpr dbaexpr_dbabinary dbaexpr::DbaMultU;
constexpr dbaexpr_dbabinary dbaexpr::DbaMultS;
constexpr dbaexpr_dbabinary dbaexpr::DbaDivU;
constexpr dbaexpr_dbabinary dbaexpr::DbaDivS;
constexpr dbaexpr_dbabinary dbaexpr::DbaModU;
constexpr dbaexpr_dbabinary dbaexpr::DbaModS;
constexpr dbaexpr_dbabinary dbaexpr::DbaOr;
constexpr dbaexpr_dbabinary dbaexpr::DbaAnd;
constexpr dbaexpr_dbabinary dbaexpr::DbaXor;
constexpr dbaexpr_dbabinary dbaexpr::DbaConcat;
constexpr dbaexpr_dbabinary dbaexpr::DbaLShiftU;
constexpr dbaexpr_dbabinary dbaexpr::DbaRShiftU;
constexpr dbaexpr_dbabinary dbaexpr::DbaRShiftS;
constexpr dbaexpr_dbabinary dbaexpr::DbaLeftRotate;
constexpr dbaexpr_dbabinary dbaexpr::DbaRightRotate;
constexpr dbaexpr_dbabinary dbaexpr::DbaEq;
constexpr dbaexpr_dbabinary dbaexpr::DbaDiff;
constexpr dbaexpr_dbabinary dbaexpr::DbaLeqU;
constexpr dbaexpr_dbabinary dbaexpr::DbaLtU;
constexpr dbaexpr_dbabinary dbaexpr::DbaGeqU;
constexpr dbaexpr_dbabinary dbaexpr::DbaGtU;
constexpr dbaexpr_dbabinary dbaexpr::DbaLeqS;
constexpr dbaexpr_dbabinary dbaexpr::DbaLtS;
constexpr dbaexpr_dbabinary dbaexpr::DbaGeqS;
constexpr dbaexpr_dbabinary dbaexpr::DbaGtS;
constexpr dbaexpr_dbabinary dbaexpr::dbabinary_MIN;
constexpr dbaexpr_dbabinary dbaexpr::dbabinary_MAX;
constexpr int dbaexpr::dbabinary_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* dbacond_typeid_dbacond_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_dba_2eproto);
  return file_level_enum_descriptors_dba_2eproto[6];
}
bool dbacond_typeid_dbacond_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
constexpr dbacond_typeid_dbacond dbacond::DbaCondReif;
constexpr dbacond_typeid_dbacond dbacond::DbaCondNot;
constexpr dbacond_typeid_dbacond dbacond::DbaCondAnd;
constexpr dbacond_typeid_dbacond dbacond::DbaCondOr;
constexpr dbacond_typeid_dbacond dbacond::DbaTrue;
constexpr dbacond_typeid_dbacond dbacond::DbaFalse;
constexpr dbacond_typeid_dbacond dbacond::typeid_dbacond_MIN;
constexpr dbacond_typeid_dbacond dbacond::typeid_dbacond_MAX;
constexpr int dbacond::typeid_dbacond_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* dbaLhs_typeid_dbalhs_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_dba_2eproto);
  return file_level_enum_descriptors_dba_2eproto[7];
}
bool dbaLhs_typeid_dbalhs_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
constexpr dbaLhs_typeid_dbalhs dbaLhs::DbaLhsVar;
constexpr dbaLhs_typeid_dbalhs dbaLhs::DbaLhsVarRestrict;
constexpr dbaLhs_typeid_dbalhs dbaLhs::DbaStore;
constexpr dbaLhs_typeid_dbalhs dbaLhs::typeid_dbalhs_MIN;
constexpr dbaLhs_typeid_dbalhs dbaLhs::typeid_dbalhs_MAX;
constexpr int dbaLhs::typeid_dbalhs_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* dbainstr_typeid_instrkind_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_dba_2eproto);
  return file_level_enum_descriptors_dba_2eproto[8];
}
bool dbainstr_typeid_instrkind_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
    case 8:
    case 9:
    case 10:
    case 11:
    case 12:
    case 13:
      return true;
    default:
      return false;
  }
}

#if (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
constexpr dbainstr_typeid_instrkind dbainstr::DbaIkAssign;
constexpr dbainstr_typeid_instrkind dbainstr::DbaIkSJump;
constexpr dbainstr_typeid_instrkind dbainstr::DbaIkDJump;
constexpr dbainstr_typeid_instrkind dbainstr::DbaIkIf;
constexpr dbainstr_typeid_instrkind dbainstr::DbaIkStop;
constexpr dbainstr_typeid_instrkind dbainstr::DbaIkAssert;
constexpr dbainstr_typeid_instrkind dbainstr::DbaIkAssume;
constexpr dbainstr_typeid_instrkind dbainstr::DbaIkNondetAssume;
constexpr dbainstr_typeid_instrkind dbainstr::DbaIkNondet;
constexpr dbainstr_typeid_instrkind dbainstr::DbaIkUndef;
constexpr dbainstr_typeid_instrkind dbainstr::DbaIkMalloc;
constexpr dbainstr_typeid_instrkind dbainstr::DbaIkFree;
constexpr dbainstr_typeid_instrkind dbainstr::DbaIkPrint;
constexpr dbainstr_typeid_instrkind dbainstr::typeid_instrkind_MIN;
constexpr dbainstr_typeid_instrkind dbainstr::typeid_instrkind_MAX;
constexpr int dbainstr::typeid_instrkind_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || _MSC_VER >= 1900)
const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* endianness_descriptor() {
  ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&descriptor_table_dba_2eproto);
  return file_level_enum_descriptors_dba_2eproto[9];
}
bool endianness_IsValid(int value) {
  switch (value) {
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}


// ===================================================================

void bitvector::InitAsDefaultInstance() {
}
class bitvector::_Internal {
 public:
  using HasBits = decltype(std::declval<bitvector>()._has_bits_);
  static void set_has_bv(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_size(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

bitvector::bitvector()
  : ::PROTOBUF_NAMESPACE_ID::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:dba.bitvector)
}
bitvector::bitvector(const bitvector& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::memcpy(&bv_, &from.bv_,
    static_cast<size_t>(reinterpret_cast<char*>(&size_) -
    reinterpret_cast<char*>(&bv_)) + sizeof(size_));
  // @@protoc_insertion_point(copy_constructor:dba.bitvector)
}

void bitvector::SharedCtor() {
  ::memset(&bv_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&size_) -
      reinterpret_cast<char*>(&bv_)) + sizeof(size_));
}

bitvector::~bitvector() {
  // @@protoc_insertion_point(destructor:dba.bitvector)
  SharedDtor();
}

void bitvector::SharedDtor() {
}

void bitvector::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const bitvector& bitvector::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_bitvector_dba_2eproto.base);
  return *internal_default_instance();
}


void bitvector::Clear() {
// @@protoc_insertion_point(message_clear_start:dba.bitvector)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    ::memset(&bv_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&size_) -
        reinterpret_cast<char*>(&bv_)) + sizeof(size_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* bitvector::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // required uint64 bv = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          _Internal::set_has_bv(&has_bits);
          bv_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // required uint32 size = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_size(&has_bits);
          size_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool bitvector::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  // @@protoc_insertion_point(parse_start:dba.bitvector)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required uint64 bv = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (8 & 0xFF)) {
          _Internal::set_has_bv(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint64, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT64>(
                 input, &bv_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // required uint32 size = 2;
      case 2: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (16 & 0xFF)) {
          _Internal::set_has_size(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32>(
                 input, &size_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:dba.bitvector)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:dba.bitvector)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void bitvector::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:dba.bitvector)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required uint64 bv = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64(1, this->bv(), output);
  }

  // required uint32 size = 2;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32(2, this->size(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:dba.bitvector)
}

::PROTOBUF_NAMESPACE_ID::uint8* bitvector::InternalSerializeWithCachedSizesToArray(
    ::PROTOBUF_NAMESPACE_ID::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:dba.bitvector)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required uint64 bv = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt64ToArray(1, this->bv(), target);
  }

  // required uint32 size = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(2, this->size(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:dba.bitvector)
  return target;
}

size_t bitvector::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:dba.bitvector)
  size_t total_size = 0;

  if (has_bv()) {
    // required uint64 bv = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
        this->bv());
  }

  if (has_size()) {
    // required uint32 size = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
        this->size());
  }

  return total_size;
}
size_t bitvector::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:dba.bitvector)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  if (((_has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required uint64 bv = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt64Size(
        this->bv());

    // required uint32 size = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
        this->size());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void bitvector::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:dba.bitvector)
  GOOGLE_DCHECK_NE(&from, this);
  const bitvector* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<bitvector>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:dba.bitvector)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:dba.bitvector)
    MergeFrom(*source);
  }
}

void bitvector::MergeFrom(const bitvector& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:dba.bitvector)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      bv_ = from.bv_;
    }
    if (cached_has_bits & 0x00000002u) {
      size_ = from.size_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void bitvector::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:dba.bitvector)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void bitvector::CopyFrom(const bitvector& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:dba.bitvector)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool bitvector::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;
  return true;
}

void bitvector::InternalSwap(bitvector* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(bv_, other->bv_);
  swap(size_, other->size_);
}

::PROTOBUF_NAMESPACE_ID::Metadata bitvector::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void dbacodeaddress::InitAsDefaultInstance() {
  ::dba::_dbacodeaddress_default_instance_._instance.get_mutable()->bitvector_ = const_cast< ::dba::bitvector*>(
      ::dba::bitvector::internal_default_instance());
}
class dbacodeaddress::_Internal {
 public:
  using HasBits = decltype(std::declval<dbacodeaddress>()._has_bits_);
  static const ::dba::bitvector& bitvector(const dbacodeaddress* msg);
  static void set_has_bitvector(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_dbaoffset(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::dba::bitvector&
dbacodeaddress::_Internal::bitvector(const dbacodeaddress* msg) {
  return *msg->bitvector_;
}
dbacodeaddress::dbacodeaddress()
  : ::PROTOBUF_NAMESPACE_ID::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:dba.dbacodeaddress)
}
dbacodeaddress::dbacodeaddress(const dbacodeaddress& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  if (from.has_bitvector()) {
    bitvector_ = new ::dba::bitvector(*from.bitvector_);
  } else {
    bitvector_ = nullptr;
  }
  dbaoffset_ = from.dbaoffset_;
  // @@protoc_insertion_point(copy_constructor:dba.dbacodeaddress)
}

void dbacodeaddress::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_dbacodeaddress_dba_2eproto.base);
  ::memset(&bitvector_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&dbaoffset_) -
      reinterpret_cast<char*>(&bitvector_)) + sizeof(dbaoffset_));
}

dbacodeaddress::~dbacodeaddress() {
  // @@protoc_insertion_point(destructor:dba.dbacodeaddress)
  SharedDtor();
}

void dbacodeaddress::SharedDtor() {
  if (this != internal_default_instance()) delete bitvector_;
}

void dbacodeaddress::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const dbacodeaddress& dbacodeaddress::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_dbacodeaddress_dba_2eproto.base);
  return *internal_default_instance();
}


void dbacodeaddress::Clear() {
// @@protoc_insertion_point(message_clear_start:dba.dbacodeaddress)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(bitvector_ != nullptr);
    bitvector_->Clear();
  }
  dbaoffset_ = 0u;
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* dbacodeaddress::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // required .dba.bitvector bitvector = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr = ctx->ParseMessage(mutable_bitvector(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // required uint32 dbaoffset = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_dbaoffset(&has_bits);
          dbaoffset_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool dbacodeaddress::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  // @@protoc_insertion_point(parse_start:dba.dbacodeaddress)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .dba.bitvector bitvector = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (10 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadMessage(
               input, mutable_bitvector()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // required uint32 dbaoffset = 2;
      case 2: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (16 & 0xFF)) {
          _Internal::set_has_dbaoffset(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32>(
                 input, &dbaoffset_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:dba.dbacodeaddress)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:dba.dbacodeaddress)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void dbacodeaddress::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:dba.dbacodeaddress)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required .dba.bitvector bitvector = 1;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, _Internal::bitvector(this), output);
  }

  // required uint32 dbaoffset = 2;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32(2, this->dbaoffset(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:dba.dbacodeaddress)
}

::PROTOBUF_NAMESPACE_ID::uint8* dbacodeaddress::InternalSerializeWithCachedSizesToArray(
    ::PROTOBUF_NAMESPACE_ID::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:dba.dbacodeaddress)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required .dba.bitvector bitvector = 1;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessageToArray(
        1, _Internal::bitvector(this), target);
  }

  // required uint32 dbaoffset = 2;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(2, this->dbaoffset(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:dba.dbacodeaddress)
  return target;
}

size_t dbacodeaddress::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:dba.dbacodeaddress)
  size_t total_size = 0;

  if (has_bitvector()) {
    // required .dba.bitvector bitvector = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *bitvector_);
  }

  if (has_dbaoffset()) {
    // required uint32 dbaoffset = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
        this->dbaoffset());
  }

  return total_size;
}
size_t dbacodeaddress::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:dba.dbacodeaddress)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  if (((_has_bits_[0] & 0x00000003) ^ 0x00000003) == 0) {  // All required fields are present.
    // required .dba.bitvector bitvector = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *bitvector_);

    // required uint32 dbaoffset = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
        this->dbaoffset());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void dbacodeaddress::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:dba.dbacodeaddress)
  GOOGLE_DCHECK_NE(&from, this);
  const dbacodeaddress* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<dbacodeaddress>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:dba.dbacodeaddress)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:dba.dbacodeaddress)
    MergeFrom(*source);
  }
}

void dbacodeaddress::MergeFrom(const dbacodeaddress& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:dba.dbacodeaddress)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      mutable_bitvector()->::dba::bitvector::MergeFrom(from.bitvector());
    }
    if (cached_has_bits & 0x00000002u) {
      dbaoffset_ = from.dbaoffset_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void dbacodeaddress::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:dba.dbacodeaddress)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void dbacodeaddress::CopyFrom(const dbacodeaddress& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:dba.dbacodeaddress)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool dbacodeaddress::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;
  if (has_bitvector()) {
    if (!this->bitvector_->IsInitialized()) return false;
  }
  return true;
}

void dbacodeaddress::InternalSwap(dbacodeaddress* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(bitvector_, other->bitvector_);
  swap(dbaoffset_, other->dbaoffset_);
}

::PROTOBUF_NAMESPACE_ID::Metadata dbacodeaddress::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void codeaddress::InitAsDefaultInstance() {
  ::dba::_codeaddress_default_instance_._instance.get_mutable()->address_ = const_cast< ::dba::dbacodeaddress*>(
      ::dba::dbacodeaddress::internal_default_instance());
}
class codeaddress::_Internal {
 public:
  using HasBits = decltype(std::declval<codeaddress>()._has_bits_);
  static void set_has_typeid_(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_offset(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::dba::dbacodeaddress& address(const codeaddress* msg);
  static void set_has_address(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::dba::dbacodeaddress&
codeaddress::_Internal::address(const codeaddress* msg) {
  return *msg->address_;
}
codeaddress::codeaddress()
  : ::PROTOBUF_NAMESPACE_ID::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:dba.codeaddress)
}
codeaddress::codeaddress(const codeaddress& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  if (from.has_address()) {
    address_ = new ::dba::dbacodeaddress(*from.address_);
  } else {
    address_ = nullptr;
  }
  ::memcpy(&typeid__, &from.typeid__,
    static_cast<size_t>(reinterpret_cast<char*>(&offset_) -
    reinterpret_cast<char*>(&typeid__)) + sizeof(offset_));
  // @@protoc_insertion_point(copy_constructor:dba.codeaddress)
}

void codeaddress::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_codeaddress_dba_2eproto.base);
  ::memset(&address_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&offset_) -
      reinterpret_cast<char*>(&address_)) + sizeof(offset_));
}

codeaddress::~codeaddress() {
  // @@protoc_insertion_point(destructor:dba.codeaddress)
  SharedDtor();
}

void codeaddress::SharedDtor() {
  if (this != internal_default_instance()) delete address_;
}

void codeaddress::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const codeaddress& codeaddress::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_codeaddress_dba_2eproto.base);
  return *internal_default_instance();
}


void codeaddress::Clear() {
// @@protoc_insertion_point(message_clear_start:dba.codeaddress)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    GOOGLE_DCHECK(address_ != nullptr);
    address_->Clear();
  }
  if (cached_has_bits & 0x00000006u) {
    ::memset(&typeid__, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&offset_) -
        reinterpret_cast<char*>(&typeid__)) + sizeof(offset_));
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* codeaddress::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // required .dba.codeaddress.typeid_codeaddress typeid = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::dba::codeaddress_typeid_codeaddress_IsValid(val))) {
            set_typeid_(static_cast<::dba::codeaddress_typeid_codeaddress>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else goto handle_unusual;
        continue;
      // optional uint32 offset = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 16)) {
          _Internal::set_has_offset(&has_bits);
          offset_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .dba.dbacodeaddress address = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26)) {
          ptr = ctx->ParseMessage(mutable_address(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool codeaddress::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  // @@protoc_insertion_point(parse_start:dba.codeaddress)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .dba.codeaddress.typeid_codeaddress typeid = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (8 & 0xFF)) {
          int value = 0;
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   int, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::dba::codeaddress_typeid_codeaddress_IsValid(value)) {
            set_typeid_(static_cast< ::dba::codeaddress_typeid_codeaddress >(value));
          } else {
            mutable_unknown_fields()->AddVarint(
                1, static_cast<::PROTOBUF_NAMESPACE_ID::uint64>(value));
          }
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 offset = 2;
      case 2: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (16 & 0xFF)) {
          _Internal::set_has_offset(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32>(
                 input, &offset_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .dba.dbacodeaddress address = 3;
      case 3: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (26 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadMessage(
               input, mutable_address()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:dba.codeaddress)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:dba.codeaddress)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void codeaddress::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:dba.codeaddress)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required .dba.codeaddress.typeid_codeaddress typeid = 1;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnum(
      1, this->typeid_(), output);
  }

  // optional uint32 offset = 2;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32(2, this->offset(), output);
  }

  // optional .dba.dbacodeaddress address = 3;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, _Internal::address(this), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:dba.codeaddress)
}

::PROTOBUF_NAMESPACE_ID::uint8* codeaddress::InternalSerializeWithCachedSizesToArray(
    ::PROTOBUF_NAMESPACE_ID::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:dba.codeaddress)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required .dba.codeaddress.typeid_codeaddress typeid = 1;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      1, this->typeid_(), target);
  }

  // optional uint32 offset = 2;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(2, this->offset(), target);
  }

  // optional .dba.dbacodeaddress address = 3;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessageToArray(
        3, _Internal::address(this), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:dba.codeaddress)
  return target;
}

size_t codeaddress::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:dba.codeaddress)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  // required .dba.codeaddress.typeid_codeaddress typeid = 1;
  if (has_typeid_()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->typeid_());
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional .dba.dbacodeaddress address = 3;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *address_);
  }

  // optional uint32 offset = 2;
  if (cached_has_bits & 0x00000004u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
        this->offset());
  }

  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void codeaddress::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:dba.codeaddress)
  GOOGLE_DCHECK_NE(&from, this);
  const codeaddress* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<codeaddress>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:dba.codeaddress)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:dba.codeaddress)
    MergeFrom(*source);
  }
}

void codeaddress::MergeFrom(const codeaddress& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:dba.codeaddress)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    if (cached_has_bits & 0x00000001u) {
      mutable_address()->::dba::dbacodeaddress::MergeFrom(from.address());
    }
    if (cached_has_bits & 0x00000002u) {
      typeid__ = from.typeid__;
    }
    if (cached_has_bits & 0x00000004u) {
      offset_ = from.offset_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void codeaddress::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:dba.codeaddress)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void codeaddress::CopyFrom(const codeaddress& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:dba.codeaddress)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool codeaddress::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000002) != 0x00000002) return false;
  if (has_address()) {
    if (!this->address_->IsInitialized()) return false;
  }
  return true;
}

void codeaddress::InternalSwap(codeaddress* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(address_, other->address_);
  swap(typeid__, other->typeid__);
  swap(offset_, other->offset_);
}

::PROTOBUF_NAMESPACE_ID::Metadata codeaddress::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void dbatag::InitAsDefaultInstance() {
  ::dba::_dbatag_default_instance_._instance.get_mutable()->address_ = const_cast< ::dba::dbacodeaddress*>(
      ::dba::dbacodeaddress::internal_default_instance());
}
class dbatag::_Internal {
 public:
  using HasBits = decltype(std::declval<dbatag>()._has_bits_);
  static void set_has_typeid_(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::dba::dbacodeaddress& address(const dbatag* msg);
  static void set_has_address(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

const ::dba::dbacodeaddress&
dbatag::_Internal::address(const dbatag* msg) {
  return *msg->address_;
}
dbatag::dbatag()
  : ::PROTOBUF_NAMESPACE_ID::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:dba.dbatag)
}
dbatag::dbatag(const dbatag& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  if (from.has_address()) {
    address_ = new ::dba::dbacodeaddress(*from.address_);
  } else {
    address_ = nullptr;
  }
  typeid__ = from.typeid__;
  // @@protoc_insertion_point(copy_constructor:dba.dbatag)
}

void dbatag::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_dbatag_dba_2eproto.base);
  address_ = nullptr;
  typeid__ = 1;
}

dbatag::~dbatag() {
  // @@protoc_insertion_point(destructor:dba.dbatag)
  SharedDtor();
}

void dbatag::SharedDtor() {
  if (this != internal_default_instance()) delete address_;
}

void dbatag::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const dbatag& dbatag::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_dbatag_dba_2eproto.base);
  return *internal_default_instance();
}


void dbatag::Clear() {
// @@protoc_insertion_point(message_clear_start:dba.dbatag)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(address_ != nullptr);
      address_->Clear();
    }
    typeid__ = 1;
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* dbatag::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // required .dba.dbatag.typeid_dbatag typeid = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::dba::dbatag_typeid_dbatag_IsValid(val))) {
            set_typeid_(static_cast<::dba::dbatag_typeid_dbatag>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else goto handle_unusual;
        continue;
      // optional .dba.dbacodeaddress address = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          ptr = ctx->ParseMessage(mutable_address(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool dbatag::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  // @@protoc_insertion_point(parse_start:dba.dbatag)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .dba.dbatag.typeid_dbatag typeid = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (8 & 0xFF)) {
          int value = 0;
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   int, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::dba::dbatag_typeid_dbatag_IsValid(value)) {
            set_typeid_(static_cast< ::dba::dbatag_typeid_dbatag >(value));
          } else {
            mutable_unknown_fields()->AddVarint(
                1, static_cast<::PROTOBUF_NAMESPACE_ID::uint64>(value));
          }
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .dba.dbacodeaddress address = 2;
      case 2: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (18 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadMessage(
               input, mutable_address()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:dba.dbatag)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:dba.dbatag)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void dbatag::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:dba.dbatag)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required .dba.dbatag.typeid_dbatag typeid = 1;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnum(
      1, this->typeid_(), output);
  }

  // optional .dba.dbacodeaddress address = 2;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, _Internal::address(this), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:dba.dbatag)
}

::PROTOBUF_NAMESPACE_ID::uint8* dbatag::InternalSerializeWithCachedSizesToArray(
    ::PROTOBUF_NAMESPACE_ID::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:dba.dbatag)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required .dba.dbatag.typeid_dbatag typeid = 1;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      1, this->typeid_(), target);
  }

  // optional .dba.dbacodeaddress address = 2;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessageToArray(
        2, _Internal::address(this), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:dba.dbatag)
  return target;
}

size_t dbatag::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:dba.dbatag)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  // required .dba.dbatag.typeid_dbatag typeid = 1;
  if (has_typeid_()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->typeid_());
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional .dba.dbacodeaddress address = 2;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *address_);
  }

  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void dbatag::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:dba.dbatag)
  GOOGLE_DCHECK_NE(&from, this);
  const dbatag* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<dbatag>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:dba.dbatag)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:dba.dbatag)
    MergeFrom(*source);
  }
}

void dbatag::MergeFrom(const dbatag& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:dba.dbatag)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      mutable_address()->::dba::dbacodeaddress::MergeFrom(from.address());
    }
    if (cached_has_bits & 0x00000002u) {
      typeid__ = from.typeid__;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void dbatag::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:dba.dbatag)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void dbatag::CopyFrom(const dbatag& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:dba.dbatag)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool dbatag::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000002) != 0x00000002) return false;
  if (has_address()) {
    if (!this->address_->IsInitialized()) return false;
  }
  return true;
}

void dbatag::InternalSwap(dbatag* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(address_, other->address_);
  swap(typeid__, other->typeid__);
}

::PROTOBUF_NAMESPACE_ID::Metadata dbatag::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void dbastopstate::InitAsDefaultInstance() {
}
class dbastopstate::_Internal {
 public:
  using HasBits = decltype(std::declval<dbastopstate>()._has_bits_);
  static void set_has_typeid_(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static void set_has_infos(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
};

dbastopstate::dbastopstate()
  : ::PROTOBUF_NAMESPACE_ID::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:dba.dbastopstate)
}
dbastopstate::dbastopstate(const dbastopstate& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  infos_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from.has_infos()) {
    infos_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.infos_);
  }
  typeid__ = from.typeid__;
  // @@protoc_insertion_point(copy_constructor:dba.dbastopstate)
}

void dbastopstate::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_dbastopstate_dba_2eproto.base);
  infos_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  typeid__ = 1;
}

dbastopstate::~dbastopstate() {
  // @@protoc_insertion_point(destructor:dba.dbastopstate)
  SharedDtor();
}

void dbastopstate::SharedDtor() {
  infos_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}

void dbastopstate::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const dbastopstate& dbastopstate::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_dbastopstate_dba_2eproto.base);
  return *internal_default_instance();
}


void dbastopstate::Clear() {
// @@protoc_insertion_point(message_clear_start:dba.dbastopstate)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      infos_.ClearNonDefaultToEmptyNoArena();
    }
    typeid__ = 1;
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* dbastopstate::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // required .dba.dbastopstate.typeid_dbastate typeid = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::dba::dbastopstate_typeid_dbastate_IsValid(val))) {
            set_typeid_(static_cast<::dba::dbastopstate_typeid_dbastate>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else goto handle_unusual;
        continue;
      // optional string infos = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParserUTF8Verify(mutable_infos(), ptr, ctx, "dba.dbastopstate.infos");
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool dbastopstate::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  // @@protoc_insertion_point(parse_start:dba.dbastopstate)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .dba.dbastopstate.typeid_dbastate typeid = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (8 & 0xFF)) {
          int value = 0;
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   int, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::dba::dbastopstate_typeid_dbastate_IsValid(value)) {
            set_typeid_(static_cast< ::dba::dbastopstate_typeid_dbastate >(value));
          } else {
            mutable_unknown_fields()->AddVarint(
                1, static_cast<::PROTOBUF_NAMESPACE_ID::uint64>(value));
          }
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional string infos = 2;
      case 2: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (18 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadString(
                input, this->mutable_infos()));
          ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
            this->infos().data(), static_cast<int>(this->infos().length()),
            ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::PARSE,
            "dba.dbastopstate.infos");
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:dba.dbastopstate)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:dba.dbastopstate)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void dbastopstate::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:dba.dbastopstate)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required .dba.dbastopstate.typeid_dbastate typeid = 1;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnum(
      1, this->typeid_(), output);
  }

  // optional string infos = 2;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->infos().data(), static_cast<int>(this->infos().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "dba.dbastopstate.infos");
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteStringMaybeAliased(
      2, this->infos(), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:dba.dbastopstate)
}

::PROTOBUF_NAMESPACE_ID::uint8* dbastopstate::InternalSerializeWithCachedSizesToArray(
    ::PROTOBUF_NAMESPACE_ID::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:dba.dbastopstate)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required .dba.dbastopstate.typeid_dbastate typeid = 1;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      1, this->typeid_(), target);
  }

  // optional string infos = 2;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->infos().data(), static_cast<int>(this->infos().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "dba.dbastopstate.infos");
    target =
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteStringToArray(
        2, this->infos(), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:dba.dbastopstate)
  return target;
}

size_t dbastopstate::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:dba.dbastopstate)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  // required .dba.dbastopstate.typeid_dbastate typeid = 1;
  if (has_typeid_()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->typeid_());
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // optional string infos = 2;
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000001u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->infos());
  }

  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void dbastopstate::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:dba.dbastopstate)
  GOOGLE_DCHECK_NE(&from, this);
  const dbastopstate* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<dbastopstate>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:dba.dbastopstate)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:dba.dbastopstate)
    MergeFrom(*source);
  }
}

void dbastopstate::MergeFrom(const dbastopstate& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:dba.dbastopstate)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      _has_bits_[0] |= 0x00000001u;
      infos_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.infos_);
    }
    if (cached_has_bits & 0x00000002u) {
      typeid__ = from.typeid__;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void dbastopstate::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:dba.dbastopstate)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void dbastopstate::CopyFrom(const dbastopstate& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:dba.dbastopstate)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool dbastopstate::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000002) != 0x00000002) return false;
  return true;
}

void dbastopstate::InternalSwap(dbastopstate* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  infos_.Swap(&other->infos_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  swap(typeid__, other->typeid__);
}

::PROTOBUF_NAMESPACE_ID::Metadata dbastopstate::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void dbaexpr::InitAsDefaultInstance() {
  ::dba::_dbaexpr_default_instance_._instance.get_mutable()->bitvector_ = const_cast< ::dba::bitvector*>(
      ::dba::bitvector::internal_default_instance());
  ::dba::_dbaexpr_default_instance_._instance.get_mutable()->expr1_ = const_cast< ::dba::dbaexpr*>(
      ::dba::dbaexpr::internal_default_instance());
  ::dba::_dbaexpr_default_instance_._instance.get_mutable()->expr2_ = const_cast< ::dba::dbaexpr*>(
      ::dba::dbaexpr::internal_default_instance());
  ::dba::_dbaexpr_default_instance_._instance.get_mutable()->cond_ = const_cast< ::dba::dbacond*>(
      ::dba::dbacond::internal_default_instance());
}
class dbaexpr::_Internal {
 public:
  using HasBits = decltype(std::declval<dbaexpr>()._has_bits_);
  static void set_has_typeid_(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static void set_has_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_size(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_endian(HasBits* has_bits) {
    (*has_bits)[0] |= 512u;
  }
  static const ::dba::bitvector& bitvector(const dbaexpr* msg);
  static void set_has_bitvector(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::dba::dbaexpr& expr1(const dbaexpr* msg);
  static void set_has_expr1(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static const ::dba::dbaexpr& expr2(const dbaexpr* msg);
  static void set_has_expr2(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_unaryop(HasBits* has_bits) {
    (*has_bits)[0] |= 1024u;
  }
  static void set_has_binaryop(HasBits* has_bits) {
    (*has_bits)[0] |= 2048u;
  }
  static void set_has_low(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static void set_has_high(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static const ::dba::dbacond& cond(const dbaexpr* msg);
  static void set_has_cond(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
};

const ::dba::bitvector&
dbaexpr::_Internal::bitvector(const dbaexpr* msg) {
  return *msg->bitvector_;
}
const ::dba::dbaexpr&
dbaexpr::_Internal::expr1(const dbaexpr* msg) {
  return *msg->expr1_;
}
const ::dba::dbaexpr&
dbaexpr::_Internal::expr2(const dbaexpr* msg) {
  return *msg->expr2_;
}
const ::dba::dbacond&
dbaexpr::_Internal::cond(const dbaexpr* msg) {
  return *msg->cond_;
}
dbaexpr::dbaexpr()
  : ::PROTOBUF_NAMESPACE_ID::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:dba.dbaexpr)
}
dbaexpr::dbaexpr(const dbaexpr& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from.has_name()) {
    name_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.name_);
  }
  if (from.has_bitvector()) {
    bitvector_ = new ::dba::bitvector(*from.bitvector_);
  } else {
    bitvector_ = nullptr;
  }
  if (from.has_expr1()) {
    expr1_ = new ::dba::dbaexpr(*from.expr1_);
  } else {
    expr1_ = nullptr;
  }
  if (from.has_expr2()) {
    expr2_ = new ::dba::dbaexpr(*from.expr2_);
  } else {
    expr2_ = nullptr;
  }
  if (from.has_cond()) {
    cond_ = new ::dba::dbacond(*from.cond_);
  } else {
    cond_ = nullptr;
  }
  ::memcpy(&size_, &from.size_,
    static_cast<size_t>(reinterpret_cast<char*>(&binaryop_) -
    reinterpret_cast<char*>(&size_)) + sizeof(binaryop_));
  // @@protoc_insertion_point(copy_constructor:dba.dbaexpr)
}

void dbaexpr::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_dbacond_dba_2eproto.base);
  name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  ::memset(&bitvector_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&high_) -
      reinterpret_cast<char*>(&bitvector_)) + sizeof(high_));
  typeid__ = 1;
  endian_ = 1;
  unaryop_ = 1;
  binaryop_ = 1;
}

dbaexpr::~dbaexpr() {
  // @@protoc_insertion_point(destructor:dba.dbaexpr)
  SharedDtor();
}

void dbaexpr::SharedDtor() {
  name_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (this != internal_default_instance()) delete bitvector_;
  if (this != internal_default_instance()) delete expr1_;
  if (this != internal_default_instance()) delete expr2_;
  if (this != internal_default_instance()) delete cond_;
}

void dbaexpr::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const dbaexpr& dbaexpr::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_dbacond_dba_2eproto.base);
  return *internal_default_instance();
}


void dbaexpr::Clear() {
// @@protoc_insertion_point(message_clear_start:dba.dbaexpr)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    if (cached_has_bits & 0x00000001u) {
      name_.ClearNonDefaultToEmptyNoArena();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(bitvector_ != nullptr);
      bitvector_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(expr1_ != nullptr);
      expr1_->Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(expr2_ != nullptr);
      expr2_->Clear();
    }
    if (cached_has_bits & 0x00000010u) {
      GOOGLE_DCHECK(cond_ != nullptr);
      cond_->Clear();
    }
  }
  if (cached_has_bits & 0x000000e0u) {
    ::memset(&size_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&high_) -
        reinterpret_cast<char*>(&size_)) + sizeof(high_));
  }
  if (cached_has_bits & 0x00000f00u) {
    typeid__ = 1;
    endian_ = 1;
    unaryop_ = 1;
    binaryop_ = 1;
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* dbaexpr::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // required .dba.dbaexpr.typeid_dbaexpr typeid = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::dba::dbaexpr_typeid_dbaexpr_IsValid(val))) {
            set_typeid_(static_cast<::dba::dbaexpr_typeid_dbaexpr>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else goto handle_unusual;
        continue;
      // optional string name = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParserUTF8Verify(mutable_name(), ptr, ctx, "dba.dbaexpr.name");
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 size = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          _Internal::set_has_size(&has_bits);
          size_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .dba.endianness endian = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 32)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::dba::endianness_IsValid(val))) {
            set_endian(static_cast<::dba::endianness>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(4, val, mutable_unknown_fields());
          }
        } else goto handle_unusual;
        continue;
      // optional .dba.bitvector bitvector = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 42)) {
          ptr = ctx->ParseMessage(mutable_bitvector(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .dba.dbaexpr expr1 = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 50)) {
          ptr = ctx->ParseMessage(mutable_expr1(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .dba.dbaexpr expr2 = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 58)) {
          ptr = ctx->ParseMessage(mutable_expr2(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .dba.dbaexpr.dbaunary unaryop = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 72)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::dba::dbaexpr_dbaunary_IsValid(val))) {
            set_unaryop(static_cast<::dba::dbaexpr_dbaunary>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(9, val, mutable_unknown_fields());
          }
        } else goto handle_unusual;
        continue;
      // optional .dba.dbaexpr.dbabinary binaryop = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 80)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::dba::dbaexpr_dbabinary_IsValid(val))) {
            set_binaryop(static_cast<::dba::dbaexpr_dbabinary>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(10, val, mutable_unknown_fields());
          }
        } else goto handle_unusual;
        continue;
      // optional uint32 low = 11;
      case 11:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 88)) {
          _Internal::set_has_low(&has_bits);
          low_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 high = 12;
      case 12:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 96)) {
          _Internal::set_has_high(&has_bits);
          high_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .dba.dbacond cond = 13;
      case 13:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 106)) {
          ptr = ctx->ParseMessage(mutable_cond(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool dbaexpr::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  // @@protoc_insertion_point(parse_start:dba.dbaexpr)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .dba.dbaexpr.typeid_dbaexpr typeid = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (8 & 0xFF)) {
          int value = 0;
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   int, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::dba::dbaexpr_typeid_dbaexpr_IsValid(value)) {
            set_typeid_(static_cast< ::dba::dbaexpr_typeid_dbaexpr >(value));
          } else {
            mutable_unknown_fields()->AddVarint(
                1, static_cast<::PROTOBUF_NAMESPACE_ID::uint64>(value));
          }
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional string name = 2;
      case 2: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (18 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadString(
                input, this->mutable_name()));
          ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
            this->name().data(), static_cast<int>(this->name().length()),
            ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::PARSE,
            "dba.dbaexpr.name");
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 size = 3;
      case 3: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (24 & 0xFF)) {
          _Internal::set_has_size(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32>(
                 input, &size_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .dba.endianness endian = 4;
      case 4: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (32 & 0xFF)) {
          int value = 0;
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   int, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::dba::endianness_IsValid(value)) {
            set_endian(static_cast< ::dba::endianness >(value));
          } else {
            mutable_unknown_fields()->AddVarint(
                4, static_cast<::PROTOBUF_NAMESPACE_ID::uint64>(value));
          }
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .dba.bitvector bitvector = 5;
      case 5: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (42 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadMessage(
               input, mutable_bitvector()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .dba.dbaexpr expr1 = 6;
      case 6: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (50 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadMessage(
               input, mutable_expr1()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .dba.dbaexpr expr2 = 7;
      case 7: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (58 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadMessage(
               input, mutable_expr2()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .dba.dbaexpr.dbaunary unaryop = 9;
      case 9: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (72 & 0xFF)) {
          int value = 0;
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   int, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::dba::dbaexpr_dbaunary_IsValid(value)) {
            set_unaryop(static_cast< ::dba::dbaexpr_dbaunary >(value));
          } else {
            mutable_unknown_fields()->AddVarint(
                9, static_cast<::PROTOBUF_NAMESPACE_ID::uint64>(value));
          }
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .dba.dbaexpr.dbabinary binaryop = 10;
      case 10: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (80 & 0xFF)) {
          int value = 0;
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   int, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::dba::dbaexpr_dbabinary_IsValid(value)) {
            set_binaryop(static_cast< ::dba::dbaexpr_dbabinary >(value));
          } else {
            mutable_unknown_fields()->AddVarint(
                10, static_cast<::PROTOBUF_NAMESPACE_ID::uint64>(value));
          }
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 low = 11;
      case 11: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (88 & 0xFF)) {
          _Internal::set_has_low(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32>(
                 input, &low_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 high = 12;
      case 12: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (96 & 0xFF)) {
          _Internal::set_has_high(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32>(
                 input, &high_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .dba.dbacond cond = 13;
      case 13: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (106 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadMessage(
               input, mutable_cond()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:dba.dbaexpr)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:dba.dbaexpr)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void dbaexpr::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:dba.dbaexpr)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required .dba.dbaexpr.typeid_dbaexpr typeid = 1;
  if (cached_has_bits & 0x00000100u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnum(
      1, this->typeid_(), output);
  }

  // optional string name = 2;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->name().data(), static_cast<int>(this->name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "dba.dbaexpr.name");
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteStringMaybeAliased(
      2, this->name(), output);
  }

  // optional uint32 size = 3;
  if (cached_has_bits & 0x00000020u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32(3, this->size(), output);
  }

  // optional .dba.endianness endian = 4;
  if (cached_has_bits & 0x00000200u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnum(
      4, this->endian(), output);
  }

  // optional .dba.bitvector bitvector = 5;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteMessageMaybeToArray(
      5, _Internal::bitvector(this), output);
  }

  // optional .dba.dbaexpr expr1 = 6;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteMessageMaybeToArray(
      6, _Internal::expr1(this), output);
  }

  // optional .dba.dbaexpr expr2 = 7;
  if (cached_has_bits & 0x00000008u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteMessageMaybeToArray(
      7, _Internal::expr2(this), output);
  }

  // optional .dba.dbaexpr.dbaunary unaryop = 9;
  if (cached_has_bits & 0x00000400u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnum(
      9, this->unaryop(), output);
  }

  // optional .dba.dbaexpr.dbabinary binaryop = 10;
  if (cached_has_bits & 0x00000800u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnum(
      10, this->binaryop(), output);
  }

  // optional uint32 low = 11;
  if (cached_has_bits & 0x00000040u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32(11, this->low(), output);
  }

  // optional uint32 high = 12;
  if (cached_has_bits & 0x00000080u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32(12, this->high(), output);
  }

  // optional .dba.dbacond cond = 13;
  if (cached_has_bits & 0x00000010u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteMessageMaybeToArray(
      13, _Internal::cond(this), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:dba.dbaexpr)
}

::PROTOBUF_NAMESPACE_ID::uint8* dbaexpr::InternalSerializeWithCachedSizesToArray(
    ::PROTOBUF_NAMESPACE_ID::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:dba.dbaexpr)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required .dba.dbaexpr.typeid_dbaexpr typeid = 1;
  if (cached_has_bits & 0x00000100u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      1, this->typeid_(), target);
  }

  // optional string name = 2;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->name().data(), static_cast<int>(this->name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "dba.dbaexpr.name");
    target =
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteStringToArray(
        2, this->name(), target);
  }

  // optional uint32 size = 3;
  if (cached_has_bits & 0x00000020u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(3, this->size(), target);
  }

  // optional .dba.endianness endian = 4;
  if (cached_has_bits & 0x00000200u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      4, this->endian(), target);
  }

  // optional .dba.bitvector bitvector = 5;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessageToArray(
        5, _Internal::bitvector(this), target);
  }

  // optional .dba.dbaexpr expr1 = 6;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessageToArray(
        6, _Internal::expr1(this), target);
  }

  // optional .dba.dbaexpr expr2 = 7;
  if (cached_has_bits & 0x00000008u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessageToArray(
        7, _Internal::expr2(this), target);
  }

  // optional .dba.dbaexpr.dbaunary unaryop = 9;
  if (cached_has_bits & 0x00000400u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      9, this->unaryop(), target);
  }

  // optional .dba.dbaexpr.dbabinary binaryop = 10;
  if (cached_has_bits & 0x00000800u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      10, this->binaryop(), target);
  }

  // optional uint32 low = 11;
  if (cached_has_bits & 0x00000040u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(11, this->low(), target);
  }

  // optional uint32 high = 12;
  if (cached_has_bits & 0x00000080u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(12, this->high(), target);
  }

  // optional .dba.dbacond cond = 13;
  if (cached_has_bits & 0x00000010u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessageToArray(
        13, _Internal::cond(this), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:dba.dbaexpr)
  return target;
}

size_t dbaexpr::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:dba.dbaexpr)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  // required .dba.dbaexpr.typeid_dbaexpr typeid = 1;
  if (has_typeid_()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->typeid_());
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    // optional string name = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->name());
    }

    // optional .dba.bitvector bitvector = 5;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *bitvector_);
    }

    // optional .dba.dbaexpr expr1 = 6;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *expr1_);
    }

    // optional .dba.dbaexpr expr2 = 7;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *expr2_);
    }

    // optional .dba.dbacond cond = 13;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *cond_);
    }

    // optional uint32 size = 3;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->size());
    }

    // optional uint32 low = 11;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->low());
    }

    // optional uint32 high = 12;
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->high());
    }

  }
  if (cached_has_bits & 0x00000e00u) {
    // optional .dba.endianness endian = 4;
    if (cached_has_bits & 0x00000200u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->endian());
    }

    // optional .dba.dbaexpr.dbaunary unaryop = 9;
    if (cached_has_bits & 0x00000400u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->unaryop());
    }

    // optional .dba.dbaexpr.dbabinary binaryop = 10;
    if (cached_has_bits & 0x00000800u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->binaryop());
    }

  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void dbaexpr::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:dba.dbaexpr)
  GOOGLE_DCHECK_NE(&from, this);
  const dbaexpr* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<dbaexpr>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:dba.dbaexpr)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:dba.dbaexpr)
    MergeFrom(*source);
  }
}

void dbaexpr::MergeFrom(const dbaexpr& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:dba.dbaexpr)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      _has_bits_[0] |= 0x00000001u;
      name_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.name_);
    }
    if (cached_has_bits & 0x00000002u) {
      mutable_bitvector()->::dba::bitvector::MergeFrom(from.bitvector());
    }
    if (cached_has_bits & 0x00000004u) {
      mutable_expr1()->::dba::dbaexpr::MergeFrom(from.expr1());
    }
    if (cached_has_bits & 0x00000008u) {
      mutable_expr2()->::dba::dbaexpr::MergeFrom(from.expr2());
    }
    if (cached_has_bits & 0x00000010u) {
      mutable_cond()->::dba::dbacond::MergeFrom(from.cond());
    }
    if (cached_has_bits & 0x00000020u) {
      size_ = from.size_;
    }
    if (cached_has_bits & 0x00000040u) {
      low_ = from.low_;
    }
    if (cached_has_bits & 0x00000080u) {
      high_ = from.high_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00000f00u) {
    if (cached_has_bits & 0x00000100u) {
      typeid__ = from.typeid__;
    }
    if (cached_has_bits & 0x00000200u) {
      endian_ = from.endian_;
    }
    if (cached_has_bits & 0x00000400u) {
      unaryop_ = from.unaryop_;
    }
    if (cached_has_bits & 0x00000800u) {
      binaryop_ = from.binaryop_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void dbaexpr::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:dba.dbaexpr)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void dbaexpr::CopyFrom(const dbaexpr& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:dba.dbaexpr)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool dbaexpr::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000100) != 0x00000100) return false;
  if (has_bitvector()) {
    if (!this->bitvector_->IsInitialized()) return false;
  }
  if (has_expr1()) {
    if (!this->expr1_->IsInitialized()) return false;
  }
  if (has_expr2()) {
    if (!this->expr2_->IsInitialized()) return false;
  }
  if (has_cond()) {
    if (!this->cond_->IsInitialized()) return false;
  }
  return true;
}

void dbaexpr::InternalSwap(dbaexpr* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  name_.Swap(&other->name_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  swap(bitvector_, other->bitvector_);
  swap(expr1_, other->expr1_);
  swap(expr2_, other->expr2_);
  swap(cond_, other->cond_);
  swap(size_, other->size_);
  swap(low_, other->low_);
  swap(high_, other->high_);
  swap(typeid__, other->typeid__);
  swap(endian_, other->endian_);
  swap(unaryop_, other->unaryop_);
  swap(binaryop_, other->binaryop_);
}

::PROTOBUF_NAMESPACE_ID::Metadata dbaexpr::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void dbacond::InitAsDefaultInstance() {
  ::dba::_dbacond_default_instance_._instance.get_mutable()->expr_ = const_cast< ::dba::dbaexpr*>(
      ::dba::dbaexpr::internal_default_instance());
  ::dba::_dbacond_default_instance_._instance.get_mutable()->cond1_ = const_cast< ::dba::dbacond*>(
      ::dba::dbacond::internal_default_instance());
  ::dba::_dbacond_default_instance_._instance.get_mutable()->cond2_ = const_cast< ::dba::dbacond*>(
      ::dba::dbacond::internal_default_instance());
}
class dbacond::_Internal {
 public:
  using HasBits = decltype(std::declval<dbacond>()._has_bits_);
  static void set_has_typeid_(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static const ::dba::dbaexpr& expr(const dbacond* msg);
  static void set_has_expr(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::dba::dbacond& cond1(const dbacond* msg);
  static void set_has_cond1(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::dba::dbacond& cond2(const dbacond* msg);
  static void set_has_cond2(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
};

const ::dba::dbaexpr&
dbacond::_Internal::expr(const dbacond* msg) {
  return *msg->expr_;
}
const ::dba::dbacond&
dbacond::_Internal::cond1(const dbacond* msg) {
  return *msg->cond1_;
}
const ::dba::dbacond&
dbacond::_Internal::cond2(const dbacond* msg) {
  return *msg->cond2_;
}
dbacond::dbacond()
  : ::PROTOBUF_NAMESPACE_ID::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:dba.dbacond)
}
dbacond::dbacond(const dbacond& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  if (from.has_expr()) {
    expr_ = new ::dba::dbaexpr(*from.expr_);
  } else {
    expr_ = nullptr;
  }
  if (from.has_cond1()) {
    cond1_ = new ::dba::dbacond(*from.cond1_);
  } else {
    cond1_ = nullptr;
  }
  if (from.has_cond2()) {
    cond2_ = new ::dba::dbacond(*from.cond2_);
  } else {
    cond2_ = nullptr;
  }
  typeid__ = from.typeid__;
  // @@protoc_insertion_point(copy_constructor:dba.dbacond)
}

void dbacond::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_dbacond_dba_2eproto.base);
  ::memset(&expr_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&cond2_) -
      reinterpret_cast<char*>(&expr_)) + sizeof(cond2_));
  typeid__ = 1;
}

dbacond::~dbacond() {
  // @@protoc_insertion_point(destructor:dba.dbacond)
  SharedDtor();
}

void dbacond::SharedDtor() {
  if (this != internal_default_instance()) delete expr_;
  if (this != internal_default_instance()) delete cond1_;
  if (this != internal_default_instance()) delete cond2_;
}

void dbacond::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const dbacond& dbacond::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_dbacond_dba_2eproto.base);
  return *internal_default_instance();
}


void dbacond::Clear() {
// @@protoc_insertion_point(message_clear_start:dba.dbacond)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(expr_ != nullptr);
      expr_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(cond1_ != nullptr);
      cond1_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(cond2_ != nullptr);
      cond2_->Clear();
    }
    typeid__ = 1;
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* dbacond::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // required .dba.dbacond.typeid_dbacond typeid = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::dba::dbacond_typeid_dbacond_IsValid(val))) {
            set_typeid_(static_cast<::dba::dbacond_typeid_dbacond>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else goto handle_unusual;
        continue;
      // optional .dba.dbaexpr expr = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          ptr = ctx->ParseMessage(mutable_expr(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .dba.dbacond cond1 = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26)) {
          ptr = ctx->ParseMessage(mutable_cond1(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .dba.dbacond cond2 = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 34)) {
          ptr = ctx->ParseMessage(mutable_cond2(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool dbacond::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  // @@protoc_insertion_point(parse_start:dba.dbacond)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .dba.dbacond.typeid_dbacond typeid = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (8 & 0xFF)) {
          int value = 0;
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   int, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::dba::dbacond_typeid_dbacond_IsValid(value)) {
            set_typeid_(static_cast< ::dba::dbacond_typeid_dbacond >(value));
          } else {
            mutable_unknown_fields()->AddVarint(
                1, static_cast<::PROTOBUF_NAMESPACE_ID::uint64>(value));
          }
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .dba.dbaexpr expr = 2;
      case 2: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (18 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadMessage(
               input, mutable_expr()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .dba.dbacond cond1 = 3;
      case 3: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (26 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadMessage(
               input, mutable_cond1()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .dba.dbacond cond2 = 4;
      case 4: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (34 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadMessage(
               input, mutable_cond2()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:dba.dbacond)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:dba.dbacond)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void dbacond::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:dba.dbacond)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required .dba.dbacond.typeid_dbacond typeid = 1;
  if (cached_has_bits & 0x00000008u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnum(
      1, this->typeid_(), output);
  }

  // optional .dba.dbaexpr expr = 2;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, _Internal::expr(this), output);
  }

  // optional .dba.dbacond cond1 = 3;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, _Internal::cond1(this), output);
  }

  // optional .dba.dbacond cond2 = 4;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteMessageMaybeToArray(
      4, _Internal::cond2(this), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:dba.dbacond)
}

::PROTOBUF_NAMESPACE_ID::uint8* dbacond::InternalSerializeWithCachedSizesToArray(
    ::PROTOBUF_NAMESPACE_ID::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:dba.dbacond)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required .dba.dbacond.typeid_dbacond typeid = 1;
  if (cached_has_bits & 0x00000008u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      1, this->typeid_(), target);
  }

  // optional .dba.dbaexpr expr = 2;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessageToArray(
        2, _Internal::expr(this), target);
  }

  // optional .dba.dbacond cond1 = 3;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessageToArray(
        3, _Internal::cond1(this), target);
  }

  // optional .dba.dbacond cond2 = 4;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessageToArray(
        4, _Internal::cond2(this), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:dba.dbacond)
  return target;
}

size_t dbacond::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:dba.dbacond)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  // required .dba.dbacond.typeid_dbacond typeid = 1;
  if (has_typeid_()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->typeid_());
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000007u) {
    // optional .dba.dbaexpr expr = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *expr_);
    }

    // optional .dba.dbacond cond1 = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *cond1_);
    }

    // optional .dba.dbacond cond2 = 4;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *cond2_);
    }

  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void dbacond::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:dba.dbacond)
  GOOGLE_DCHECK_NE(&from, this);
  const dbacond* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<dbacond>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:dba.dbacond)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:dba.dbacond)
    MergeFrom(*source);
  }
}

void dbacond::MergeFrom(const dbacond& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:dba.dbacond)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000000fu) {
    if (cached_has_bits & 0x00000001u) {
      mutable_expr()->::dba::dbaexpr::MergeFrom(from.expr());
    }
    if (cached_has_bits & 0x00000002u) {
      mutable_cond1()->::dba::dbacond::MergeFrom(from.cond1());
    }
    if (cached_has_bits & 0x00000004u) {
      mutable_cond2()->::dba::dbacond::MergeFrom(from.cond2());
    }
    if (cached_has_bits & 0x00000008u) {
      typeid__ = from.typeid__;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void dbacond::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:dba.dbacond)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void dbacond::CopyFrom(const dbacond& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:dba.dbacond)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool dbacond::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000008) != 0x00000008) return false;
  if (has_expr()) {
    if (!this->expr_->IsInitialized()) return false;
  }
  if (has_cond1()) {
    if (!this->cond1_->IsInitialized()) return false;
  }
  if (has_cond2()) {
    if (!this->cond2_->IsInitialized()) return false;
  }
  return true;
}

void dbacond::InternalSwap(dbacond* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  swap(expr_, other->expr_);
  swap(cond1_, other->cond1_);
  swap(cond2_, other->cond2_);
  swap(typeid__, other->typeid__);
}

::PROTOBUF_NAMESPACE_ID::Metadata dbacond::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void dbaLhs::InitAsDefaultInstance() {
  ::dba::_dbaLhs_default_instance_._instance.get_mutable()->expr_ = const_cast< ::dba::dbaexpr*>(
      ::dba::dbaexpr::internal_default_instance());
}
class dbaLhs::_Internal {
 public:
  using HasBits = decltype(std::declval<dbaLhs>()._has_bits_);
  static void set_has_typeid_(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static void set_has_name(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static void set_has_size(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_low(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static void set_has_high(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static void set_has_endian(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
  static const ::dba::dbaexpr& expr(const dbaLhs* msg);
  static void set_has_expr(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
};

const ::dba::dbaexpr&
dbaLhs::_Internal::expr(const dbaLhs* msg) {
  return *msg->expr_;
}
dbaLhs::dbaLhs()
  : ::PROTOBUF_NAMESPACE_ID::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:dba.dbaLhs)
}
dbaLhs::dbaLhs(const dbaLhs& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (from.has_name()) {
    name_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.name_);
  }
  if (from.has_expr()) {
    expr_ = new ::dba::dbaexpr(*from.expr_);
  } else {
    expr_ = nullptr;
  }
  ::memcpy(&size_, &from.size_,
    static_cast<size_t>(reinterpret_cast<char*>(&endian_) -
    reinterpret_cast<char*>(&size_)) + sizeof(endian_));
  // @@protoc_insertion_point(copy_constructor:dba.dbaLhs)
}

void dbaLhs::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_dbaLhs_dba_2eproto.base);
  name_.UnsafeSetDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  ::memset(&expr_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&high_) -
      reinterpret_cast<char*>(&expr_)) + sizeof(high_));
  typeid__ = 1;
  endian_ = 1;
}

dbaLhs::~dbaLhs() {
  // @@protoc_insertion_point(destructor:dba.dbaLhs)
  SharedDtor();
}

void dbaLhs::SharedDtor() {
  name_.DestroyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  if (this != internal_default_instance()) delete expr_;
}

void dbaLhs::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const dbaLhs& dbaLhs::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_dbaLhs_dba_2eproto.base);
  return *internal_default_instance();
}


void dbaLhs::Clear() {
// @@protoc_insertion_point(message_clear_start:dba.dbaLhs)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x00000003u) {
    if (cached_has_bits & 0x00000001u) {
      name_.ClearNonDefaultToEmptyNoArena();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(expr_ != nullptr);
      expr_->Clear();
    }
  }
  if (cached_has_bits & 0x0000007cu) {
    ::memset(&size_, 0, static_cast<size_t>(
        reinterpret_cast<char*>(&high_) -
        reinterpret_cast<char*>(&size_)) + sizeof(high_));
    typeid__ = 1;
    endian_ = 1;
  }
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* dbaLhs::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // required .dba.dbaLhs.typeid_dbalhs typeid = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::dba::dbaLhs_typeid_dbalhs_IsValid(val))) {
            set_typeid_(static_cast<::dba::dbaLhs_typeid_dbalhs>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else goto handle_unusual;
        continue;
      // optional string name = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          ptr = ::PROTOBUF_NAMESPACE_ID::internal::InlineGreedyStringParserUTF8Verify(mutable_name(), ptr, ctx, "dba.dbaLhs.name");
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 size = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 24)) {
          _Internal::set_has_size(&has_bits);
          size_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 low = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 32)) {
          _Internal::set_has_low(&has_bits);
          low_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 high = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 40)) {
          _Internal::set_has_high(&has_bits);
          high_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .dba.endianness endian = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 48)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::dba::endianness_IsValid(val))) {
            set_endian(static_cast<::dba::endianness>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(6, val, mutable_unknown_fields());
          }
        } else goto handle_unusual;
        continue;
      // optional .dba.dbaexpr expr = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 58)) {
          ptr = ctx->ParseMessage(mutable_expr(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool dbaLhs::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  // @@protoc_insertion_point(parse_start:dba.dbaLhs)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .dba.dbaLhs.typeid_dbalhs typeid = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (8 & 0xFF)) {
          int value = 0;
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   int, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::dba::dbaLhs_typeid_dbalhs_IsValid(value)) {
            set_typeid_(static_cast< ::dba::dbaLhs_typeid_dbalhs >(value));
          } else {
            mutable_unknown_fields()->AddVarint(
                1, static_cast<::PROTOBUF_NAMESPACE_ID::uint64>(value));
          }
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional string name = 2;
      case 2: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (18 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadString(
                input, this->mutable_name()));
          ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
            this->name().data(), static_cast<int>(this->name().length()),
            ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::PARSE,
            "dba.dbaLhs.name");
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 size = 3;
      case 3: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (24 & 0xFF)) {
          _Internal::set_has_size(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32>(
                 input, &size_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 low = 4;
      case 4: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (32 & 0xFF)) {
          _Internal::set_has_low(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32>(
                 input, &low_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 high = 5;
      case 5: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (40 & 0xFF)) {
          _Internal::set_has_high(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32>(
                 input, &high_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .dba.endianness endian = 6;
      case 6: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (48 & 0xFF)) {
          int value = 0;
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   int, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::dba::endianness_IsValid(value)) {
            set_endian(static_cast< ::dba::endianness >(value));
          } else {
            mutable_unknown_fields()->AddVarint(
                6, static_cast<::PROTOBUF_NAMESPACE_ID::uint64>(value));
          }
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .dba.dbaexpr expr = 7;
      case 7: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (58 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadMessage(
               input, mutable_expr()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:dba.dbaLhs)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:dba.dbaLhs)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void dbaLhs::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:dba.dbaLhs)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required .dba.dbaLhs.typeid_dbalhs typeid = 1;
  if (cached_has_bits & 0x00000020u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnum(
      1, this->typeid_(), output);
  }

  // optional string name = 2;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->name().data(), static_cast<int>(this->name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "dba.dbaLhs.name");
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteStringMaybeAliased(
      2, this->name(), output);
  }

  // optional uint32 size = 3;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32(3, this->size(), output);
  }

  // optional uint32 low = 4;
  if (cached_has_bits & 0x00000008u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32(4, this->low(), output);
  }

  // optional uint32 high = 5;
  if (cached_has_bits & 0x00000010u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32(5, this->high(), output);
  }

  // optional .dba.endianness endian = 6;
  if (cached_has_bits & 0x00000040u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnum(
      6, this->endian(), output);
  }

  // optional .dba.dbaexpr expr = 7;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteMessageMaybeToArray(
      7, _Internal::expr(this), output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:dba.dbaLhs)
}

::PROTOBUF_NAMESPACE_ID::uint8* dbaLhs::InternalSerializeWithCachedSizesToArray(
    ::PROTOBUF_NAMESPACE_ID::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:dba.dbaLhs)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required .dba.dbaLhs.typeid_dbalhs typeid = 1;
  if (cached_has_bits & 0x00000020u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      1, this->typeid_(), target);
  }

  // optional string name = 2;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::VerifyUTF8StringNamedField(
      this->name().data(), static_cast<int>(this->name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SERIALIZE,
      "dba.dbaLhs.name");
    target =
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteStringToArray(
        2, this->name(), target);
  }

  // optional uint32 size = 3;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(3, this->size(), target);
  }

  // optional uint32 low = 4;
  if (cached_has_bits & 0x00000008u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(4, this->low(), target);
  }

  // optional uint32 high = 5;
  if (cached_has_bits & 0x00000010u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(5, this->high(), target);
  }

  // optional .dba.endianness endian = 6;
  if (cached_has_bits & 0x00000040u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      6, this->endian(), target);
  }

  // optional .dba.dbaexpr expr = 7;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessageToArray(
        7, _Internal::expr(this), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:dba.dbaLhs)
  return target;
}

size_t dbaLhs::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:dba.dbaLhs)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  // required .dba.dbaLhs.typeid_dbalhs typeid = 1;
  if (has_typeid_()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->typeid_());
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000001fu) {
    // optional string name = 2;
    if (cached_has_bits & 0x00000001u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
          this->name());
    }

    // optional .dba.dbaexpr expr = 7;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *expr_);
    }

    // optional uint32 size = 3;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->size());
    }

    // optional uint32 low = 4;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->low());
    }

    // optional uint32 high = 5;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->high());
    }

  }
  // optional .dba.endianness endian = 6;
  if (cached_has_bits & 0x00000040u) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->endian());
  }

  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void dbaLhs::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:dba.dbaLhs)
  GOOGLE_DCHECK_NE(&from, this);
  const dbaLhs* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<dbaLhs>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:dba.dbaLhs)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:dba.dbaLhs)
    MergeFrom(*source);
  }
}

void dbaLhs::MergeFrom(const dbaLhs& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:dba.dbaLhs)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    if (cached_has_bits & 0x00000001u) {
      _has_bits_[0] |= 0x00000001u;
      name_.AssignWithDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), from.name_);
    }
    if (cached_has_bits & 0x00000002u) {
      mutable_expr()->::dba::dbaexpr::MergeFrom(from.expr());
    }
    if (cached_has_bits & 0x00000004u) {
      size_ = from.size_;
    }
    if (cached_has_bits & 0x00000008u) {
      low_ = from.low_;
    }
    if (cached_has_bits & 0x00000010u) {
      high_ = from.high_;
    }
    if (cached_has_bits & 0x00000020u) {
      typeid__ = from.typeid__;
    }
    if (cached_has_bits & 0x00000040u) {
      endian_ = from.endian_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
}

void dbaLhs::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:dba.dbaLhs)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void dbaLhs::CopyFrom(const dbaLhs& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:dba.dbaLhs)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool dbaLhs::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000020) != 0x00000020) return false;
  if (has_expr()) {
    if (!this->expr_->IsInitialized()) return false;
  }
  return true;
}

void dbaLhs::InternalSwap(dbaLhs* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  name_.Swap(&other->name_, &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
    GetArenaNoVirtual());
  swap(expr_, other->expr_);
  swap(size_, other->size_);
  swap(low_, other->low_);
  swap(high_, other->high_);
  swap(typeid__, other->typeid__);
  swap(endian_, other->endian_);
}

::PROTOBUF_NAMESPACE_ID::Metadata dbaLhs::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void dbainstr::InitAsDefaultInstance() {
  ::dba::_dbainstr_default_instance_._instance.get_mutable()->location_ = const_cast< ::dba::dbacodeaddress*>(
      ::dba::dbacodeaddress::internal_default_instance());
  ::dba::_dbainstr_default_instance_._instance.get_mutable()->lhs_ = const_cast< ::dba::dbaLhs*>(
      ::dba::dbaLhs::internal_default_instance());
  ::dba::_dbainstr_default_instance_._instance.get_mutable()->expr_ = const_cast< ::dba::dbaexpr*>(
      ::dba::dbaexpr::internal_default_instance());
  ::dba::_dbainstr_default_instance_._instance.get_mutable()->address_ = const_cast< ::dba::codeaddress*>(
      ::dba::codeaddress::internal_default_instance());
  ::dba::_dbainstr_default_instance_._instance.get_mutable()->tags_ = const_cast< ::dba::dbatag*>(
      ::dba::dbatag::internal_default_instance());
  ::dba::_dbainstr_default_instance_._instance.get_mutable()->cond_ = const_cast< ::dba::dbacond*>(
      ::dba::dbacond::internal_default_instance());
  ::dba::_dbainstr_default_instance_._instance.get_mutable()->stopinfos_ = const_cast< ::dba::dbastopstate*>(
      ::dba::dbastopstate::internal_default_instance());
}
class dbainstr::_Internal {
 public:
  using HasBits = decltype(std::declval<dbainstr>()._has_bits_);
  static void set_has_typeid_(HasBits* has_bits) {
    (*has_bits)[0] |= 256u;
  }
  static const ::dba::dbacodeaddress& location(const dbainstr* msg);
  static void set_has_location(HasBits* has_bits) {
    (*has_bits)[0] |= 1u;
  }
  static const ::dba::dbaLhs& lhs(const dbainstr* msg);
  static void set_has_lhs(HasBits* has_bits) {
    (*has_bits)[0] |= 2u;
  }
  static const ::dba::dbaexpr& expr(const dbainstr* msg);
  static void set_has_expr(HasBits* has_bits) {
    (*has_bits)[0] |= 4u;
  }
  static void set_has_offset(HasBits* has_bits) {
    (*has_bits)[0] |= 128u;
  }
  static const ::dba::codeaddress& address(const dbainstr* msg);
  static void set_has_address(HasBits* has_bits) {
    (*has_bits)[0] |= 8u;
  }
  static const ::dba::dbatag& tags(const dbainstr* msg);
  static void set_has_tags(HasBits* has_bits) {
    (*has_bits)[0] |= 16u;
  }
  static const ::dba::dbacond& cond(const dbainstr* msg);
  static void set_has_cond(HasBits* has_bits) {
    (*has_bits)[0] |= 32u;
  }
  static const ::dba::dbastopstate& stopinfos(const dbainstr* msg);
  static void set_has_stopinfos(HasBits* has_bits) {
    (*has_bits)[0] |= 64u;
  }
};

const ::dba::dbacodeaddress&
dbainstr::_Internal::location(const dbainstr* msg) {
  return *msg->location_;
}
const ::dba::dbaLhs&
dbainstr::_Internal::lhs(const dbainstr* msg) {
  return *msg->lhs_;
}
const ::dba::dbaexpr&
dbainstr::_Internal::expr(const dbainstr* msg) {
  return *msg->expr_;
}
const ::dba::codeaddress&
dbainstr::_Internal::address(const dbainstr* msg) {
  return *msg->address_;
}
const ::dba::dbatag&
dbainstr::_Internal::tags(const dbainstr* msg) {
  return *msg->tags_;
}
const ::dba::dbacond&
dbainstr::_Internal::cond(const dbainstr* msg) {
  return *msg->cond_;
}
const ::dba::dbastopstate&
dbainstr::_Internal::stopinfos(const dbainstr* msg) {
  return *msg->stopinfos_;
}
dbainstr::dbainstr()
  : ::PROTOBUF_NAMESPACE_ID::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:dba.dbainstr)
}
dbainstr::dbainstr(const dbainstr& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_),
      exprs_(from.exprs_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  if (from.has_location()) {
    location_ = new ::dba::dbacodeaddress(*from.location_);
  } else {
    location_ = nullptr;
  }
  if (from.has_lhs()) {
    lhs_ = new ::dba::dbaLhs(*from.lhs_);
  } else {
    lhs_ = nullptr;
  }
  if (from.has_expr()) {
    expr_ = new ::dba::dbaexpr(*from.expr_);
  } else {
    expr_ = nullptr;
  }
  if (from.has_address()) {
    address_ = new ::dba::codeaddress(*from.address_);
  } else {
    address_ = nullptr;
  }
  if (from.has_tags()) {
    tags_ = new ::dba::dbatag(*from.tags_);
  } else {
    tags_ = nullptr;
  }
  if (from.has_cond()) {
    cond_ = new ::dba::dbacond(*from.cond_);
  } else {
    cond_ = nullptr;
  }
  if (from.has_stopinfos()) {
    stopinfos_ = new ::dba::dbastopstate(*from.stopinfos_);
  } else {
    stopinfos_ = nullptr;
  }
  ::memcpy(&offset_, &from.offset_,
    static_cast<size_t>(reinterpret_cast<char*>(&typeid__) -
    reinterpret_cast<char*>(&offset_)) + sizeof(typeid__));
  // @@protoc_insertion_point(copy_constructor:dba.dbainstr)
}

void dbainstr::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_dbainstr_dba_2eproto.base);
  ::memset(&location_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&offset_) -
      reinterpret_cast<char*>(&location_)) + sizeof(offset_));
  typeid__ = 1;
}

dbainstr::~dbainstr() {
  // @@protoc_insertion_point(destructor:dba.dbainstr)
  SharedDtor();
}

void dbainstr::SharedDtor() {
  if (this != internal_default_instance()) delete location_;
  if (this != internal_default_instance()) delete lhs_;
  if (this != internal_default_instance()) delete expr_;
  if (this != internal_default_instance()) delete address_;
  if (this != internal_default_instance()) delete tags_;
  if (this != internal_default_instance()) delete cond_;
  if (this != internal_default_instance()) delete stopinfos_;
}

void dbainstr::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const dbainstr& dbainstr::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_dbainstr_dba_2eproto.base);
  return *internal_default_instance();
}


void dbainstr::Clear() {
// @@protoc_insertion_point(message_clear_start:dba.dbainstr)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  exprs_.Clear();
  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x0000007fu) {
    if (cached_has_bits & 0x00000001u) {
      GOOGLE_DCHECK(location_ != nullptr);
      location_->Clear();
    }
    if (cached_has_bits & 0x00000002u) {
      GOOGLE_DCHECK(lhs_ != nullptr);
      lhs_->Clear();
    }
    if (cached_has_bits & 0x00000004u) {
      GOOGLE_DCHECK(expr_ != nullptr);
      expr_->Clear();
    }
    if (cached_has_bits & 0x00000008u) {
      GOOGLE_DCHECK(address_ != nullptr);
      address_->Clear();
    }
    if (cached_has_bits & 0x00000010u) {
      GOOGLE_DCHECK(tags_ != nullptr);
      tags_->Clear();
    }
    if (cached_has_bits & 0x00000020u) {
      GOOGLE_DCHECK(cond_ != nullptr);
      cond_->Clear();
    }
    if (cached_has_bits & 0x00000040u) {
      GOOGLE_DCHECK(stopinfos_ != nullptr);
      stopinfos_->Clear();
    }
  }
  offset_ = 0u;
  typeid__ = 1;
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* dbainstr::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  _Internal::HasBits has_bits{};
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // required .dba.dbainstr.typeid_instrkind typeid = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 8)) {
          ::PROTOBUF_NAMESPACE_ID::uint64 val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
          if (PROTOBUF_PREDICT_TRUE(::dba::dbainstr_typeid_instrkind_IsValid(val))) {
            set_typeid_(static_cast<::dba::dbainstr_typeid_instrkind>(val));
          } else {
            ::PROTOBUF_NAMESPACE_ID::internal::WriteVarint(1, val, mutable_unknown_fields());
          }
        } else goto handle_unusual;
        continue;
      // required .dba.dbacodeaddress location = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 18)) {
          ptr = ctx->ParseMessage(mutable_location(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .dba.dbaLhs lhs = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 26)) {
          ptr = ctx->ParseMessage(mutable_lhs(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .dba.dbaexpr expr = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 34)) {
          ptr = ctx->ParseMessage(mutable_expr(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional uint32 offset = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 40)) {
          _Internal::set_has_offset(&has_bits);
          offset_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint(&ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .dba.codeaddress address = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 50)) {
          ptr = ctx->ParseMessage(mutable_address(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .dba.dbatag tags = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 58)) {
          ptr = ctx->ParseMessage(mutable_tags(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .dba.dbacond cond = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 66)) {
          ptr = ctx->ParseMessage(mutable_cond(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // optional .dba.dbastopstate stopinfos = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 74)) {
          ptr = ctx->ParseMessage(mutable_stopinfos(), ptr);
          CHK_(ptr);
        } else goto handle_unusual;
        continue;
      // repeated .dba.dbaexpr exprs = 10;
      case 10:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 82)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(add_exprs(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<::PROTOBUF_NAMESPACE_ID::uint8>(ptr) == 82);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  _has_bits_.Or(has_bits);
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool dbainstr::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  // @@protoc_insertion_point(parse_start:dba.dbainstr)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .dba.dbainstr.typeid_instrkind typeid = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (8 & 0xFF)) {
          int value = 0;
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   int, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::dba::dbainstr_typeid_instrkind_IsValid(value)) {
            set_typeid_(static_cast< ::dba::dbainstr_typeid_instrkind >(value));
          } else {
            mutable_unknown_fields()->AddVarint(
                1, static_cast<::PROTOBUF_NAMESPACE_ID::uint64>(value));
          }
        } else {
          goto handle_unusual;
        }
        break;
      }

      // required .dba.dbacodeaddress location = 2;
      case 2: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (18 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadMessage(
               input, mutable_location()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .dba.dbaLhs lhs = 3;
      case 3: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (26 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadMessage(
               input, mutable_lhs()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .dba.dbaexpr expr = 4;
      case 4: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (34 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadMessage(
               input, mutable_expr()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional uint32 offset = 5;
      case 5: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (40 & 0xFF)) {
          _Internal::set_has_offset(&_has_bits_);
          DO_((::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadPrimitive<
                   ::PROTOBUF_NAMESPACE_ID::uint32, ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_UINT32>(
                 input, &offset_)));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .dba.codeaddress address = 6;
      case 6: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (50 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadMessage(
               input, mutable_address()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .dba.dbatag tags = 7;
      case 7: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (58 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadMessage(
               input, mutable_tags()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .dba.dbacond cond = 8;
      case 8: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (66 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadMessage(
               input, mutable_cond()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // optional .dba.dbastopstate stopinfos = 9;
      case 9: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (74 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadMessage(
               input, mutable_stopinfos()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      // repeated .dba.dbaexpr exprs = 10;
      case 10: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (82 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadMessage(
                input, add_exprs()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:dba.dbainstr)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:dba.dbainstr)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void dbainstr::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:dba.dbainstr)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required .dba.dbainstr.typeid_instrkind typeid = 1;
  if (cached_has_bits & 0x00000100u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnum(
      1, this->typeid_(), output);
  }

  // required .dba.dbacodeaddress location = 2;
  if (cached_has_bits & 0x00000001u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, _Internal::location(this), output);
  }

  // optional .dba.dbaLhs lhs = 3;
  if (cached_has_bits & 0x00000002u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, _Internal::lhs(this), output);
  }

  // optional .dba.dbaexpr expr = 4;
  if (cached_has_bits & 0x00000004u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteMessageMaybeToArray(
      4, _Internal::expr(this), output);
  }

  // optional uint32 offset = 5;
  if (cached_has_bits & 0x00000080u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32(5, this->offset(), output);
  }

  // optional .dba.codeaddress address = 6;
  if (cached_has_bits & 0x00000008u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteMessageMaybeToArray(
      6, _Internal::address(this), output);
  }

  // optional .dba.dbatag tags = 7;
  if (cached_has_bits & 0x00000010u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteMessageMaybeToArray(
      7, _Internal::tags(this), output);
  }

  // optional .dba.dbacond cond = 8;
  if (cached_has_bits & 0x00000020u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteMessageMaybeToArray(
      8, _Internal::cond(this), output);
  }

  // optional .dba.dbastopstate stopinfos = 9;
  if (cached_has_bits & 0x00000040u) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteMessageMaybeToArray(
      9, _Internal::stopinfos(this), output);
  }

  // repeated .dba.dbaexpr exprs = 10;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->exprs_size()); i < n; i++) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteMessageMaybeToArray(
      10,
      this->exprs(static_cast<int>(i)),
      output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:dba.dbainstr)
}

::PROTOBUF_NAMESPACE_ID::uint8* dbainstr::InternalSerializeWithCachedSizesToArray(
    ::PROTOBUF_NAMESPACE_ID::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:dba.dbainstr)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  cached_has_bits = _has_bits_[0];
  // required .dba.dbainstr.typeid_instrkind typeid = 1;
  if (cached_has_bits & 0x00000100u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteEnumToArray(
      1, this->typeid_(), target);
  }

  // required .dba.dbacodeaddress location = 2;
  if (cached_has_bits & 0x00000001u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessageToArray(
        2, _Internal::location(this), target);
  }

  // optional .dba.dbaLhs lhs = 3;
  if (cached_has_bits & 0x00000002u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessageToArray(
        3, _Internal::lhs(this), target);
  }

  // optional .dba.dbaexpr expr = 4;
  if (cached_has_bits & 0x00000004u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessageToArray(
        4, _Internal::expr(this), target);
  }

  // optional uint32 offset = 5;
  if (cached_has_bits & 0x00000080u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteUInt32ToArray(5, this->offset(), target);
  }

  // optional .dba.codeaddress address = 6;
  if (cached_has_bits & 0x00000008u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessageToArray(
        6, _Internal::address(this), target);
  }

  // optional .dba.dbatag tags = 7;
  if (cached_has_bits & 0x00000010u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessageToArray(
        7, _Internal::tags(this), target);
  }

  // optional .dba.dbacond cond = 8;
  if (cached_has_bits & 0x00000020u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessageToArray(
        8, _Internal::cond(this), target);
  }

  // optional .dba.dbastopstate stopinfos = 9;
  if (cached_has_bits & 0x00000040u) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessageToArray(
        9, _Internal::stopinfos(this), target);
  }

  // repeated .dba.dbaexpr exprs = 10;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->exprs_size()); i < n; i++) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessageToArray(
        10, this->exprs(static_cast<int>(i)), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:dba.dbainstr)
  return target;
}

size_t dbainstr::RequiredFieldsByteSizeFallback() const {
// @@protoc_insertion_point(required_fields_byte_size_fallback_start:dba.dbainstr)
  size_t total_size = 0;

  if (has_location()) {
    // required .dba.dbacodeaddress location = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *location_);
  }

  if (has_typeid_()) {
    // required .dba.dbainstr.typeid_instrkind typeid = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->typeid_());
  }

  return total_size;
}
size_t dbainstr::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:dba.dbainstr)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  if (((_has_bits_[0] & 0x00000101) ^ 0x00000101) == 0) {  // All required fields are present.
    // required .dba.dbacodeaddress location = 2;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *location_);

    // required .dba.dbainstr.typeid_instrkind typeid = 1;
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::EnumSize(this->typeid_());

  } else {
    total_size += RequiredFieldsByteSizeFallback();
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .dba.dbaexpr exprs = 10;
  {
    unsigned int count = static_cast<unsigned int>(this->exprs_size());
    total_size += 1UL * count;
    for (unsigned int i = 0; i < count; i++) {
      total_size +=
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          this->exprs(static_cast<int>(i)));
    }
  }

  cached_has_bits = _has_bits_[0];
  if (cached_has_bits & 0x000000feu) {
    // optional .dba.dbaLhs lhs = 3;
    if (cached_has_bits & 0x00000002u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *lhs_);
    }

    // optional .dba.dbaexpr expr = 4;
    if (cached_has_bits & 0x00000004u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *expr_);
    }

    // optional .dba.codeaddress address = 6;
    if (cached_has_bits & 0x00000008u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *address_);
    }

    // optional .dba.dbatag tags = 7;
    if (cached_has_bits & 0x00000010u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *tags_);
    }

    // optional .dba.dbacond cond = 8;
    if (cached_has_bits & 0x00000020u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *cond_);
    }

    // optional .dba.dbastopstate stopinfos = 9;
    if (cached_has_bits & 0x00000040u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *stopinfos_);
    }

    // optional uint32 offset = 5;
    if (cached_has_bits & 0x00000080u) {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::UInt32Size(
          this->offset());
    }

  }
  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void dbainstr::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:dba.dbainstr)
  GOOGLE_DCHECK_NE(&from, this);
  const dbainstr* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<dbainstr>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:dba.dbainstr)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:dba.dbainstr)
    MergeFrom(*source);
  }
}

void dbainstr::MergeFrom(const dbainstr& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:dba.dbainstr)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  exprs_.MergeFrom(from.exprs_);
  cached_has_bits = from._has_bits_[0];
  if (cached_has_bits & 0x000000ffu) {
    if (cached_has_bits & 0x00000001u) {
      mutable_location()->::dba::dbacodeaddress::MergeFrom(from.location());
    }
    if (cached_has_bits & 0x00000002u) {
      mutable_lhs()->::dba::dbaLhs::MergeFrom(from.lhs());
    }
    if (cached_has_bits & 0x00000004u) {
      mutable_expr()->::dba::dbaexpr::MergeFrom(from.expr());
    }
    if (cached_has_bits & 0x00000008u) {
      mutable_address()->::dba::codeaddress::MergeFrom(from.address());
    }
    if (cached_has_bits & 0x00000010u) {
      mutable_tags()->::dba::dbatag::MergeFrom(from.tags());
    }
    if (cached_has_bits & 0x00000020u) {
      mutable_cond()->::dba::dbacond::MergeFrom(from.cond());
    }
    if (cached_has_bits & 0x00000040u) {
      mutable_stopinfos()->::dba::dbastopstate::MergeFrom(from.stopinfos());
    }
    if (cached_has_bits & 0x00000080u) {
      offset_ = from.offset_;
    }
    _has_bits_[0] |= cached_has_bits;
  }
  if (cached_has_bits & 0x00000100u) {
    set_typeid_(from.typeid_());
  }
}

void dbainstr::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:dba.dbainstr)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void dbainstr::CopyFrom(const dbainstr& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:dba.dbainstr)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool dbainstr::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000101) != 0x00000101) return false;
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(this->exprs())) return false;
  if (has_location()) {
    if (!this->location_->IsInitialized()) return false;
  }
  if (has_lhs()) {
    if (!this->lhs_->IsInitialized()) return false;
  }
  if (has_expr()) {
    if (!this->expr_->IsInitialized()) return false;
  }
  if (has_address()) {
    if (!this->address_->IsInitialized()) return false;
  }
  if (has_tags()) {
    if (!this->tags_->IsInitialized()) return false;
  }
  if (has_cond()) {
    if (!this->cond_->IsInitialized()) return false;
  }
  if (has_stopinfos()) {
    if (!this->stopinfos_->IsInitialized()) return false;
  }
  return true;
}

void dbainstr::InternalSwap(dbainstr* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  CastToBase(&exprs_)->InternalSwap(CastToBase(&other->exprs_));
  swap(location_, other->location_);
  swap(lhs_, other->lhs_);
  swap(expr_, other->expr_);
  swap(address_, other->address_);
  swap(tags_, other->tags_);
  swap(cond_, other->cond_);
  swap(stopinfos_, other->stopinfos_);
  swap(offset_, other->offset_);
  swap(typeid__, other->typeid__);
}

::PROTOBUF_NAMESPACE_ID::Metadata dbainstr::GetMetadata() const {
  return GetMetadataStatic();
}


// ===================================================================

void dba_list::InitAsDefaultInstance() {
}
class dba_list::_Internal {
 public:
  using HasBits = decltype(std::declval<dba_list>()._has_bits_);
};

dba_list::dba_list()
  : ::PROTOBUF_NAMESPACE_ID::Message(), _internal_metadata_(nullptr) {
  SharedCtor();
  // @@protoc_insertion_point(constructor:dba.dba_list)
}
dba_list::dba_list(const dba_list& from)
  : ::PROTOBUF_NAMESPACE_ID::Message(),
      _internal_metadata_(nullptr),
      _has_bits_(from._has_bits_),
      instrs_(from.instrs_) {
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:dba.dba_list)
}

void dba_list::SharedCtor() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&scc_info_dba_list_dba_2eproto.base);
}

dba_list::~dba_list() {
  // @@protoc_insertion_point(destructor:dba.dba_list)
  SharedDtor();
}

void dba_list::SharedDtor() {
}

void dba_list::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}
const dba_list& dba_list::default_instance() {
  ::PROTOBUF_NAMESPACE_ID::internal::InitSCC(&::scc_info_dba_list_dba_2eproto.base);
  return *internal_default_instance();
}


void dba_list::Clear() {
// @@protoc_insertion_point(message_clear_start:dba.dba_list)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  instrs_.Clear();
  _has_bits_.Clear();
  _internal_metadata_.Clear();
}

#if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
const char* dba_list::_InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    ::PROTOBUF_NAMESPACE_ID::uint32 tag;
    ptr = ::PROTOBUF_NAMESPACE_ID::internal::ReadTag(ptr, &tag);
    CHK_(ptr);
    switch (tag >> 3) {
      // repeated .dba.dbainstr instrs = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<::PROTOBUF_NAMESPACE_ID::uint8>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(add_instrs(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<::PROTOBUF_NAMESPACE_ID::uint8>(ptr) == 10);
        } else goto handle_unusual;
        continue;
      default: {
      handle_unusual:
        if ((tag & 7) == 4 || tag == 0) {
          ctx->SetLastTag(tag);
          goto success;
        }
        ptr = UnknownFieldParse(tag, &_internal_metadata_, ptr, ctx);
        CHK_(ptr != nullptr);
        continue;
      }
    }  // switch
  }  // while
success:
  return ptr;
failure:
  ptr = nullptr;
  goto success;
#undef CHK_
}
#else  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
bool dba_list::MergePartialFromCodedStream(
    ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!PROTOBUF_PREDICT_TRUE(EXPRESSION)) goto failure
  ::PROTOBUF_NAMESPACE_ID::uint32 tag;
  // @@protoc_insertion_point(parse_start:dba.dba_list)
  for (;;) {
    ::std::pair<::PROTOBUF_NAMESPACE_ID::uint32, bool> p = input->ReadTagWithCutoffNoLastTag(127u);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .dba.dbainstr instrs = 1;
      case 1: {
        if (static_cast< ::PROTOBUF_NAMESPACE_ID::uint8>(tag) == (10 & 0xFF)) {
          DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::ReadMessage(
                input, add_instrs()));
        } else {
          goto handle_unusual;
        }
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0) {
          goto success;
        }
        DO_(::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SkipField(
              input, tag, _internal_metadata_.mutable_unknown_fields()));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:dba.dba_list)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:dba.dba_list)
  return false;
#undef DO_
}
#endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER

void dba_list::SerializeWithCachedSizes(
    ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:dba.dba_list)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .dba.dbainstr instrs = 1;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->instrs_size()); i < n; i++) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::WriteMessageMaybeToArray(
      1,
      this->instrs(static_cast<int>(i)),
      output);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SerializeUnknownFields(
        _internal_metadata_.unknown_fields(), output);
  }
  // @@protoc_insertion_point(serialize_end:dba.dba_list)
}

::PROTOBUF_NAMESPACE_ID::uint8* dba_list::InternalSerializeWithCachedSizesToArray(
    ::PROTOBUF_NAMESPACE_ID::uint8* target) const {
  // @@protoc_insertion_point(serialize_to_array_start:dba.dba_list)
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .dba.dbainstr instrs = 1;
  for (unsigned int i = 0,
      n = static_cast<unsigned int>(this->instrs_size()); i < n; i++) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessageToArray(
        1, this->instrs(static_cast<int>(i)), target);
  }

  if (_internal_metadata_.have_unknown_fields()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::SerializeUnknownFieldsToArray(
        _internal_metadata_.unknown_fields(), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:dba.dba_list)
  return target;
}

size_t dba_list::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:dba.dba_list)
  size_t total_size = 0;

  if (_internal_metadata_.have_unknown_fields()) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormat::ComputeUnknownFieldsSize(
        _internal_metadata_.unknown_fields());
  }
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .dba.dbainstr instrs = 1;
  {
    unsigned int count = static_cast<unsigned int>(this->instrs_size());
    total_size += 1UL * count;
    for (unsigned int i = 0; i < count; i++) {
      total_size +=
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          this->instrs(static_cast<int>(i)));
    }
  }

  int cached_size = ::PROTOBUF_NAMESPACE_ID::internal::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void dba_list::MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:dba.dba_list)
  GOOGLE_DCHECK_NE(&from, this);
  const dba_list* source =
      ::PROTOBUF_NAMESPACE_ID::DynamicCastToGenerated<dba_list>(
          &from);
  if (source == nullptr) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:dba.dba_list)
    ::PROTOBUF_NAMESPACE_ID::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:dba.dba_list)
    MergeFrom(*source);
  }
}

void dba_list::MergeFrom(const dba_list& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:dba.dba_list)
  GOOGLE_DCHECK_NE(&from, this);
  _internal_metadata_.MergeFrom(from._internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::uint32 cached_has_bits = 0;
  (void) cached_has_bits;

  instrs_.MergeFrom(from.instrs_);
}

void dba_list::CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:dba.dba_list)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void dba_list::CopyFrom(const dba_list& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:dba.dba_list)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool dba_list::IsInitialized() const {
  if (!::PROTOBUF_NAMESPACE_ID::internal::AllAreInitialized(this->instrs())) return false;
  return true;
}

void dba_list::InternalSwap(dba_list* other) {
  using std::swap;
  _internal_metadata_.Swap(&other->_internal_metadata_);
  swap(_has_bits_[0], other->_has_bits_[0]);
  CastToBase(&instrs_)->InternalSwap(CastToBase(&other->instrs_));
}

::PROTOBUF_NAMESPACE_ID::Metadata dba_list::GetMetadata() const {
  return GetMetadataStatic();
}


// @@protoc_insertion_point(namespace_scope)
}  // namespace dba
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::dba::bitvector* Arena::CreateMaybeMessage< ::dba::bitvector >(Arena* arena) {
  return Arena::CreateInternal< ::dba::bitvector >(arena);
}
template<> PROTOBUF_NOINLINE ::dba::dbacodeaddress* Arena::CreateMaybeMessage< ::dba::dbacodeaddress >(Arena* arena) {
  return Arena::CreateInternal< ::dba::dbacodeaddress >(arena);
}
template<> PROTOBUF_NOINLINE ::dba::codeaddress* Arena::CreateMaybeMessage< ::dba::codeaddress >(Arena* arena) {
  return Arena::CreateInternal< ::dba::codeaddress >(arena);
}
template<> PROTOBUF_NOINLINE ::dba::dbatag* Arena::CreateMaybeMessage< ::dba::dbatag >(Arena* arena) {
  return Arena::CreateInternal< ::dba::dbatag >(arena);
}
template<> PROTOBUF_NOINLINE ::dba::dbastopstate* Arena::CreateMaybeMessage< ::dba::dbastopstate >(Arena* arena) {
  return Arena::CreateInternal< ::dba::dbastopstate >(arena);
}
template<> PROTOBUF_NOINLINE ::dba::dbaexpr* Arena::CreateMaybeMessage< ::dba::dbaexpr >(Arena* arena) {
  return Arena::CreateInternal< ::dba::dbaexpr >(arena);
}
template<> PROTOBUF_NOINLINE ::dba::dbacond* Arena::CreateMaybeMessage< ::dba::dbacond >(Arena* arena) {
  return Arena::CreateInternal< ::dba::dbacond >(arena);
}
template<> PROTOBUF_NOINLINE ::dba::dbaLhs* Arena::CreateMaybeMessage< ::dba::dbaLhs >(Arena* arena) {
  return Arena::CreateInternal< ::dba::dbaLhs >(arena);
}
template<> PROTOBUF_NOINLINE ::dba::dbainstr* Arena::CreateMaybeMessage< ::dba::dbainstr >(Arena* arena) {
  return Arena::CreateInternal< ::dba::dbainstr >(arena);
}
template<> PROTOBUF_NOINLINE ::dba::dba_list* Arena::CreateMaybeMessage< ::dba::dba_list >(Arena* arena) {
  return Arena::CreateInternal< ::dba::dba_list >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
