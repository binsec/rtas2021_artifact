// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: message.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_message_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_message_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3009000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3009001 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "common.pb.h"
#include "dba.pb.h"
#include "config.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_message_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_message_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxillaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[10]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_message_2eproto;
class message_bp_reached;
class message_bp_reachedDefaultTypeInternal;
extern message_bp_reachedDefaultTypeInternal _message_bp_reached_default_instance_;
class message_decode_instr;
class message_decode_instrDefaultTypeInternal;
extern message_decode_instrDefaultTypeInternal _message_decode_instr_default_instance_;
class message_decode_instr_instr_entry;
class message_decode_instr_instr_entryDefaultTypeInternal;
extern message_decode_instr_instr_entryDefaultTypeInternal _message_decode_instr_instr_entry_default_instance_;
class message_decode_instr_reply;
class message_decode_instr_replyDefaultTypeInternal;
extern message_decode_instr_replyDefaultTypeInternal _message_decode_instr_reply_default_instance_;
class message_decode_instr_reply_instr_entry;
class message_decode_instr_reply_instr_entryDefaultTypeInternal;
extern message_decode_instr_reply_instr_entryDefaultTypeInternal _message_decode_instr_reply_instr_entry_default_instance_;
class message_infos;
class message_infosDefaultTypeInternal;
extern message_infosDefaultTypeInternal _message_infos_default_instance_;
class message_output;
class message_outputDefaultTypeInternal;
extern message_outputDefaultTypeInternal _message_output_default_instance_;
class message_patch;
class message_patchDefaultTypeInternal;
extern message_patchDefaultTypeInternal _message_patch_default_instance_;
class message_start_exec;
class message_start_execDefaultTypeInternal;
extern message_start_execDefaultTypeInternal _message_start_exec_default_instance_;
class message_start_symb_exec;
class message_start_symb_execDefaultTypeInternal;
extern message_start_symb_execDefaultTypeInternal _message_start_symb_exec_default_instance_;
PROTOBUF_NAMESPACE_OPEN
template<> ::message_bp_reached* Arena::CreateMaybeMessage<::message_bp_reached>(Arena*);
template<> ::message_decode_instr* Arena::CreateMaybeMessage<::message_decode_instr>(Arena*);
template<> ::message_decode_instr_instr_entry* Arena::CreateMaybeMessage<::message_decode_instr_instr_entry>(Arena*);
template<> ::message_decode_instr_reply* Arena::CreateMaybeMessage<::message_decode_instr_reply>(Arena*);
template<> ::message_decode_instr_reply_instr_entry* Arena::CreateMaybeMessage<::message_decode_instr_reply_instr_entry>(Arena*);
template<> ::message_infos* Arena::CreateMaybeMessage<::message_infos>(Arena*);
template<> ::message_output* Arena::CreateMaybeMessage<::message_output>(Arena*);
template<> ::message_patch* Arena::CreateMaybeMessage<::message_patch>(Arena*);
template<> ::message_start_exec* Arena::CreateMaybeMessage<::message_start_exec>(Arena*);
template<> ::message_start_symb_exec* Arena::CreateMaybeMessage<::message_start_symb_exec>(Arena*);
PROTOBUF_NAMESPACE_CLOSE

enum message_decode_instr_bin_kind : int {
  message_decode_instr_bin_kind_HEXA = 1,
  message_decode_instr_bin_kind_BIN = 2
};
bool message_decode_instr_bin_kind_IsValid(int value);
constexpr message_decode_instr_bin_kind message_decode_instr_bin_kind_bin_kind_MIN = message_decode_instr_bin_kind_HEXA;
constexpr message_decode_instr_bin_kind message_decode_instr_bin_kind_bin_kind_MAX = message_decode_instr_bin_kind_BIN;
constexpr int message_decode_instr_bin_kind_bin_kind_ARRAYSIZE = message_decode_instr_bin_kind_bin_kind_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* message_decode_instr_bin_kind_descriptor();
template<typename T>
inline const std::string& message_decode_instr_bin_kind_Name(T enum_t_value) {
  static_assert(::std::is_same<T, message_decode_instr_bin_kind>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function message_decode_instr_bin_kind_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    message_decode_instr_bin_kind_descriptor(), enum_t_value);
}
inline bool message_decode_instr_bin_kind_Parse(
    const std::string& name, message_decode_instr_bin_kind* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<message_decode_instr_bin_kind>(
    message_decode_instr_bin_kind_descriptor(), name, value);
}
enum message_start_symb_exec_trace_kind : int {
  message_start_symb_exec_trace_kind_FILE = 1,
  message_start_symb_exec_trace_kind_STREAM = 2
};
bool message_start_symb_exec_trace_kind_IsValid(int value);
constexpr message_start_symb_exec_trace_kind message_start_symb_exec_trace_kind_trace_kind_MIN = message_start_symb_exec_trace_kind_FILE;
constexpr message_start_symb_exec_trace_kind message_start_symb_exec_trace_kind_trace_kind_MAX = message_start_symb_exec_trace_kind_STREAM;
constexpr int message_start_symb_exec_trace_kind_trace_kind_ARRAYSIZE = message_start_symb_exec_trace_kind_trace_kind_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* message_start_symb_exec_trace_kind_descriptor();
template<typename T>
inline const std::string& message_start_symb_exec_trace_kind_Name(T enum_t_value) {
  static_assert(::std::is_same<T, message_start_symb_exec_trace_kind>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function message_start_symb_exec_trace_kind_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    message_start_symb_exec_trace_kind_descriptor(), enum_t_value);
}
inline bool message_start_symb_exec_trace_kind_Parse(
    const std::string& name, message_start_symb_exec_trace_kind* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<message_start_symb_exec_trace_kind>(
    message_start_symb_exec_trace_kind_descriptor(), name, value);
}
enum message_output_output_kind : int {
  message_output_output_kind_SUCCESS = 1,
  message_output_output_kind_RESULT = 2,
  message_output_output_kind_DEBUG = 3,
  message_output_output_kind_WARNING = 4,
  message_output_output_kind_ERROR = 5,
  message_output_output_kind_FAILURE = 6
};
bool message_output_output_kind_IsValid(int value);
constexpr message_output_output_kind message_output_output_kind_output_kind_MIN = message_output_output_kind_SUCCESS;
constexpr message_output_output_kind message_output_output_kind_output_kind_MAX = message_output_output_kind_FAILURE;
constexpr int message_output_output_kind_output_kind_ARRAYSIZE = message_output_output_kind_output_kind_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* message_output_output_kind_descriptor();
template<typename T>
inline const std::string& message_output_output_kind_Name(T enum_t_value) {
  static_assert(::std::is_same<T, message_output_output_kind>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function message_output_output_kind_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    message_output_output_kind_descriptor(), enum_t_value);
}
inline bool message_output_output_kind_Parse(
    const std::string& name, message_output_output_kind* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<message_output_output_kind>(
    message_output_output_kind_descriptor(), name, value);
}
// ===================================================================

class message_start_exec :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:message_start_exec) */ {
 public:
  message_start_exec();
  virtual ~message_start_exec();

  message_start_exec(const message_start_exec& from);
  message_start_exec(message_start_exec&& from) noexcept
    : message_start_exec() {
    *this = ::std::move(from);
  }

  inline message_start_exec& operator=(const message_start_exec& from) {
    CopyFrom(from);
    return *this;
  }
  inline message_start_exec& operator=(message_start_exec&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const message_start_exec& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const message_start_exec* internal_default_instance() {
    return reinterpret_cast<const message_start_exec*>(
               &_message_start_exec_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(message_start_exec& a, message_start_exec& b) {
    a.Swap(&b);
  }
  inline void Swap(message_start_exec* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline message_start_exec* New() const final {
    return CreateMaybeMessage<message_start_exec>(nullptr);
  }

  message_start_exec* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<message_start_exec>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const message_start_exec& from);
  void MergeFrom(const message_start_exec& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(message_start_exec* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "message_start_exec";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_message_2eproto);
    return ::descriptor_table_message_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBreakpointsFieldNumber = 4,
    kInputsFieldNumber = 5,
    kSkipsFieldNumber = 6,
    kStartFieldNumber = 1,
    kStopFieldNumber = 2,
    kSizeChunksFieldNumber = 3,
  };
  // repeated uint64 breakpoints = 4;
  int breakpoints_size() const;
  void clear_breakpoints();
  ::PROTOBUF_NAMESPACE_ID::uint64 breakpoints(int index) const;
  void set_breakpoints(int index, ::PROTOBUF_NAMESPACE_ID::uint64 value);
  void add_breakpoints(::PROTOBUF_NAMESPACE_ID::uint64 value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint64 >&
      breakpoints() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint64 >*
      mutable_breakpoints();

  // repeated .configuration.input_t inputs = 5;
  int inputs_size() const;
  void clear_inputs();
  ::configuration::input_t* mutable_inputs(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::configuration::input_t >*
      mutable_inputs();
  const ::configuration::input_t& inputs(int index) const;
  ::configuration::input_t* add_inputs();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::configuration::input_t >&
      inputs() const;

  // repeated uint64 skips = 6;
  int skips_size() const;
  void clear_skips();
  ::PROTOBUF_NAMESPACE_ID::uint64 skips(int index) const;
  void set_skips(int index, ::PROTOBUF_NAMESPACE_ID::uint64 value);
  void add_skips(::PROTOBUF_NAMESPACE_ID::uint64 value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint64 >&
      skips() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint64 >*
      mutable_skips();

  // required uint64 start = 1;
  bool has_start() const;
  void clear_start();
  ::PROTOBUF_NAMESPACE_ID::uint64 start() const;
  void set_start(::PROTOBUF_NAMESPACE_ID::uint64 value);

  // required uint64 stop = 2;
  bool has_stop() const;
  void clear_stop();
  ::PROTOBUF_NAMESPACE_ID::uint64 stop() const;
  void set_stop(::PROTOBUF_NAMESPACE_ID::uint64 value);

  // optional uint32 size_chunks = 3 [default = 1000];
  bool has_size_chunks() const;
  void clear_size_chunks();
  ::PROTOBUF_NAMESPACE_ID::uint32 size_chunks() const;
  void set_size_chunks(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // @@protoc_insertion_point(class_scope:message_start_exec)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint64 > breakpoints_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::configuration::input_t > inputs_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint64 > skips_;
  ::PROTOBUF_NAMESPACE_ID::uint64 start_;
  ::PROTOBUF_NAMESPACE_ID::uint64 stop_;
  ::PROTOBUF_NAMESPACE_ID::uint32 size_chunks_;
  friend struct ::TableStruct_message_2eproto;
};
// -------------------------------------------------------------------

class message_bp_reached :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:message_bp_reached) */ {
 public:
  message_bp_reached();
  virtual ~message_bp_reached();

  message_bp_reached(const message_bp_reached& from);
  message_bp_reached(message_bp_reached&& from) noexcept
    : message_bp_reached() {
    *this = ::std::move(from);
  }

  inline message_bp_reached& operator=(const message_bp_reached& from) {
    CopyFrom(from);
    return *this;
  }
  inline message_bp_reached& operator=(message_bp_reached&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const message_bp_reached& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const message_bp_reached* internal_default_instance() {
    return reinterpret_cast<const message_bp_reached*>(
               &_message_bp_reached_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(message_bp_reached& a, message_bp_reached& b) {
    a.Swap(&b);
  }
  inline void Swap(message_bp_reached* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline message_bp_reached* New() const final {
    return CreateMaybeMessage<message_bp_reached>(nullptr);
  }

  message_bp_reached* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<message_bp_reached>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const message_bp_reached& from);
  void MergeFrom(const message_bp_reached& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(message_bp_reached* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "message_bp_reached";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_message_2eproto);
    return ::descriptor_table_message_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAddrFieldNumber = 1,
  };
  // required uint64 addr = 1;
  bool has_addr() const;
  void clear_addr();
  ::PROTOBUF_NAMESPACE_ID::uint64 addr() const;
  void set_addr(::PROTOBUF_NAMESPACE_ID::uint64 value);

  // @@protoc_insertion_point(class_scope:message_bp_reached)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::uint64 addr_;
  friend struct ::TableStruct_message_2eproto;
};
// -------------------------------------------------------------------

class message_patch :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:message_patch) */ {
 public:
  message_patch();
  virtual ~message_patch();

  message_patch(const message_patch& from);
  message_patch(message_patch&& from) noexcept
    : message_patch() {
    *this = ::std::move(from);
  }

  inline message_patch& operator=(const message_patch& from) {
    CopyFrom(from);
    return *this;
  }
  inline message_patch& operator=(message_patch&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const message_patch& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const message_patch* internal_default_instance() {
    return reinterpret_cast<const message_patch*>(
               &_message_patch_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(message_patch& a, message_patch& b) {
    a.Swap(&b);
  }
  inline void Swap(message_patch* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline message_patch* New() const final {
    return CreateMaybeMessage<message_patch>(nullptr);
  }

  message_patch* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<message_patch>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const message_patch& from);
  void MergeFrom(const message_patch& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(message_patch* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "message_patch";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_message_2eproto);
    return ::descriptor_table_message_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPatchFieldNumber = 1,
  };
  // repeated .configuration.input_t patch = 1;
  int patch_size() const;
  void clear_patch();
  ::configuration::input_t* mutable_patch(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::configuration::input_t >*
      mutable_patch();
  const ::configuration::input_t& patch(int index) const;
  ::configuration::input_t* add_patch();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::configuration::input_t >&
      patch() const;

  // @@protoc_insertion_point(class_scope:message_patch)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::configuration::input_t > patch_;
  friend struct ::TableStruct_message_2eproto;
};
// -------------------------------------------------------------------

class message_infos :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:message_infos) */ {
 public:
  message_infos();
  virtual ~message_infos();

  message_infos(const message_infos& from);
  message_infos(message_infos&& from) noexcept
    : message_infos() {
    *this = ::std::move(from);
  }

  inline message_infos& operator=(const message_infos& from) {
    CopyFrom(from);
    return *this;
  }
  inline message_infos& operator=(message_infos&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const message_infos& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const message_infos* internal_default_instance() {
    return reinterpret_cast<const message_infos*>(
               &_message_infos_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(message_infos& a, message_infos& b) {
    a.Swap(&b);
  }
  inline void Swap(message_infos* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline message_infos* New() const final {
    return CreateMaybeMessage<message_infos>(nullptr);
  }

  message_infos* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<message_infos>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const message_infos& from);
  void MergeFrom(const message_infos& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(message_infos* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "message_infos";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_message_2eproto);
    return ::descriptor_table_message_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAnalysesFieldNumber = 2,
    kSolversFieldNumber = 3,
    kNbWorkersFieldNumber = 1,
  };
  // repeated string analyses = 2;
  int analyses_size() const;
  void clear_analyses();
  const std::string& analyses(int index) const;
  std::string* mutable_analyses(int index);
  void set_analyses(int index, const std::string& value);
  void set_analyses(int index, std::string&& value);
  void set_analyses(int index, const char* value);
  void set_analyses(int index, const char* value, size_t size);
  std::string* add_analyses();
  void add_analyses(const std::string& value);
  void add_analyses(std::string&& value);
  void add_analyses(const char* value);
  void add_analyses(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& analyses() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_analyses();

  // repeated string solvers = 3;
  int solvers_size() const;
  void clear_solvers();
  const std::string& solvers(int index) const;
  std::string* mutable_solvers(int index);
  void set_solvers(int index, const std::string& value);
  void set_solvers(int index, std::string&& value);
  void set_solvers(int index, const char* value);
  void set_solvers(int index, const char* value, size_t size);
  std::string* add_solvers();
  void add_solvers(const std::string& value);
  void add_solvers(std::string&& value);
  void add_solvers(const char* value);
  void add_solvers(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& solvers() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_solvers();

  // required uint32 nb_workers = 1;
  bool has_nb_workers() const;
  void clear_nb_workers();
  ::PROTOBUF_NAMESPACE_ID::uint32 nb_workers() const;
  void set_nb_workers(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // @@protoc_insertion_point(class_scope:message_infos)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> analyses_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> solvers_;
  ::PROTOBUF_NAMESPACE_ID::uint32 nb_workers_;
  friend struct ::TableStruct_message_2eproto;
};
// -------------------------------------------------------------------

class message_decode_instr_instr_entry :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:message_decode_instr.instr_entry) */ {
 public:
  message_decode_instr_instr_entry();
  virtual ~message_decode_instr_instr_entry();

  message_decode_instr_instr_entry(const message_decode_instr_instr_entry& from);
  message_decode_instr_instr_entry(message_decode_instr_instr_entry&& from) noexcept
    : message_decode_instr_instr_entry() {
    *this = ::std::move(from);
  }

  inline message_decode_instr_instr_entry& operator=(const message_decode_instr_instr_entry& from) {
    CopyFrom(from);
    return *this;
  }
  inline message_decode_instr_instr_entry& operator=(message_decode_instr_instr_entry&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const message_decode_instr_instr_entry& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const message_decode_instr_instr_entry* internal_default_instance() {
    return reinterpret_cast<const message_decode_instr_instr_entry*>(
               &_message_decode_instr_instr_entry_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(message_decode_instr_instr_entry& a, message_decode_instr_instr_entry& b) {
    a.Swap(&b);
  }
  inline void Swap(message_decode_instr_instr_entry* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline message_decode_instr_instr_entry* New() const final {
    return CreateMaybeMessage<message_decode_instr_instr_entry>(nullptr);
  }

  message_decode_instr_instr_entry* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<message_decode_instr_instr_entry>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const message_decode_instr_instr_entry& from);
  void MergeFrom(const message_decode_instr_instr_entry& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(message_decode_instr_instr_entry* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "message_decode_instr.instr_entry";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_message_2eproto);
    return ::descriptor_table_message_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kInstrFieldNumber = 1,
    kBaseAddrFieldNumber = 2,
  };
  // required string instr = 1;
  bool has_instr() const;
  void clear_instr();
  const std::string& instr() const;
  void set_instr(const std::string& value);
  void set_instr(std::string&& value);
  void set_instr(const char* value);
  void set_instr(const char* value, size_t size);
  std::string* mutable_instr();
  std::string* release_instr();
  void set_allocated_instr(std::string* instr);

  // optional uint64 base_addr = 2 [default = 0];
  bool has_base_addr() const;
  void clear_base_addr();
  ::PROTOBUF_NAMESPACE_ID::uint64 base_addr() const;
  void set_base_addr(::PROTOBUF_NAMESPACE_ID::uint64 value);

  // @@protoc_insertion_point(class_scope:message_decode_instr.instr_entry)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr instr_;
  ::PROTOBUF_NAMESPACE_ID::uint64 base_addr_;
  friend struct ::TableStruct_message_2eproto;
};
// -------------------------------------------------------------------

class message_decode_instr :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:message_decode_instr) */ {
 public:
  message_decode_instr();
  virtual ~message_decode_instr();

  message_decode_instr(const message_decode_instr& from);
  message_decode_instr(message_decode_instr&& from) noexcept
    : message_decode_instr() {
    *this = ::std::move(from);
  }

  inline message_decode_instr& operator=(const message_decode_instr& from) {
    CopyFrom(from);
    return *this;
  }
  inline message_decode_instr& operator=(message_decode_instr&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const message_decode_instr& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const message_decode_instr* internal_default_instance() {
    return reinterpret_cast<const message_decode_instr*>(
               &_message_decode_instr_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(message_decode_instr& a, message_decode_instr& b) {
    a.Swap(&b);
  }
  inline void Swap(message_decode_instr* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline message_decode_instr* New() const final {
    return CreateMaybeMessage<message_decode_instr>(nullptr);
  }

  message_decode_instr* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<message_decode_instr>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const message_decode_instr& from);
  void MergeFrom(const message_decode_instr& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(message_decode_instr* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "message_decode_instr";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_message_2eproto);
    return ::descriptor_table_message_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef message_decode_instr_instr_entry instr_entry;

  typedef message_decode_instr_bin_kind bin_kind;
  static constexpr bin_kind HEXA =
    message_decode_instr_bin_kind_HEXA;
  static constexpr bin_kind BIN =
    message_decode_instr_bin_kind_BIN;
  static inline bool bin_kind_IsValid(int value) {
    return message_decode_instr_bin_kind_IsValid(value);
  }
  static constexpr bin_kind bin_kind_MIN =
    message_decode_instr_bin_kind_bin_kind_MIN;
  static constexpr bin_kind bin_kind_MAX =
    message_decode_instr_bin_kind_bin_kind_MAX;
  static constexpr int bin_kind_ARRAYSIZE =
    message_decode_instr_bin_kind_bin_kind_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  bin_kind_descriptor() {
    return message_decode_instr_bin_kind_descriptor();
  }
  template<typename T>
  static inline const std::string& bin_kind_Name(T enum_t_value) {
    static_assert(::std::is_same<T, bin_kind>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function bin_kind_Name.");
    return message_decode_instr_bin_kind_Name(enum_t_value);
  }
  static inline bool bin_kind_Parse(const std::string& name,
      bin_kind* value) {
    return message_decode_instr_bin_kind_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kInstrsFieldNumber = 1,
    kKindFieldNumber = 2,
    kIrkindFieldNumber = 3,
  };
  // repeated .message_decode_instr.instr_entry instrs = 1;
  int instrs_size() const;
  void clear_instrs();
  ::message_decode_instr_instr_entry* mutable_instrs(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::message_decode_instr_instr_entry >*
      mutable_instrs();
  const ::message_decode_instr_instr_entry& instrs(int index) const;
  ::message_decode_instr_instr_entry* add_instrs();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::message_decode_instr_instr_entry >&
      instrs() const;

  // optional .message_decode_instr.bin_kind kind = 2 [default = BIN];
  bool has_kind() const;
  void clear_kind();
  ::message_decode_instr_bin_kind kind() const;
  void set_kind(::message_decode_instr_bin_kind value);

  // optional .common.ir_kind_t irkind = 3 [default = DBA];
  bool has_irkind() const;
  void clear_irkind();
  ::common::ir_kind_t irkind() const;
  void set_irkind(::common::ir_kind_t value);

  // @@protoc_insertion_point(class_scope:message_decode_instr)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::message_decode_instr_instr_entry > instrs_;
  int kind_;
  int irkind_;
  friend struct ::TableStruct_message_2eproto;
};
// -------------------------------------------------------------------

class message_decode_instr_reply_instr_entry :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:message_decode_instr_reply.instr_entry) */ {
 public:
  message_decode_instr_reply_instr_entry();
  virtual ~message_decode_instr_reply_instr_entry();

  message_decode_instr_reply_instr_entry(const message_decode_instr_reply_instr_entry& from);
  message_decode_instr_reply_instr_entry(message_decode_instr_reply_instr_entry&& from) noexcept
    : message_decode_instr_reply_instr_entry() {
    *this = ::std::move(from);
  }

  inline message_decode_instr_reply_instr_entry& operator=(const message_decode_instr_reply_instr_entry& from) {
    CopyFrom(from);
    return *this;
  }
  inline message_decode_instr_reply_instr_entry& operator=(message_decode_instr_reply_instr_entry&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const message_decode_instr_reply_instr_entry& default_instance();

  enum InstrsCntCase {
    kDbaInstrs = 3,
    INSTRS_CNT_NOT_SET = 0,
  };

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const message_decode_instr_reply_instr_entry* internal_default_instance() {
    return reinterpret_cast<const message_decode_instr_reply_instr_entry*>(
               &_message_decode_instr_reply_instr_entry_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(message_decode_instr_reply_instr_entry& a, message_decode_instr_reply_instr_entry& b) {
    a.Swap(&b);
  }
  inline void Swap(message_decode_instr_reply_instr_entry* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline message_decode_instr_reply_instr_entry* New() const final {
    return CreateMaybeMessage<message_decode_instr_reply_instr_entry>(nullptr);
  }

  message_decode_instr_reply_instr_entry* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<message_decode_instr_reply_instr_entry>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const message_decode_instr_reply_instr_entry& from);
  void MergeFrom(const message_decode_instr_reply_instr_entry& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(message_decode_instr_reply_instr_entry* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "message_decode_instr_reply.instr_entry";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_message_2eproto);
    return ::descriptor_table_message_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kOpcodeFieldNumber = 1,
    kIrkindFieldNumber = 2,
    kDbaInstrsFieldNumber = 3,
  };
  // required string opcode = 1;
  bool has_opcode() const;
  void clear_opcode();
  const std::string& opcode() const;
  void set_opcode(const std::string& value);
  void set_opcode(std::string&& value);
  void set_opcode(const char* value);
  void set_opcode(const char* value, size_t size);
  std::string* mutable_opcode();
  std::string* release_opcode();
  void set_allocated_opcode(std::string* opcode);

  // required .common.ir_kind_t irkind = 2;
  bool has_irkind() const;
  void clear_irkind();
  ::common::ir_kind_t irkind() const;
  void set_irkind(::common::ir_kind_t value);

  // optional .dba.dba_list dba_instrs = 3;
  bool has_dba_instrs() const;
  void clear_dba_instrs();
  const ::dba::dba_list& dba_instrs() const;
  ::dba::dba_list* release_dba_instrs();
  ::dba::dba_list* mutable_dba_instrs();
  void set_allocated_dba_instrs(::dba::dba_list* dba_instrs);

  void clear_instrs_cnt();
  InstrsCntCase instrs_cnt_case() const;
  // @@protoc_insertion_point(class_scope:message_decode_instr_reply.instr_entry)
 private:
  class _Internal;
  void set_has_dba_instrs();

  inline bool has_instrs_cnt() const;
  inline void clear_has_instrs_cnt();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr opcode_;
  int irkind_;
  union InstrsCntUnion {
    InstrsCntUnion() {}
    ::dba::dba_list* dba_instrs_;
  } instrs_cnt_;
  ::PROTOBUF_NAMESPACE_ID::uint32 _oneof_case_[1];

  friend struct ::TableStruct_message_2eproto;
};
// -------------------------------------------------------------------

class message_decode_instr_reply :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:message_decode_instr_reply) */ {
 public:
  message_decode_instr_reply();
  virtual ~message_decode_instr_reply();

  message_decode_instr_reply(const message_decode_instr_reply& from);
  message_decode_instr_reply(message_decode_instr_reply&& from) noexcept
    : message_decode_instr_reply() {
    *this = ::std::move(from);
  }

  inline message_decode_instr_reply& operator=(const message_decode_instr_reply& from) {
    CopyFrom(from);
    return *this;
  }
  inline message_decode_instr_reply& operator=(message_decode_instr_reply&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const message_decode_instr_reply& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const message_decode_instr_reply* internal_default_instance() {
    return reinterpret_cast<const message_decode_instr_reply*>(
               &_message_decode_instr_reply_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(message_decode_instr_reply& a, message_decode_instr_reply& b) {
    a.Swap(&b);
  }
  inline void Swap(message_decode_instr_reply* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline message_decode_instr_reply* New() const final {
    return CreateMaybeMessage<message_decode_instr_reply>(nullptr);
  }

  message_decode_instr_reply* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<message_decode_instr_reply>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const message_decode_instr_reply& from);
  void MergeFrom(const message_decode_instr_reply& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(message_decode_instr_reply* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "message_decode_instr_reply";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_message_2eproto);
    return ::descriptor_table_message_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef message_decode_instr_reply_instr_entry instr_entry;

  // accessors -------------------------------------------------------

  enum : int {
    kInstrsFieldNumber = 1,
  };
  // repeated .message_decode_instr_reply.instr_entry instrs = 1;
  int instrs_size() const;
  void clear_instrs();
  ::message_decode_instr_reply_instr_entry* mutable_instrs(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::message_decode_instr_reply_instr_entry >*
      mutable_instrs();
  const ::message_decode_instr_reply_instr_entry& instrs(int index) const;
  ::message_decode_instr_reply_instr_entry* add_instrs();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::message_decode_instr_reply_instr_entry >&
      instrs() const;

  // @@protoc_insertion_point(class_scope:message_decode_instr_reply)
 private:
  class _Internal;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::message_decode_instr_reply_instr_entry > instrs_;
  friend struct ::TableStruct_message_2eproto;
};
// -------------------------------------------------------------------

class message_start_symb_exec :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:message_start_symb_exec) */ {
 public:
  message_start_symb_exec();
  virtual ~message_start_symb_exec();

  message_start_symb_exec(const message_start_symb_exec& from);
  message_start_symb_exec(message_start_symb_exec&& from) noexcept
    : message_start_symb_exec() {
    *this = ::std::move(from);
  }

  inline message_start_symb_exec& operator=(const message_start_symb_exec& from) {
    CopyFrom(from);
    return *this;
  }
  inline message_start_symb_exec& operator=(message_start_symb_exec&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const message_start_symb_exec& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const message_start_symb_exec* internal_default_instance() {
    return reinterpret_cast<const message_start_symb_exec*>(
               &_message_start_symb_exec_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(message_start_symb_exec& a, message_start_symb_exec& b) {
    a.Swap(&b);
  }
  inline void Swap(message_start_symb_exec* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline message_start_symb_exec* New() const final {
    return CreateMaybeMessage<message_start_symb_exec>(nullptr);
  }

  message_start_symb_exec* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<message_start_symb_exec>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const message_start_symb_exec& from);
  void MergeFrom(const message_start_symb_exec& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(message_start_symb_exec* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "message_start_symb_exec";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_message_2eproto);
    return ::descriptor_table_message_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef message_start_symb_exec_trace_kind trace_kind;
  static constexpr trace_kind FILE =
    message_start_symb_exec_trace_kind_FILE;
  static constexpr trace_kind STREAM =
    message_start_symb_exec_trace_kind_STREAM;
  static inline bool trace_kind_IsValid(int value) {
    return message_start_symb_exec_trace_kind_IsValid(value);
  }
  static constexpr trace_kind trace_kind_MIN =
    message_start_symb_exec_trace_kind_trace_kind_MIN;
  static constexpr trace_kind trace_kind_MAX =
    message_start_symb_exec_trace_kind_trace_kind_MAX;
  static constexpr int trace_kind_ARRAYSIZE =
    message_start_symb_exec_trace_kind_trace_kind_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  trace_kind_descriptor() {
    return message_start_symb_exec_trace_kind_descriptor();
  }
  template<typename T>
  static inline const std::string& trace_kind_Name(T enum_t_value) {
    static_assert(::std::is_same<T, trace_kind>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function trace_kind_Name.");
    return message_start_symb_exec_trace_kind_Name(enum_t_value);
  }
  static inline bool trace_kind_Parse(const std::string& name,
      trace_kind* value) {
    return message_start_symb_exec_trace_kind_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 2,
    kPredicateFieldNumber = 11,
    kTraceFilenameFieldNumber = 12,
    kConfigFieldNumber = 4,
    kFormulaOptimCstfoldFieldNumber = 6,
    kFormulaOptimRebaseFieldNumber = 7,
    kFormulaOptimRowFieldNumber = 8,
    kVerboseFieldNumber = 9,
    kAddrPredicateFieldNumber = 10,
    kIrkindFieldNumber = 5,
    kTraceTypeFieldNumber = 1,
    kSolverFieldNumber = 3,
  };
  // required string name = 2;
  bool has_name() const;
  void clear_name();
  const std::string& name() const;
  void set_name(const std::string& value);
  void set_name(std::string&& value);
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  std::string* mutable_name();
  std::string* release_name();
  void set_allocated_name(std::string* name);

  // optional string predicate = 11;
  bool has_predicate() const;
  void clear_predicate();
  const std::string& predicate() const;
  void set_predicate(const std::string& value);
  void set_predicate(std::string&& value);
  void set_predicate(const char* value);
  void set_predicate(const char* value, size_t size);
  std::string* mutable_predicate();
  std::string* release_predicate();
  void set_allocated_predicate(std::string* predicate);

  // optional string trace_filename = 12;
  bool has_trace_filename() const;
  void clear_trace_filename();
  const std::string& trace_filename() const;
  void set_trace_filename(const std::string& value);
  void set_trace_filename(std::string&& value);
  void set_trace_filename(const char* value);
  void set_trace_filename(const char* value, size_t size);
  std::string* mutable_trace_filename();
  std::string* release_trace_filename();
  void set_allocated_trace_filename(std::string* trace_filename);

  // optional .configuration.configuration config = 4;
  bool has_config() const;
  void clear_config();
  const ::configuration::configuration& config() const;
  ::configuration::configuration* release_config();
  ::configuration::configuration* mutable_config();
  void set_allocated_config(::configuration::configuration* config);

  // optional bool formula_optim_cstfold = 6;
  bool has_formula_optim_cstfold() const;
  void clear_formula_optim_cstfold();
  bool formula_optim_cstfold() const;
  void set_formula_optim_cstfold(bool value);

  // optional bool formula_optim_rebase = 7;
  bool has_formula_optim_rebase() const;
  void clear_formula_optim_rebase();
  bool formula_optim_rebase() const;
  void set_formula_optim_rebase(bool value);

  // optional bool formula_optim_row = 8;
  bool has_formula_optim_row() const;
  void clear_formula_optim_row();
  bool formula_optim_row() const;
  void set_formula_optim_row(bool value);

  // required uint32 verbose = 9;
  bool has_verbose() const;
  void clear_verbose();
  ::PROTOBUF_NAMESPACE_ID::uint32 verbose() const;
  void set_verbose(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // optional uint64 addr_predicate = 10;
  bool has_addr_predicate() const;
  void clear_addr_predicate();
  ::PROTOBUF_NAMESPACE_ID::uint64 addr_predicate() const;
  void set_addr_predicate(::PROTOBUF_NAMESPACE_ID::uint64 value);

  // optional .common.ir_kind_t irkind = 5 [default = DBA];
  bool has_irkind() const;
  void clear_irkind();
  ::common::ir_kind_t irkind() const;
  void set_irkind(::common::ir_kind_t value);

  // required .message_start_symb_exec.trace_kind trace_type = 1;
  bool has_trace_type() const;
  void clear_trace_type();
  ::message_start_symb_exec_trace_kind trace_type() const;
  void set_trace_type(::message_start_symb_exec_trace_kind value);

  // optional .common.solver_t solver = 3 [default = Z3];
  bool has_solver() const;
  void clear_solver();
  ::common::solver_t solver() const;
  void set_solver(::common::solver_t value);

  // @@protoc_insertion_point(class_scope:message_start_symb_exec)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr predicate_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr trace_filename_;
  ::configuration::configuration* config_;
  bool formula_optim_cstfold_;
  bool formula_optim_rebase_;
  bool formula_optim_row_;
  ::PROTOBUF_NAMESPACE_ID::uint32 verbose_;
  ::PROTOBUF_NAMESPACE_ID::uint64 addr_predicate_;
  int irkind_;
  int trace_type_;
  int solver_;
  friend struct ::TableStruct_message_2eproto;
};
// -------------------------------------------------------------------

class message_output :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:message_output) */ {
 public:
  message_output();
  virtual ~message_output();

  message_output(const message_output& from);
  message_output(message_output&& from) noexcept
    : message_output() {
    *this = ::std::move(from);
  }

  inline message_output& operator=(const message_output& from) {
    CopyFrom(from);
    return *this;
  }
  inline message_output& operator=(message_output&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  inline const ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::PROTOBUF_NAMESPACE_ID::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return GetMetadataStatic().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return GetMetadataStatic().reflection;
  }
  static const message_output& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const message_output* internal_default_instance() {
    return reinterpret_cast<const message_output*>(
               &_message_output_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(message_output& a, message_output& b) {
    a.Swap(&b);
  }
  inline void Swap(message_output* other) {
    if (other == this) return;
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline message_output* New() const final {
    return CreateMaybeMessage<message_output>(nullptr);
  }

  message_output* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<message_output>(arena);
  }
  void CopyFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void MergeFrom(const ::PROTOBUF_NAMESPACE_ID::Message& from) final;
  void CopyFrom(const message_output& from);
  void MergeFrom(const message_output& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  #else
  bool MergePartialFromCodedStream(
      ::PROTOBUF_NAMESPACE_ID::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::PROTOBUF_NAMESPACE_ID::io::CodedOutputStream* output) const final;
  ::PROTOBUF_NAMESPACE_ID::uint8* InternalSerializeWithCachedSizesToArray(
      ::PROTOBUF_NAMESPACE_ID::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  inline void SharedCtor();
  inline void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(message_output* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "message_output";
  }
  private:
  inline ::PROTOBUF_NAMESPACE_ID::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  private:
  static ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadataStatic() {
    ::PROTOBUF_NAMESPACE_ID::internal::AssignDescriptors(&::descriptor_table_message_2eproto);
    return ::descriptor_table_message_2eproto.file_level_metadata[kIndexInFileMessages];
  }

  public:

  // nested types ----------------------------------------------------

  typedef message_output_output_kind output_kind;
  static constexpr output_kind SUCCESS =
    message_output_output_kind_SUCCESS;
  static constexpr output_kind RESULT =
    message_output_output_kind_RESULT;
  static constexpr output_kind DEBUG =
    message_output_output_kind_DEBUG;
  static constexpr output_kind WARNING =
    message_output_output_kind_WARNING;
  static constexpr output_kind ERROR =
    message_output_output_kind_ERROR;
  static constexpr output_kind FAILURE =
    message_output_output_kind_FAILURE;
  static inline bool output_kind_IsValid(int value) {
    return message_output_output_kind_IsValid(value);
  }
  static constexpr output_kind output_kind_MIN =
    message_output_output_kind_output_kind_MIN;
  static constexpr output_kind output_kind_MAX =
    message_output_output_kind_output_kind_MAX;
  static constexpr int output_kind_ARRAYSIZE =
    message_output_output_kind_output_kind_ARRAYSIZE;
  static inline const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor*
  output_kind_descriptor() {
    return message_output_output_kind_descriptor();
  }
  template<typename T>
  static inline const std::string& output_kind_Name(T enum_t_value) {
    static_assert(::std::is_same<T, output_kind>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function output_kind_Name.");
    return message_output_output_kind_Name(enum_t_value);
  }
  static inline bool output_kind_Parse(const std::string& name,
      output_kind* value) {
    return message_output_output_kind_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kMessageFieldNumber = 2,
    kRamTotalFieldNumber = 3,
    kRamFreeFieldNumber = 4,
    kRamAvailableFieldNumber = 5,
    kTypeFieldNumber = 1,
  };
  // required string message = 2;
  bool has_message() const;
  void clear_message();
  const std::string& message() const;
  void set_message(const std::string& value);
  void set_message(std::string&& value);
  void set_message(const char* value);
  void set_message(const char* value, size_t size);
  std::string* mutable_message();
  std::string* release_message();
  void set_allocated_message(std::string* message);

  // optional uint32 ram_total = 3;
  bool has_ram_total() const;
  void clear_ram_total();
  ::PROTOBUF_NAMESPACE_ID::uint32 ram_total() const;
  void set_ram_total(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // optional uint32 ram_free = 4;
  bool has_ram_free() const;
  void clear_ram_free();
  ::PROTOBUF_NAMESPACE_ID::uint32 ram_free() const;
  void set_ram_free(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // optional uint32 ram_available = 5;
  bool has_ram_available() const;
  void clear_ram_available();
  ::PROTOBUF_NAMESPACE_ID::uint32 ram_available() const;
  void set_ram_available(::PROTOBUF_NAMESPACE_ID::uint32 value);

  // required .message_output.output_kind type = 1;
  bool has_type() const;
  void clear_type();
  ::message_output_output_kind type() const;
  void set_type(::message_output_output_kind value);

  // @@protoc_insertion_point(class_scope:message_output)
 private:
  class _Internal;

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::PROTOBUF_NAMESPACE_ID::internal::InternalMetadataWithArena _internal_metadata_;
  ::PROTOBUF_NAMESPACE_ID::internal::HasBits<1> _has_bits_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr message_;
  ::PROTOBUF_NAMESPACE_ID::uint32 ram_total_;
  ::PROTOBUF_NAMESPACE_ID::uint32 ram_free_;
  ::PROTOBUF_NAMESPACE_ID::uint32 ram_available_;
  int type_;
  friend struct ::TableStruct_message_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// message_start_exec

// required uint64 start = 1;
inline bool message_start_exec::has_start() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void message_start_exec::clear_start() {
  start_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 message_start_exec::start() const {
  // @@protoc_insertion_point(field_get:message_start_exec.start)
  return start_;
}
inline void message_start_exec::set_start(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000001u;
  start_ = value;
  // @@protoc_insertion_point(field_set:message_start_exec.start)
}

// required uint64 stop = 2;
inline bool message_start_exec::has_stop() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void message_start_exec::clear_stop() {
  stop_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 message_start_exec::stop() const {
  // @@protoc_insertion_point(field_get:message_start_exec.stop)
  return stop_;
}
inline void message_start_exec::set_stop(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000002u;
  stop_ = value;
  // @@protoc_insertion_point(field_set:message_start_exec.stop)
}

// optional uint32 size_chunks = 3 [default = 1000];
inline bool message_start_exec::has_size_chunks() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void message_start_exec::clear_size_chunks() {
  size_chunks_ = 1000u;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 message_start_exec::size_chunks() const {
  // @@protoc_insertion_point(field_get:message_start_exec.size_chunks)
  return size_chunks_;
}
inline void message_start_exec::set_size_chunks(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000004u;
  size_chunks_ = value;
  // @@protoc_insertion_point(field_set:message_start_exec.size_chunks)
}

// repeated uint64 breakpoints = 4;
inline int message_start_exec::breakpoints_size() const {
  return breakpoints_.size();
}
inline void message_start_exec::clear_breakpoints() {
  breakpoints_.Clear();
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 message_start_exec::breakpoints(int index) const {
  // @@protoc_insertion_point(field_get:message_start_exec.breakpoints)
  return breakpoints_.Get(index);
}
inline void message_start_exec::set_breakpoints(int index, ::PROTOBUF_NAMESPACE_ID::uint64 value) {
  breakpoints_.Set(index, value);
  // @@protoc_insertion_point(field_set:message_start_exec.breakpoints)
}
inline void message_start_exec::add_breakpoints(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  breakpoints_.Add(value);
  // @@protoc_insertion_point(field_add:message_start_exec.breakpoints)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint64 >&
message_start_exec::breakpoints() const {
  // @@protoc_insertion_point(field_list:message_start_exec.breakpoints)
  return breakpoints_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint64 >*
message_start_exec::mutable_breakpoints() {
  // @@protoc_insertion_point(field_mutable_list:message_start_exec.breakpoints)
  return &breakpoints_;
}

// repeated .configuration.input_t inputs = 5;
inline int message_start_exec::inputs_size() const {
  return inputs_.size();
}
inline ::configuration::input_t* message_start_exec::mutable_inputs(int index) {
  // @@protoc_insertion_point(field_mutable:message_start_exec.inputs)
  return inputs_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::configuration::input_t >*
message_start_exec::mutable_inputs() {
  // @@protoc_insertion_point(field_mutable_list:message_start_exec.inputs)
  return &inputs_;
}
inline const ::configuration::input_t& message_start_exec::inputs(int index) const {
  // @@protoc_insertion_point(field_get:message_start_exec.inputs)
  return inputs_.Get(index);
}
inline ::configuration::input_t* message_start_exec::add_inputs() {
  // @@protoc_insertion_point(field_add:message_start_exec.inputs)
  return inputs_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::configuration::input_t >&
message_start_exec::inputs() const {
  // @@protoc_insertion_point(field_list:message_start_exec.inputs)
  return inputs_;
}

// repeated uint64 skips = 6;
inline int message_start_exec::skips_size() const {
  return skips_.size();
}
inline void message_start_exec::clear_skips() {
  skips_.Clear();
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 message_start_exec::skips(int index) const {
  // @@protoc_insertion_point(field_get:message_start_exec.skips)
  return skips_.Get(index);
}
inline void message_start_exec::set_skips(int index, ::PROTOBUF_NAMESPACE_ID::uint64 value) {
  skips_.Set(index, value);
  // @@protoc_insertion_point(field_set:message_start_exec.skips)
}
inline void message_start_exec::add_skips(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  skips_.Add(value);
  // @@protoc_insertion_point(field_add:message_start_exec.skips)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint64 >&
message_start_exec::skips() const {
  // @@protoc_insertion_point(field_list:message_start_exec.skips)
  return skips_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< ::PROTOBUF_NAMESPACE_ID::uint64 >*
message_start_exec::mutable_skips() {
  // @@protoc_insertion_point(field_mutable_list:message_start_exec.skips)
  return &skips_;
}

// -------------------------------------------------------------------

// message_bp_reached

// required uint64 addr = 1;
inline bool message_bp_reached::has_addr() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void message_bp_reached::clear_addr() {
  addr_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 message_bp_reached::addr() const {
  // @@protoc_insertion_point(field_get:message_bp_reached.addr)
  return addr_;
}
inline void message_bp_reached::set_addr(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000001u;
  addr_ = value;
  // @@protoc_insertion_point(field_set:message_bp_reached.addr)
}

// -------------------------------------------------------------------

// message_patch

// repeated .configuration.input_t patch = 1;
inline int message_patch::patch_size() const {
  return patch_.size();
}
inline ::configuration::input_t* message_patch::mutable_patch(int index) {
  // @@protoc_insertion_point(field_mutable:message_patch.patch)
  return patch_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::configuration::input_t >*
message_patch::mutable_patch() {
  // @@protoc_insertion_point(field_mutable_list:message_patch.patch)
  return &patch_;
}
inline const ::configuration::input_t& message_patch::patch(int index) const {
  // @@protoc_insertion_point(field_get:message_patch.patch)
  return patch_.Get(index);
}
inline ::configuration::input_t* message_patch::add_patch() {
  // @@protoc_insertion_point(field_add:message_patch.patch)
  return patch_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::configuration::input_t >&
message_patch::patch() const {
  // @@protoc_insertion_point(field_list:message_patch.patch)
  return patch_;
}

// -------------------------------------------------------------------

// message_infos

// required uint32 nb_workers = 1;
inline bool message_infos::has_nb_workers() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void message_infos::clear_nb_workers() {
  nb_workers_ = 0u;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 message_infos::nb_workers() const {
  // @@protoc_insertion_point(field_get:message_infos.nb_workers)
  return nb_workers_;
}
inline void message_infos::set_nb_workers(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000001u;
  nb_workers_ = value;
  // @@protoc_insertion_point(field_set:message_infos.nb_workers)
}

// repeated string analyses = 2;
inline int message_infos::analyses_size() const {
  return analyses_.size();
}
inline void message_infos::clear_analyses() {
  analyses_.Clear();
}
inline const std::string& message_infos::analyses(int index) const {
  // @@protoc_insertion_point(field_get:message_infos.analyses)
  return analyses_.Get(index);
}
inline std::string* message_infos::mutable_analyses(int index) {
  // @@protoc_insertion_point(field_mutable:message_infos.analyses)
  return analyses_.Mutable(index);
}
inline void message_infos::set_analyses(int index, const std::string& value) {
  // @@protoc_insertion_point(field_set:message_infos.analyses)
  analyses_.Mutable(index)->assign(value);
}
inline void message_infos::set_analyses(int index, std::string&& value) {
  // @@protoc_insertion_point(field_set:message_infos.analyses)
  analyses_.Mutable(index)->assign(std::move(value));
}
inline void message_infos::set_analyses(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  analyses_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:message_infos.analyses)
}
inline void message_infos::set_analyses(int index, const char* value, size_t size) {
  analyses_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:message_infos.analyses)
}
inline std::string* message_infos::add_analyses() {
  // @@protoc_insertion_point(field_add_mutable:message_infos.analyses)
  return analyses_.Add();
}
inline void message_infos::add_analyses(const std::string& value) {
  analyses_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:message_infos.analyses)
}
inline void message_infos::add_analyses(std::string&& value) {
  analyses_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:message_infos.analyses)
}
inline void message_infos::add_analyses(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  analyses_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:message_infos.analyses)
}
inline void message_infos::add_analyses(const char* value, size_t size) {
  analyses_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:message_infos.analyses)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
message_infos::analyses() const {
  // @@protoc_insertion_point(field_list:message_infos.analyses)
  return analyses_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
message_infos::mutable_analyses() {
  // @@protoc_insertion_point(field_mutable_list:message_infos.analyses)
  return &analyses_;
}

// repeated string solvers = 3;
inline int message_infos::solvers_size() const {
  return solvers_.size();
}
inline void message_infos::clear_solvers() {
  solvers_.Clear();
}
inline const std::string& message_infos::solvers(int index) const {
  // @@protoc_insertion_point(field_get:message_infos.solvers)
  return solvers_.Get(index);
}
inline std::string* message_infos::mutable_solvers(int index) {
  // @@protoc_insertion_point(field_mutable:message_infos.solvers)
  return solvers_.Mutable(index);
}
inline void message_infos::set_solvers(int index, const std::string& value) {
  // @@protoc_insertion_point(field_set:message_infos.solvers)
  solvers_.Mutable(index)->assign(value);
}
inline void message_infos::set_solvers(int index, std::string&& value) {
  // @@protoc_insertion_point(field_set:message_infos.solvers)
  solvers_.Mutable(index)->assign(std::move(value));
}
inline void message_infos::set_solvers(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  solvers_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:message_infos.solvers)
}
inline void message_infos::set_solvers(int index, const char* value, size_t size) {
  solvers_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:message_infos.solvers)
}
inline std::string* message_infos::add_solvers() {
  // @@protoc_insertion_point(field_add_mutable:message_infos.solvers)
  return solvers_.Add();
}
inline void message_infos::add_solvers(const std::string& value) {
  solvers_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:message_infos.solvers)
}
inline void message_infos::add_solvers(std::string&& value) {
  solvers_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:message_infos.solvers)
}
inline void message_infos::add_solvers(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  solvers_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:message_infos.solvers)
}
inline void message_infos::add_solvers(const char* value, size_t size) {
  solvers_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:message_infos.solvers)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
message_infos::solvers() const {
  // @@protoc_insertion_point(field_list:message_infos.solvers)
  return solvers_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
message_infos::mutable_solvers() {
  // @@protoc_insertion_point(field_mutable_list:message_infos.solvers)
  return &solvers_;
}

// -------------------------------------------------------------------

// message_decode_instr_instr_entry

// required string instr = 1;
inline bool message_decode_instr_instr_entry::has_instr() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void message_decode_instr_instr_entry::clear_instr() {
  instr_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& message_decode_instr_instr_entry::instr() const {
  // @@protoc_insertion_point(field_get:message_decode_instr.instr_entry.instr)
  return instr_.GetNoArena();
}
inline void message_decode_instr_instr_entry::set_instr(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  instr_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:message_decode_instr.instr_entry.instr)
}
inline void message_decode_instr_instr_entry::set_instr(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  instr_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:message_decode_instr.instr_entry.instr)
}
inline void message_decode_instr_instr_entry::set_instr(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  instr_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:message_decode_instr.instr_entry.instr)
}
inline void message_decode_instr_instr_entry::set_instr(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  instr_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:message_decode_instr.instr_entry.instr)
}
inline std::string* message_decode_instr_instr_entry::mutable_instr() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:message_decode_instr.instr_entry.instr)
  return instr_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* message_decode_instr_instr_entry::release_instr() {
  // @@protoc_insertion_point(field_release:message_decode_instr.instr_entry.instr)
  if (!has_instr()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return instr_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void message_decode_instr_instr_entry::set_allocated_instr(std::string* instr) {
  if (instr != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  instr_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), instr);
  // @@protoc_insertion_point(field_set_allocated:message_decode_instr.instr_entry.instr)
}

// optional uint64 base_addr = 2 [default = 0];
inline bool message_decode_instr_instr_entry::has_base_addr() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void message_decode_instr_instr_entry::clear_base_addr() {
  base_addr_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 message_decode_instr_instr_entry::base_addr() const {
  // @@protoc_insertion_point(field_get:message_decode_instr.instr_entry.base_addr)
  return base_addr_;
}
inline void message_decode_instr_instr_entry::set_base_addr(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000002u;
  base_addr_ = value;
  // @@protoc_insertion_point(field_set:message_decode_instr.instr_entry.base_addr)
}

// -------------------------------------------------------------------

// message_decode_instr

// repeated .message_decode_instr.instr_entry instrs = 1;
inline int message_decode_instr::instrs_size() const {
  return instrs_.size();
}
inline void message_decode_instr::clear_instrs() {
  instrs_.Clear();
}
inline ::message_decode_instr_instr_entry* message_decode_instr::mutable_instrs(int index) {
  // @@protoc_insertion_point(field_mutable:message_decode_instr.instrs)
  return instrs_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::message_decode_instr_instr_entry >*
message_decode_instr::mutable_instrs() {
  // @@protoc_insertion_point(field_mutable_list:message_decode_instr.instrs)
  return &instrs_;
}
inline const ::message_decode_instr_instr_entry& message_decode_instr::instrs(int index) const {
  // @@protoc_insertion_point(field_get:message_decode_instr.instrs)
  return instrs_.Get(index);
}
inline ::message_decode_instr_instr_entry* message_decode_instr::add_instrs() {
  // @@protoc_insertion_point(field_add:message_decode_instr.instrs)
  return instrs_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::message_decode_instr_instr_entry >&
message_decode_instr::instrs() const {
  // @@protoc_insertion_point(field_list:message_decode_instr.instrs)
  return instrs_;
}

// optional .message_decode_instr.bin_kind kind = 2 [default = BIN];
inline bool message_decode_instr::has_kind() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void message_decode_instr::clear_kind() {
  kind_ = 2;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::message_decode_instr_bin_kind message_decode_instr::kind() const {
  // @@protoc_insertion_point(field_get:message_decode_instr.kind)
  return static_cast< ::message_decode_instr_bin_kind >(kind_);
}
inline void message_decode_instr::set_kind(::message_decode_instr_bin_kind value) {
  assert(::message_decode_instr_bin_kind_IsValid(value));
  _has_bits_[0] |= 0x00000001u;
  kind_ = value;
  // @@protoc_insertion_point(field_set:message_decode_instr.kind)
}

// optional .common.ir_kind_t irkind = 3 [default = DBA];
inline bool message_decode_instr::has_irkind() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void message_decode_instr::clear_irkind() {
  irkind_ = 1;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::common::ir_kind_t message_decode_instr::irkind() const {
  // @@protoc_insertion_point(field_get:message_decode_instr.irkind)
  return static_cast< ::common::ir_kind_t >(irkind_);
}
inline void message_decode_instr::set_irkind(::common::ir_kind_t value) {
  assert(::common::ir_kind_t_IsValid(value));
  _has_bits_[0] |= 0x00000002u;
  irkind_ = value;
  // @@protoc_insertion_point(field_set:message_decode_instr.irkind)
}

// -------------------------------------------------------------------

// message_decode_instr_reply_instr_entry

// required string opcode = 1;
inline bool message_decode_instr_reply_instr_entry::has_opcode() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void message_decode_instr_reply_instr_entry::clear_opcode() {
  opcode_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& message_decode_instr_reply_instr_entry::opcode() const {
  // @@protoc_insertion_point(field_get:message_decode_instr_reply.instr_entry.opcode)
  return opcode_.GetNoArena();
}
inline void message_decode_instr_reply_instr_entry::set_opcode(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  opcode_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:message_decode_instr_reply.instr_entry.opcode)
}
inline void message_decode_instr_reply_instr_entry::set_opcode(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  opcode_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:message_decode_instr_reply.instr_entry.opcode)
}
inline void message_decode_instr_reply_instr_entry::set_opcode(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  opcode_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:message_decode_instr_reply.instr_entry.opcode)
}
inline void message_decode_instr_reply_instr_entry::set_opcode(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  opcode_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:message_decode_instr_reply.instr_entry.opcode)
}
inline std::string* message_decode_instr_reply_instr_entry::mutable_opcode() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:message_decode_instr_reply.instr_entry.opcode)
  return opcode_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* message_decode_instr_reply_instr_entry::release_opcode() {
  // @@protoc_insertion_point(field_release:message_decode_instr_reply.instr_entry.opcode)
  if (!has_opcode()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return opcode_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void message_decode_instr_reply_instr_entry::set_allocated_opcode(std::string* opcode) {
  if (opcode != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  opcode_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), opcode);
  // @@protoc_insertion_point(field_set_allocated:message_decode_instr_reply.instr_entry.opcode)
}

// required .common.ir_kind_t irkind = 2;
inline bool message_decode_instr_reply_instr_entry::has_irkind() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void message_decode_instr_reply_instr_entry::clear_irkind() {
  irkind_ = 1;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::common::ir_kind_t message_decode_instr_reply_instr_entry::irkind() const {
  // @@protoc_insertion_point(field_get:message_decode_instr_reply.instr_entry.irkind)
  return static_cast< ::common::ir_kind_t >(irkind_);
}
inline void message_decode_instr_reply_instr_entry::set_irkind(::common::ir_kind_t value) {
  assert(::common::ir_kind_t_IsValid(value));
  _has_bits_[0] |= 0x00000002u;
  irkind_ = value;
  // @@protoc_insertion_point(field_set:message_decode_instr_reply.instr_entry.irkind)
}

// optional .dba.dba_list dba_instrs = 3;
inline bool message_decode_instr_reply_instr_entry::has_dba_instrs() const {
  return instrs_cnt_case() == kDbaInstrs;
}
inline void message_decode_instr_reply_instr_entry::set_has_dba_instrs() {
  _oneof_case_[0] = kDbaInstrs;
}
inline ::dba::dba_list* message_decode_instr_reply_instr_entry::release_dba_instrs() {
  // @@protoc_insertion_point(field_release:message_decode_instr_reply.instr_entry.dba_instrs)
  if (has_dba_instrs()) {
    clear_has_instrs_cnt();
      ::dba::dba_list* temp = instrs_cnt_.dba_instrs_;
    instrs_cnt_.dba_instrs_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::dba::dba_list& message_decode_instr_reply_instr_entry::dba_instrs() const {
  // @@protoc_insertion_point(field_get:message_decode_instr_reply.instr_entry.dba_instrs)
  return has_dba_instrs()
      ? *instrs_cnt_.dba_instrs_
      : *reinterpret_cast< ::dba::dba_list*>(&::dba::_dba_list_default_instance_);
}
inline ::dba::dba_list* message_decode_instr_reply_instr_entry::mutable_dba_instrs() {
  if (!has_dba_instrs()) {
    clear_instrs_cnt();
    set_has_dba_instrs();
    instrs_cnt_.dba_instrs_ = CreateMaybeMessage< ::dba::dba_list >(
        GetArenaNoVirtual());
  }
  // @@protoc_insertion_point(field_mutable:message_decode_instr_reply.instr_entry.dba_instrs)
  return instrs_cnt_.dba_instrs_;
}

inline bool message_decode_instr_reply_instr_entry::has_instrs_cnt() const {
  return instrs_cnt_case() != INSTRS_CNT_NOT_SET;
}
inline void message_decode_instr_reply_instr_entry::clear_has_instrs_cnt() {
  _oneof_case_[0] = INSTRS_CNT_NOT_SET;
}
inline message_decode_instr_reply_instr_entry::InstrsCntCase message_decode_instr_reply_instr_entry::instrs_cnt_case() const {
  return message_decode_instr_reply_instr_entry::InstrsCntCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// message_decode_instr_reply

// repeated .message_decode_instr_reply.instr_entry instrs = 1;
inline int message_decode_instr_reply::instrs_size() const {
  return instrs_.size();
}
inline void message_decode_instr_reply::clear_instrs() {
  instrs_.Clear();
}
inline ::message_decode_instr_reply_instr_entry* message_decode_instr_reply::mutable_instrs(int index) {
  // @@protoc_insertion_point(field_mutable:message_decode_instr_reply.instrs)
  return instrs_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::message_decode_instr_reply_instr_entry >*
message_decode_instr_reply::mutable_instrs() {
  // @@protoc_insertion_point(field_mutable_list:message_decode_instr_reply.instrs)
  return &instrs_;
}
inline const ::message_decode_instr_reply_instr_entry& message_decode_instr_reply::instrs(int index) const {
  // @@protoc_insertion_point(field_get:message_decode_instr_reply.instrs)
  return instrs_.Get(index);
}
inline ::message_decode_instr_reply_instr_entry* message_decode_instr_reply::add_instrs() {
  // @@protoc_insertion_point(field_add:message_decode_instr_reply.instrs)
  return instrs_.Add();
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::message_decode_instr_reply_instr_entry >&
message_decode_instr_reply::instrs() const {
  // @@protoc_insertion_point(field_list:message_decode_instr_reply.instrs)
  return instrs_;
}

// -------------------------------------------------------------------

// message_start_symb_exec

// required .message_start_symb_exec.trace_kind trace_type = 1;
inline bool message_start_symb_exec::has_trace_type() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void message_start_symb_exec::clear_trace_type() {
  trace_type_ = 1;
  _has_bits_[0] &= ~0x00000400u;
}
inline ::message_start_symb_exec_trace_kind message_start_symb_exec::trace_type() const {
  // @@protoc_insertion_point(field_get:message_start_symb_exec.trace_type)
  return static_cast< ::message_start_symb_exec_trace_kind >(trace_type_);
}
inline void message_start_symb_exec::set_trace_type(::message_start_symb_exec_trace_kind value) {
  assert(::message_start_symb_exec_trace_kind_IsValid(value));
  _has_bits_[0] |= 0x00000400u;
  trace_type_ = value;
  // @@protoc_insertion_point(field_set:message_start_symb_exec.trace_type)
}

// required string name = 2;
inline bool message_start_symb_exec::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void message_start_symb_exec::clear_name() {
  name_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& message_start_symb_exec::name() const {
  // @@protoc_insertion_point(field_get:message_start_symb_exec.name)
  return name_.GetNoArena();
}
inline void message_start_symb_exec::set_name(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:message_start_symb_exec.name)
}
inline void message_start_symb_exec::set_name(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  name_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:message_start_symb_exec.name)
}
inline void message_start_symb_exec::set_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:message_start_symb_exec.name)
}
inline void message_start_symb_exec::set_name(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  name_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:message_start_symb_exec.name)
}
inline std::string* message_start_symb_exec::mutable_name() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:message_start_symb_exec.name)
  return name_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* message_start_symb_exec::release_name() {
  // @@protoc_insertion_point(field_release:message_start_symb_exec.name)
  if (!has_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return name_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void message_start_symb_exec::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  name_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:message_start_symb_exec.name)
}

// optional .common.solver_t solver = 3 [default = Z3];
inline bool message_start_symb_exec::has_solver() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void message_start_symb_exec::clear_solver() {
  solver_ = 1;
  _has_bits_[0] &= ~0x00000800u;
}
inline ::common::solver_t message_start_symb_exec::solver() const {
  // @@protoc_insertion_point(field_get:message_start_symb_exec.solver)
  return static_cast< ::common::solver_t >(solver_);
}
inline void message_start_symb_exec::set_solver(::common::solver_t value) {
  assert(::common::solver_t_IsValid(value));
  _has_bits_[0] |= 0x00000800u;
  solver_ = value;
  // @@protoc_insertion_point(field_set:message_start_symb_exec.solver)
}

// optional .configuration.configuration config = 4;
inline bool message_start_symb_exec::has_config() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline const ::configuration::configuration& message_start_symb_exec::config() const {
  const ::configuration::configuration* p = config_;
  // @@protoc_insertion_point(field_get:message_start_symb_exec.config)
  return p != nullptr ? *p : *reinterpret_cast<const ::configuration::configuration*>(
      &::configuration::_configuration_default_instance_);
}
inline ::configuration::configuration* message_start_symb_exec::release_config() {
  // @@protoc_insertion_point(field_release:message_start_symb_exec.config)
  _has_bits_[0] &= ~0x00000008u;
  ::configuration::configuration* temp = config_;
  config_ = nullptr;
  return temp;
}
inline ::configuration::configuration* message_start_symb_exec::mutable_config() {
  _has_bits_[0] |= 0x00000008u;
  if (config_ == nullptr) {
    auto* p = CreateMaybeMessage<::configuration::configuration>(GetArenaNoVirtual());
    config_ = p;
  }
  // @@protoc_insertion_point(field_mutable:message_start_symb_exec.config)
  return config_;
}
inline void message_start_symb_exec::set_allocated_config(::configuration::configuration* config) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete reinterpret_cast< ::PROTOBUF_NAMESPACE_ID::MessageLite*>(config_);
  }
  if (config) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      config = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, config, submessage_arena);
    }
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  config_ = config;
  // @@protoc_insertion_point(field_set_allocated:message_start_symb_exec.config)
}

// optional .common.ir_kind_t irkind = 5 [default = DBA];
inline bool message_start_symb_exec::has_irkind() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void message_start_symb_exec::clear_irkind() {
  irkind_ = 1;
  _has_bits_[0] &= ~0x00000200u;
}
inline ::common::ir_kind_t message_start_symb_exec::irkind() const {
  // @@protoc_insertion_point(field_get:message_start_symb_exec.irkind)
  return static_cast< ::common::ir_kind_t >(irkind_);
}
inline void message_start_symb_exec::set_irkind(::common::ir_kind_t value) {
  assert(::common::ir_kind_t_IsValid(value));
  _has_bits_[0] |= 0x00000200u;
  irkind_ = value;
  // @@protoc_insertion_point(field_set:message_start_symb_exec.irkind)
}

// optional bool formula_optim_cstfold = 6;
inline bool message_start_symb_exec::has_formula_optim_cstfold() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void message_start_symb_exec::clear_formula_optim_cstfold() {
  formula_optim_cstfold_ = false;
  _has_bits_[0] &= ~0x00000010u;
}
inline bool message_start_symb_exec::formula_optim_cstfold() const {
  // @@protoc_insertion_point(field_get:message_start_symb_exec.formula_optim_cstfold)
  return formula_optim_cstfold_;
}
inline void message_start_symb_exec::set_formula_optim_cstfold(bool value) {
  _has_bits_[0] |= 0x00000010u;
  formula_optim_cstfold_ = value;
  // @@protoc_insertion_point(field_set:message_start_symb_exec.formula_optim_cstfold)
}

// optional bool formula_optim_rebase = 7;
inline bool message_start_symb_exec::has_formula_optim_rebase() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void message_start_symb_exec::clear_formula_optim_rebase() {
  formula_optim_rebase_ = false;
  _has_bits_[0] &= ~0x00000020u;
}
inline bool message_start_symb_exec::formula_optim_rebase() const {
  // @@protoc_insertion_point(field_get:message_start_symb_exec.formula_optim_rebase)
  return formula_optim_rebase_;
}
inline void message_start_symb_exec::set_formula_optim_rebase(bool value) {
  _has_bits_[0] |= 0x00000020u;
  formula_optim_rebase_ = value;
  // @@protoc_insertion_point(field_set:message_start_symb_exec.formula_optim_rebase)
}

// optional bool formula_optim_row = 8;
inline bool message_start_symb_exec::has_formula_optim_row() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void message_start_symb_exec::clear_formula_optim_row() {
  formula_optim_row_ = false;
  _has_bits_[0] &= ~0x00000040u;
}
inline bool message_start_symb_exec::formula_optim_row() const {
  // @@protoc_insertion_point(field_get:message_start_symb_exec.formula_optim_row)
  return formula_optim_row_;
}
inline void message_start_symb_exec::set_formula_optim_row(bool value) {
  _has_bits_[0] |= 0x00000040u;
  formula_optim_row_ = value;
  // @@protoc_insertion_point(field_set:message_start_symb_exec.formula_optim_row)
}

// required uint32 verbose = 9;
inline bool message_start_symb_exec::has_verbose() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void message_start_symb_exec::clear_verbose() {
  verbose_ = 0u;
  _has_bits_[0] &= ~0x00000080u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 message_start_symb_exec::verbose() const {
  // @@protoc_insertion_point(field_get:message_start_symb_exec.verbose)
  return verbose_;
}
inline void message_start_symb_exec::set_verbose(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000080u;
  verbose_ = value;
  // @@protoc_insertion_point(field_set:message_start_symb_exec.verbose)
}

// optional uint64 addr_predicate = 10;
inline bool message_start_symb_exec::has_addr_predicate() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void message_start_symb_exec::clear_addr_predicate() {
  addr_predicate_ = PROTOBUF_ULONGLONG(0);
  _has_bits_[0] &= ~0x00000100u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 message_start_symb_exec::addr_predicate() const {
  // @@protoc_insertion_point(field_get:message_start_symb_exec.addr_predicate)
  return addr_predicate_;
}
inline void message_start_symb_exec::set_addr_predicate(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _has_bits_[0] |= 0x00000100u;
  addr_predicate_ = value;
  // @@protoc_insertion_point(field_set:message_start_symb_exec.addr_predicate)
}

// optional string predicate = 11;
inline bool message_start_symb_exec::has_predicate() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void message_start_symb_exec::clear_predicate() {
  predicate_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000002u;
}
inline const std::string& message_start_symb_exec::predicate() const {
  // @@protoc_insertion_point(field_get:message_start_symb_exec.predicate)
  return predicate_.GetNoArena();
}
inline void message_start_symb_exec::set_predicate(const std::string& value) {
  _has_bits_[0] |= 0x00000002u;
  predicate_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:message_start_symb_exec.predicate)
}
inline void message_start_symb_exec::set_predicate(std::string&& value) {
  _has_bits_[0] |= 0x00000002u;
  predicate_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:message_start_symb_exec.predicate)
}
inline void message_start_symb_exec::set_predicate(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000002u;
  predicate_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:message_start_symb_exec.predicate)
}
inline void message_start_symb_exec::set_predicate(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000002u;
  predicate_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:message_start_symb_exec.predicate)
}
inline std::string* message_start_symb_exec::mutable_predicate() {
  _has_bits_[0] |= 0x00000002u;
  // @@protoc_insertion_point(field_mutable:message_start_symb_exec.predicate)
  return predicate_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* message_start_symb_exec::release_predicate() {
  // @@protoc_insertion_point(field_release:message_start_symb_exec.predicate)
  if (!has_predicate()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000002u;
  return predicate_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void message_start_symb_exec::set_allocated_predicate(std::string* predicate) {
  if (predicate != nullptr) {
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  predicate_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), predicate);
  // @@protoc_insertion_point(field_set_allocated:message_start_symb_exec.predicate)
}

// optional string trace_filename = 12;
inline bool message_start_symb_exec::has_trace_filename() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void message_start_symb_exec::clear_trace_filename() {
  trace_filename_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000004u;
}
inline const std::string& message_start_symb_exec::trace_filename() const {
  // @@protoc_insertion_point(field_get:message_start_symb_exec.trace_filename)
  return trace_filename_.GetNoArena();
}
inline void message_start_symb_exec::set_trace_filename(const std::string& value) {
  _has_bits_[0] |= 0x00000004u;
  trace_filename_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:message_start_symb_exec.trace_filename)
}
inline void message_start_symb_exec::set_trace_filename(std::string&& value) {
  _has_bits_[0] |= 0x00000004u;
  trace_filename_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:message_start_symb_exec.trace_filename)
}
inline void message_start_symb_exec::set_trace_filename(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000004u;
  trace_filename_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:message_start_symb_exec.trace_filename)
}
inline void message_start_symb_exec::set_trace_filename(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000004u;
  trace_filename_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:message_start_symb_exec.trace_filename)
}
inline std::string* message_start_symb_exec::mutable_trace_filename() {
  _has_bits_[0] |= 0x00000004u;
  // @@protoc_insertion_point(field_mutable:message_start_symb_exec.trace_filename)
  return trace_filename_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* message_start_symb_exec::release_trace_filename() {
  // @@protoc_insertion_point(field_release:message_start_symb_exec.trace_filename)
  if (!has_trace_filename()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000004u;
  return trace_filename_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void message_start_symb_exec::set_allocated_trace_filename(std::string* trace_filename) {
  if (trace_filename != nullptr) {
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  trace_filename_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), trace_filename);
  // @@protoc_insertion_point(field_set_allocated:message_start_symb_exec.trace_filename)
}

// -------------------------------------------------------------------

// message_output

// required .message_output.output_kind type = 1;
inline bool message_output::has_type() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void message_output::clear_type() {
  type_ = 1;
  _has_bits_[0] &= ~0x00000010u;
}
inline ::message_output_output_kind message_output::type() const {
  // @@protoc_insertion_point(field_get:message_output.type)
  return static_cast< ::message_output_output_kind >(type_);
}
inline void message_output::set_type(::message_output_output_kind value) {
  assert(::message_output_output_kind_IsValid(value));
  _has_bits_[0] |= 0x00000010u;
  type_ = value;
  // @@protoc_insertion_point(field_set:message_output.type)
}

// required string message = 2;
inline bool message_output::has_message() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void message_output::clear_message() {
  message_.ClearToEmptyNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const std::string& message_output::message() const {
  // @@protoc_insertion_point(field_get:message_output.message)
  return message_.GetNoArena();
}
inline void message_output::set_message(const std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  message_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:message_output.message)
}
inline void message_output::set_message(std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  message_.SetNoArena(
    &::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:message_output.message)
}
inline void message_output::set_message(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  message_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:message_output.message)
}
inline void message_output::set_message(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  message_.SetNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:message_output.message)
}
inline std::string* message_output::mutable_message() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:message_output.message)
  return message_.MutableNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline std::string* message_output::release_message() {
  // @@protoc_insertion_point(field_release:message_output.message)
  if (!has_message()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return message_.ReleaseNonDefaultNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited());
}
inline void message_output::set_allocated_message(std::string* message) {
  if (message != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  message_.SetAllocatedNoArena(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), message);
  // @@protoc_insertion_point(field_set_allocated:message_output.message)
}

// optional uint32 ram_total = 3;
inline bool message_output::has_ram_total() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void message_output::clear_ram_total() {
  ram_total_ = 0u;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 message_output::ram_total() const {
  // @@protoc_insertion_point(field_get:message_output.ram_total)
  return ram_total_;
}
inline void message_output::set_ram_total(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000002u;
  ram_total_ = value;
  // @@protoc_insertion_point(field_set:message_output.ram_total)
}

// optional uint32 ram_free = 4;
inline bool message_output::has_ram_free() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void message_output::clear_ram_free() {
  ram_free_ = 0u;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 message_output::ram_free() const {
  // @@protoc_insertion_point(field_get:message_output.ram_free)
  return ram_free_;
}
inline void message_output::set_ram_free(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000004u;
  ram_free_ = value;
  // @@protoc_insertion_point(field_set:message_output.ram_free)
}

// optional uint32 ram_available = 5;
inline bool message_output::has_ram_available() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void message_output::clear_ram_available() {
  ram_available_ = 0u;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 message_output::ram_available() const {
  // @@protoc_insertion_point(field_get:message_output.ram_available)
  return ram_available_;
}
inline void message_output::set_ram_available(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _has_bits_[0] |= 0x00000008u;
  ram_available_ = value;
  // @@protoc_insertion_point(field_set:message_output.ram_available)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)


PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::message_decode_instr_bin_kind> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::message_decode_instr_bin_kind>() {
  return ::message_decode_instr_bin_kind_descriptor();
}
template <> struct is_proto_enum< ::message_start_symb_exec_trace_kind> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::message_start_symb_exec_trace_kind>() {
  return ::message_start_symb_exec_trace_kind_descriptor();
}
template <> struct is_proto_enum< ::message_output_output_kind> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::message_output_output_kind>() {
  return ::message_output_output_kind_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_message_2eproto
